{
    "RECORDS": [
        {
            "_id": "6367676d1a6d9265ec018229",
            "all_context": "{ \"class_level\" : \"import java.nio.charset.Charset;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nimport java.util.Enumeration;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Locale;\\nimport java.util.Properties;\\nimport java.util.Set;\\nimport java.util.StringTokenizer;\\nimport java.util.TreeSet;\\nString FOLDER_SEPARATOR;\\nString WINDOWS_FOLDER_SEPARATOR;\\nString TOP_PATH;\\nString CURRENT_PATH;\\nchar EXTENSION_SEPARATOR;\\nCharset UTF_8;\\nStrings();\\nhasLength(String str);\\nhasText(CharSequence str);\\nhasText(String str);\\ncontainsWhitespace(CharSequence str);\\ncontainsWhitespace(String str);\\ntrimWhitespace(String str);\\ntrimWhitespace(CharSequence str);\\nclean(String str);\\nclean(CharSequence str);\\ntrimAllWhitespace(String str);\\ntrimLeadingWhitespace(String str);\\ntrimTrailingWhitespace(String str);\\ntrimLeadingCharacter(String str,char leadingCharacter);\\ntrimTrailingCharacter(String str,char trailingCharacter);\\nstartsWithIgnoreCase(String str,String prefix);\\nendsWithIgnoreCase(String str,String suffix);\\nsubstringMatch(CharSequence str,int index,CharSequence substring);\\ncountOccurrencesOf(String str,String sub);\\nreplace(String inString,String oldPattern,String newPattern);\\ndelete(String inString,String pattern);\\ndeleteAny(String inString,String charsToDelete);\\nquote(String str);\\nquoteIfString(Object obj);\\nunqualify(String qualifiedName);\\nunqualify(String qualifiedName,char separator);\\ncapitalize(String str);\\nuncapitalize(String str);\\nchangeFirstCharacterCase(String str,boolean capitalize);\\ngetFilename(String path);\\ngetFilenameExtension(String path);\\nstripFilenameExtension(String path);\\napplyRelativePath(String path,String relativePath);\\ncleanPath(String path);\\npathEquals(String path1,String path2);\\nparseLocaleString(String localeString);\\nvalidateLocalePart(String localePart);\\ntoLanguageTag(Locale locale);\\naddStringToArray(String[] array,String str);\\nconcatenateStringArrays(String[] array1,String[] array2);\\nmergeStringArrays(String[] array1,String[] array2);\\nsortStringArray(String[] array);\\ntoStringArray(Collection collection);\\ntoStringArray(Enumeration enumeration);\\ntrimArrayElements(String[] array);\\nremoveDuplicateStrings(String[] array);\\nsplit(String toSplit,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter,String charsToDelete);\\ntokenizeToStringArray(String str,String delimiters);\\ntokenizeToStringArray(String str,String delimiters,boolean trimTokens,boolean ignoreEmptyTokens);\\ndelimitedListToStringArray(String str,String delimiter);\\ndelimitedListToStringArray(String str,String delimiter,String charsToDelete);\\ncommaDelimitedListToStringArray(String str);\\ncommaDelimitedListToSet(String str);\\ncollectionToDelimitedString(Collection coll,String delim,String prefix,String suffix);\\ncollectionToDelimitedString(Collection coll,String delim);\\ncollectionToCommaDelimitedString(Collection coll);\\narrayToDelimitedString(Object[] arr,String delim);\\narrayToCommaDelimitedString(Object[] arr);\\nhasLength(CharSequence str);\\n\", \"repo_level\" : \"\" }",
            "class_name": "Strings",
            "code": "public static String[] trimArrayElements(String[] array){\n  if (Objects.isEmpty(array)) {\n    return new String[0];\n  }\n  String[] result=new String[array.length];\n  for (int i=0; i < array.length; i++) {\n    String element=array[i];\n    result[i]=(element != null ? element.trim() : null);\n  }\n  return result;\n}\n",
            "docstring": "/** \n * Trim the elements of the given String array, calling <code>String.trim()</code> on each of them.\n * @param array the original String array\n * @return the resulting array (of the same size) with trimmed elements\n */\n",
            "end_lineno": "842",
            "file_content": "/*\n * Copyright (C) 2014 jsonwebtoken.io\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.jsonwebtoken.lang;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic final class Strings {\n\n    private static final String FOLDER_SEPARATOR = \"/\";\n\n    private static final String WINDOWS_FOLDER_SEPARATOR = \"\\\\\";\n\n    private static final String TOP_PATH = \"..\";\n\n    private static final String CURRENT_PATH = \".\";\n\n    private static final char EXTENSION_SEPARATOR = '.';\n\n    public static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    private Strings(){} //prevent instantiation\n\n    //---------------------------------------------------------------------\n    // General convenience methods for working with Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Check that the given CharSequence is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a CharSequence that purely consists of whitespace.\n     * <pre>\n     * Strings.hasLength(null) = false\n     * Strings.hasLength(\"\") = false\n     * Strings.hasLength(\" \") = true\n     * Strings.hasLength(\"Hello\") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(CharSequence str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasLength(CharSequence)\n     */\n    public static boolean hasLength(String str) {\n        return hasLength((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <pre>\n     * Strings.hasText(null) = false\n     * Strings.hasText(\"\") = false\n     * Strings.hasText(\" \") = false\n     * Strings.hasText(\"12345\") = true\n     * Strings.hasText(\" 12345 \") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not <code>null</code>,\n     * its length is greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     * greater than 0, and it does not contain whitespace only\n     * @see #hasText(CharSequence)\n     */\n    public static boolean hasText(String str) {\n        return hasText((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence contains any whitespace characters.\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not empty and\n     * contains at least 1 whitespace character\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean containsWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String contains any whitespace characters.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not empty and\n     * contains at least 1 whitespace character\n     * @see #containsWhitespace(CharSequence)\n     */\n    public static boolean containsWhitespace(String str) {\n        return containsWhitespace((CharSequence) str);\n    }\n\n    /**\n     * Trim leading and trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimWhitespace(String str) {\n        return (String) trimWhitespace((CharSequence)str);\n    }\n    \n    \n    private static CharSequence trimWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        final int length = str.length();\n\n        int start = 0;\n\t\twhile (start < length && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        \n\t\tint end = length;\n        while (start < length && Character.isWhitespace(str.charAt(end - 1))) {\n            end--;\n        }\n        \n        return ((start > 0) || (end < length)) ? str.subSequence(start, end) : str;\n    }\n\n    public static String clean(String str) {\n    \tCharSequence result = clean((CharSequence) str);\n        \n        return result!=null?result.toString():null;\n    }\n    \n    public static CharSequence clean(CharSequence str) {\n        str = trimWhitespace(str);\n        if (!hasLength(str)) {\n            return null;\n        }\n        return str;\n    }\n\n    /**\n     * Trim <i>all</i> whitespace from the given String:\n     * leading, trailing, and intermediate characters.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimAllWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        int index = 0;\n        while (sb.length() > index) {\n            if (Character.isWhitespace(sb.charAt(index))) {\n                sb.deleteCharAt(index);\n            }\n            else {\n                index++;\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim leading whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimLeadingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimTrailingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied leading character from the given String.\n     * @param str the String to check\n     * @param leadingCharacter the leading character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimLeadingCharacter(String str, char leadingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied trailing character from the given String.\n     * @param str the String to check\n     * @param trailingCharacter the trailing character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimTrailingCharacter(String str, char trailingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n\n    /**\n     * Returns {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @param str the String to check\n     * @param prefix the prefix to look for\n     * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @param str the String to check\n     * @param suffix the suffix to look for\n     * @return {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @see java.lang.String#endsWith\n     */\n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        if (str == null || suffix == null) {\n            return false;\n        }\n        if (str.endsWith(suffix)) {\n            return true;\n        }\n        if (str.length() < suffix.length()) {\n            return false;\n        }\n\n        String lcStr = str.substring(str.length() - suffix.length()).toLowerCase();\n        String lcSuffix = suffix.toLowerCase();\n        return lcStr.equals(lcSuffix);\n    }\n\n    /**\n     * Returns {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     * @param str the original string (or StringBuilder)\n     * @param index the index in the original string to start matching against\n     * @param substring the substring to match at the given index\n     * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     */\n    public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n        for (int j = 0; j < substring.length(); j++) {\n            int i = index + j;\n            if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the number of occurrences the substring {@code sub} appears in string {@code str}.\n     * @param str string to search in. Return 0 if this is null.\n     * @param sub string to search for. Return 0 if this is null.\n     * @return the number of occurrences the substring {@code sub} appears in string {@code str}.\n     */\n    public static int countOccurrencesOf(String str, String sub) {\n        if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n            return 0;\n        }\n        int count = 0;\n        int pos = 0;\n        int idx;\n        while ((idx = str.indexOf(sub, pos)) != -1) {\n            ++count;\n            pos = idx + sub.length();\n        }\n        return count;\n    }\n\n    /**\n     * Replace all occurrences of a substring within a string with\n     * another string.\n     * @param inString String to examine\n     * @param oldPattern String to replace\n     * @param newPattern String to insert\n     * @return a String with the replacements\n     */\n    public static String replace(String inString, String oldPattern, String newPattern) {\n        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        int pos = 0; // our position in the old string\n        int index = inString.indexOf(oldPattern);\n        // the index of an occurrence we've found, or -1\n        int patLen = oldPattern.length();\n        while (index >= 0) {\n            sb.append(inString.substring(pos, index));\n            sb.append(newPattern);\n            pos = index + patLen;\n            index = inString.indexOf(oldPattern, pos);\n        }\n        sb.append(inString.substring(pos));\n        // remember to append any characters to the right of a match\n        return sb.toString();\n    }\n\n    /**\n     * Delete all occurrences of the given substring.\n     * @param inString the original String\n     * @param pattern the pattern to delete all occurrences of\n     * @return the resulting String\n     */\n    public static String delete(String inString, String pattern) {\n        return replace(inString, pattern, \"\");\n    }\n\n    /**\n     * Delete any character in a given String.\n     * @param inString the original String\n     * @param charsToDelete a set of characters to delete.\n     * E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n     * @return the resulting String\n     */\n    public static String deleteAny(String inString, String charsToDelete) {\n        if (!hasLength(inString) || !hasLength(charsToDelete)) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < inString.length(); i++) {\n            char c = inString.charAt(i);\n            if (charsToDelete.indexOf(c) == -1) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with formatted Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Quote the given String with single quotes.\n     * @param str the input String (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or <code>null</code> if the input was <code>null</code>\n     */\n    public static String quote(String str) {\n        return (str != null ? \"'\" + str + \"'\" : null);\n    }\n\n    /**\n     * Turn the given Object into a String with single quotes\n     * if it is a String; keeping the Object as-is else.\n     * @param obj the input Object (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or the input object as-is if not a String\n     */\n    public static Object quoteIfString(Object obj) {\n        return (obj instanceof String ? quote((String) obj) : obj);\n    }\n\n    /**\n     * Unqualify a string qualified by a '.' dot character. For example,\n     * \"this.name.is.qualified\", returns \"qualified\".\n     * @param qualifiedName the qualified name\n     * @return an unqualified string by stripping all previous text before (and including) the last period character.\n     */\n    public static String unqualify(String qualifiedName) {\n        return unqualify(qualifiedName, '.');\n    }\n\n    /**\n     * Unqualify a string qualified by a separator character. For example,\n     * \"this:name:is:qualified\" returns \"qualified\" if using a ':' separator.\n     * @param qualifiedName the qualified name\n     * @param separator the separator\n     * @return an unqualified string by stripping all previous text before and including the last {@code separator} character.\n     */\n    public static String unqualify(String qualifiedName, char separator) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);\n    }\n\n    /**\n     * Capitalize a <code>String</code>, changing the first letter to\n     * upper case as per {@link Character#toUpperCase(char)}.\n     * No other letters are changed.\n     * @param str the String to capitalize, may be <code>null</code>\n     * @return the capitalized String, <code>null</code> if null\n     */\n    public static String capitalize(String str) {\n        return changeFirstCharacterCase(str, true);\n    }\n\n    /**\n     * Uncapitalize a <code>String</code>, changing the first letter to\n     * lower case as per {@link Character#toLowerCase(char)}.\n     * No other letters are changed.\n     * @param str the String to uncapitalize, may be <code>null</code>\n     * @return the uncapitalized String, <code>null</code> if null\n     */\n    public static String uncapitalize(String str) {\n        return changeFirstCharacterCase(str, false);\n    }\n\n    private static String changeFirstCharacterCase(String str, boolean capitalize) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str.length());\n        if (capitalize) {\n            sb.append(Character.toUpperCase(str.charAt(0)));\n        }\n        else {\n            sb.append(Character.toLowerCase(str.charAt(0)));\n        }\n        sb.append(str.substring(1));\n        return sb.toString();\n    }\n\n    /**\n     * Extract the filename from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"myfile.txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename, or <code>null</code> if none\n     */\n    public static String getFilename(String path) {\n        if (path == null) {\n            return null;\n        }\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);\n    }\n\n    /**\n     * Extract the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename extension, or <code>null</code> if none\n     */\n    public static String getFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return null;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return null;\n        }\n        return path.substring(extIndex + 1);\n    }\n\n    /**\n     * Strip the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"mypath/myfile\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the path with stripped filename extension,\n     * or <code>null</code> if none\n     */\n    public static String stripFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return path;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return path;\n        }\n        return path.substring(0, extIndex);\n    }\n\n    /**\n     * Apply the given relative path to the given path,\n     * assuming standard Java folder separation (i.e. \"/\" separators).\n     * @param path the path to start from (usually a full file path)\n     * @param relativePath the relative path to apply\n     * (relative to the full file path above)\n     * @return the full file path that results from applying the relative path\n     */\n    public static String applyRelativePath(String path, String relativePath) {\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (separatorIndex != -1) {\n            String newPath = path.substring(0, separatorIndex);\n            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n                newPath += FOLDER_SEPARATOR;\n            }\n            return newPath + relativePath;\n        }\n        else {\n            return relativePath;\n        }\n    }\n\n    /**\n     * Normalize the path by suppressing sequences like \"path/..\" and\n     * inner simple dots.\n     * <p>The result is convenient for path comparison. For other uses,\n     * notice that Windows separators (\"\\\") are replaced by simple slashes.\n     * @param path the original path\n     * @return the normalized path\n     */\n    public static String cleanPath(String path) {\n        if (path == null) {\n            return null;\n        }\n        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);\n\n        // Strip prefix from path to analyze, to not treat it as part of the\n        // first path element. This is necessary to correctly parse paths like\n        // \"file:core/../core/io/Resource.class\", where the \"..\" should just\n        // strip the first \"core\" directory while keeping the \"file:\" prefix.\n        int prefixIndex = pathToUse.indexOf(\":\");\n        String prefix = \"\";\n        if (prefixIndex != -1) {\n            prefix = pathToUse.substring(0, prefixIndex + 1);\n            pathToUse = pathToUse.substring(prefixIndex + 1);\n        }\n        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {\n            prefix = prefix + FOLDER_SEPARATOR;\n            pathToUse = pathToUse.substring(1);\n        }\n\n        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);\n        List<String> pathElements = new LinkedList<String>();\n        int tops = 0;\n\n        for (int i = pathArray.length - 1; i >= 0; i--) {\n            String element = pathArray[i];\n            if (CURRENT_PATH.equals(element)) {\n                // Points to current directory - drop it.\n            }\n            else if (TOP_PATH.equals(element)) {\n                // Registering top path found.\n                tops++;\n            }\n            else {\n                if (tops > 0) {\n                    // Merging path element with element corresponding to top path.\n                    tops--;\n                }\n                else {\n                    // Normal path element found.\n                    pathElements.add(0, element);\n                }\n            }\n        }\n\n        // Remaining top paths need to be retained.\n        for (int i = 0; i < tops; i++) {\n            pathElements.add(0, TOP_PATH);\n        }\n\n        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);\n    }\n\n    /**\n     * Compare two paths after normalization of them.\n     * @param path1 first path for comparison\n     * @param path2 second path for comparison\n     * @return whether the two paths are equivalent after normalization\n     */\n    public static boolean pathEquals(String path1, String path2) {\n        return cleanPath(path1).equals(cleanPath(path2));\n    }\n\n    /**\n     * Parse the given <code>localeString</code> value into a {@link java.util.Locale}.\n     * <p>This is the inverse operation of {@link java.util.Locale#toString Locale's toString}.\n     * @param localeString the locale string, following <code>Locale's</code>\n     * <code>toString()</code> format (\"en\", \"en_UK\", etc);\n     * also accepts spaces as separators, as an alternative to underscores\n     * @return a corresponding <code>Locale</code> instance\n     */\n    public static Locale parseLocaleString(String localeString) {\n        String[] parts = tokenizeToStringArray(localeString, \"_ \", false, false);\n        String language = (parts.length > 0 ? parts[0] : \"\");\n        String country = (parts.length > 1 ? parts[1] : \"\");\n        validateLocalePart(language);\n        validateLocalePart(country);\n        String variant = \"\";\n        if (parts.length >= 2) {\n            // There is definitely a variant, and it is everything after the country\n            // code sans the separator between the country code and the variant.\n            int endIndexOfCountryCode = localeString.indexOf(country) + country.length();\n            // Strip off any leading '_' and whitespace, what's left is the variant.\n            variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));\n            if (variant.startsWith(\"_\")) {\n                variant = trimLeadingCharacter(variant, '_');\n            }\n        }\n        return (language.length() > 0 ? new Locale(language, country, variant) : null);\n    }\n\n    private static void validateLocalePart(String localePart) {\n        for (int i = 0; i < localePart.length(); i++) {\n            char ch = localePart.charAt(i);\n            if (ch != '_' && ch != ' ' && !Character.isLetterOrDigit(ch)) {\n                throw new IllegalArgumentException(\n                    \"Locale part \\\"\" + localePart + \"\\\" contains invalid characters\");\n            }\n        }\n    }\n\n    /**\n     * Determine the RFC 3066 compliant language tag,\n     * as used for the HTTP \"Accept-Language\" header.\n     * @param locale the Locale to transform to a language tag\n     * @return the RFC 3066 compliant language tag as String\n     */\n    public static String toLanguageTag(Locale locale) {\n        return locale.getLanguage() + (hasText(locale.getCountry()) ? \"-\" + locale.getCountry() : \"\");\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with String arrays\n    //---------------------------------------------------------------------\n\n    /**\n     * Append the given String to the given String array, returning a new array\n     * consisting of the input array contents plus the given String.\n     * @param array the array to append to (can be <code>null</code>)\n     * @param str the String to append\n     * @return the new array (never <code>null</code>)\n     */\n    public static String[] addStringToArray(String[] array, String str) {\n        if (Objects.isEmpty(array)) {\n            return new String[] {str};\n        }\n        String[] newArr = new String[array.length + 1];\n        System.arraycopy(array, 0, newArr, 0, array.length);\n        newArr[array.length] = str;\n        return newArr;\n    }\n\n    /**\n     * Concatenate the given String arrays into one,\n     * with overlapping array elements included twice.\n     * <p>The order of elements in the original arrays is preserved.\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        String[] newArr = new String[array1.length + array2.length];\n        System.arraycopy(array1, 0, newArr, 0, array1.length);\n        System.arraycopy(array2, 0, newArr, array1.length, array2.length);\n        return newArr;\n    }\n\n    /**\n     * Merge the given String arrays into one, with overlapping\n     * array elements only included once.\n     * <p>The order of elements in the original arrays is preserved\n     * (with the exception of overlapping elements, which are only\n     * included on their first occurrence).\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] mergeStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        List<String> result = new ArrayList<String>();\n        result.addAll(Arrays.asList(array1));\n        for (String str : array2) {\n            if (!result.contains(str)) {\n                result.add(str);\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Turn given source String array into sorted array.\n     * @param array the source array\n     * @return the sorted array (never <code>null</code>)\n     */\n    public static String[] sortStringArray(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        Arrays.sort(array);\n        return array;\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Collection was <code>null</code>)\n     */\n    public static String[] toStringArray(Collection<String> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new String[collection.size()]);\n    }\n\n    /**\n     * Copy the given Enumeration into a String array.\n     * The Enumeration must contain String elements only.\n     * @param enumeration the Enumeration to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Enumeration was <code>null</code>)\n     */\n    public static String[] toStringArray(Enumeration<String> enumeration) {\n        if (enumeration == null) {\n            return null;\n        }\n        List<String> list = java.util.Collections.list(enumeration);\n        return list.toArray(new String[list.size()]);\n    }\n\n    /**\n     * Trim the elements of the given String array,\n     * calling <code>String.trim()</code> on each of them.\n     * @param array the original String array\n     * @return the resulting array (of the same size) with trimmed elements\n     */\n    public static String[] trimArrayElements(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        String[] result = new String[array.length];\n        for (int i = 0; i < array.length; i++) {\n            String element = array[i];\n            result[i] = (element != null ? element.trim() : null);\n        }\n        return result;\n    }\n\n    /**\n     * Remove duplicate Strings from the given array.\n     * Also sorts the array, as it uses a TreeSet.\n     * @param array the String array\n     * @return an array without duplicates, in natural sort order\n     */\n    public static String[] removeDuplicateStrings(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return array;\n        }\n        Set<String> set = new TreeSet<String>();\n        for (String element : array) {\n            set.add(element);\n        }\n        return toStringArray(set);\n    }\n\n    /**\n     * Split a String at the first occurrence of the delimiter.\n     * Does not include the delimiter in the result.\n     * @param toSplit the string to split\n     * @param delimiter to split the string up with\n     * @return a two element array with index 0 being before the delimiter, and\n     * index 1 being after the delimiter (neither element includes the delimiter);\n     * or <code>null</code> if the delimiter wasn't found in the given input String\n     */\n    public static String[] split(String toSplit, String delimiter) {\n        if (!hasLength(toSplit) || !hasLength(delimiter)) {\n            return null;\n        }\n        int offset = toSplit.indexOf(delimiter);\n        if (offset < 0) {\n            return null;\n        }\n        String beforeDelimiter = toSplit.substring(0, offset);\n        String afterDelimiter = toSplit.substring(offset + delimiter.length());\n        return new String[] {beforeDelimiter, afterDelimiter};\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was null or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {\n        return splitArrayElementsIntoProperties(array, delimiter, null);\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @param charsToDelete one or more characters to remove from each element\n     * prior to attempting the split operation (typically the quotation mark\n     * symbol), or <code>null</code> if no removal should occur\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was <code>null</code> or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(\n        String[] array, String delimiter, String charsToDelete) {\n\n        if (Objects.isEmpty(array)) {\n            return null;\n        }\n        Properties result = new Properties();\n        for (String element : array) {\n            if (charsToDelete != null) {\n                element = deleteAny(element, charsToDelete);\n            }\n            String[] splittedElement = split(element, delimiter);\n            if (splittedElement == null) {\n                continue;\n            }\n            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n        }\n        return result;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter)\n     * @param trimTokens trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     * (only applies to tokens that are empty after trimming; StringTokenizer\n     * will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     * was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(\n        String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List<String> tokens = new ArrayList<String>();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter) {\n        return delimitedListToStringArray(str, delimiter, null);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @param charsToDelete a set of characters to delete. Useful for deleting unwanted\n     * line breaks: e.g. \"\\r\\n\\f\" will delete all new lines and line feeds in a String.\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {\n        if (str == null) {\n            return new String[0];\n        }\n        if (delimiter == null) {\n            return new String[] {str};\n        }\n        List<String> result = new ArrayList<String>();\n        if (\"\".equals(delimiter)) {\n            for (int i = 0; i < str.length(); i++) {\n                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));\n            }\n        }\n        else {\n            int pos = 0;\n            int delPos;\n            while ((delPos = str.indexOf(delimiter, pos)) != -1) {\n                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));\n                pos = delPos + delimiter.length();\n            }\n            if (str.length() > 0 && pos <= str.length()) {\n                // Add rest of String, but not in case of empty input.\n                result.add(deleteAny(str.substring(pos), charsToDelete));\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Convert a CSV list into an array of Strings.\n     * @param str the input String\n     * @return an array of Strings, or the empty array in case of empty input\n     */\n    public static String[] commaDelimitedListToStringArray(String str) {\n        return delimitedListToStringArray(str, \",\");\n    }\n\n    /**\n     * Convenience method to convert a CSV string list to a set.\n     * Note that this will suppress duplicates.\n     * @param str the input String\n     * @return a Set of String entries in the list\n     */\n    public static Set<String> commaDelimitedListToSet(String str) {\n        Set<String> set = new TreeSet<String>();\n        String[] tokens = commaDelimitedListToStringArray(str);\n        for (String token : tokens) {\n            set.add(token);\n        }\n        return set;\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @param prefix the String to start each element with\n     * @param suffix the String to end each element with\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {\n        if (Collections.isEmpty(coll)) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        Iterator<?> it = coll.iterator();\n        while (it.hasNext()) {\n            sb.append(prefix).append(it.next()).append(suffix);\n            if (it.hasNext()) {\n                sb.append(delim);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim) {\n        return collectionToDelimitedString(coll, delim, \"\", \"\");\n    }\n\n    /**\n     * Convenience method to return a Collection as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @return the delimited String\n     */\n    public static String collectionToCommaDelimitedString(Collection<?> coll) {\n        return collectionToDelimitedString(coll, \",\");\n    }\n\n    /**\n     * Convenience method to return a String array as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String arrayToDelimitedString(Object[] arr, String delim) {\n        if (Objects.isEmpty(arr)) {\n            return \"\";\n        }\n        if (arr.length == 1) {\n            return Objects.nullSafeToString(arr[0]);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < arr.length; i++) {\n            if (i > 0) {\n                sb.append(delim);\n            }\n            sb.append(arr[i]);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a String array as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @return the delimited String\n     */\n    public static String arrayToCommaDelimitedString(Object[] arr) {\n        return arrayToDelimitedString(arr, \",\");\n    }\n\n}\n\n",
            "file_name": "Strings.java",
            "human_label": "Trim each element in the given string array and return the resulting array.",
            "level": "self_contained",
            "lineno": "826",
            "name": "trimArrayElements",
            "oracle_context": "{ \"apis\" : \"[isEmpty, trim]\", \"classes\" : \"[String[], String]\", \"vars\" : \"[length]\" }",
            "package": "io.jsonwebtoken.lang",
            "project": "jjwt-master"
        },
        {
            "_id": "636766f81a6d9265ec01775c",
            "all_context": "{ \"class_level\" : \"import java.io.Serializable;\\nNull NULL;\\nlong serialVersionUID;\\nObjectUtils();\\nequals(Object object1,Object object2);\\nnotEqual(Object object1,Object object2);\\nhashCode(Object obj);\\nidentityToString(Object object);\\nidentityToString(StringBuffer buffer,Object object);\\ntoString(Object obj);\\ntoString(Object obj,String nullStr);\\nmin(Comparable c1,Comparable c2);\\nmax(Comparable c1,Comparable c2);\\ncompare(Comparable c1,Comparable c2);\\ncompare(Comparable c1,Comparable c2,boolean nullGreater);\\nNull();\\nreadResolve();\\ndefaultIfNull(Object object,Object defaultValue);\\n\", \"repo_level\" : \"\" }",
            "class_name": "ObjectUtils",
            "code": "public static String toString(Object obj){\n  return obj == null ? \"\" : obj.toString();\n}\n",
            "docstring": "/** \n * <p>Gets the <code>toString</code> of an <code>Object</code> returning an empty string (\"\") if <code>null</code> input.</p> <pre> ObjectUtils.toString(null)         = \"\" ObjectUtils.toString(\"\")           = \"\" ObjectUtils.toString(\"bat\")        = \"bat\" ObjectUtils.toString(Boolean.TRUE) = \"true\" </pre>\n * @see StringUtils#defaultString(String)\n * @see String#valueOf(Object)\n * @param obj  the Object to <code>toString</code>, may be null\n * @return the passed in Object's toString, or nullStr if <code>null</code> input\n * @since 2.0\n */\n",
            "end_lineno": "231",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils;\nimport java.io.Serializable;\n\n/**\n * <p>Operations on <code>Object</code>.</p>\n *\n * <p>This class tries to handle <code>null</code> input gracefully.\n * An exception will generally not be thrown for a <code>null</code> input.\n * Each method documents its behaviour in more detail.</p>\n *\n * <p>#ThreadSafe#</p>\n * @author Apache Software Foundation\n * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n * @author <a href=\"mailto:janekdb@yahoo.co.uk\">Janek Bogucki</a>\n * @author Daniel L. Rall\n * @author Gary Gregory\n * @author Mario Winterer\n * @author <a href=\"mailto:david@davidkarlsen.com\">David J. M. Karlsen</a>\n * @since 1.0\n * @version $Id: ObjectUtils.java 1057434 2011-01-11 01:27:37Z niallp $\n */\npublic class ObjectUtils {\n    /**\n     * <p>Singleton used as a <code>null</code> placeholder where\n     * <code>null</code> has another meaning.</p>\n     *\n     * <p>For example, in a <code>HashMap</code> the\n     * {@link java.util.HashMap#get(Object)} method returns\n     * <code>null</code> if the <code>Map</code> contains\n     * <code>null</code> or if there is no matching key. The\n     * <code>Null</code> placeholder can be used to distinguish between\n     * these two cases.</p>\n     *\n     * <p>Another example is <code>Hashtable</code>, where <code>null</code>\n     * cannot be stored.</p>\n     *\n     * <p>This instance is Serializable.</p>\n     */\n    public static final Null NULL = new Null();\n\n    /**\n     * <p><code>ObjectUtils</code> instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * <code>ObjectUtils.defaultIfNull(\"a\",\"b\");</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     */\n    public ObjectUtils() {\n        super();\n    }\n    // Defaulting\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Returns a default value if the object passed is\n     * <code>null</code>.</p>\n     *\n     * <pre>\n     * ObjectUtils.defaultIfNull(null, null)      = null\n     * ObjectUtils.defaultIfNull(null, \"\")        = \"\"\n     * ObjectUtils.defaultIfNull(null, \"zz\")      = \"zz\"\n     * ObjectUtils.defaultIfNull(\"abc\", *)        = \"abc\"\n     * ObjectUtils.defaultIfNull(Boolean.TRUE, *) = Boolean.TRUE\n     * </pre>\n     *\n     * @param object  the <code>Object</code> to test, may be <code>null</code>\n     * @param defaultValue  the default value to return, may be <code>null</code>\n     * @return <code>object</code> if it is not <code>null</code>, defaultValue otherwise\n     */\n    public static Object defaultIfNull(Object object, Object defaultValue) {\n        return object != null ? object : defaultValue;\n    }\n\n    /**\n     * <p>Compares two objects for equality, where either one or both\n     * objects may be <code>null</code>.</p>\n     *\n     * <pre>\n     * ObjectUtils.equals(null, null)                  = true\n     * ObjectUtils.equals(null, \"\")                    = false\n     * ObjectUtils.equals(\"\", null)                    = false\n     * ObjectUtils.equals(\"\", \"\")                      = true\n     * ObjectUtils.equals(Boolean.TRUE, null)          = false\n     * ObjectUtils.equals(Boolean.TRUE, \"true\")        = false\n     * ObjectUtils.equals(Boolean.TRUE, Boolean.TRUE)  = true\n     * ObjectUtils.equals(Boolean.TRUE, Boolean.FALSE) = false\n     * </pre>\n     *\n     * @param object1  the first object, may be <code>null</code>\n     * @param object2  the second object, may be <code>null</code>\n     * @return <code>true</code> if the values of both objects are the same\n     */\n    public static boolean equals(Object object1, Object object2) {\n        if (object1 == object2) {\n            return true;\n        }\n        if ((object1 == null) || (object2 == null)) {\n            return false;\n        }\n        return object1.equals(object2);\n    }\n\n    /**\n     * <p>Compares two objects for inequality, where either one or both\n     * objects may be <code>null</code>.</p>\n     *\n     * <pre>\n     * ObjectUtils.notEqual(null, null)                  = false\n     * ObjectUtils.notEqual(null, \"\")                    = true\n     * ObjectUtils.notEqual(\"\", null)                    = true\n     * ObjectUtils.notEqual(\"\", \"\")                      = false\n     * ObjectUtils.notEqual(Boolean.TRUE, null)          = true\n     * ObjectUtils.notEqual(Boolean.TRUE, \"true\")        = true\n     * ObjectUtils.notEqual(Boolean.TRUE, Boolean.TRUE)  = false\n     * ObjectUtils.notEqual(Boolean.TRUE, Boolean.FALSE) = true\n     * </pre>\n     *\n     * @param object1  the first object, may be <code>null</code>\n     * @param object2  the second object, may be <code>null</code>\n     * @return <code>false</code> if the values of both objects are the same\n     * @since 2.6\n     */\n    public static boolean notEqual(Object object1, Object object2) {\n        return ObjectUtils.equals(object1, object2) == false;\n    }\n\n    /**\n     * <p>Gets the hash code of an object returning zero when the\n     * object is <code>null</code>.</p>\n     *\n     * <pre>\n     * ObjectUtils.hashCode(null)   = 0\n     * ObjectUtils.hashCode(obj)    = obj.hashCode()\n     * </pre>\n     *\n     * @param obj  the object to obtain the hash code of, may be <code>null</code>\n     * @return the hash code of the object, or zero if null\n     * @since 2.1\n     */\n    public static int hashCode(Object obj) {\n        return (obj == null) ? 0 : obj.hashCode();\n    }\n    // Identity ToString\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Gets the toString that would be produced by <code>Object</code>\n     * if a class did not override toString itself. <code>null</code>\n     * will return <code>null</code>.</p>\n     *\n     * <pre>\n     * ObjectUtils.identityToString(null)         = null\n     * ObjectUtils.identityToString(\"\")           = \"java.lang.String@1e23\"\n     * ObjectUtils.identityToString(Boolean.TRUE) = \"java.lang.Boolean@7fa\"\n     * </pre>\n     *\n     * @param object  the object to create a toString for, may be\n     *  <code>null</code>\n     * @return the default toString text, or <code>null</code> if\n     *  <code>null</code> passed in\n     */\n    public static String identityToString(Object object) {\n        if (object == null) {\n            return null;\n        }\n        StringBuffer buffer = new StringBuffer();\n        identityToString(buffer, object);\n        return buffer.toString();\n    }\n\n    /**\n     * <p>Appends the toString that would be produced by <code>Object</code>\n     * if a class did not override toString itself. <code>null</code>\n     * will throw a NullPointerException for either of the two parameters. </p>\n     *\n     * <pre>\n     * ObjectUtils.identityToString(buf, \"\")            = buf.append(\"java.lang.String@1e23\"\n     * ObjectUtils.identityToString(buf, Boolean.TRUE)  = buf.append(\"java.lang.Boolean@7fa\"\n     * ObjectUtils.identityToString(buf, Boolean.TRUE)  = buf.append(\"java.lang.Boolean@7fa\")\n     * </pre>\n     *\n     * @param buffer  the buffer to append to\n     * @param object  the object to create a toString for\n     * @since 2.4\n     */\n    public static void identityToString(StringBuffer buffer, Object object) {\n        if (object == null) {\n            throw new NullPointerException(\"Cannot get the toString of a null identity\");\n        }\n        buffer.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object)));\n    }\n    // ToString\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Gets the <code>toString</code> of an <code>Object</code> returning\n     * an empty string (\"\") if <code>null</code> input.</p>\n     *\n     * <pre>\n     * ObjectUtils.toString(null)         = \"\"\n     * ObjectUtils.toString(\"\")           = \"\"\n     * ObjectUtils.toString(\"bat\")        = \"bat\"\n     * ObjectUtils.toString(Boolean.TRUE) = \"true\"\n     * </pre>\n     *\n     * @see StringUtils#defaultString(String)\n     * @see String#valueOf(Object)\n     * @param obj  the Object to <code>toString</code>, may be null\n     * @return the passed in Object's toString, or nullStr if <code>null</code> input\n     * @since 2.0\n     */\n    public static String toString(Object obj) {\n        return obj == null ? \"\" : obj.toString();\n    }\n\n    /**\n     * <p>Gets the <code>toString</code> of an <code>Object</code> returning\n     * a specified text if <code>null</code> input.</p>\n     *\n     * <pre>\n     * ObjectUtils.toString(null, null)           = null\n     * ObjectUtils.toString(null, \"null\")         = \"null\"\n     * ObjectUtils.toString(\"\", \"null\")           = \"\"\n     * ObjectUtils.toString(\"bat\", \"null\")        = \"bat\"\n     * ObjectUtils.toString(Boolean.TRUE, \"null\") = \"true\"\n     * </pre>\n     *\n     * @see StringUtils#defaultString(String, String)\n     * @see String#valueOf(Object)\n     * @param obj  the Object to <code>toString</code>, may be null\n     * @param nullStr  the String to return if <code>null</code> input, may be null\n     * @return the passed in Object's toString, or nullStr if <code>null</code> input\n     * @since 2.0\n     */\n    public static String toString(Object obj, String nullStr) {\n        return obj == null ? nullStr : obj.toString();\n    }\n    // Min/Max\n    //-----------------------------------------------------------------------\n\n    /**\n     * Null safe comparison of Comparables.\n     *\n     * @param c1  the first comparable, may be null\n     * @param c2  the second comparable, may be null\n     * @return\n     *  <ul>\n     *   <li>If both objects are non-null and unequal, the lesser object.\n     *   <li>If both objects are non-null and equal, c1.\n     *   <li>If one of the comparables is null, the non-null object.\n     *   <li>If both the comparables are null, null is returned.\n     *  </ul>\n     */\n    public static Object min(Comparable c1, Comparable c2) {\n        return (compare(c1, c2, true) <= 0 ? c1 : c2);\n    }\n\n    /**\n     * Null safe comparison of Comparables.\n     *\n     * @param c1  the first comparable, may be null\n     * @param c2  the second comparable, may be null\n     * @return\n     *  <ul>\n     *   <li>If both objects are non-null and unequal, the greater object.\n     *   <li>If both objects are non-null and equal, c1.\n     *   <li>If one of the comparables is null, the non-null object.\n     *   <li>If both the comparables are null, null is returned.\n     *  </ul>\n     */\n    public static Object max(Comparable c1, Comparable c2) {\n        return (compare(c1, c2, false) >= 0 ? c1 : c2);\n    }\n\n    /**\n     * Null safe comparison of Comparables.\n     * {@code null} is assumed to be less than a non-{@code null} value.\n     *\n     * @param c1  the first comparable, may be null\n     * @param c2  the second comparable, may be null\n     * @return a negative value if c1 < c2, zero if c1 = c2\n     * and a positive value if c1 > c2\n     * @since 2.6\n     */\n    public static int compare(Comparable c1, Comparable c2) {\n        return compare(c1, c2, false);\n    }\n\n    /**\n     * Null safe comparison of Comparables.\n     *\n     * @param c1  the first comparable, may be null\n     * @param c2  the second comparable, may be null\n     * @param nullGreater if true <code>null</code> is considered greater\n     * than a Non-<code>null</code> value or if false <code>null</code> is\n     * considered less than a Non-<code>null</code> value\n     * @return a negative value if c1 < c2, zero if c1 = c2\n     * and a positive value if c1 > c2\n     * @see java.util.Comparator#compare(Object, Object)\n     * @since 2.6\n     */\n    public static int compare(Comparable c1, Comparable c2, boolean nullGreater) {\n        if (c1 == c2) {\n            return 0;\n        } else if (c1 == null) {\n            return (nullGreater ? 1 : -1);\n        } else if (c2 == null) {\n            return (nullGreater ? -1 : 1);\n        }\n        return c1.compareTo(c2);\n    }\n    // Null\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Class used as a null placeholder where <code>null</code>\n     * has another meaning.</p>\n     *\n     * <p>For example, in a <code>HashMap</code> the\n     * {@link java.util.HashMap#get(Object)} method returns\n     * <code>null</code> if the <code>Map</code> contains\n     * <code>null</code> or if there is no matching key. The\n     * <code>Null</code> placeholder can be used to distinguish between\n     * these two cases.</p>\n     *\n     * <p>Another example is <code>Hashtable</code>, where <code>null</code>\n     * cannot be stored.</p>\n     */\n    public static class Null implements Serializable {\n        /**\n         * Required for serialization support. Declare serialization compatibility with Commons Lang 1.0\n         *\n         * @see Serializable\n         */\n        private static final long serialVersionUID = 7092611880189329093L;\n\n        /**\n         * Restricted constructor - singleton.\n         */\n        Null() {\n            super();\n        }\n\n        /**\n         * <p>Ensure singleton.</p>\n         *\n         * @return the singleton value\n         */\n        private Object readResolve() {\n            return ObjectUtils.NULL;\n        }\n    }\n}\n",
            "file_name": "ObjectUtils.java",
            "human_label": "Return the string representation of the given object, return an empty string if the object is null.",
            "level": "self_contained",
            "lineno": "212",
            "name": "toString",
            "oracle_context": "{ \"apis\" : \"[]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
            "package": "net.hasor.utils",
            "project": "hasor-master"
        },
        {
            "_id": "636767691a6d9265ec0181aa",
            "all_context": "{ \"class_level\" : \"import java.io.Closeable;\\nimport java.io.IOException;\\nimport java.lang.reflect.Array;\\nimport java.util.Arrays;\\nint INITIAL_HASH;\\nint MULTIPLIER;\\nString EMPTY_STRING;\\nString NULL_STRING;\\nString ARRAY_START;\\nString ARRAY_END;\\nString EMPTY_ARRAY;\\nString ARRAY_ELEMENT_SEPARATOR;\\nObjects();\\nisCompatibleWithThrowsClause(Throwable ex,Class[] declaredExceptions);\\nisArray(Object obj);\\nisEmpty(Object[] array);\\nisEmpty(byte[] array);\\ncontainsElement(Object[] array,Object element);\\ncontainsConstant(Enum<?>[] enumValues,String constant);\\ncontainsConstant(Enum<?>[] enumValues,String constant,boolean caseSensitive);\\ncaseInsensitiveValueOf(E[] enumValues,String constant);\\naddObjectToArray(A[] array,O obj);\\ntoObjectArray(Object source);\\nnullSafeEquals(Object o1,Object o2);\\nnullSafeHashCode(Object obj);\\nnullSafeHashCode(Object[] array);\\nnullSafeHashCode(boolean[] array);\\nnullSafeHashCode(byte[] array);\\nnullSafeHashCode(char[] array);\\nnullSafeHashCode(double[] array);\\nnullSafeHashCode(float[] array);\\nnullSafeHashCode(int[] array);\\nnullSafeHashCode(long[] array);\\nnullSafeHashCode(short[] array);\\nhashCode(boolean bool);\\nhashCode(double dbl);\\nhashCode(float flt);\\nhashCode(long lng);\\nidentityToString(Object obj);\\ngetIdentityHexString(Object obj);\\ngetDisplayString(Object obj);\\nnullSafeClassName(Object obj);\\nnullSafeToString(Object obj);\\nnullSafeToString(Object[] array);\\nnullSafeToString(boolean[] array);\\nnullSafeToString(byte[] array);\\nnullSafeToString(char[] array);\\nnullSafeToString(double[] array);\\nnullSafeToString(float[] array);\\nnullSafeToString(int[] array);\\nnullSafeToString(long[] array);\\nnullSafeToString(short[] array);\\nnullSafeClose(Closeable closeables);\\nisCheckedException(Throwable ex);\\n\", \"repo_level\" : \"\" }",
            "class_name": "Objects",
            "code": "public static int nullSafeHashCode(long[] array){\n  if (array == null) {\n    return 0;\n  }\n  int hash=INITIAL_HASH;\n  int arraySize=array.length;\n  for (int i=0; i < arraySize; i++) {\n    hash=MULTIPLIER * hash + hashCode(array[i]);\n  }\n  return hash;\n}\n",
            "docstring": "/** \n * Return a hash code based on the contents of the specified array. If <code>array</code> is <code>null</code>, this method returns 0.\n * @param array the long array to obtain a hashcode\n * @return the long array's hashcode, which could be 0 if the array is null.\n */\n",
            "end_lineno": "493",
            "file_content": "/*\n * Copyright (C) 2014 jsonwebtoken.io\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.jsonwebtoken.lang;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\n\npublic final class Objects {\n\n    private Objects(){} //prevent instantiation\n\n    private static final int INITIAL_HASH = 7;\n    private static final int MULTIPLIER   = 31;\n\n    private static final String EMPTY_STRING            = \"\";\n    private static final String NULL_STRING             = \"null\";\n    private static final String ARRAY_START             = \"{\";\n    private static final String ARRAY_END               = \"}\";\n    private static final String EMPTY_ARRAY             = ARRAY_START + ARRAY_END;\n    private static final String ARRAY_ELEMENT_SEPARATOR = \", \";\n\n    /**\n     * Return whether the given throwable is a checked exception:\n     * that is, neither a RuntimeException nor an Error.\n     *\n     * @param ex the throwable to check\n     * @return whether the throwable is a checked exception\n     * @see java.lang.Exception\n     * @see java.lang.RuntimeException\n     * @see java.lang.Error\n     */\n    public static boolean isCheckedException(Throwable ex) {\n        return !(ex instanceof RuntimeException || ex instanceof Error);\n    }\n\n    /**\n     * Check whether the given exception is compatible with the exceptions\n     * declared in a throws clause.\n     *\n     * @param ex                 the exception to checked\n     * @param declaredExceptions the exceptions declared in the throws clause\n     * @return whether the given exception is compatible\n     */\n    public static boolean isCompatibleWithThrowsClause(Throwable ex, Class[] declaredExceptions) {\n        if (!isCheckedException(ex)) {\n            return true;\n        }\n        if (declaredExceptions != null) {\n            int i = 0;\n            while (i < declaredExceptions.length) {\n                if (declaredExceptions[i].isAssignableFrom(ex.getClass())) {\n                    return true;\n                }\n                i++;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns {@code true} if the specified argument is an Object or primitive array, {@code false} otherwise.\n     *\n     * @param obj the object instance to check\n     * @return {@code true} if the specified argument is an Object or primitive array, {@code false} otherwise.\n     */\n    public static boolean isArray(Object obj) {\n        return (obj != null && obj.getClass().isArray());\n    }\n\n    /**\n     * {@code true} if the specified array is null or zero length, {@code false} if populated.\n     *\n     * @param array the array to check\n     * @return {@code true} if the specified array is null or zero length, {@code false} if populated.\n     */\n    public static boolean isEmpty(Object[] array) {\n        return (array == null || array.length == 0);\n    }\n\n    /**\n     * Returns {@code true} if the specified byte array is null or of zero length, {@code false} if populated.\n     *\n     * @param array the byte array to check\n     * @return {@code true} if the specified byte array is null or of zero length, {@code false} if populated.\n     */\n    public static boolean isEmpty(byte[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * Check whether the given array contains the given element.\n     *\n     * @param array   the array to check (may be <code>null</code>,\n     *                in which case the return value will always be <code>false</code>)\n     * @param element the element to check for\n     * @return whether the element has been found in the given array\n     */\n    public static boolean containsElement(Object[] array, Object element) {\n        if (array == null) {\n            return false;\n        }\n        for (Object arrayEle : array) {\n            if (nullSafeEquals(arrayEle, element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given array of enum constants contains a constant with the given name,\n     * ignoring case when determining a match.\n     *\n     * @param enumValues the enum values to check, typically the product of a call to MyEnum.values()\n     * @param constant   the constant name to find (must not be null or empty string)\n     * @return whether the constant has been found in the given array\n     */\n    public static boolean containsConstant(Enum<?>[] enumValues, String constant) {\n        return containsConstant(enumValues, constant, false);\n    }\n\n    /**\n     * Check whether the given array of enum constants contains a constant with the given name.\n     *\n     * @param enumValues    the enum values to check, typically the product of a call to MyEnum.values()\n     * @param constant      the constant name to find (must not be null or empty string)\n     * @param caseSensitive whether case is significant in determining a match\n     * @return whether the constant has been found in the given array\n     */\n    public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive) {\n        for (Enum<?> candidate : enumValues) {\n            if (caseSensitive ?\n                candidate.toString().equals(constant) :\n                candidate.toString().equalsIgnoreCase(constant)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Case insensitive alternative to {@link Enum#valueOf(Class, String)}.\n     *\n     * @param <E>        the concrete Enum type\n     * @param enumValues the array of all Enum constants in question, usually per Enum.values()\n     * @param constant   the constant to get the enum value of\n     * @return the enum constant of the specified enum type with the specified case-insensitive name\n     * @throws IllegalArgumentException if the given constant is not found in the given array\n     *                                  of enum values. Use {@link #containsConstant(Enum[], String)} as a guard to\n     *                                  avoid this exception.\n     */\n    public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant) {\n        for (E candidate : enumValues) {\n            if (candidate.toString().equalsIgnoreCase(constant)) {\n                return candidate;\n            }\n        }\n        throw new IllegalArgumentException(\n            String.format(\"constant [%s] does not exist in enum type %s\",\n                          constant, enumValues.getClass().getComponentType().getName()));\n    }\n\n    /**\n     * Append the given object to the given array, returning a new array\n     * consisting of the input array contents plus the given object.\n     *\n     * @param array the array to append to (can be <code>null</code>)\n     * @param <A> the type of each element in the specified {@code array}\n     * @param obj   the object to append\n     * @param <O> the type of the specified object, which must equal to or extend the {@code &lt;A&gt;} type.\n     * @return the new array (of the same component type; never <code>null</code>)\n     */\n    public static <A, O extends A> A[] addObjectToArray(A[] array, O obj) {\n        Class<?> compType = Object.class;\n        if (array != null) {\n            compType = array.getClass().getComponentType();\n        } else if (obj != null) {\n            compType = obj.getClass();\n        }\n        int newArrLength = (array != null ? array.length + 1 : 1);\n        @SuppressWarnings(\"unchecked\")\n        A[] newArr = (A[]) Array.newInstance(compType, newArrLength);\n        if (array != null) {\n            System.arraycopy(array, 0, newArr, 0, array.length);\n        }\n        newArr[newArr.length - 1] = obj;\n        return newArr;\n    }\n\n    /**\n     * Convert the given array (which may be a primitive array) to an\n     * object array (if necessary of primitive wrapper objects).\n     * <p>A <code>null</code> source value will be converted to an\n     * empty Object array.\n     *\n     * @param source the (potentially primitive) array\n     * @return the corresponding object array (never <code>null</code>)\n     * @throws IllegalArgumentException if the parameter is not an array\n     */\n    public static Object[] toObjectArray(Object source) {\n        if (source instanceof Object[]) {\n            return (Object[]) source;\n        }\n        if (source == null) {\n            return new Object[0];\n        }\n        if (!source.getClass().isArray()) {\n            throw new IllegalArgumentException(\"Source is not an array: \" + source);\n        }\n        int length = Array.getLength(source);\n        if (length == 0) {\n            return new Object[0];\n        }\n        Class wrapperType = Array.get(source, 0).getClass();\n        Object[] newArray = (Object[]) Array.newInstance(wrapperType, length);\n        for (int i = 0; i < length; i++) {\n            newArray[i] = Array.get(source, i);\n        }\n        return newArray;\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for content-based equality/hash-code handling\n    //---------------------------------------------------------------------\n\n    /**\n     * Determine if the given objects are equal, returning <code>true</code>\n     * if both are <code>null</code> or <code>false</code> if only one is\n     * <code>null</code>.\n     * <p>Compares arrays with <code>Arrays.equals</code>, performing an equality\n     * check based on the array elements rather than the array reference.\n     *\n     * @param o1 first Object to compare\n     * @param o2 second Object to compare\n     * @return whether the given objects are equal\n     * @see java.util.Arrays#equals\n     */\n    public static boolean nullSafeEquals(Object o1, Object o2) {\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.equals(o2)) {\n            return true;\n        }\n        if (o1.getClass().isArray() && o2.getClass().isArray()) {\n            if (o1 instanceof Object[] && o2 instanceof Object[]) {\n                return Arrays.equals((Object[]) o1, (Object[]) o2);\n            }\n            if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n                return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n            }\n            if (o1 instanceof byte[] && o2 instanceof byte[]) {\n                return Arrays.equals((byte[]) o1, (byte[]) o2);\n            }\n            if (o1 instanceof char[] && o2 instanceof char[]) {\n                return Arrays.equals((char[]) o1, (char[]) o2);\n            }\n            if (o1 instanceof double[] && o2 instanceof double[]) {\n                return Arrays.equals((double[]) o1, (double[]) o2);\n            }\n            if (o1 instanceof float[] && o2 instanceof float[]) {\n                return Arrays.equals((float[]) o1, (float[]) o2);\n            }\n            if (o1 instanceof int[] && o2 instanceof int[]) {\n                return Arrays.equals((int[]) o1, (int[]) o2);\n            }\n            if (o1 instanceof long[] && o2 instanceof long[]) {\n                return Arrays.equals((long[]) o1, (long[]) o2);\n            }\n            if (o1 instanceof short[] && o2 instanceof short[]) {\n                return Arrays.equals((short[]) o1, (short[]) o2);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return as hash code for the given object; typically the value of\n     * <code>{@link Object#hashCode()}</code>. If the object is an array,\n     * this method will delegate to any of the <code>nullSafeHashCode</code>\n     * methods for arrays in this class. If the object is <code>null</code>,\n     * this method returns 0.\n     *\n     * @see #nullSafeHashCode(Object[])\n     * @see #nullSafeHashCode(boolean[])\n     * @see #nullSafeHashCode(byte[])\n     * @see #nullSafeHashCode(char[])\n     * @see #nullSafeHashCode(double[])\n     * @see #nullSafeHashCode(float[])\n     * @see #nullSafeHashCode(int[])\n     * @see #nullSafeHashCode(long[])\n     * @see #nullSafeHashCode(short[])\n     * @param obj the object to use for obtaining a hashcode\n     * @return the object's hashcode, which could be 0 if the object is null.\n     */\n    public static int nullSafeHashCode(Object obj) {\n        if (obj == null) {\n            return 0;\n        }\n        if (obj.getClass().isArray()) {\n            if (obj instanceof Object[]) {\n                return nullSafeHashCode((Object[]) obj);\n            }\n            if (obj instanceof boolean[]) {\n                return nullSafeHashCode((boolean[]) obj);\n            }\n            if (obj instanceof byte[]) {\n                return nullSafeHashCode((byte[]) obj);\n            }\n            if (obj instanceof char[]) {\n                return nullSafeHashCode((char[]) obj);\n            }\n            if (obj instanceof double[]) {\n                return nullSafeHashCode((double[]) obj);\n            }\n            if (obj instanceof float[]) {\n                return nullSafeHashCode((float[]) obj);\n            }\n            if (obj instanceof int[]) {\n                return nullSafeHashCode((int[]) obj);\n            }\n            if (obj instanceof long[]) {\n                return nullSafeHashCode((long[]) obj);\n            }\n            if (obj instanceof short[]) {\n                return nullSafeHashCode((short[]) obj);\n            }\n        }\n        return obj.hashCode();\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the array to obtain a hashcode\n     * @return the array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(Object[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + nullSafeHashCode(array[i]);\n        }\n        return hash;\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the boolean array to obtain a hashcode\n     * @return the boolean array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(boolean[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + hashCode(array[i]);\n        }\n        return hash;\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the byte array to obtain a hashcode\n     * @return the byte array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(byte[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + array[i];\n        }\n        return hash;\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the char array to obtain a hashcode\n     * @return the char array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(char[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + array[i];\n        }\n        return hash;\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the double array to obtain a hashcode\n     * @return the double array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(double[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + hashCode(array[i]);\n        }\n        return hash;\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the float array to obtain a hashcode\n     * @return the float array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(float[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + hashCode(array[i]);\n        }\n        return hash;\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the int array to obtain a hashcode\n     * @return the int array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(int[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + array[i];\n        }\n        return hash;\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the long array to obtain a hashcode\n     * @return the long array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(long[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + hashCode(array[i]);\n        }\n        return hash;\n    }\n\n    /**\n     * Return a hash code based on the contents of the specified array.\n     * If <code>array</code> is <code>null</code>, this method returns 0.\n     * @param array the short array to obtain a hashcode\n     * @return the short array's hashcode, which could be 0 if the array is null.\n     */\n    public static int nullSafeHashCode(short[] array) {\n        if (array == null) {\n            return 0;\n        }\n        int hash = INITIAL_HASH;\n        int arraySize = array.length;\n        for (int i = 0; i < arraySize; i++) {\n            hash = MULTIPLIER * hash + array[i];\n        }\n        return hash;\n    }\n\n    /**\n     * Return the same value as <code>{@link Boolean#hashCode()}</code>.\n     *\n     * @param bool the boolean to get a hashcode\n     * @return the same value as {@link Boolean#hashCode()}.\n     * @see Boolean#hashCode()\n     */\n    public static int hashCode(boolean bool) {\n        return bool ? 1231 : 1237;\n    }\n\n    /**\n     * Return the same value as <code>{@link Double#hashCode()}</code>.\n     *\n     * @param dbl the double to get a hashcode\n     * @return the same value as {@link Double#hashCode()}.\n     * @see Double#hashCode()\n     */\n    public static int hashCode(double dbl) {\n        long bits = Double.doubleToLongBits(dbl);\n        return hashCode(bits);\n    }\n\n    /**\n     * Return the same value as <code>{@link Float#hashCode()}</code>.\n     *\n     * @param flt the float to get a hashcode\n     * @return the same value as {@link Float#hashCode()}.\n     * @see Float#hashCode()\n     */\n    public static int hashCode(float flt) {\n        return Float.floatToIntBits(flt);\n    }\n\n    /**\n     * Return the same value as <code>{@link Long#hashCode()}</code>.\n     *\n     * @param lng the long to get a hashcode\n     * @return the same value as {@link Long#hashCode()}.\n     * @see Long#hashCode()\n     */\n    public static int hashCode(long lng) {\n        return (int) (lng ^ (lng >>> 32));\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for toString output\n    //---------------------------------------------------------------------\n\n    /**\n     * Return a String representation of an object's overall identity.\n     *\n     * @param obj the object (which may be <code>null</code>).\n     * @return the object's identity as String representation, or an empty String if the object was <code>null</code>.\n     */\n    public static String identityToString(Object obj) {\n        if (obj == null) {\n            return EMPTY_STRING;\n        }\n        return obj.getClass().getName() + \"@\" + getIdentityHexString(obj);\n    }\n\n    /**\n     * Return a hex String form of an object's identity hash code.\n     *\n     * @param obj the object\n     * @return the object's identity code in hex notation\n     */\n    public static String getIdentityHexString(Object obj) {\n        return Integer.toHexString(System.identityHashCode(obj));\n    }\n\n    /**\n     * Return a content-based String representation if <code>obj</code> is\n     * not <code>null</code>; otherwise returns an empty String.\n     * <p>Differs from {@link #nullSafeToString(Object)} in that it returns\n     * an empty String rather than \"null\" for a <code>null</code> value.\n     *\n     * @param obj the object to build a display String for\n     * @return a display String representation of <code>obj</code>\n     * @see #nullSafeToString(Object)\n     */\n    public static String getDisplayString(Object obj) {\n        if (obj == null) {\n            return EMPTY_STRING;\n        }\n        return nullSafeToString(obj);\n    }\n\n    /**\n     * Determine the class name for the given object.\n     * <p>Returns <code>\"null\"</code> if <code>obj</code> is <code>null</code>.\n     *\n     * @param obj the object to introspect (may be <code>null</code>)\n     * @return the corresponding class name\n     */\n    public static String nullSafeClassName(Object obj) {\n        return (obj != null ? obj.getClass().getName() : NULL_STRING);\n    }\n\n    /**\n     * Return a String representation of the specified Object.\n     * <p>Builds a String representation of the contents in case of an array.\n     * Returns <code>\"null\"</code> if <code>obj</code> is <code>null</code>.\n     *\n     * @param obj the object to build a String representation for\n     * @return a String representation of <code>obj</code>\n     */\n    public static String nullSafeToString(Object obj) {\n        if (obj == null) {\n            return NULL_STRING;\n        }\n        if (obj instanceof String) {\n            return (String) obj;\n        }\n        if (obj instanceof Object[]) {\n            return nullSafeToString((Object[]) obj);\n        }\n        if (obj instanceof boolean[]) {\n            return nullSafeToString((boolean[]) obj);\n        }\n        if (obj instanceof byte[]) {\n            return nullSafeToString((byte[]) obj);\n        }\n        if (obj instanceof char[]) {\n            return nullSafeToString((char[]) obj);\n        }\n        if (obj instanceof double[]) {\n            return nullSafeToString((double[]) obj);\n        }\n        if (obj instanceof float[]) {\n            return nullSafeToString((float[]) obj);\n        }\n        if (obj instanceof int[]) {\n            return nullSafeToString((int[]) obj);\n        }\n        if (obj instanceof long[]) {\n            return nullSafeToString((long[]) obj);\n        }\n        if (obj instanceof short[]) {\n            return nullSafeToString((short[]) obj);\n        }\n        String str = obj.toString();\n        return (str != null ? str : EMPTY_STRING);\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(Object[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n            sb.append(String.valueOf(array[i]));\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(boolean[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n\n            sb.append(array[i]);\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(byte[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n            sb.append(array[i]);\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(char[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n            sb.append(\"'\").append(array[i]).append(\"'\");\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(double[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n\n            sb.append(array[i]);\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(float[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n\n            sb.append(array[i]);\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(int[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n            sb.append(array[i]);\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(long[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n            sb.append(array[i]);\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    /**\n     * Return a String representation of the contents of the specified array.\n     * <p>The String representation consists of a list of the array's elements,\n     * enclosed in curly braces (<code>\"{}\"</code>). Adjacent elements are separated\n     * by the characters <code>\", \"</code> (a comma followed by a space). Returns\n     * <code>\"null\"</code> if <code>array</code> is <code>null</code>.\n     *\n     * @param array the array to build a String representation for\n     * @return a String representation of <code>array</code>\n     */\n    public static String nullSafeToString(short[] array) {\n        if (array == null) {\n            return NULL_STRING;\n        }\n        int length = array.length;\n        if (length == 0) {\n            return EMPTY_ARRAY;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            if (i == 0) {\n                sb.append(ARRAY_START);\n            } else {\n                sb.append(ARRAY_ELEMENT_SEPARATOR);\n            }\n            sb.append(array[i]);\n        }\n        sb.append(ARRAY_END);\n        return sb.toString();\n    }\n\n    public static void nullSafeClose(Closeable... closeables) {\n        if (closeables == null) {\n            return;\n        }\n\n        for (Closeable closeable : closeables) {\n            if (closeable != null) {\n                try {\n                    closeable.close();\n                } catch (IOException e) {\n                    //Ignore the exception during close.\n                }\n            }\n        }\n    }\n}\n",
            "file_name": "Objects.java",
            "human_label": "Compute the hash code of the whole array, by accumulating the multiplication of each element hash code and the  MULTIPLIER.",
            "level": "class_runnable",
            "lineno": "477",
            "name": "nullSafeHashCode",
            "oracle_context": "{ \"apis\" : \"[hashCode]\", \"classes\" : \"[]\", \"vars\" : \"[length, INITIAL_HASH, MULTIPLIER]\" }",
            "package": "io.jsonwebtoken.lang",
            "project": "jjwt-master"
        },
        {
            "_id": "636767441a6d9265ec017cc1",
            "all_context": "{ \"class_level\" : \"import java.util.*;\\nTreeNode<T> virtualRoot;\\nint modCount;\\nTreeNodeIterator iterator;\\nTreeNode<T> nextNode;\\nint expectedModCount;\\nT value;\\nTreeNode<T> parent;\\nTreeNode<T> left;\\nTreeNode<T> right;\\nTreeNode<T> successor;\\nTreeNode<T> predecessor;\\nTreeNode<T> subtreeMin;\\nTreeNode<T> subtreeMax;\\nint height;\\nint subtreeSize;\\nAVLTree();\\nAVLTree(TreeNode root);\\naddMaxNode(TreeNode newMax);\\naddMin(T value);\\naddMinNode(TreeNode newMin);\\nsplitAfter(TreeNode node);\\nsplitBefore(TreeNode node);\\nmergeAfter(AVLTree tree);\\nmergeBefore(AVLTree tree);\\nremoveMin();\\nremoveMax();\\ngetRoot();\\nsuccessor(TreeNode node);\\npredecessor(TreeNode node);\\ngetMin();\\ngetMax();\\nisEmpty();\\nclear();\\ngetSize();\\nmakeRoot(TreeNode node);\\nsplit(TreeNode left,TreeNode right,TreeNode p,boolean leftMove);\\nmerge(TreeNode junctionNode,TreeNode left,TreeNode right);\\nswap(AVLTree tree);\\nrotateRight(TreeNode node);\\nrotateLeft(TreeNode node);\\nbalance(TreeNode node);\\nbalance(TreeNode node,TreeNode stop);\\nbalanceNode(TreeNode node);\\nregisterModification();\\ntoString();\\niterator();\\nnodeIterator();\\nTreeValuesIterator();\\nhasNext();\\nnext();\\nTreeNodeIterator();\\ncheckForComodification();\\nTreeNode(T value);\\ngetValue();\\ngetSubtreeMin();\\ngetSubtreeMax();\\ngetTreeMin();\\ngetTreeMax();\\ngetParent();\\ngetLeft();\\ngetRight();\\ngetHeight();\\ngetSubtreeSize();\\nreset();\\ngetRightHeight();\\ngetLeftHeight();\\ngetLeftSubtreeSize();\\ngetRightSubtreeSize();\\nupdateHeightAndSubtreeSize();\\nisLeftDoubleHeavy();\\nisRightDoubleHeavy();\\nisLeftHeavy();\\nisRightHeavy();\\nisLeftChild();\\nisRightChild();\\ngetSuccessor();\\ngetPredecessor();\\nsetSuccessor(TreeNode node);\\nsetPredecessor(TreeNode node);\\nsetLeftChild(TreeNode node);\\nsetRightChild(TreeNode node);\\nsubstituteChild(TreeNode prevChild,TreeNode newChild);\\naddMax(T value);\\n\", \"repo_level\" : \"\" }",
            "class_name": "AVLTree",
            "code": "private TreeNode<T> rotateRight(TreeNode<T> node){\n  TreeNode<T> left=node.left;\n  left.parent=null;\n  node.setLeftChild(left.right);\n  left.setRightChild(node);\n  node.updateHeightAndSubtreeSize();\n  left.updateHeightAndSubtreeSize();\n  return left;\n}\n",
            "docstring": "/** \n * Performs a right node rotation.\n * @param node a node to rotate\n * @return a new parent of the {@code node}\n */\n",
            "end_lineno": "506",
            "file_content": "/*\n * (C) Copyright 2020-2021, by Timofey Chudakov and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.util;\n\nimport java.util.*;\n\n/**\n * Implementation of the <a href=\"https://en.wikipedia.org/wiki/AVL_tree\">AVL tree</a> data\n * structure. <b>Note:</b> this tree doesn't use key comparisons, so this tree can't be used as a\n * binary search tree. This implies that the same key can be added to this tree multiple times.\n * <p>\n * AVL tree is a self-balancing binary tree data structure. In an AVL tree, the heights of two child\n * subtrees differ by at most one. This ensures that the height of the tree is $\\mathcal{O}(\\log n)$\n * where $n$ is the number of elements in the tree. Also this tree doesn't support key comparisons,\n * it does define an element order. As a result, this tree can be used to query node\n * successor/predecessor.\n * <p>\n * Subtree query means that the result is being computed only on the subtree nodes. This tree\n * supports the following operations:\n * <ul>\n * <li>Min/max insertion and deletion in $\\mathcal{O}(\\log n)$ time</li>\n * <li>Subtree min/max queries in $\\mathcal{O}(1)$ time</li>\n * <li>Node successor/predecessor queries in $\\mathcal{O}(1)$ time</li>\n * <li>Tree split in $\\mathcal{O}(\\log n)$ time</li>\n * <li>Tree merge in $\\mathcal{O}(\\log n)$ time</li>\n * </ul>\n * <p>\n * This implementation gives users access to the tree nodes which hold the inserted elements. The\n * user is able to store the tree nodes references but isn't able to modify them.\n *\n * @param <T> the key data type\n * @author Timofey Chudakov\n */\npublic class AVLTree<T>\n    implements\n    Iterable<T>\n{\n    /**\n     * An auxiliary node which's always present in a tree and doesn't contain any data.\n     */\n    private TreeNode<T> virtualRoot = new TreeNode<>(null);\n    /**\n     * Modification tracker\n     */\n    private int modCount = 0;\n\n    /**\n     * Constructs an empty tree\n     */\n    public AVLTree()\n    {\n    }\n\n    /**\n     * Constructor for internal usage\n     *\n     * @param root the root of the newly create tree\n     */\n    private AVLTree(TreeNode<T> root)\n    {\n        makeRoot(root);\n    }\n\n    /**\n     * Adds {@code value} as a maximum element to this tree. The running time of this method is\n     * $\\mathcal{O}(\\log n)$\n     *\n     * @param value a value to add as a tree max\n     * @return a tree node holding the {@code value}\n     */\n    public TreeNode<T> addMax(T value)\n    {\n        TreeNode<T> newMax = new TreeNode<>(value);\n        addMaxNode(newMax);\n        return newMax;\n    }\n\n    /**\n     * Adds the {@code newMax} as a maximum node to this tree.\n     *\n     * @param newMax a node to add as a tree max\n     */\n    public void addMaxNode(TreeNode<T> newMax)\n    {\n        registerModification();\n\n        if (isEmpty()) {\n            virtualRoot.left = newMax;\n            newMax.parent = virtualRoot;\n        } else {\n            TreeNode<T> max = getMax();\n            max.setRightChild(newMax);\n            balance(max);\n        }\n    }\n\n    /**\n     * Adds the {@code value} as a minimum element to this tree\n     *\n     * @param value a value to add as a tree min\n     * @return a tree node holding the {@code value}\n     */\n    public TreeNode<T> addMin(T value)\n    {\n        TreeNode<T> newMin = new TreeNode<>(value);\n        addMinNode(newMin);\n        return newMin;\n    }\n\n    /**\n     * Adds the {@code newMin} as a minimum node to this tree\n     *\n     * @param newMin a node to add as a tree min\n     */\n    public void addMinNode(TreeNode<T> newMin)\n    {\n        registerModification();\n        if (isEmpty()) {\n            virtualRoot.left = newMin;\n            newMin.parent = virtualRoot;\n        } else {\n            TreeNode<T> min = getMin();\n            min.setLeftChild(newMin);\n            balance(min);\n        }\n    }\n\n    /**\n     * Splits the tree into two parts.\n     * <p>\n     * The first part contains the nodes which are smaller than or equal to the {@code node}. The\n     * first part stays in this tree. The second part contains the nodes which are strictly greater\n     * than the {@code node}. The second part is returned as a tree.\n     *\n     * @param node a separating node\n     * @return a tree containing the nodes which are strictly greater than the {@code node}\n     */\n    public AVLTree<T> splitAfter(TreeNode<T> node)\n    {\n        registerModification();\n\n        TreeNode<T> parent = node.parent;\n        boolean nextMove = node.isLeftChild();\n        TreeNode<T> left = node.left;\n        TreeNode<T> right = node.right;\n\n        node.parent.substituteChild(node, null);\n\n        node.reset();\n\n        if (left != null) {\n            left.parent = null;\n        }\n        if (right != null) {\n            right.parent = null;\n        }\n\n        if (left == null) {\n            left = node;\n        } else {\n            // insert node as a left subtree max\n            TreeNode<T> t = left;\n            while (t.right != null) {\n                t = t.right;\n            }\n            t.setRightChild(node);\n\n            while (t != left) {\n                TreeNode<T> p = t.parent;\n                p.substituteChild(t, balanceNode(t));\n                t = p;\n            }\n            left = balanceNode(left);\n\n        }\n        return split(left, right, parent, nextMove);\n    }\n\n    /**\n     * Splits the tree into two parts.\n     * <p>\n     * The first part contains the nodes which are smaller than the {@code node}. The first part\n     * stays in this tree. The second part contains the nodes which are greater than or equal to the\n     * {@code node}. The second part is returned as a tree.\n     *\n     * @param node a separating node\n     * @return a tree containing the nodes which are greater than or equal to the {@code node}\n     */\n    public AVLTree<T> splitBefore(TreeNode<T> node)\n    {\n        registerModification();\n\n        TreeNode<T> predecessor = predecessor(node);\n        if (predecessor == null) {\n            // node is a minimum node\n            AVLTree<T> tree = new AVLTree<>();\n            swap(tree);\n            return tree;\n        }\n        return splitAfter(predecessor);\n    }\n\n    /**\n     * Append the nodes in the {@code tree} after the nodes in this tree.\n     * <p>\n     * The result of this operation is stored in this tree.\n     *\n     * @param tree a tree to append\n     */\n    public void mergeAfter(AVLTree<T> tree)\n    {\n        registerModification();\n        if (tree.isEmpty()) {\n            return;\n        } else if (tree.getSize() == 1) {\n            addMaxNode(tree.removeMin());\n            return;\n        }\n\n        TreeNode<T> junctionNode = tree.removeMin();\n        TreeNode<T> treeRoot = tree.getRoot();\n        tree.clear();\n\n        makeRoot(merge(junctionNode, getRoot(), treeRoot));\n    }\n\n    /**\n     * Prepends the nodes in the {@code tree} before the nodes in this tree.\n     * <p>\n     * The result of this operation is stored in this tree.\n     *\n     * @param tree a tree to prepend\n     */\n    public void mergeBefore(AVLTree<T> tree)\n    {\n        registerModification();\n\n        tree.mergeAfter(this);\n\n        swap(tree);\n    }\n\n    /**\n     * Removes the minimum node in this tree. Returns {@code null} if this tree is empty\n     *\n     * @return the removed node or {@code null} if this tree is empty\n     */\n    public TreeNode<T> removeMin()\n    {\n        registerModification();\n\n        if (isEmpty()) {\n            return null;\n        }\n        TreeNode<T> min = getMin();\n        // min.parent != null\n        if (min.parent == virtualRoot) {\n            makeRoot(min.right);\n        } else {\n            min.parent.setLeftChild(min.right);\n        }\n\n        balance(min.parent);\n\n        return min;\n    }\n\n    /**\n     * Removes the maximum node in this tree. Returns {@code null} if this tree is empty\n     *\n     * @return the removed node or {@code null} if this tree is empty\n     */\n    public TreeNode<T> removeMax()\n    {\n        registerModification();\n        if (isEmpty()) {\n            return null;\n        }\n        TreeNode<T> max = getMax();\n        if (max.parent == virtualRoot) {\n            makeRoot(max.left);\n        } else {\n            max.parent.setRightChild(max.left);\n        }\n        balance(max.parent);\n        return max;\n    }\n\n    /**\n     * Returns the root of this tree or null if this tree is empty.\n     *\n     * @return the root of this tree or null if this tree is empty.\n     */\n    public TreeNode<T> getRoot()\n    {\n        return virtualRoot.left;\n    }\n\n    /**\n     * Returns the node following the {@code node} in the order defined by this tree. Returns null\n     * if the {@code node} is the maximum node in the tree.\n     *\n     * @param node a node to compute successor of\n     * @return the successor of the {@code node}\n     */\n    public TreeNode<T> successor(TreeNode<T> node)\n    {\n        return node.successor;\n    }\n\n    /**\n     * Returns the node, which is before the {@code node} in the order defined by this tree. Returns\n     * null if the {@code node} is the minimum node in the tree.\n     *\n     * @param node a node to compute predecessor of\n     * @return the predecessor of the {@code node}\n     */\n    public TreeNode<T> predecessor(TreeNode<T> node)\n    {\n        return node.predecessor;\n    }\n\n    /**\n     * Returns the minimum node in this tree or null if the tree is empty.\n     *\n     * @return the minimum node in this tree or null if the tree is empty.\n     */\n    public TreeNode<T> getMin()\n    {\n        return getRoot() == null ? null : getRoot().getSubtreeMin();\n    }\n\n    /**\n     * Returns the maximum node in this tree or null if the tree is empty.\n     *\n     * @return the maximum node in this tree or null if the tree is empty.\n     */\n    public TreeNode<T> getMax()\n    {\n        return getRoot() == null ? null : getRoot().getSubtreeMax();\n    }\n\n    /**\n     * Check if this tree is empty\n     *\n     * @return {@code true} if this tree is empty, {@code false otherwise}\n     */\n    public boolean isEmpty()\n    {\n        return getRoot() == null;\n    }\n\n    /**\n     * Removes all nodes from this tree.\n     * <p>\n     * <b>Note:</b> the memory allocated for the tree structure won't be deallocated until there are\n     * active external referenced to the nodes of this tree.\n     */\n    public void clear()\n    {\n        registerModification();\n\n        virtualRoot.left = null;\n    }\n\n    /**\n     * Returns the size of this tree\n     *\n     * @return the size of this tree\n     */\n    public int getSize()\n    {\n        return virtualRoot.left == null ? 0 : virtualRoot.left.subtreeSize;\n    }\n\n    /**\n     * Makes the {@code node} the root of this tree\n     *\n     * @param node a new root of this tree\n     */\n    private void makeRoot(TreeNode<T> node)\n    {\n        virtualRoot.left = node;\n        if (node != null) {\n            node.subtreeMax.successor = null;\n            node.subtreeMin.predecessor = null;\n            node.parent = virtualRoot;\n        }\n    }\n\n    /**\n     * Traverses the tree up until the virtual root and splits it into two parts.\n     * <p>\n     * The algorithm is described in <i>Donald E. Knuth. The art of computer programming. Second\n     * Edition. Volume 3 / Sorting and Searching, p. 474</i>.\n     *\n     * @param left a left subtree\n     * @param right a right subtree\n     * @param p next parent node\n     * @param leftMove {@code true} if we're moving from the left child, {@code false} otherwise.\n     * @return the resulting right tree\n     */\n    private AVLTree<T> split(TreeNode<T> left, TreeNode<T> right, TreeNode<T> p, boolean leftMove)\n    {\n        while (p != virtualRoot) {\n            boolean nextMove = p.isLeftChild();\n            TreeNode<T> nextP = p.parent;\n\n            p.parent.substituteChild(p, null);\n            p.parent = null;\n\n            if (leftMove) {\n                right = merge(p, right, p.right);\n            } else {\n                left = merge(p, p.left, left);\n            }\n            p = nextP;\n            leftMove = nextMove;\n        }\n\n        makeRoot(left);\n\n        return new AVLTree<>(right);\n    }\n\n    /**\n     * Merges the {@code left} and {@code right} subtrees using the {@code junctionNode}.\n     * <p>\n     * The algorithm is described in <i>Donald E. Knuth. The art of computer programming. Second\n     * Edition. Volume 3 / Sorting and Searching, p. 474</i>.\n     *\n     * @param junctionNode a node between left and right subtrees\n     * @param left a left subtree\n     * @param right a right subtree\n     * @return the root of the resulting tree\n     */\n    private TreeNode<T> merge(TreeNode<T> junctionNode, TreeNode<T> left, TreeNode<T> right)\n    {\n        if (left == null && right == null) {\n            junctionNode.reset();\n            return junctionNode;\n        } else if (left == null) {\n            right.setLeftChild(merge(junctionNode, left, right.left));\n            return balanceNode(right);\n        } else if (right == null) {\n            left.setRightChild(merge(junctionNode, left.right, right));\n            return balanceNode(left);\n        } else if (left.getHeight() > right.getHeight() + 1) {\n            left.setRightChild(merge(junctionNode, left.right, right));\n            return balanceNode(left);\n        } else if (right.getHeight() > left.getHeight() + 1) {\n            right.setLeftChild(merge(junctionNode, left, right.left));\n            return balanceNode(right);\n        } else {\n            junctionNode.setLeftChild(left);\n            junctionNode.setRightChild(right);\n            return balanceNode(junctionNode);\n        }\n    }\n\n    /**\n     * Swaps the contents of this tree and the {@code tree}\n     *\n     * @param tree a tree to swap content of\n     */\n    private void swap(AVLTree<T> tree)\n    {\n        TreeNode<T> t = virtualRoot.left;\n        makeRoot(tree.virtualRoot.left);\n        tree.makeRoot(t);\n    }\n\n    /**\n     * Performs a right node rotation.\n     *\n     * @param node a node to rotate\n     * @return a new parent of the {@code node}\n     */\n    private TreeNode<T> rotateRight(TreeNode<T> node)\n    {\n        TreeNode<T> left = node.left;\n        left.parent = null;\n\n        node.setLeftChild(left.right);\n        left.setRightChild(node);\n\n        node.updateHeightAndSubtreeSize();\n        left.updateHeightAndSubtreeSize();\n\n        return left;\n    }\n\n    /**\n     * Performs a left node rotation.\n     *\n     * @param node a node to rotate\n     * @return a new parent of the {@code node}\n     */\n    private TreeNode<T> rotateLeft(TreeNode<T> node)\n    {\n        TreeNode<T> right = node.right;\n        right.parent = null;\n\n        node.setRightChild(right.left);\n\n        right.setLeftChild(node);\n\n        node.updateHeightAndSubtreeSize();\n        right.updateHeightAndSubtreeSize();\n\n        return right;\n    }\n\n    /**\n     * Performs a node balancing on the path from {@code node} up until the root\n     *\n     * @param node a node to start tree balancing from\n     */\n    private void balance(TreeNode<T> node)\n    {\n        balance(node, virtualRoot);\n    }\n\n    /**\n     * Performs a node balancing on the path from {@code node} up until the {@code stop} node\n     *\n     * @param node a node to start tree balancing from\n     * @param stop a node to stop balancing at (this node is not being balanced)\n     */\n    private void balance(TreeNode<T> node, TreeNode<T> stop)\n    {\n        if (node == stop) {\n            return;\n        }\n        TreeNode<T> p = node.parent;\n        if (p == virtualRoot) {\n            makeRoot(balanceNode(node));\n        } else {\n            p.substituteChild(node, balanceNode(node));\n        }\n\n        balance(p, stop);\n    }\n\n    /**\n     * Checks whether the {@code node} is unbalanced. If so, balances the {@code node}\n     *\n     * @param node a node to balance\n     * @return a new parent of {@code node} if the balancing occurs, {@code node} otherwise\n     */\n    private TreeNode<T> balanceNode(TreeNode<T> node)\n    {\n        node.updateHeightAndSubtreeSize();\n        if (node.isLeftDoubleHeavy()) {\n            if (node.left.isRightHeavy()) {\n                node.setLeftChild(rotateLeft(node.left));\n            }\n            rotateRight(node);\n            return node.parent;\n        } else if (node.isRightDoubleHeavy()) {\n            if (node.right.isLeftHeavy()) {\n                node.setRightChild(rotateRight(node.right));\n            }\n            rotateLeft(node);\n            return node.parent;\n        }\n        return node;\n    }\n\n    /**\n     * Registers a modifying operation\n     */\n    private void registerModification()\n    {\n        ++modCount;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder builder = new StringBuilder();\n        for (Iterator<TreeNode<T>> i = nodeIterator(); i.hasNext();) {\n            TreeNode<T> node = i.next();\n            builder.append(node.toString()).append(\"\\n\");\n        }\n        return builder.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Iterator<T> iterator()\n    {\n        return new TreeValuesIterator();\n    }\n\n    /**\n     * Returns an iterator over the tree nodes rather than the node values. The tree are returned in\n     * the same order as the tree values.\n     *\n     * @return an iterator over the tree nodes\n     */\n    public Iterator<TreeNode<T>> nodeIterator()\n    {\n        return new TreeNodeIterator();\n    }\n\n    /**\n     * Iterator over the values stored in this tree. This implementation uses the\n     * {@code TreeNodeIterator} to iterator over the values.\n     */\n    private class TreeValuesIterator\n        implements\n        Iterator<T>\n    {\n        /**\n         * Internally used {@code TreeNodeIterator}\n         */\n        private TreeNodeIterator iterator;\n\n        /**\n         * Constructs a new {@code TreeValuesIterator}\n         */\n        public TreeValuesIterator()\n        {\n            iterator = new TreeNodeIterator();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean hasNext()\n        {\n            return iterator.hasNext();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public T next()\n        {\n            return iterator.next().getValue();\n        }\n    }\n\n    /**\n     * Iterator over the tree nodes. The nodes are returned according to the in order tree\n     * traversal.\n     */\n    private class TreeNodeIterator\n        implements\n        Iterator<TreeNode<T>>\n    {\n        /**\n         * A node that is returned next or {@code null} if all nodes are traversed\n         */\n        private TreeNode<T> nextNode;\n        /**\n         * Number of modifications of the tree at the time this iterator is created.\n         */\n        private final int expectedModCount;\n\n        /**\n         * Constructs a new {@code TreeNodeIterator}\n         */\n        public TreeNodeIterator()\n        {\n            nextNode = getMin();\n            expectedModCount = modCount;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean hasNext()\n        {\n            checkForComodification();\n            return nextNode != null;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public TreeNode<T> next()\n        {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            TreeNode<T> result = nextNode;\n            nextNode = successor(nextNode);\n            return result;\n        }\n\n        /**\n         * Checks if the tree has been modified during the iteration process\n         */\n        private void checkForComodification()\n        {\n            if (expectedModCount != modCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n    }\n\n    /**\n     * Container holding the values stored in the tree.\n     *\n     * @param <T> a tree node value type\n     */\n    public static class TreeNode<T>\n    {\n        /**\n         * A value stored in this tree node\n         */\n        T value;\n\n        /**\n         * Parent of this node\n         */\n        TreeNode<T> parent;\n        /**\n         * Left child of this node\n         */\n        TreeNode<T> left;\n        /**\n         * Right child of this node\n         */\n        TreeNode<T> right;\n        /**\n         * Next node in the tree according to the in order traversal\n         */\n        TreeNode<T> successor;\n        /**\n         * Previous node in the tree according to the in order traversal\n         */\n        TreeNode<T> predecessor;\n        /**\n         * A minimum node in the subtree rooted at this node\n         */\n        TreeNode<T> subtreeMin;\n        /**\n         * A maximum node in the subtree rooted at this node\n         */\n        TreeNode<T> subtreeMax;\n        /**\n         * Height of the node\n         */\n        int height;\n        /**\n         * Size of the subtree rooted at this node\n         */\n        int subtreeSize;\n\n        /**\n         * Constructs a new node with the {@code value} stored in it\n         *\n         * @param value a value to store in this node\n         */\n        TreeNode(T value)\n        {\n            this.value = value;\n            reset();\n        }\n\n        /**\n         * Returns a value stored in this node\n         *\n         * @return a value stored in this node\n         */\n        public T getValue()\n        {\n            return value;\n        }\n\n        /**\n         * Returns a root of the tree this node is stored in\n         *\n         * @return a root of the tree this node is stored in\n         */\n        public TreeNode<T> getRoot()\n        {\n            TreeNode<T> current = this;\n            while (current.parent != null) {\n                current = current.parent;\n            }\n            return current.left;\n        }\n\n        /**\n         * Returns a minimum node stored in the subtree rooted at this node\n         *\n         * @return a minimum node stored in the subtree rooted at this node\n         */\n        public TreeNode<T> getSubtreeMin()\n        {\n            return subtreeMin;\n        }\n\n        /**\n         * Returns a maximum node stored in the subtree rooted at this node\n         *\n         * @return a maximum node stored in the subtree rooted at this node\n         */\n        public TreeNode<T> getSubtreeMax()\n        {\n            return subtreeMax;\n        }\n\n        /**\n         * Returns a minimum node stored in the tree\n         *\n         * @return a minimum node stored in the tree\n         */\n        public TreeNode<T> getTreeMin()\n        {\n            return getRoot().getSubtreeMin();\n        }\n\n        /**\n         * Returns a maximum node stored in the tree\n         *\n         * @return a maximum node stored in the tree\n         */\n        public TreeNode<T> getTreeMax()\n        {\n            return getRoot().getSubtreeMax();\n        }\n\n        /**\n         * Returns a parent of this node\n         *\n         * @return a parent of this node\n         */\n        public TreeNode<T> getParent()\n        {\n            return parent;\n        }\n\n        /**\n         * Returns a left child of this node\n         *\n         * @return a left child of this node\n         */\n        public TreeNode<T> getLeft()\n        {\n            return left;\n        }\n\n        /**\n         * Returns a right child of this node\n         *\n         * @return a right child of this node\n         */\n        public TreeNode<T> getRight()\n        {\n            return right;\n        }\n\n        /**\n         * Returns a height of this node\n         *\n         * @return a height of this node\n         */\n        int getHeight()\n        {\n            return height;\n        }\n\n        /**\n         * Returns a subtree size of the tree rooted at this node\n         *\n         * @return a subtree size of the tree rooted at this node\n         */\n        int getSubtreeSize()\n        {\n            return subtreeSize;\n        }\n\n        /**\n         * Resets this node to the default state\n         */\n        void reset()\n        {\n            this.height = 1;\n            this.subtreeSize = 1;\n            this.subtreeMin = this;\n            this.subtreeMax = this;\n            this.left = this.right = this.parent = this.predecessor = this.successor = null;\n        }\n\n        /**\n         * Returns a height of the right subtree\n         *\n         * @return a height of the right subtree\n         */\n        int getRightHeight()\n        {\n            return right == null ? 0 : right.height;\n        }\n\n        /**\n         * Returns a height of the left subtree\n         *\n         * @return a height of the right subtree\n         */\n        int getLeftHeight()\n        {\n            return left == null ? 0 : left.height;\n        }\n\n        /**\n         * Returns a size of the left subtree\n         *\n         * @return a size of the left subtree\n         */\n        int getLeftSubtreeSize()\n        {\n            return left == null ? 0 : left.subtreeSize;\n        }\n\n        /**\n         * Returns a size of the right subtree\n         *\n         * @return a size of the right subtree\n         */\n        int getRightSubtreeSize()\n        {\n            return right == null ? 0 : right.subtreeSize;\n        }\n\n        /**\n         * Updates the height and subtree size of this node according to the values of the left and\n         * right children\n         */\n        void updateHeightAndSubtreeSize()\n        {\n            height = Math.max(getLeftHeight(), getRightHeight()) + 1;\n            subtreeSize = getLeftSubtreeSize() + getRightSubtreeSize() + 1;\n        }\n\n        /**\n         * Returns {@code true} if this node is unbalanced and the left child's height is greater,\n         * {@code false otherwise}\n         *\n         * @return {@code true} if this node is unbalanced and the left child's height is greater,\n         *         {@code false otherwise}\n         */\n        boolean isLeftDoubleHeavy()\n        {\n            return getLeftHeight() > getRightHeight() + 1;\n        }\n\n        /**\n         * Returns {@code true} if this node is unbalanced and the right child's height is greater,\n         * {@code false otherwise}\n         *\n         * @return {@code true} if this node is unbalanced and the right child's height is greater,\n         *         {@code false otherwise}\n         */\n        boolean isRightDoubleHeavy()\n        {\n            return getRightHeight() > getLeftHeight() + 1;\n        }\n\n        /**\n         * Returns {@code true} if the height of the left child is greater than the height of the\n         * right child\n         *\n         * @return {@code true} if the height of the left child is greater than the height of the\n         *         right child\n         */\n        boolean isLeftHeavy()\n        {\n            return getLeftHeight() > getRightHeight();\n        }\n\n        /**\n         * Returns {@code true} if the height of the right child is greater than the height of the\n         * left child\n         *\n         * @return {@code true} if the height of the right child is greater than the height of the\n         *         left child\n         */\n        boolean isRightHeavy()\n        {\n            return getRightHeight() > getLeftHeight();\n        }\n\n        /**\n         * Returns {@code true} if this node is a left child of its parent, {@code false} otherwise\n         *\n         * @return {@code true} if this node is a left child of its parent, {@code false} otherwise\n         */\n        boolean isLeftChild()\n        {\n            return this == parent.left;\n        }\n\n        /**\n         * Returns {@code true} if this node is a right child of its parent, {@code false} otherwise\n         *\n         * @return {@code true} if this node is a right child of its parent, {@code false} otherwise\n         */\n        boolean isRightChild()\n        {\n            return this == parent.right;\n        }\n\n        /**\n         * Returns a successor of this node according to the tree in order traversal, or\n         * {@code null} if this node is a maximum node in the tree\n         *\n         * @return successor of this node, or {@code} null if this node in a maximum node in the\n         *         tree\n         */\n        public TreeNode<T> getSuccessor()\n        {\n            return successor;\n        }\n\n        /**\n         * Returns a predecessor of this node according to the tree in order traversal, or\n         * {@code null} if this node is a minimum node in the tree\n         *\n         * @return predecessor of this node, or {@code} null if this node in a minimum node in the\n         *         tree\n         */\n        public TreeNode<T> getPredecessor()\n        {\n            return predecessor;\n        }\n\n        /**\n         * Updates the successor reference of this node. If the {@code node} is not {@code null},\n         * updates its predecessor reference as well\n         *\n         * @param node new successor\n         */\n        void setSuccessor(TreeNode<T> node)\n        {\n            successor = node;\n            if (node != null) {\n                node.predecessor = this;\n            }\n        }\n\n        /**\n         * Updates the predecessor reference of this node. If the {@code node} is not {@code null},\n         * updates its successor reference as well\n         *\n         * @param node new predecessor\n         */\n        void setPredecessor(TreeNode<T> node)\n        {\n            predecessor = node;\n            if (node != null) {\n                node.successor = this;\n            }\n        }\n\n        /**\n         * Sets the left child reference of this node to {@code node}. If the {@code node} is not\n         * {@code null}, updates its parent reference as well.\n         *\n         * @param node a new left child\n         */\n        void setLeftChild(TreeNode<T> node)\n        {\n            left = node;\n            if (node != null) {\n                node.parent = this;\n                setPredecessor(node.subtreeMax);\n                subtreeMin = node.subtreeMin;\n            } else {\n                subtreeMin = this;\n                predecessor = null;\n            }\n        }\n\n        /**\n         * Sets the right child reference of this node to {@code node}. If the {@code node} is not\n         * {@code null}, updates its parent reference as well.\n         *\n         * @param node a new right child\n         */\n        void setRightChild(TreeNode<T> node)\n        {\n            right = node;\n            if (node != null) {\n                node.parent = this;\n                setSuccessor(node.subtreeMin);\n                subtreeMax = node.subtreeMax;\n            } else {\n                successor = null;\n                subtreeMax = this;\n            }\n        }\n\n        /**\n         * Substitutes the {@code prevChild} with the {@code newChild}. If the {@code newChild} is\n         * not {@code null}, updates its parent reference as well\n         *\n         * @param prevChild either left or right child of this node\n         * @param newChild a new child of this node\n         */\n        void substituteChild(TreeNode<T> prevChild, TreeNode<T> newChild)\n        {\n            assert left == prevChild || right == prevChild;\n            assert !(left == prevChild && right == prevChild);\n            if (left == prevChild) {\n                setLeftChild(newChild);\n            } else {\n                setRightChild(newChild);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            return String\n                .format(\n                    \"{%s}: [parent = %s, left = %s, right = %s], [subtreeMin = %s, subtreeMax = %s], [predecessor = %s, successor = %s], [height = %d, subtreeSize = %d]\",\n                    value, parent == null ? \"null\" : parent.value,\n                    left == null ? \"null\" : left.value, right == null ? \"null\" : right.value,\n                    subtreeMin == null ? \"null\" : subtreeMin.value,\n                    subtreeMax == null ? \"null\" : subtreeMax.value,\n                    predecessor == null ? \"null\" : predecessor.value,\n                    successor == null ? \"null\" : successor.value, height, subtreeSize);\n        }\n    }\n\n}\n",
            "file_name": "AVLTree.java",
            "human_label": "Perform a right node rotation on the AVL tree.",
            "level": "file_runnable",
            "lineno": "488",
            "name": "rotateRight",
            "oracle_context": "{ \"apis\" : \"[setLeftChild, setRightChild, updateHeightAndSubtreeSize, TreeNode]\", \"classes\" : \"[TreeNode<T>]\", \"vars\" : \"[parent, right]\" }",
            "package": "org.jgrapht.util",
            "project": "jgrapht-master"
        },
        {
            "_id": "6367667f1a6d9265ec01745c",
            "all_context": "{ \"class_level\" : \"import org.slf4j.Logger;\\nimport org.slf4j.LoggerFactory;\\nimport java.io.File;\\nimport java.io.FilenameFilter;\\nimport java.io.IOException;\\nimport java.lang.reflect.Method;\\nimport java.net.InetAddress;\\nimport java.net.MalformedURLException;\\nimport java.net.URL;\\nimport java.net.UnknownHostException;\\nimport java.util.Hashtable;\\nimport java.util.StringTokenizer;\\nimport java.util.Vector;\\nLogger logger;\\nHashtable<Class<?>,Method[]> objectMethods;\\nObject[] emptyArray;\\nint dbg;\\nsetAttribute(Object proxy,String name,Object value);\\ngetAttribute(Object proxy,String name);\\nsetProperty(Object o,String name,String value);\\naddProperty(Object o,String name,String value);\\ninvokeProperty(Object object,String setter,String name,String value);\\ngetProperty(Object object,String name);\\nsetProperty(Object object,String name);\\nreplaceProperties(String value,Hashtable staticProp,PropertySource dynamicProp);\\ncapitalize(String name);\\nunCapitalize(String name);\\naddToClassPath(Vector cpV,String dir);\\naddToolsJar(Vector v);\\ngetFilesByExt(String ld,String ext);\\naccept(File d,String name);\\ngetURL(String base,String file);\\naddJarsFromClassPath(Vector jars,String cp);\\ngetClassPath(Vector v);\\ngetClassPath(String dir,String cpath,String cpathProp,boolean addTools);\\nprocessArgs(Object proxy,String args);\\nprocessArgs(Object proxy,String args,String args0,String args1,Hashtable aliases);\\nclear();\\nfindVoidSetters(Class c);\\nfindBooleanSetters(Class c);\\nfindMethods(Class c);\\nfindMethod(Class c,String name,Class params);\\nhasHook(Object obj,String methodN);\\ncallMain(Class c,String args);\\ncallMethod1(Object target,String methodN,Object param1,String typeParam1,ClassLoader cl);\\ncallMethod0(Object target,String methodN);\\ncallMethodN(Object target,String methodN,Object params,Class typeParams);\\nconvert(String object,Class paramType);\\ngetProperty(String key);\\nsetAttribute(String key,Object o);\\ndebug(String s);\\nexecute(Object proxy,String method);\\n\", \"repo_level\" : \"\" }",
            "class_name": "IntrospectionUtils",
            "code": "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n  try {\n    String cpComp[]=getFilesByExt(dir,\".jar\");\n    if (cpComp != null) {\n      int jarCount=cpComp.length;\n      for (int i=0; i < jarCount; i++) {\n        URL url=getURL(dir,cpComp[i]);\n        if (url != null)         cpV.addElement(url);\n      }\n    }\n  }\n catch (  Exception ex) {\n    logger.debug(\"failed to add urls to classpath\",ex);\n  }\n}\n",
            "docstring": "/** \n * Add all the jar files in a dir to the classpath, represented as a Vector of URLs.\n */\n",
            "end_lineno": "416",
            "file_content": "/*\n * Copyright 2008-2022 Async-IO.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n/*\n * This file incorporates work covered by the following copyright and\n * permission notice:\n *\n * Copyright 2004 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.atmosphere.util;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.net.InetAddress;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.Hashtable;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n/**\n * Utils for introspection and reflection\n */\npublic final class IntrospectionUtils {\n\n    private static final Logger logger = LoggerFactory.getLogger(IntrospectionUtils.class);\n\n    /**\n     * Call execute() - any ant-like task should work\n     */\n    public static void execute(Object proxy, String method) throws Exception {\n        Method executeM = null;\n        Class<?> c = proxy.getClass();\n        Class<?> params[] = new Class[0];\n        //    params[0]=args.getClass();\n        executeM = findMethod(c, method, params);\n        if (executeM == null) {\n            throw new RuntimeException(\"No execute in \" + proxy.getClass());\n        }\n        executeM.invoke(proxy, (Object[]) null);//new Object[] { args });\n    }\n\n    /**\n     * Call void setAttribute( String ,Object )\n     */\n    public static void setAttribute(Object proxy, String name, Object value)\n            throws Exception {\n        if (proxy instanceof AttributeHolder) {\n            ((AttributeHolder) proxy).setAttribute(name, value);\n            return;\n        }\n\n        Method executeM = null;\n        Class<?> c = proxy.getClass();\n        Class<?> params[] = new Class[2];\n        params[0] = String.class;\n        params[1] = Object.class;\n        executeM = findMethod(c, \"setAttribute\", params);\n        if (executeM == null) {\n            logger.debug(\"No setAttribute in {}\", proxy.getClass());\n            return;\n        }\n\n        logger.debug(\"Setting {}={} in proxy: {}\", new Object[]{name, value, proxy});\n        executeM.invoke(proxy, new Object[]{name, value});\n        return;\n    }\n\n    /**\n     * Call void getAttribute( String )\n     */\n    public static Object getAttribute(Object proxy, String name) throws Exception {\n        Class<?> c = proxy.getClass();\n        Class<?> params[] = new Class[1];\n        params[0] = String.class;\n        Method executeM = findMethod(c, \"getAttribute\", params);\n        if (executeM == null) {\n            logger.debug(\"No getAttribute in {}\", proxy.getClass());\n            return null;\n        }\n        return executeM.invoke(proxy, new Object[]{name});\n    }\n\n\n    /**\n     * Find a method with the right name If found, call the method ( if param is\n     * int or boolean we'll convert value to the right type before) - that means\n     * you can have setDebug(1).\n     */\n    final public static boolean setProperty(Object o, String name, String value) {\n        String setter = \"set\" + capitalize(name);\n        return invokeProperty(o, setter, name, value);\n    }\n\n    final public static boolean addProperty(Object o, String name, String value) {\n        String setter = \"add\" + capitalize(name);\n        return invokeProperty(o, setter, name, value);\n    }\n\n    final static public boolean invokeProperty(Object object, String setter, String name, String value) {\n        try {\n            Method methods[] = findMethods(object.getClass());\n            Method setPropertyMethodVoid = null;\n            Method setPropertyMethodBool = null;\n\n            // First, the ideal case - a setFoo( String ) method\n            for (int i = 0; i < methods.length; i++) {\n                Class<?> paramT[] = methods[i].getParameterTypes();\n                if (setter.equals(methods[i].getName()) && paramT.length == 1\n                        && \"java.lang.String\".equals(paramT[0].getName())) {\n\n                    methods[i].invoke(object, new Object[]{value});\n                    return true;\n                }\n            }\n\n            // Try a setFoo ( int ) or ( boolean )\n            for (int i = 0; i < methods.length; i++) {\n                boolean ok = true;\n                if (setter.equals(methods[i].getName())\n                        && methods[i].getParameterTypes().length == 1) {\n\n                    // match - find the type and invoke it\n                    Class<?> paramType = methods[i].getParameterTypes()[0];\n                    Object params[] = new Object[1];\n\n                    // Try a setFoo ( int )\n                    if (\"java.lang.Integer\".equals(paramType.getName())\n                            || \"int\".equals(paramType.getName())) {\n                        try {\n                            params[0] = new Integer(value);\n                        } catch (NumberFormatException ex) {\n                            ok = false;\n                        }\n                        // Try a setFoo ( long )\n                    } else if (\"java.lang.Long\".equals(paramType.getName())\n                            || \"long\".equals(paramType.getName())) {\n                        try {\n                            params[0] = new Long(value);\n                        } catch (NumberFormatException ex) {\n                            ok = false;\n                        }\n\n                        // Try a setFoo ( boolean )\n                    } else if (\"java.lang.Boolean\".equals(paramType.getName())\n                            || \"boolean\".equals(paramType.getName())) {\n                        params[0] = new Boolean(value);\n\n                        // Try a setFoo ( InetAddress )\n                    } else if (\"java.net.InetAddress\".equals(paramType\n                            .getName())) {\n                        try {\n                            params[0] = InetAddress.getByName(value);\n                        } catch (UnknownHostException exc) {\n                            debug(\"Unable to resolve host name:\" + value);\n                            ok = false;\n                        }\n\n                        // Unknown type\n                    } else {\n                        debug(\"Unknown type \" + paramType.getName());\n                    }\n\n                    if (ok) {\n                        methods[i].invoke(object, params);\n                        return true;\n                    }\n                }\n\n                // save \"setProperty\" for later\n                if (\"setProperty\".equals(methods[i].getName())) {\n                    if (methods[i].getReturnType() == Boolean.TYPE) {\n                        setPropertyMethodBool = methods[i];\n                    } else {\n                        setPropertyMethodVoid = methods[i];\n                    }\n\n                }\n            }\n\n            // Ok, no setXXX found, try a setProperty(\"name\", \"value\")\n            if (setPropertyMethodBool != null || setPropertyMethodVoid != null) {\n                Object params[] = new Object[2];\n                params[0] = name;\n                params[1] = value;\n                if (setPropertyMethodBool != null) {\n                    try {\n                        return (Boolean) setPropertyMethodBool.invoke(object, params);\n                    } catch (IllegalArgumentException biae) {\n                        //the boolean method had the wrong\n                        //parameter types. lets try the other\n                        if (setPropertyMethodVoid != null) {\n                            setPropertyMethodVoid.invoke(object, params);\n                            return true;\n                        } else {\n                            throw biae;\n                        }\n                    }\n                } else {\n                    setPropertyMethodVoid.invoke(object, params);\n                    return true;\n                }\n            }\n\n        } catch (IllegalArgumentException e) {\n            logger.info(\"failed, object: \" + object + \", setter: \" + setter + \", value: \" + value, e);\n        } catch (Exception e) {\n            if (dbg > 0) {\n                debug(e.getClass().getSimpleName() + \" for \" + object.getClass() + \" \" + setter + \"=\" + value + \")\");\n            }\n            if (dbg > 1) {\n                logger.debug(\"\", e);\n            }\n        }\n\n        return false;\n    }\n\n    public static Object getProperty(Object object, String name) {\n        String getter = \"get\" + capitalize(name);\n        String isGetter = \"is\" + capitalize(name);\n\n        try {\n            Method methods[] = findMethods(object.getClass());\n            Method getPropertyMethod = null;\n\n            // First, the ideal case - a getFoo() method\n            for (int i = 0; i < methods.length; i++) {\n                Class<?> paramT[] = methods[i].getParameterTypes();\n                if (getter.equals(methods[i].getName()) && paramT.length == 0) {\n                    return methods[i].invoke(object, (Object[]) null);\n                }\n                if (isGetter.equals(methods[i].getName()) && paramT.length == 0) {\n                    return methods[i].invoke(object, (Object[]) null);\n                }\n\n                if (\"getProperty\".equals(methods[i].getName())) {\n                    getPropertyMethod = methods[i];\n                }\n            }\n\n            // Ok, no setXXX found, try a getProperty(\"name\")\n            if (getPropertyMethod != null) {\n                Object params[] = new Object[1];\n                params[0] = name;\n                return getPropertyMethod.invoke(object, params);\n            }\n\n        } catch (IllegalArgumentException e) {\n            logger.info(\"failed, object: \" + object + \", name: \" + name, e);\n        } catch (Exception e) {\n            if (dbg > 0) {\n                debug(e.getClass().getSimpleName() + \" for \" + object.getClass() + \" \" + name + \")\");\n            }\n            if (dbg > 1) {\n                logger.debug(\"\", e);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     */\n    public static void setProperty(Object object, String name) {\n        String setter = \"set\" + capitalize(name);\n        try {\n            Method methods[] = findMethods(object.getClass());\n            Method setPropertyMethod = null;\n            // find setFoo() method\n            for (int i = 0; i < methods.length; i++) {\n                Class<?> paramT[] = methods[i].getParameterTypes();\n                if (setter.equals(methods[i].getName()) && paramT.length == 0) {\n                    methods[i].invoke(object, new Object[]{});\n                    return;\n                }\n            }\n        } catch (Exception e) {\n            if (dbg > 0) {\n                debug(\"Exception for \" + object.getClass() + \" \" + name);\n            }\n            if (dbg > 1) {\n                logger.debug(\"\", e);\n            }\n        }\n    }\n\n    /**\n     * Replace ${NAME} with the property value\n     */\n    public static String replaceProperties(String value,\n                                           Hashtable<String, String> staticProp, PropertySource dynamicProp[]) {\n        if (value.indexOf(\"$\") < 0) {\n            return value;\n        }\n        StringBuilder sb = new StringBuilder();\n        int prev = 0;\n        // assert value!=nil\n        int pos;\n        while ((pos = value.indexOf(\"$\", prev)) >= 0) {\n            if (pos > 0) {\n                sb.append(value.substring(prev, pos));\n            }\n            if (pos == (value.length() - 1)) {\n                sb.append('$');\n                prev = pos + 1;\n            } else if (value.charAt(pos + 1) != '{') {\n                sb.append('$');\n                prev = pos + 1; // XXX\n            } else {\n                int endName = value.indexOf('}', pos);\n                if (endName < 0) {\n                    sb.append(value.substring(pos));\n                    prev = value.length();\n                    continue;\n                }\n                String n = value.substring(pos + 2, endName);\n                String v = null;\n                if (staticProp != null) {\n                    v = staticProp.get(n);\n                }\n                if (v == null && dynamicProp != null) {\n                    for (int i = 0; i < dynamicProp.length; i++) {\n                        v = dynamicProp[i].getProperty(n);\n                        if (v != null) {\n                            break;\n                        }\n                    }\n                }\n                if (v == null)\n                    v = \"${\" + n + \"}\";\n\n                sb.append(v);\n                prev = endName + 1;\n            }\n        }\n        if (prev < value.length())\n            sb.append(value.substring(prev));\n        return sb.toString();\n    }\n\n    /**\n     * Reverse of Introspector.decapitalize\n     */\n    public static String capitalize(String name) {\n        if (name == null || name.length() == 0) {\n            return name;\n        }\n        char chars[] = name.toCharArray();\n        chars[0] = Character.toUpperCase(chars[0]);\n        return new String(chars);\n    }\n\n    public static String unCapitalize(String name) {\n        if (name == null || name.length() == 0) {\n            return name;\n        }\n        char chars[] = name.toCharArray();\n        chars[0] = Character.toLowerCase(chars[0]);\n        return new String(chars);\n    }\n\n    // -------------------- Class path tools --------------------\n\n    /**\n     * Add all the jar files in a dir to the classpath, represented as a Vector\n     * of URLs.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static void addToClassPath(Vector<URL> cpV, String dir) {\n        try {\n            String cpComp[] = getFilesByExt(dir, \".jar\");\n            if (cpComp != null) {\n                int jarCount = cpComp.length;\n                for (int i = 0; i < jarCount; i++) {\n                    URL url = getURL(dir, cpComp[i]);\n                    if (url != null)\n                        cpV.addElement(url);\n                }\n            }\n        } catch (Exception ex) {\n            logger.debug(\"failed to add urls to classpath\", ex);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static void addToolsJar(Vector<URL> v) {\n        try {\n            // Add tools.jar in any case\n            File f = new File(System.getProperty(\"java.home\")\n                    + \"/../lib/tools.jar\");\n\n            if (!f.exists()) {\n                // On some systems java.home gets set to the root of jdk.\n                // That's a bug, but we can work around and be nice.\n                f = new File(System.getProperty(\"java.home\") + \"/lib/tools.jar\");\n                if (f.exists()) {\n                    logger.debug(\"Detected strange java.home value {}, it should point to jre\",\n                            System.getProperty(\"java.home\"));\n                }\n            }\n            URL url = new URL(\"file\", \"\", f.getAbsolutePath());\n\n            v.addElement(url);\n        } catch (MalformedURLException ex) {\n            logger.debug(\"failed to add tools jar url to vector\", ex);\n        }\n    }\n\n    /**\n     * Return all files with a given extension in a dir\n     */\n    public static String[] getFilesByExt(String ld, String ext) {\n        File dir = new File(ld);\n        String[] names = null;\n        final String lext = ext;\n        if (dir.isDirectory()) {\n            names = dir.list(new FilenameFilter() {\n                public boolean accept(File d, String name) {\n                    if (name.endsWith(lext)) {\n                        return true;\n                    }\n                    return false;\n                }\n            });\n        }\n        return names;\n    }\n\n    /**\n     * Construct a file url from a file, using a base dir\n     */\n    public static URL getURL(String base, String file) {\n        try {\n            File baseF = new File(base);\n            File f = new File(baseF, file);\n            String path = f.getCanonicalPath();\n            if (f.isDirectory()) {\n                path += \"/\";\n            }\n            if (!f.exists()) {\n                return null;\n            }\n            return new URL(\"file\", \"\", path);\n        } catch (Exception ex) {\n            logger.debug(\"failed to get url, base: \" + base + \", file: \" + file, ex);\n            return null;\n        }\n    }\n\n    /**\n     * Add elements from the classpath <i>cp </i> to a Vector <i>jars </i> as\n     * file URLs (We use Vector for JDK 1.1 compat).\n     * <p/>\n     *\n     * @param jars The jar list\n     * @param cp   a String classpath of directory or jar file elements\n     *             separated by path.separator delimiters.\n     * @throws IOException           If an I/O error occurs\n     * @throws MalformedURLException Doh ;)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static void addJarsFromClassPath(Vector<URL> jars, String cp)\n            throws IOException, MalformedURLException {\n        String sep = System.getProperty(\"path.separator\");\n        String token;\n        StringTokenizer st;\n        if (cp != null) {\n            st = new StringTokenizer(cp, sep);\n            while (st.hasMoreTokens()) {\n                File f = new File(st.nextToken());\n                String path = f.getCanonicalPath();\n                if (f.isDirectory()) {\n                    path += \"/\";\n                }\n                URL url = new URL(\"file\", \"\", path);\n                if (!jars.contains(url)) {\n                    jars.addElement(url);\n                }\n            }\n        }\n    }\n\n    /**\n     * Return a URL[] that can be used to construct a class loader\n     */\n    public static URL[] getClassPath(Vector<URL> v) {\n        URL[] urls = new URL[v.size()];\n        for (int i = 0; i < v.size(); i++) {\n            urls[i] = v.elementAt(i);\n        }\n        return urls;\n    }\n\n    /**\n     * Construct a URL classpath from files in a directory, a cpath property,\n     * and tools.jar.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static URL[] getClassPath(String dir, String cpath,\n                                     String cpathProp, boolean addTools) throws IOException,\n            MalformedURLException {\n        Vector<URL> jarsV = new Vector<URL>();\n        if (dir != null) {\n            // Add dir/classes first, if it exists\n            URL url = getURL(dir, \"classes\");\n            if (url != null)\n                jarsV.addElement(url);\n            addToClassPath(jarsV, dir);\n        }\n\n        if (cpath != null)\n            addJarsFromClassPath(jarsV, cpath);\n\n        if (cpathProp != null) {\n            String cpath1 = System.getProperty(cpathProp);\n            addJarsFromClassPath(jarsV, cpath1);\n        }\n\n        if (addTools)\n            addToolsJar(jarsV);\n\n        return getClassPath(jarsV);\n    }\n\n    // -------------------- Mapping command line params to setters\n\n    public static boolean processArgs(Object proxy, String args[])\n            throws Exception {\n        String args0[] = null;\n        if (null != findMethod(proxy.getClass(), \"getOptions1\", new Class[]{})) {\n            args0 = (String[]) callMethod0(proxy, \"getOptions1\");\n        }\n\n        if (args0 == null) {\n            //args0=findVoidSetters(proxy.getClass());\n            args0 = findBooleanSetters(proxy.getClass());\n        }\n        Hashtable<String, String> h = null;\n        if (null != findMethod(proxy.getClass(), \"getOptionAliases\",\n                new Class[]{})) {\n            h = (Hashtable<String, String>) callMethod0(proxy, \"getOptionAliases\");\n        }\n        return processArgs(proxy, args, args0, null, h);\n    }\n\n    public static boolean processArgs(Object proxy, String args[],\n                                      String args0[], String args1[],\n                                      Hashtable<String, String> aliases) throws Exception {\n        for (int i = 0; i < args.length; i++) {\n            String arg = args[i];\n            if (arg.startsWith(\"-\"))\n                arg = arg.substring(1);\n            if (aliases != null && aliases.get(arg) != null)\n                arg = aliases.get(arg);\n\n            if (args0 != null) {\n                boolean set = false;\n                for (int j = 0; j < args0.length; j++) {\n                    if (args0[j].equalsIgnoreCase(arg)) {\n                        setProperty(proxy, args0[j], \"true\");\n                        set = true;\n                        break;\n                    }\n                }\n                if (set)\n                    continue;\n            }\n            if (args1 != null) {\n                for (int j = 0; j < args1.length; j++) {\n                    if (args1[j].equalsIgnoreCase(arg)) {\n                        i++;\n                        if (i >= args.length)\n                            return false;\n                        setProperty(proxy, arg, args[i]);\n                        break;\n                    }\n                }\n            } else {\n                // if args1 is not specified,assume all other options have param\n                i++;\n                if (i >= args.length)\n                    return false;\n                setProperty(proxy, arg, args[i]);\n            }\n\n        }\n        return true;\n    }\n\n    // -------------------- other utils --------------------\n\n    public static void clear() {\n        objectMethods.clear();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static String[] findVoidSetters(Class<?> c) {\n        Method m[] = findMethods(c);\n        if (m == null)\n            return null;\n        Vector<String> v = new Vector<String>();\n        for (int i = 0; i < m.length; i++) {\n            if (m[i].getName().startsWith(\"set\")\n                    && m[i].getParameterTypes().length == 0) {\n                String arg = m[i].getName().substring(3);\n                v.addElement(unCapitalize(arg));\n            }\n        }\n        String s[] = new String[v.size()];\n        for (int i = 0; i < s.length; i++) {\n            s[i] = (String) v.elementAt(i);\n        }\n        return s;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static String[] findBooleanSetters(Class<?> c) {\n        Method m[] = findMethods(c);\n        if (m == null)\n            return null;\n        Vector<String> v = new Vector<String>();\n        for (int i = 0; i < m.length; i++) {\n            if (m[i].getName().startsWith(\"set\")\n                    && m[i].getParameterTypes().length == 1\n                    && \"boolean\".equalsIgnoreCase(m[i].getParameterTypes()[0]\n                    .getName())) {\n                String arg = m[i].getName().substring(3);\n                v.addElement(unCapitalize(arg));\n            }\n        }\n        String s[] = new String[v.size()];\n        for (int i = 0; i < s.length; i++) {\n            s[i] = v.elementAt(i);\n        }\n        return s;\n    }\n\n    static Hashtable<Class<?>, Method[]> objectMethods =\n            new Hashtable<Class<?>, Method[]>();\n\n    @SuppressWarnings(\"unchecked\")\n    public static Method[] findMethods(Class<?> c) {\n        Method methods[] = (Method[]) objectMethods.get(c);\n        if (methods != null)\n            return methods;\n\n        methods = c.getMethods();\n        objectMethods.put(c, methods);\n        return methods;\n    }\n\n    public static Method findMethod(Class<?> c, String name,\n                                    Class<?> params[]) {\n        Method methods[] = findMethods(c);\n        if (methods == null)\n            return null;\n        for (int i = 0; i < methods.length; i++) {\n            if (methods[i].getName().equals(name)) {\n                Class<?> methodParams[] = methods[i].getParameterTypes();\n                if (methodParams == null)\n                    if (params == null || params.length == 0)\n                        return methods[i];\n                if (params == null)\n                    if (methodParams == null || methodParams.length == 0)\n                        return methods[i];\n                if (params.length != methodParams.length)\n                    continue;\n                boolean found = true;\n                for (int j = 0; j < params.length; j++) {\n                    if (params[j] != methodParams[j]) {\n                        found = false;\n                        break;\n                    }\n                }\n                if (found)\n                    return methods[i];\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Test if the object implements a particular\n     * method\n     */\n    public static boolean hasHook(Object obj, String methodN) {\n        try {\n            Method myMethods[] = findMethods(obj.getClass());\n            for (int i = 0; i < myMethods.length; i++) {\n                if (methodN.equals(myMethods[i].getName())) {\n                    // check if it's overriden\n                    Class<?> declaring = myMethods[i].getDeclaringClass();\n                    Class<?> parentOfDeclaring = declaring.getSuperclass();\n                    // this works only if the base class doesn't extend\n                    // another class.\n\n                    // if the method is declared in a top level class\n                    // like BaseInterceptor parent is Object, otherwise\n                    // parent is BaseInterceptor or an intermediate class\n                    if (!\"java.lang.Object\".equals(parentOfDeclaring.getName())) {\n                        return true;\n                    }\n                }\n            }\n        } catch (Exception ex) {\n            logger.debug(\"hasHook() failed\", ex);\n        }\n        return false;\n    }\n\n    public static void callMain(Class<?> c, String args[]) throws Exception {\n        Class<?> p[] = new Class[1];\n        p[0] = args.getClass();\n        @SuppressWarnings(\"unchecked\")\n        Method m = c.getMethod(\"main\", p);\n        m.invoke(c, new Object[]{args});\n    }\n\n    public static Object callMethod1(Object target, String methodN,\n                                     Object param1, String typeParam1, ClassLoader cl) throws Exception {\n        if (target == null || param1 == null) {\n            debug(\"Assert: Illegal params \" + target + \" \" + param1);\n        }\n        if (dbg > 0)\n            debug(\"callMethod1 \" + target.getClass().getName() + \" \" + param1.getClass().getName() + \" \" +\n                    typeParam1);\n\n        Class<?> params[] = new Class[1];\n        if (typeParam1 == null) {\n            params[0] = param1.getClass();\n        } else {\n            params[0] = cl.loadClass(typeParam1);\n        }\n        Method m = findMethod(target.getClass(), methodN, params);\n        if (m == null) {\n            throw new NoSuchMethodException(target.getClass().getName() + \" \" + methodN);\n        }\n        return m.invoke(target, new Object[]{param1});\n    }\n\n    public static Object callMethod0(Object target, String methodN)\n            throws Exception {\n        if (target == null) {\n            debug(\"Assert: Illegal params \" + target);\n            return null;\n        }\n        if (dbg > 0) {\n            debug(\"callMethod0 \" + target.getClass().getName() + \".\" + methodN);\n        }\n\n        Class params[] = new Class[0];\n        Method m = findMethod(target.getClass(), methodN, params);\n        if (m == null) {\n            throw new NoSuchMethodException(target.getClass().getName() + \" \" + methodN);\n        }\n        return m.invoke(target, emptyArray);\n    }\n\n    static Object[] emptyArray = new Object[]{};\n\n    public static Object callMethodN(Object target, String methodN,\n                                     Object params[], Class<?> typeParams[]) throws Exception {\n        Method m = null;\n        m = findMethod(target.getClass(), methodN, typeParams);\n        if (m == null) {\n            debug(\"Can't find method \" + methodN + \" in \" + target + \" CLASS \" + target.getClass());\n            return null;\n        }\n        Object o = m.invoke(target, params);\n\n        if (dbg > 0) {\n            // debug\n            StringBuffer sb = new StringBuffer();\n            sb.append(\"\" + target.getClass().getName() + \".\" + methodN + \"( \");\n            for (int i = 0; i < params.length; i++) {\n                if (i > 0)\n                    sb.append(\", \");\n                sb.append(params[i]);\n            }\n            sb.append(\")\");\n            debug(sb.toString());\n        }\n        return o;\n    }\n\n    public static Object convert(String object, Class<?> paramType) {\n        Object result = null;\n        if (\"java.lang.String\".equals(paramType.getName())) {\n            result = object;\n        } else if (\"java.lang.Integer\".equals(paramType.getName())\n                || \"int\".equals(paramType.getName())) {\n            try {\n                result = new Integer(object);\n            } catch (NumberFormatException ex) {\n            }\n            // Try a setFoo ( boolean )\n        } else if (\"java.lang.Boolean\".equals(paramType.getName())\n                || \"boolean\".equals(paramType.getName())) {\n            result = new Boolean(object);\n\n            // Try a setFoo ( InetAddress )\n        } else if (\"java.net.InetAddress\".equals(paramType\n                .getName())) {\n            try {\n                result = InetAddress.getByName(object);\n            } catch (UnknownHostException exc) {\n                debug(\"Unable to resolve host name:\" + object);\n            }\n\n            // Unknown type\n        } else {\n            debug(\"Unknown type \" + paramType.getName());\n        }\n        if (result == null) {\n            throw new IllegalArgumentException(\"Can't convert argument: \" + object);\n        }\n        return result;\n    }\n\n    // -------------------- Get property --------------------\n    // This provides a layer of abstraction\n\n    public static interface PropertySource {\n\n        public String getProperty(String key);\n\n    }\n\n    public static interface AttributeHolder {\n\n        public void setAttribute(String key, Object o);\n\n    }\n\n    // debug --------------------\n    static final int dbg = 0;\n\n    static void debug(String s) {\n        logger.debug(\"IntrospectionUtils: {}\", s);\n    }\n}\n",
            "file_name": "IntrospectionUtils.java",
            "human_label": "Add all the jar files in the given dir to the classpath. The classpath is represented as a Vector of URLs.",
            "level": "class_runnable",
            "lineno": "397",
            "name": "addToClassPath",
            "oracle_context": "{ \"apis\" : \"[getFilesByExt, getURL, addElement, debug]\", \"classes\" : \"[String, URL]\", \"vars\" : \"[length, logger]\" }",
            "package": "org.atmosphere.util",
            "project": "atmosphere-atmosphere-2.7.x"
        },
        {
            "_id": "636766f61a6d9265ec017701",
            "all_context": "{ \"class_level\" : \"import net.hasor.core.Singleton;\\nimport net.hasor.dataql.UdfSourceAssembly;\\nimport net.hasor.utils.StringUtils;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nPattern linePattern;\\nPattern humpPattern;\\nstartsWithIgnoreCase(String str,String prefix);\\nendsWith(String str,String suffix);\\nendsWithIgnoreCase(String str,String suffix);\\n_startsWith(String str,String prefix,boolean ignoreCase);\\n_endsWith(String str,String suffix,boolean ignoreCase);\\nlineToHump(String str);\\nhumpToLine(String str);\\nfirstCharToUpperCase(String value);\\nfirstCharToLowerCase(String value);\\ntoUpperCase(String value);\\ntoLowerCase(String value);\\nindexOf(String str,String searchStr);\\nindexOfWithStart(String str,String searchStr,int startPos);\\nindexOfIgnoreCase(String str,String searchStr);\\nindexOfIgnoreCaseWithStart(String str,String searchStr,int startPos);\\nlastIndexOf(String str,String searchStr);\\nlastIndexOfWithStart(String str,String searchChar,int startPos);\\nlastIndexOfIgnoreCase(String str,String searchStr);\\nlastIndexOfIgnoreCaseWithStart(String str,String searchStr,int startPos);\\ncontains(String str,String searchStr);\\ncontainsIgnoreCase(String str,String searchStr);\\ncontainsAny(String str,List searchStrArray);\\ncontainsAnyIgnoreCase(String str,List searchStrArray);\\ntrim(String str);\\nsub(String str,int start,int end);\\nleft(String str,int len);\\nright(String str,int len);\\nalignRight(String str,String padChar,int len);\\nalignLeft(String str,String padChar,int len);\\nalignCenter(String str,String padChar,int len);\\ncompareString(String str1,String str2);\\ncompareStringIgnoreCase(String str1,String str2);\\nsplit(String str,String separatorChars);\\njoin(List array,String separator);\\nisEmpty(String str);\\nequalsIgnoreCase(String str1,String str2);\\nstartsWith(String str,String prefix);\\n\", \"repo_level\" : \"public interface UdfSourceAssembly {default Supplier<?> getSupplier(Class targetType,Finder finder);\\ndefault Predicate<Method> getPredicate(Class targetType);\\npublic Object[] allParams();\\ndefault Supplier<Map<String,Udf>> getUdfResource(Finder finder);\\npublic Class<? extends Annotation> annotationType();\\npublic String value();\\npublic Object call(Hints readOnly,Object values);\\npublic Object call(Hints readOnly,Object values);\\n }\\npublic interface StringUtils {static boolean isEmpty(String str);\\nstatic boolean isNotEmpty(String str);\\nstatic boolean isBlank(String str);\\nstatic boolean isNotBlank(String str);\\nstatic String trim(String str);\\nstatic String trimToNull(String str);\\nstatic String trimToEmpty(String str);\\nstatic String strip(String str);\\nstatic String stripToNull(String str);\\nstatic String stripToEmpty(String str);\\nstatic String strip(String str,String stripChars);\\nstatic String stripStart(String str,String stripChars);\\nstatic String stripEnd(String str,String stripChars);\\nstatic String[] stripAll(String[] strs);\\nstatic String[] stripAll(String[] strs,String stripChars);\\nstatic boolean equals(String str1,String str2);\\nstatic boolean equalsIgnoreCase(String str1,String str2);\\nstatic int indexOf(String str,char searchChar);\\nstatic int indexOf(String str,char searchChar,int startPos);\\nstatic int indexOf(String str,String searchStr);\\nstatic int ordinalIndexOf(String str,String searchStr,int ordinal);\\nstatic int indexOf(String str,String searchStr,int startPos);\\nstatic int indexOfIgnoreCase(String str,String searchStr);\\nstatic int indexOfIgnoreCase(String str,String searchStr,int startPos);\\nstatic int lastIndexOf(String str,char searchChar);\\nstatic int lastIndexOf(String str,char searchChar,int startPos);\\nstatic int lastIndexOf(String str,String searchStr);\\nstatic int lastOrdinalIndexOf(String str,String searchStr,int ordinal);\\nstatic int lastIndexOf(String str,String searchStr,int startPos);\\nstatic int lastIndexOfIgnoreCase(String str,String searchStr);\\nstatic int lastIndexOfIgnoreCase(String str,String searchStr,int startPos);\\nstatic boolean contains(String str,char searchChar);\\nstatic boolean contains(String str,String searchStr);\\nstatic boolean containsIgnoreCase(String str,String searchStr);\\nstatic int indexOfAny(String str,char[] searchChars);\\nstatic int indexOfAny(String str,String searchChars);\\nstatic boolean containsAny(String str,char[] searchChars);\\nstatic boolean containsAny(String str,String searchChars);\\nstatic int indexOfAnyBut(String str,char[] searchChars);\\nstatic int indexOfAnyBut(String str,String searchChars);\\nstatic boolean containsOnly(String str,char[] valid);\\nstatic boolean containsOnly(String str,String validChars);\\nstatic boolean containsNone(String str,char[] searchChars);\\nstatic boolean containsNone(String str,String invalidChars);\\nstatic int indexOfAny(String str,String[] searchStrs);\\nstatic int lastIndexOfAny(String str,String[] searchStrs);\\nstatic String substring(String str,int start);\\nstatic String substring(String str,int start,int end);\\nstatic String left(String str,int len);\\nstatic String right(String str,int len);\\nstatic String mid(String str,int pos,int len);\\nstatic String substringBefore(String str,String separator);\\nstatic String substringAfter(String str,String separator);\\nstatic String substringBeforeLast(String str,String separator);\\nstatic String substringAfterLast(String str,String separator);\\nstatic String substringBetween(String str,String tag);\\nstatic String substringBetween(String str,String open,String close);\\nstatic String[] substringsBetween(String str,String open,String close);\\nstatic String[] splitKeep(String str,char separatorChar);\\nstatic String[] splitKeep(String str,String separatorStr);\\nstatic String[] split(String str);\\nstatic String[] split(String str,char separatorChar);\\nstatic String[] split(String str,String separatorChars);\\nstatic String[] split(String str,String separatorChars,int max);\\nstatic String[] splitByWholeSeparator(String str,String separator);\\nstatic String[] splitByWholeSeparator(String str,String separator,int max);\\nstatic String[] splitByWholeSeparatorPreserveAllTokens(String str,String separator);\\nstatic String[] splitByWholeSeparatorPreserveAllTokens(String str,String separator,int max);\\nstatic String[] splitPreserveAllTokens(String str);\\nstatic String[] splitPreserveAllTokens(String str,char separatorChar);\\nstatic String[] splitPreserveAllTokens(String str,String separatorChars);\\nstatic String[] splitPreserveAllTokens(String str,String separatorChars,int max);\\nstatic String[] splitByCharacterType(String str);\\nstatic String[] splitByCharacterTypeCamelCase(String str);\\nstatic String join(Object[] array);\\nstatic String join(Object[] array,char separator);\\nstatic String join(Object[] array,char separator,int startIndex,int endIndex);\\nstatic String join(Object[] array,String separator);\\nstatic String join(Object[] array,String separator,int startIndex,int endIndex);\\nstatic String deleteWhitespace(String str);\\nstatic String removeStart(String str,String remove);\\nstatic String removeStartIgnoreCase(String str,String remove);\\nstatic String removeEnd(String str,String remove);\\nstatic String removeEndIgnoreCase(String str,String remove);\\nstatic String remove(String str,String remove);\\nstatic String remove(String str,char remove);\\nstatic String replaceOnce(String text,String searchString,String replacement);\\nstatic String replace(String text,String searchString,String replacement);\\nstatic String replace(String text,String searchString,String replacement,int max);\\nstatic String replaceEach(String text,String[] searchList,String[] replacementList);\\nstatic String replaceEachRepeatedly(String text,String[] searchList,String[] replacementList);\\nstatic String replaceChars(String str,char searchChar,char replaceChar);\\nstatic String replaceChars(String str,String searchChars,String replaceChars);\\nstatic String overlay(String str,String overlay,int start,int end);\\nstatic String chomp(String str);\\nstatic String chomp(String str,String separator);\\nstatic String chop(String str);\\nstatic String repeat(char character,int repeat);\\nstatic String repeat(String str,int repeat);\\nstatic String repeat(String str,String separator,int repeat);\\nstatic String rightPad(String str,int size);\\nstatic String rightPad(String str,int size,char padChar);\\nstatic String rightPad(String str,int size,String padStr);\\nstatic String leftPad(String str,int size);\\nstatic String leftPad(String str,int size,char padChar);\\nstatic String leftPad(String str,int size,String padStr);\\nstatic int length(String str);\\nstatic String center(String str,int size);\\nstatic String center(String str,int size,char padChar);\\nstatic String center(String str,int size,String padStr);\\nstatic String upperCase(String str);\\nstatic String upperCase(String str,Locale locale);\\nstatic String lowerCase(String str);\\nstatic String lowerCase(String str,Locale locale);\\nstatic String capitalize(String str);\\nstatic String uncapitalize(String str);\\nstatic String swapCase(String str);\\nstatic int countMatches(String str,String sub);\\nstatic boolean isAlpha(String str);\\nstatic boolean isAlphaSpace(String str);\\nstatic boolean isAlphanumeric(String str);\\nstatic boolean isAlphanumericSpace(String str);\\nstatic boolean isAsciiPrintable(String str);\\nstatic boolean isNumeric(String str);\\nstatic boolean isNumericSpace(String str);\\nstatic boolean isWhitespace(String str);\\nstatic boolean isAllLowerCase(String str);\\nstatic boolean isAllUpperCase(String str);\\nstatic String defaultString(String str);\\nstatic String defaultString(String str,String defaultStr);\\nstatic String defaultIfBlank(String str,String defaultStr);\\nstatic String defaultIfEmpty(String str,String defaultStr);\\nstatic String reverse(String str);\\nstatic String reverseDelimited(String str,char separatorChar);\\nstatic String abbreviate(String str,int maxWidth);\\nstatic String abbreviate(String str,int offset,int maxWidth);\\nstatic String abbreviateMiddle(String str,String middle,int length);\\nstatic String difference(String str1,String str2);\\nstatic int indexOfDifference(String str1,String str2);\\nstatic int indexOfDifference(String[] strs);\\nstatic String getCommonPrefix(String[] strs);\\nstatic int getLevenshteinDistance(String s,String t);\\nstatic boolean startsWith(String str,String prefix);\\nstatic boolean startsWithIgnoreCase(String str,String prefix);\\nstatic boolean startsWithAny(String string,String[] searchStrings);\\nstatic boolean endsWith(String str,String suffix);\\nstatic boolean endsWithIgnoreCase(String str,String suffix);\\nstatic String normalizeSpace(String str);\\nstatic boolean endsWithAny(String string,String[] searchStrings);\\nstatic String firstCharToUpperCase(String value);\\nstatic String firstCharToLowerCase(String value);\\nstatic boolean equalsBlankIgnoreCase(String str1,String str2);\\nstatic String quote(String input);\\nstatic void quote(Appendable buffer,String input);\\nstatic String toString(Object object);\\n }\\n\" }",
            "class_name": "StringUdfSource",
            "code": "public static int lastIndexOf(String str,String searchStr){\n  if (StringUtils.isEmpty(str)) {\n    return StringUtils.INDEX_NOT_FOUND;\n  }\n  return str.lastIndexOf(searchStr);\n}\n",
            "docstring": "/** \n * Finds the last index within a String, handling <code>null</code>. This method uses  {@link String#lastIndexOf(String)}. \n */\n",
            "end_lineno": "166",
            "file_content": "/*\n * Copyright 2008-2009 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.dataql.fx.basic;\nimport net.hasor.core.Singleton;\nimport net.hasor.dataql.UdfSourceAssembly;\nimport net.hasor.utils.StringUtils;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n *  <code>import 'net.hasor.dataql.fx.basic.StringUdfSource' as string;</code>\n * @version : 2019-12-12\n */\n@Singleton\npublic class StringUdfSource implements UdfSourceAssembly {\n    // startsWith/endsWith\n    //-----------------------------------------------------------------------\n\n    /** Check if a String starts with a specified prefix. */\n    public static boolean startsWith(String str, String prefix) {\n        return _startsWith(str, prefix, false);\n    }\n\n    /** Case insensitive check if a String starts with a specified prefix. */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        return _startsWith(str, prefix, true);\n    }\n\n    /** Case insensitive check if a String ends with a specified suffix. */\n    public static boolean endsWith(String str, String suffix) {\n        return _endsWith(str, suffix, false);\n    }\n\n    /** Case insensitive check if a String ends with a specified suffix. */\n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        return _endsWith(str, suffix, true);\n    }\n\n    private static boolean _startsWith(String str, String prefix, boolean ignoreCase) {\n        if (str == null || prefix == null) {\n            return str == null && prefix == null;\n        }\n        if (prefix.length() > str.length()) {\n            return false;\n        }\n        return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n    }\n\n    private static boolean _endsWith(String str, String suffix, boolean ignoreCase) {\n        if (str == null || suffix == null) {\n            return str == null && suffix == null;\n        }\n        if (suffix.length() > str.length()) {\n            return false;\n        }\n        int strOffset = str.length() - suffix.length();\n        return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n    }\n\n    // Hump\n    //-----------------------------------------------------------------------\n    private static final Pattern linePattern = Pattern.compile(\"_(\\\\w)\");\n    private static final Pattern humpPattern = Pattern.compile(\"[A-Z]\");\n\n    /**  */\n    public static String lineToHump(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = str.toLowerCase();\n        Matcher matcher = linePattern.matcher(str);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            matcher.appendReplacement(sb, matcher.group(1).toUpperCase());\n        }\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n\n    /**  */\n    public static String humpToLine(String str) {\n        if (str == null) {\n            return null;\n        }\n        Matcher matcher = humpPattern.matcher(str);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            matcher.appendReplacement(sb, \"_\" + matcher.group(0).toLowerCase());\n        }\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n    // UpperCase/LowerCase\n    //-----------------------------------------------------------------------\n\n    /**  */\n    public static String firstCharToUpperCase(String value) {\n        return StringUtils.firstCharToUpperCase(value);\n    }\n\n    /**  */\n    public static String firstCharToLowerCase(String value) {\n        return StringUtils.firstCharToLowerCase(value);\n    }\n\n    /**  */\n    public static String toUpperCase(String value) {\n        return StringUtils.upperCase(value);\n    }\n\n    /**  */\n    public static String toLowerCase(String value) {\n        return StringUtils.lowerCase(value);\n    }\n    // IndexOf/lastIndexOf\n    //-----------------------------------------------------------------------\n\n    /** Finds the first index within a String, handling <code>null</code>. This method uses {@link String#indexOf(String)}. */\n    public static int indexOf(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchStr);\n    }\n\n    /** Finds the first index within a String from a start position, handling <code>null</code>. This method uses {@link String#indexOf(String, int)}. */\n    public static int indexOfWithStart(String str, String searchStr, int startPos) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchStr, startPos);\n    }\n\n    /** Case in-sensitive find of the first index within a String. */\n    public static int indexOfIgnoreCase(String str, String searchStr) {\n        return StringUtils.indexOfIgnoreCase(str, searchStr, 0);\n    }\n\n    /** Case in-sensitive find of the first index within a String from the specified position. */\n    public static int indexOfIgnoreCaseWithStart(String str, String searchStr, int startPos) {\n        return StringUtils.indexOfIgnoreCase(str, searchStr, startPos);\n    }\n\n    /** Finds the last index within a String, handling <code>null</code>. This method uses {@link String#lastIndexOf(String)}. */\n    public static int lastIndexOf(String str, String searchStr) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchStr);\n    }\n\n    /** Finds the last index within a String from a start position, handling <code>null</code>. This method uses {@link String#lastIndexOf(String, int)}. */\n    public static int lastIndexOfWithStart(String str, String searchChar, int startPos) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchChar, startPos);\n    }\n\n    /** Case in-sensitive find of the last index within a String from the specified position. */\n    public static int lastIndexOfIgnoreCase(String str, String searchStr) {\n        return StringUtils.lastIndexOfIgnoreCase(str, searchStr, 0);\n    }\n\n    /** Case in-sensitive find of the last index within a String from the specified position. */\n    public static int lastIndexOfIgnoreCaseWithStart(String str, String searchStr, int startPos) {\n        return StringUtils.lastIndexOfIgnoreCase(str, searchStr, startPos);\n    }\n    // Contains\n    //-----------------------------------------------------------------------\n\n    /** Checks if String contains a search String, handling <code>null</code>. This method uses {@link String#indexOf(String)}. */\n    public static boolean contains(String str, String searchStr) {\n        return StringUtils.contains(str, searchStr);\n    }\n\n    /** Checks if String contains a search String irrespective of case, handling <code>null</code>. Case-insensitivity is defined as by {@link String#equalsIgnoreCase(String)}. */\n    public static boolean containsIgnoreCase(String str, String searchStr) {\n        return StringUtils.containsIgnoreCase(str, searchStr);\n    }\n\n    /** Checks if the String contains any character in the given set of string. */\n    public static boolean containsAny(String str, List<String> searchStrArray) {\n        if (StringUtils.isEmpty(str) || searchStrArray == null || searchStrArray.isEmpty()) {\n            return false;\n        }\n        for (String item : searchStrArray) {\n            if (contains(str, item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /** Case in-sensitive Checks if the String contains any character in the given set of string. */\n    public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n        if (StringUtils.isEmpty(str) || searchStrArray == null || searchStrArray.isEmpty()) {\n            return false;\n        }\n        for (String item : searchStrArray) {\n            if (containsIgnoreCase(str, item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // trim/Sub/left/right\n    //-----------------------------------------------------------------------\n\n    /**  */\n    public static String trim(final String str) {\n        return str == null ? null : str.trim();\n    }\n\n    /** Gets a substring from the specified String avoiding exceptions. */\n    public static String sub(String str, int start, int end) {\n        return StringUtils.substring(str, start, end);\n    }\n\n    /** Gets the leftmost <code>len</code> characters of a String. */\n    public static String left(String str, int len) {\n        return StringUtils.left(str, len);\n    }\n\n    /** Gets the rightmost <code>len</code> characters of a String. */\n    public static String right(String str, int len) {\n        return StringUtils.right(str, len);\n    }\n    // align/pading\n    //-----------------------------------------------------------------------\n\n    /** padChar */\n    public static String alignRight(String str, String padChar, int len) {\n        if (str != null) {\n            if (str.length() > len) {\n                return str;\n            }\n        }\n        char pad = padChar.length() == 0 ? ' ' : padChar.charAt(0);\n        return StringUtils.rightPad(str, len, pad);\n    }\n\n    /** padChar */\n    public static String alignLeft(String str, String padChar, int len) {\n        if (str != null) {\n            if (str.length() > len) {\n                return str;\n            }\n        }\n        char pad = padChar.length() == 0 ? ' ' : padChar.charAt(0);\n        return StringUtils.leftPad(str, len, pad);\n    }\n\n    /** padChar */\n    public static String alignCenter(String str, String padChar, int len) {\n        if (str != null) {\n            if (str.length() > len) {\n                return str;\n            }\n        }\n        char pad = padChar.length() == 0 ? ' ' : padChar.charAt(0);\n        return StringUtils.center(str, len, pad);\n    }\n    // compare\n    //-----------------------------------------------------------------------\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * <p>\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let <i>k</i> be the smallest such index; then the string\n     * whose character at position <i>k</i> has the smaller value, as\n     * determined by using the &lt; operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * <blockquote><pre>\n     * this.charAt(k)-anotherString.charAt(k)\n     * </pre></blockquote>\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * <blockquote><pre>\n     * this.length()-anotherString.length()\n     * </pre></blockquote>\n     *\n     * @param   str1   the {@code String} to be compared.\n     * @param   str2   the {@code String} to be compared.\n     * @return the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public static int compareString(String str1, String str2) {\n        str1 = str1 == null ? \"\" : str1;\n        str2 = str2 == null ? \"\" : str2;\n        return str1.compareTo(str2);\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with normalized versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(character))} on\n     * each character.\n     * <p>\n     * Note that this method does <em>not</em> take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The java.text package provides <em>collators</em> to allow\n     * locale-sensitive ordering.\n     *\n     * @param   str1   the {@code String} to be compared.\n     * @param   str2   the {@code String} to be compared.\n     * @return a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator#compare(String, String)\n     * @since 1.2\n     */\n    public static int compareStringIgnoreCase(String str1, String str2) {\n        str1 = str1 == null ? \"\" : str1;\n        str2 = str2 == null ? \"\" : str2;\n        return str1.compareToIgnoreCase(str2);\n    }\n    // other\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Splits the provided text into an array, separators specified.\n     * This is an alternative to using StringTokenizer.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as one separator.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separatorChars splits on whitespace.</p>\n     *\n     * <pre>\n     * StringUtils.split(null, *)         = null\n     * StringUtils.split(\"\", *)           = []\n     * StringUtils.split(\"abc def\", null) = [\"abc\", \"def\"]\n     * StringUtils.split(\"abc def\", \" \")  = [\"abc\", \"def\"]\n     * StringUtils.split(\"abc  def\", \" \") = [\"abc\", \"def\"]\n     * StringUtils.split(\"ab:cd:ef\", \":\") = [\"ab\", \"cd\", \"ef\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separatorChars  the characters used as the delimiters, <code>null</code> splits on whitespace\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    public static List<String> split(String str, String separatorChars) {\n        return Arrays.asList(StringUtils.split(str, separatorChars));\n    }\n\n    /** Joins the elements of the provided array into a single String containing the provided list of elements. */\n    public static String join(List<Object> array, String separator) {\n        if (array == null) {\n            return null;\n        }\n        return StringUtils.join(array.toArray(), separator);\n    }\n\n    /** Checks if a String is empty (\"\") or null.*/\n    public static boolean isEmpty(String str) {\n        return str == null || str.length() == 0;\n    }\n\n    /**  */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n}\n",
            "file_name": "StringUdfSource.java",
            "human_label": "Find the last index of the searchStr in str, and return INDEXNOTFOUND if str is empty.",
            "level": "project_runnable",
            "lineno": "160",
            "name": "lastIndexOf",
            "oracle_context": "{ \"apis\" : \"[isEmpty]\", \"classes\" : \"[StringUtils]\", \"vars\" : \"[INDEX_NOT_FOUND]\" }",
            "package": "net.hasor.dataql.fx.basic",
            "project": "hasor-master"
        },
        {
            "_id": "6367670b1a6d9265ec0179fe",
            "all_context": "{ \"class_level\" : \"import java.io.IOException;\\nimport java.io.OutputStream;\\nint threshold;\\nlong written;\\nboolean thresholdExceeded;\\nThresholdingOutputStream(int threshold);\\nwrite(byte b);\\nwrite(byte b,int off,int len);\\nflush();\\nclose();\\ngetThreshold();\\ngetByteCount();\\nisThresholdExceeded();\\ncheckThreshold(int count);\\nresetByteCount();\\ngetStream();\\nthresholdReached();\\nwrite(int b);\\n\", \"repo_level\" : \"\" }",
            "class_name": "ThresholdingOutputStream",
            "code": "@Override public void write(byte b[]) throws IOException {\n  checkThreshold(b.length);\n  getStream().write(b);\n  written+=b.length;\n}\n",
            "docstring": "/** \n * Writes <code>b.length</code> bytes from the specified byte array to this output stream.\n * @param b The array of bytes to be written.\n * @exception IOException if an error occurs.\n */\n",
            "end_lineno": "91",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.io.output;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\n/**\n * An output stream which triggers an event when a specified number of bytes of\n * data have been written to it. The event can be used, for example, to throw\n * an exception if a maximum has been reached, or to switch the underlying\n * stream type when the threshold is exceeded.\n * <p>\n * This class overrides all <code>OutputStream</code> methods. However, these\n * overrides ultimately call the corresponding methods in the underlying output\n * stream implementation.\n * <p>\n * NOTE: This implementation may trigger the event <em>before</em> the threshold\n * is actually reached, since it triggers when a pending write operation would\n * cause the threshold to be exceeded.\n *\n * @version $Id: ThresholdingOutputStream.java 1307462 2012-03-30 15:13:11Z ggregory $\n */\npublic abstract class ThresholdingOutputStream extends OutputStream {\n    // ----------------------------------------------------------- Data members\n    /**\n     * The threshold at which the event will be triggered.\n     */\n    private final int     threshold;\n    /**\n     * The number of bytes written to the output stream.\n     */\n    private       long    written;\n    /**\n     * Whether or not the configured threshold has been exceeded.\n     */\n    private       boolean thresholdExceeded;\n    // ----------------------------------------------------------- Constructors\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the\n     * specified threshold.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     */\n    public ThresholdingOutputStream(int threshold) {\n        this.threshold = threshold;\n    }\n    // --------------------------------------------------- OutputStream methods\n\n    /**\n     * Writes the specified byte to this output stream.\n     *\n     * @param b The byte to be written.\n     *\n     * @exception IOException if an error occurs.\n     */\n    @Override\n    public void write(int b) throws IOException {\n        checkThreshold(1);\n        getStream().write(b);\n        written++;\n    }\n\n    /**\n     * Writes <code>b.length</code> bytes from the specified byte array to this\n     * output stream.\n     *\n     * @param b The array of bytes to be written.\n     *\n     * @exception IOException if an error occurs.\n     */\n    @Override\n    public void write(byte b[]) throws IOException {\n        checkThreshold(b.length);\n        getStream().write(b);\n        written += b.length;\n    }\n\n    /**\n     * Writes <code>len</code> bytes from the specified byte array starting at\n     * offset <code>off</code> to this output stream.\n     *\n     * @param b   The byte array from which the data will be written.\n     * @param off The start offset in the byte array.\n     * @param len The number of bytes to write.\n     *\n     * @exception IOException if an error occurs.\n     */\n    @Override\n    public void write(byte b[], int off, int len) throws IOException {\n        checkThreshold(len);\n        getStream().write(b, off, len);\n        written += len;\n    }\n\n    /**\n     * Flushes this output stream and forces any buffered output bytes to be\n     * written out.\n     *\n     * @exception IOException if an error occurs.\n     */\n    @Override\n    public void flush() throws IOException {\n        getStream().flush();\n    }\n\n    /**\n     * Closes this output stream and releases any system resources associated\n     * with this stream.\n     *\n     * @exception IOException if an error occurs.\n     */\n    @Override\n    public void close() throws IOException {\n        try {\n            flush();\n        } catch (IOException ignored) {\n            // ignore\n        }\n        getStream().close();\n    }\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Returns the threshold, in bytes, at which an event will be triggered.\n     *\n     * @return The threshold point, in bytes.\n     */\n    public int getThreshold() {\n        return threshold;\n    }\n\n    /**\n     * Returns the number of bytes that have been written to this output stream.\n     *\n     * @return The number of bytes written.\n     */\n    public long getByteCount() {\n        return written;\n    }\n\n    /**\n     * Determines whether or not the configured threshold has been exceeded for\n     * this output stream.\n     *\n     * @return {@code true} if the threshold has been reached;\n     *         {@code false} otherwise.\n     */\n    public boolean isThresholdExceeded() {\n        return written > threshold;\n    }\n    // ------------------------------------------------------ Protected methods\n\n    /**\n     * Checks to see if writing the specified number of bytes would cause the\n     * configured threshold to be exceeded. If so, triggers an event to allow\n     * a concrete implementation to take action on this.\n     *\n     * @param count The number of bytes about to be written to the underlying\n     *              output stream.\n     *\n     * @exception IOException if an error occurs.\n     */\n    protected void checkThreshold(int count) throws IOException {\n        if (!thresholdExceeded && written + count > threshold) {\n            thresholdExceeded = true;\n            thresholdReached();\n        }\n    }\n\n    /**\n     * Resets the byteCount to zero.  You can call this from \n     * {@link #thresholdReached()} if you want the event to be triggered again. \n     */\n    protected void resetByteCount() {\n        this.thresholdExceeded = false;\n        this.written = 0;\n    }\n    // ------------------------------------------------------- Abstract methods\n\n    /**\n     * Returns the underlying output stream, to which the corresponding\n     * <code>OutputStream</code> methods in this class will ultimately delegate.\n     *\n     * @return The underlying output stream.\n     *\n     * @exception IOException if an error occurs.\n     */\n    protected abstract OutputStream getStream() throws IOException;\n\n    /**\n     * Indicates that the configured threshold has been reached, and that a\n     * subclass should take whatever action necessary on this event. This may\n     * include changing the underlying output stream.\n     *\n     * @exception IOException if an error occurs.\n     */\n    protected abstract void thresholdReached() throws IOException;\n}\n",
            "file_name": "ThresholdingOutputStream.java",
            "human_label": "Write the given byte array b into the output stream that this class represents.",
            "level": "class_runnable",
            "lineno": "78",
            "name": "write",
            "oracle_context": "{ \"apis\" : \"[checkThreshold, getStream]\", \"classes\" : \"[]\", \"vars\" : \"[length, written]\" }",
            "package": "net.hasor.utils.io.output",
            "project": "hasor-master"
        },
        {
            "_id": "6367675f1a6d9265ec0180d3",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.*;\\nimport org.jgrapht.util.*;\\nimport java.util.*;\\nint NULL_NODE;\\nMap<V,V> forwardMapping;\\nMap<V,V> backwardMapping;\\nGraph<V,E> graph1;\\nGraph<V,E> graph2;\\nIsomorphicGraphMapping(GraphOrdering g1,GraphOrdering g2,int[] core1,int[] core2);\\nIsomorphicGraphMapping(Map forwardMapping,Map backwardMapping,Graph graph1,Graph graph2);\\ngetVertexCorrespondence(V v,boolean forward);\\ngetEdgeCorrespondence(E e,boolean forward);\\ngetForwardMapping();\\ngetBackwardMapping();\\ngetMappingDomain();\\ngetMappingRange();\\nhasEdgeCorrespondence(E e);\\nequals(Object o);\\nhashCode();\\ntoString();\\nisValidIsomorphism();\\nisEqualMapping(GraphMapping rel);\\ncompose(IsomorphicGraphMapping otherMapping);\\nidentity(Graph graph);\\nhasVertexCorrespondence(V v);\\n\", \"repo_level\" : \"\" }",
            "class_name": "IsomorphicGraphMapping",
            "code": "public static <V,E>IsomorphicGraphMapping<V,E> identity(Graph<V,E> graph){\n  Map<V,V> fMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());\n  Map<V,V> bMap=CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());\n  for (  V v : graph.vertexSet()) {\n    fMap.put(v,v);\n    bMap.put(v,v);\n  }\n  return new IsomorphicGraphMapping<>(fMap,bMap,graph,graph);\n}\n",
            "docstring": "/** \n * Computes an identity automorphism (i.e. a self-mapping of a graph in which each vertex also maps to itself).\n * @param graph the input graph\n * @param < V > the graph vertex type\n * @param < E > the graph edge type\n * @return a mapping from graph to graph\n */\n",
            "end_lineno": "358",
            "file_content": "/*\n * (C) Copyright 2015-2021, by Fabian Sph and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.alg.isomorphism;\n\nimport org.jgrapht.*;\nimport org.jgrapht.util.*;\n\nimport java.util.*;\n\n/**\n * This class represents a GraphMapping between two (subgraph)isomorphic graphs. In the subgraph\n * isomorphic case, the second one is assumed to be a subgraph of the first one.\n *\n * @author Fabian Sph\n * @author Alexandru Valeanu\n *\n * @param <V> the type of the vertices\n * @param <E> the type of the edges\n */\npublic class IsomorphicGraphMapping<V, E>\n    implements\n    GraphMapping<V, E>\n{\n\n    public static final int NULL_NODE = -1;\n\n    private final Map<V, V> forwardMapping;\n    private final Map<V, V> backwardMapping;\n\n    private final Graph<V, E> graph1;\n    private final Graph<V, E> graph2;\n\n    /**\n     * Construct a new isomorphic graph mapping\n     * \n     * @param g1 the first graph\n     * @param g2 the second graph which is a possible subgraph of g1\n     * @param core1 the mapping as array (forwards)\n     * @param core2 the mapping as array (backwards)\n     */\n    public IsomorphicGraphMapping(\n        GraphOrdering<V, E> g1, GraphOrdering<V, E> g2, int[] core1, int[] core2)\n    {\n        this.graph1 = g1.getGraph();\n        this.graph2 = g2.getGraph();\n\n        this.forwardMapping =\n            CollectionUtil.newHashMapWithExpectedSize(this.graph1.vertexSet().size());\n        this.backwardMapping =\n            CollectionUtil.newHashMapWithExpectedSize(this.graph1.vertexSet().size());\n\n        for (V v : graph1.vertexSet()) {\n            int vNumber = g1.getVertexNumber(v);\n            int uNumber = core1[vNumber];\n\n            if (uNumber != NULL_NODE) {\n                forwardMapping.put(v, g2.getVertex(uNumber));\n            }\n        }\n\n        for (V v : graph2.vertexSet()) {\n            int vNumber = g2.getVertexNumber(v);\n            int uNumber = core2[vNumber];\n\n            if (uNumber != NULL_NODE) {\n                backwardMapping.put(v, g1.getVertex(uNumber));\n            }\n        }\n    }\n\n    /**\n     * Construct a new isomorphic graph mapping.\n     *\n     * @param forwardMapping the mapping from graph1 to graph2\n     * @param backwardMapping the mapping from graph2 to graph1 (inverse of forwardMapping)\n     * @param graph1 the first graph\n     * @param graph2 the second graph\n     * \n     */\n    public IsomorphicGraphMapping(\n        Map<V, V> forwardMapping, Map<V, V> backwardMapping, Graph<V, E> graph1, Graph<V, E> graph2)\n    {\n        this.forwardMapping = Objects.requireNonNull(forwardMapping);\n        this.backwardMapping = Objects.requireNonNull(backwardMapping);\n\n        this.graph1 = Objects.requireNonNull(graph1);\n        this.graph2 = Objects.requireNonNull(graph2);\n    }\n\n    @Override\n    public V getVertexCorrespondence(V v, boolean forward)\n    {\n        if (forward)\n            return forwardMapping.get(v);\n        else\n            return backwardMapping.get(v);\n    }\n\n    @Override\n    public E getEdgeCorrespondence(E e, boolean forward)\n    {\n        Graph<V, E> fromGraph;\n        Graph<V, E> toGraph;\n\n        if (forward) {\n            fromGraph = graph1;\n            toGraph = graph2;\n\n        } else {\n            fromGraph = graph2;\n            toGraph = graph1;\n        }\n\n        V u = fromGraph.getEdgeSource(e);\n        V v = fromGraph.getEdgeTarget(e);\n\n        V uu = getVertexCorrespondence(u, forward);\n        if (uu == null) {\n            return null;\n        }\n\n        V vv = getVertexCorrespondence(v, forward);\n        if (vv == null) {\n            return null;\n        }\n\n        return toGraph.getEdge(uu, vv);\n    }\n\n    /**\n     * Get an unmodifiable version of the forward mapping function.\n     *\n     * @return the unmodifiable forward mapping function\n     */\n    public Map<V, V> getForwardMapping()\n    {\n        return Collections.unmodifiableMap(forwardMapping);\n    }\n\n    /**\n     * Get an unmodifiable version of the backward mapping function.\n     *\n     * @return the unmodifiable backward mapping function\n     */\n    public Map<V, V> getBackwardMapping()\n    {\n        return Collections.unmodifiableMap(backwardMapping);\n    }\n\n    /**\n     * Get the active domain of the isomorphism.\n     *\n     * @return the set of vertices $v$ for which the mapping is defined\n     */\n    public Set<V> getMappingDomain()\n    {\n        return Collections.unmodifiableSet(forwardMapping.keySet());\n    }\n\n    /**\n     * Get the range of the isomorphism.\n     *\n     * @return the set of vertices $v$ for which a preimage exists\n     */\n    public Set<V> getMappingRange()\n    {\n        return Collections.unmodifiableSet(backwardMapping.keySet());\n    }\n\n    /**\n     * Checks if a vertex $v$ from the first graph has a corresponding vertex in the second graph\n     *\n     * @param v the vertex\n     * @return is there a corresponding vertex to $v$ in the subgraph\n     */\n    public boolean hasVertexCorrespondence(V v)\n    {\n        return getVertexCorrespondence(v, true) != null;\n    }\n\n    /**\n     * Checks if a edge e from the first graph has a corresponding edge in the second graph\n     *\n     * @param e the edge\n     * @return is there a corresponding edge to $e$ in the subgraph\n     */\n    public boolean hasEdgeCorrespondence(E e)\n    {\n        return getEdgeCorrespondence(e, true) != null;\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        IsomorphicGraphMapping<?, ?> that = (IsomorphicGraphMapping<?, ?>) o;\n        return Objects.equals(forwardMapping, that.forwardMapping)\n            && Objects.equals(backwardMapping, that.backwardMapping) && graph1 == that.graph1\n            && graph2 == that.graph2;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return Objects\n            .hash(\n                forwardMapping, backwardMapping, System.identityHashCode(graph1),\n                System.identityHashCode(graph2));\n    }\n\n    @Override\n    public String toString()\n    {\n        StringBuilder str = new StringBuilder(\"[\");\n        Set<V> vertexSet = graph1.vertexSet();\n        Map<String, V> vertexMap = new TreeMap<>();\n\n        for (V v : vertexSet) {\n            vertexMap.put(v.toString(), v);\n        }\n\n        int i = 0;\n        for (Map.Entry<String, V> entry : vertexMap.entrySet()) {\n            V u = getVertexCorrespondence(entry.getValue(), true);\n            str\n                .append((i++ == 0) ? \"\" : \" \").append(entry.getKey()).append(\"=\")\n                .append((u == null) ? \"~~\" : u);\n        }\n\n        return str + \"]\";\n    }\n\n    /**\n     * Determines whether this mapping is indeed a valid isomorphic mapping between the first graph\n     * and the second graph. Note that this method will return false for a homomorphism returned by\n     * a subgraph isomorphism inspector unless the resulting mapping happens to be bijective as well\n     * (mapping all of the vertices and edges from the first graph to the second graph and vice\n     * versa).\n     *\n     * @return true iff this mapping is a valid isomorphism between the two graphs\n     */\n    public boolean isValidIsomorphism()\n    {\n        for (V v : graph1.vertexSet()) {\n            if (!forwardMapping.containsKey(v) || !graph2.containsVertex(forwardMapping.get(v)))\n                return false;\n        }\n\n        for (V v : graph2.vertexSet()) {\n            if (!backwardMapping.containsKey(v) || !graph1.containsVertex(backwardMapping.get(v)))\n                return false;\n        }\n\n        for (E edge : graph1.edgeSet()) {\n            E e = getEdgeCorrespondence(edge, true);\n            V u = graph1.getEdgeSource(e);\n            V v = graph1.getEdgeTarget(e);\n\n            if (!graph2.containsEdge(u, v))\n                return false;\n        }\n\n        for (E edge : graph2.edgeSet()) {\n            E e = getEdgeCorrespondence(edge, false);\n            V u = graph2.getEdgeSource(e);\n            V v = graph2.getEdgeTarget(e);\n\n            if (!graph1.containsEdge(u, v))\n                return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks for equality. Assuming both are mappings on the same graphs.\n     *\n     * @param rel the corresponding mapping\n     * @return do both relations map to the same vertices\n     */\n    public boolean isEqualMapping(GraphMapping<V, E> rel)\n    {\n        for (V v : graph2.vertexSet()) {\n            if (!getVertexCorrespondence(v, false).equals(rel.getVertexCorrespondence(v, false))) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Computes the composition of two isomorphisms. Let $f : V_{G_1} \\rightarrow V_{G_2}$ be an\n     * isomorphism from $V_{G_1}$ to $V_{G_2}$ and $g : V_{G_2} \\rightarrow V_{G_3}$ one from\n     * $V_{G_2}$ to $V_{G_3}$.\n     *\n     * This method computes an isomorphism $h : V_{G_1} \\rightarrow V_{G_3}$ from $V_{G_1}$ to\n     * $V_{G_3}$.\n     *\n     * Note: The composition $g  f$ can be built only if $f$'s codomain equals $g$'s domain; this\n     * implementation only requires that the former is a subset of the latter.\n     *\n     * @param otherMapping the other isomorphism (i.e. function $g$)\n     * @return the composition of the two isomorphism\n     */\n    public IsomorphicGraphMapping<V, E> compose(IsomorphicGraphMapping<V, E> otherMapping)\n    {\n        Map<V, V> fMap = CollectionUtil.newHashMapWithExpectedSize(forwardMapping.size());\n        Map<V, V> bMap = CollectionUtil.newHashMapWithExpectedSize(forwardMapping.size());\n\n        for (V v : graph1.vertexSet()) {\n            V u = otherMapping.getVertexCorrespondence(forwardMapping.get(v), true);\n            fMap.put(v, u);\n            bMap.put(u, v);\n        }\n\n        return new IsomorphicGraphMapping<>(fMap, bMap, graph1, otherMapping.graph2);\n    }\n\n    /**\n     * Computes an identity automorphism (i.e. a self-mapping of a graph in which each vertex also\n     * maps to itself).\n     *\n     * @param graph the input graph\n     * @param <V> the graph vertex type\n     * @param <E> the graph edge type\n     * @return a mapping from graph to graph\n     */\n    public static <V, E> IsomorphicGraphMapping<V, E> identity(Graph<V, E> graph)\n    {\n        Map<V, V> fMap = CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());\n        Map<V, V> bMap = CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());\n\n        for (V v : graph.vertexSet()) {\n            fMap.put(v, v);\n            bMap.put(v, v);\n        }\n\n        return new IsomorphicGraphMapping<>(fMap, bMap, graph, graph);\n    }\n}\n",
            "file_name": "IsomorphicGraphMapping.java",
            "human_label": "Compute and return an identity automorphism for the given graph.",
            "level": "project_runnable",
            "lineno": "338",
            "name": "identity",
            "oracle_context": "{ \"apis\" : \"[newHashMapWithExpectedSize, size, vertexSet, put, IsomorphicGraphMapping]\", \"classes\" : \"[Map<V,V>]\", \"vars\" : \"[]\" }",
            "package": "org.jgrapht.alg.isomorphism",
            "project": "jgrapht-master"
        },
        {
            "_id": "636766fe1a6d9265ec017833",
            "all_context": "{ \"class_level\" : \"import java.io.*;\\nimport java.util.Collection;\\nimport java.util.List;\\nreadFileToString(File file);\\nreadFileToByteArray(File file);\\nreadLines(File file,String encoding);\\nreadLines(File file);\\nlineIterator(File file,String encoding);\\nlineIterator(File file);\\nwriteStringToFile(File file,String data,String encoding);\\nwriteStringToFile(File file,String data,String encoding,boolean append);\\nwriteStringToFile(File file,String data);\\nwriteStringToFile(File file,String data,boolean append);\\nwrite(File file,CharSequence data);\\nwrite(File file,CharSequence data,boolean append);\\nwrite(File file,CharSequence data,String encoding);\\nwrite(File file,CharSequence data,String encoding,boolean append);\\nwriteByteArrayToFile(File file,byte[] data);\\nwriteByteArrayToFile(File file,byte[] data,boolean append);\\nwriteLines(File file,String encoding,Collection lines);\\nwriteLines(File file,String encoding,Collection lines,boolean append);\\nwriteLines(File file,Collection lines);\\nwriteLines(File file,Collection lines,boolean append);\\nwriteLines(File file,String encoding,Collection lines,String lineEnding);\\nwriteLines(File file,String encoding,Collection lines,String lineEnding,boolean append);\\nwriteLines(File file,Collection lines,String lineEnding);\\nwriteLines(File file,Collection lines,String lineEnding,boolean append);\\nopenInputStream(File file);\\nopenOutputStream(File file);\\nopenOutputStream(File file,boolean append);\\ndeleteDirectory(File directory);\\ncleanDirectory(File directory);\\ndeleteQuietly(File file);\\ndeleteDirectoryOnExit(File directory);\\ncleanDirectoryOnExit(File directory);\\nisSymlink(File file);\\nforceDelete(File file);\\nforceDeleteOnExit(File file);\\nreadFileToString(File file,String encoding);\\n\", \"repo_level\" : \"\" }",
            "class_name": "FileUtils",
            "code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  }\n else {\n    file.deleteOnExit();\n  }\n}\n",
            "docstring": "/** \n * Schedules a file to be deleted when JVM exits. If file is directory delete it and all sub-directories.\n * @param file  file or directory to delete, must not be {@code null}\n * @throws NullPointerException if the file is {@code null}\n * @throws IOException in case deletion is unsuccessful\n */\n",
            "end_lineno": "783",
            "file_content": "/*\n * Copyright 2008-2009 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.io;\nimport java.io.*;\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * \n * @version : 2011-6-3\n * @author  (zyc@hasor.net)\n */\npublic abstract class FileUtils {\n    /**\n     * Reads the contents of a file into a String.\n     * The file is always closed.\n     *\n     * @param file  the file to read, must not be <code>null</code>\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @return the file contents, never <code>null</code>\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     */\n    public static String readFileToString(File file, String encoding) throws IOException {\n        InputStream in = null;\n        try {\n            in = openInputStream(file);\n            return IOUtils.toString(in, encoding);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }\n\n    /**\n     * Reads the contents of a file into a String using the default encoding for the VM. \n     * The file is always closed.\n     *\n     * @param file  the file to read, must not be <code>null</code>\n     * @return the file contents, never <code>null</code>\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 1.3.1\n     */\n    public static String readFileToString(File file) throws IOException {\n        return readFileToString(file, null);\n    }\n\n    /**\n     * Reads the contents of a file into a byte array.\n     * The file is always closed.\n     *\n     * @param file  the file to read, must not be <code>null</code>\n     * @return the file contents, never <code>null</code>\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 1.1\n     */\n    public static byte[] readFileToByteArray(File file) throws IOException {\n        InputStream in = null;\n        try {\n            in = openInputStream(file);\n            return IOUtils.toByteArray(in, file.length());\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }\n\n    /**\n     * Reads the contents of a file line by line to a List of Strings.\n     * The file is always closed.\n     *\n     * @param file  the file to read, must not be <code>null</code>\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @return the list of Strings representing each line in the file, never <code>null</code>\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     * @since Commons IO 1.1\n     */\n    public static List<String> readLines(File file, String encoding) throws IOException {\n        InputStream in = null;\n        try {\n            in = openInputStream(file);\n            return IOUtils.readLines(in, encoding);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }\n\n    /**\n     * Reads the contents of a file line by line to a List of Strings using the default encoding for the VM.\n     * The file is always closed.\n     *\n     * @param file  the file to read, must not be <code>null</code>\n     * @return the list of Strings representing each line in the file, never <code>null</code>\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 1.3\n     */\n    public static List<String> readLines(File file) throws IOException {\n        return readLines(file, null);\n    }\n\n    /**\n     * Returns an Iterator for the lines in a <code>File</code>.\n     * <p>\n     * This method opens an <code>InputStream</code> for the file.\n     * When you have finished with the iterator you should close the stream\n     * to free internal resources. This can be done by calling the\n     * {@link LineIterator#close()} or\n     * {@link LineIterator#closeQuietly(LineIterator)} method.\n     * <p>\n     * The recommended usage pattern is:\n     * <pre>\n     * LineIterator it = FileUtils.lineIterator(file, \"UTF-8\");\n     * try {\n     *   while (it.hasNext()) {\n     *     String line = it.nextLine();\n     *     /// do something with line\n     *   }\n     * } finally {\n     *   LineIterator.closeQuietly(iterator);\n     * }\n     * </pre>\n     * <p>\n     * If an exception occurs during the creation of the iterator, the\n     * underlying stream is closed.\n     *\n     * @param file  the file to open for input, must not be <code>null</code>\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @return an Iterator of the lines in the file, never <code>null</code>\n     * @throws IOException in case of an I/O error (file closed)\n     * @since Commons IO 1.2\n     */\n    public static LineIterator lineIterator(File file, String encoding) throws IOException {\n        InputStream in = null;\n        try {\n            in = openInputStream(file);\n            return IOUtils.lineIterator(in, encoding);\n        } catch (IOException ex) {\n            IOUtils.closeQuietly(in);\n            throw ex;\n        } catch (RuntimeException ex) {\n            IOUtils.closeQuietly(in);\n            throw ex;\n        }\n    }\n\n    /**\n     * Returns an Iterator for the lines in a <code>File</code> using the default encoding for the VM.\n     *\n     * @param file  the file to open for input, must not be <code>null</code>\n     * @return an Iterator of the lines in the file, never <code>null</code>\n     * @throws IOException in case of an I/O error (file closed)\n     * @since Commons IO 1.3\n     * @see #lineIterator(File, String)\n     */\n    public static LineIterator lineIterator(File file) throws IOException {\n        return lineIterator(file, null);\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Writes a String to a file creating the file if it does not exist.\n     *\n     * NOTE: As from v1.3, the parent directories of the file will be created\n     * if they do not exist.\n     *\n     * @param file  the file to write\n     * @param data  the content to write to the file\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     */\n    public static void writeStringToFile(File file, String data, String encoding) throws IOException {\n        writeStringToFile(file, data, encoding, false);\n    }\n\n    /**\n     * Writes a String to a file creating the file if it does not exist.\n     *\n     * @param file  the file to write\n     * @param data  the content to write to the file\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @param append if <code>true</code>, then the String will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     * @since Commons IO 2.1\n     */\n    public static void writeStringToFile(File file, String data, String encoding, boolean append) throws IOException {\n        OutputStream out = null;\n        try {\n            out = openOutputStream(file, append);\n            IOUtils.write(data, out, encoding);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    /**\n     * Writes a String to a file creating the file if it does not exist using the default encoding for the VM.\n     *\n     * @param file  the file to write\n     * @param data  the content to write to the file\n     * @throws IOException in case of an I/O error\n     */\n    public static void writeStringToFile(File file, String data) throws IOException {\n        writeStringToFile(file, data, null, false);\n    }\n\n    /**\n     * Writes a String to a file creating the file if it does not exist using the default encoding for the VM.\n     *\n     * @param file  the file to write\n     * @param data  the content to write to the file\n     * @param append if <code>true</code>, then the String will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 2.1\n     */\n    public static void writeStringToFile(File file, String data, boolean append) throws IOException {\n        writeStringToFile(file, data, null, append);\n    }\n\n    /**\n     * Writes a CharSequence to a file creating the file if it does not exist using the default encoding for the VM.\n     *\n     * @param file  the file to write\n     * @param data  the content to write to the file\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 2.0\n     */\n    public static void write(File file, CharSequence data) throws IOException {\n        write(file, data, null, false);\n    }\n\n    /**\n     * Writes a CharSequence to a file creating the file if it does not exist using the default encoding for the VM.\n     *\n     * @param file  the file to write\n     * @param data  the content to write to the file\n     * @param append if <code>true</code>, then the data will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 2.1\n     */\n    public static void write(File file, CharSequence data, boolean append) throws IOException {\n        write(file, data, null, append);\n    }\n\n    /**\n     * Writes a CharSequence to a file creating the file if it does not exist.\n     *\n     * @param file  the file to write\n     * @param data  the content to write to the file\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     * @since Commons IO 2.0\n     */\n    public static void write(File file, CharSequence data, String encoding) throws IOException {\n        write(file, data, encoding, false);\n    }\n\n    /**\n     * Writes a CharSequence to a file creating the file if it does not exist.\n     *\n     * @param file  the file to write\n     * @param data  the content to write to the file\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @param append if <code>true</code>, then the data will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     * @since IO 2.1\n     */\n    public static void write(File file, CharSequence data, String encoding, boolean append) throws IOException {\n        String str = data == null ? null : data.toString();\n        writeStringToFile(file, str, encoding, append);\n    }\n\n    /**\n     * Writes a byte array to a file creating the file if it does not exist.\n     * <p>\n     * NOTE: As from v1.3, the parent directories of the file will be created\n     * if they do not exist.\n     *\n     * @param file  the file to write to\n     * @param data  the content to write to the file\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 1.1\n     */\n    public static void writeByteArrayToFile(File file, byte[] data) throws IOException {\n        writeByteArrayToFile(file, data, false);\n    }\n\n    /**\n     * Writes a byte array to a file creating the file if it does not exist.\n     *\n     * @param file  the file to write to\n     * @param data  the content to write to the file\n     * @param append if <code>true</code>, then bytes will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @since IO 2.1\n     */\n    public static void writeByteArrayToFile(File file, byte[] data, boolean append) throws IOException {\n        OutputStream out = null;\n        try {\n            out = openOutputStream(file, append);\n            out.write(data);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    /**\n     * Writes the <code>toString()</code> value of each item in a collection to\n     * the specified <code>File</code> line by line.\n     * The specified character encoding and the default line ending will be used.\n     * <p>\n     * NOTE: As from v1.3, the parent directories of the file will be created\n     * if they do not exist.\n     *\n     * @param file  the file to write to\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @param lines  the lines to write, <code>null</code> entries produce blank lines\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     * @since Commons IO 1.1\n     */\n    public static void writeLines(File file, String encoding, Collection<?> lines) throws IOException {\n        writeLines(file, encoding, lines, null, false);\n    }\n\n    /**\n     * Writes the <code>toString()</code> value of each item in a collection to\n     * the specified <code>File</code> line by line, optionally appending.\n     * The specified character encoding and the default line ending will be used.\n     *\n     * @param file  the file to write to\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @param lines  the lines to write, <code>null</code> entries produce blank lines\n     * @param append if <code>true</code>, then the lines will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     * @since Commons IO 2.1\n     */\n    public static void writeLines(File file, String encoding, Collection<?> lines, boolean append) throws IOException {\n        writeLines(file, encoding, lines, null, append);\n    }\n\n    /**\n     * Writes the <code>toString()</code> value of each item in a collection to\n     * the specified <code>File</code> line by line.\n     * The default VM encoding and the default line ending will be used.\n     *\n     * @param file  the file to write to\n     * @param lines  the lines to write, <code>null</code> entries produce blank lines\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 1.3\n     */\n    public static void writeLines(File file, Collection<?> lines) throws IOException {\n        writeLines(file, null, lines, null, false);\n    }\n\n    /**\n     * Writes the <code>toString()</code> value of each item in a collection to\n     * the specified <code>File</code> line by line.\n     * The default VM encoding and the default line ending will be used.\n     *\n     * @param file  the file to write to\n     * @param lines  the lines to write, <code>null</code> entries produce blank lines\n     * @param append if <code>true</code>, then the lines will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 2.1\n     */\n    public static void writeLines(File file, Collection<?> lines, boolean append) throws IOException {\n        writeLines(file, null, lines, null, append);\n    }\n\n    /**\n     * Writes the <code>toString()</code> value of each item in a collection to\n     * the specified <code>File</code> line by line.\n     * The specified character encoding and the line ending will be used.\n     * <p>\n     * NOTE: As from v1.3, the parent directories of the file will be created\n     * if they do not exist.\n     *\n     * @param file  the file to write to\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @param lines  the lines to write, <code>null</code> entries produce blank lines\n     * @param lineEnding  the line separator to use, <code>null</code> is system default\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     * @since Commons IO 1.1\n     */\n    public static void writeLines(File file, String encoding, Collection<?> lines, String lineEnding) throws IOException {\n        writeLines(file, encoding, lines, lineEnding, false);\n    }\n\n    /**\n     * Writes the <code>toString()</code> value of each item in a collection to\n     * the specified <code>File</code> line by line.\n     * The specified character encoding and the line ending will be used.\n     *\n     * @param file  the file to write to\n     * @param encoding  the encoding to use, <code>null</code> means platform default\n     * @param lines  the lines to write, <code>null</code> entries produce blank lines\n     * @param lineEnding  the line separator to use, <code>null</code> is system default\n     * @param append if <code>true</code>, then the lines will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @throws UnsupportedEncodingException if the encoding is not supported by the VM\n     * @since Commons IO 2.1\n     */\n    public static void writeLines(File file, String encoding, Collection<?> lines, String lineEnding, boolean append) throws IOException {\n        OutputStream out = null;\n        try {\n            out = openOutputStream(file, append);\n            IOUtils.writeLines(lines, lineEnding, out, encoding);\n        } finally {\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    /**\n     * Writes the <code>toString()</code> value of each item in a collection to\n     * the specified <code>File</code> line by line.\n     * The default VM encoding and the specified line ending will be used.\n     *\n     * @param file  the file to write to\n     * @param lines  the lines to write, <code>null</code> entries produce blank lines\n     * @param lineEnding  the line separator to use, <code>null</code> is system default\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 1.3\n     */\n    public static void writeLines(File file, Collection<?> lines, String lineEnding) throws IOException {\n        writeLines(file, null, lines, lineEnding, false);\n    }\n\n    /**\n     * Writes the <code>toString()</code> value of each item in a collection to\n     * the specified <code>File</code> line by line.\n     * The default VM encoding and the specified line ending will be used.\n     *\n     * @param file  the file to write to\n     * @param lines  the lines to write, <code>null</code> entries produce blank lines\n     * @param lineEnding  the line separator to use, <code>null</code> is system default\n     * @param append if <code>true</code>, then the lines will be added to the\n     * end of the file rather than overwriting\n     * @throws IOException in case of an I/O error\n     * @since Commons IO 2.1\n     */\n    public static void writeLines(File file, Collection<?> lines, String lineEnding, boolean append) throws IOException {\n        writeLines(file, null, lines, lineEnding, append);\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Opens a {@link FileInputStream} for the specified file, providing better\n     * error messages than simply calling <code>new FileInputStream(file)</code>.\n     * <p>\n     * At the end of the method either the stream will be successfully opened,\n     * or an exception will have been thrown.\n     * <p>\n     * An exception is thrown if the file does not exist.\n     * An exception is thrown if the file object exists but is a directory.\n     * An exception is thrown if the file exists but cannot be read.\n     *\n     * @param file  the file to open for input, must not be <code>null</code>\n     * @return a new {@link FileInputStream} for the specified file\n     * @throws FileNotFoundException if the file does not exist\n     * @throws IOException if the file object is a directory\n     * @throws IOException if the file cannot be read\n     * @since Commons IO 1.3\n     */\n    public static FileInputStream openInputStream(File file) throws IOException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                throw new IOException(\"File '\" + file + \"' exists but is a directory\");\n            }\n            if (file.canRead() == false) {\n                throw new IOException(\"File '\" + file + \"' cannot be read\");\n            }\n        } else {\n            throw new FileNotFoundException(\"File '\" + file + \"' does not exist\");\n        }\n        return new FileInputStream(file);\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Opens a {@link FileOutputStream} for the specified file, checking and\n     * creating the parent directory if it does not exist.\n     * <p>\n     * At the end of the method either the stream will be successfully opened,\n     * or an exception will have been thrown.\n     * <p>\n     * The parent directory will be created if it does not exist.\n     * The file will be created if it does not exist.\n     * An exception is thrown if the file object exists but is a directory.\n     * An exception is thrown if the file exists but cannot be written to.\n     * An exception is thrown if the parent directory cannot be created.\n     *\n     * @param file  the file to open for output, must not be <code>null</code>\n     * @return a new {@link FileOutputStream} for the specified file\n     * @throws IOException if the file object is a directory\n     * @throws IOException if the file cannot be written to\n     * @throws IOException if a parent directory needs creating but that fails\n     * @since Commons IO 1.3\n     */\n    public static FileOutputStream openOutputStream(File file) throws IOException {\n        return openOutputStream(file, false);\n    }\n\n    /**\n     * Opens a {@link FileOutputStream} for the specified file, checking and\n     * creating the parent directory if it does not exist.\n     * <p>\n     * At the end of the method either the stream will be successfully opened,\n     * or an exception will have been thrown.\n     * <p>\n     * The parent directory will be created if it does not exist.\n     * The file will be created if it does not exist.\n     * An exception is thrown if the file object exists but is a directory.\n     * An exception is thrown if the file exists but cannot be written to.\n     * An exception is thrown if the parent directory cannot be created.\n     *\n     * @param file  the file to open for output, must not be <code>null</code>\n     * @param append if <code>true</code>, then bytes will be added to the\n     * end of the file rather than overwriting\n     * @return a new {@link FileOutputStream} for the specified file\n     * @throws IOException if the file object is a directory\n     * @throws IOException if the file cannot be written to\n     * @throws IOException if a parent directory needs creating but that fails\n     * @since Commons IO 2.1\n     */\n    public static FileOutputStream openOutputStream(File file, boolean append) throws IOException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                throw new IOException(\"File '\" + file + \"' exists but is a directory\");\n            }\n            if (file.canWrite() == false) {\n                throw new IOException(\"File '\" + file + \"' cannot be written to\");\n            }\n        } else {\n            File parent = file.getParentFile();\n            if (parent != null) {\n                if (!parent.mkdirs() && !parent.isDirectory()) {\n                    throw new IOException(\"Directory '\" + parent + \"' could not be created\");\n                }\n            }\n        }\n        return new FileOutputStream(file, append);\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Deletes a directory recursively. \n     *\n     * @param directory  directory to delete\n     * @throws IOException in case deletion is unsuccessful\n     */\n    public static void deleteDirectory(File directory) throws IOException {\n        if (!directory.exists()) {\n            return;\n        }\n        if (!isSymlink(directory)) {\n            cleanDirectory(directory);\n        }\n        if (!directory.delete()) {\n            String message = \"Unable to delete directory \" + directory + \".\";\n            throw new IOException(message);\n        }\n    }\n\n    /**\n     * Cleans a directory without deleting it.\n     *\n     * @param directory directory to clean\n     * @throws IOException in case cleaning is unsuccessful\n     */\n    public static void cleanDirectory(File directory) throws IOException {\n        if (!directory.exists()) {\n            String message = directory + \" does not exist\";\n            throw new IllegalArgumentException(message);\n        }\n        if (!directory.isDirectory()) {\n            String message = directory + \" is not a directory\";\n            throw new IllegalArgumentException(message);\n        }\n        File[] files = directory.listFiles();\n        if (files == null) {  // null if security restricted\n            throw new IOException(\"Failed to list contents of \" + directory);\n        }\n        IOException exception = null;\n        for (File file : files) {\n            try {\n                forceDelete(file);\n            } catch (IOException ioe) {\n                exception = ioe;\n            }\n        }\n        if (null != exception) {\n            throw exception;\n        }\n    }\n\n    /**\n     * Deletes a file, never throwing an exception. If file is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * <ul>\n     * <li>A directory to be deleted does not have to be empty.</li>\n     * <li>No exceptions are thrown when a file or directory cannot be deleted.</li>\n     * </ul>\n     *\n     * @param file  file or directory to delete, can be {@code null}\n     * @return {@code true} if the file or directory was deleted, otherwise\n     * {@code false}\n     *\n     * @since 1.4\n     */\n    public static boolean deleteQuietly(File file) {\n        if (file == null) {\n            return false;\n        }\n        try {\n            if (file.isDirectory()) {\n                cleanDirectory(file);\n            }\n        } catch (Exception ignored) {\n        }\n        try {\n            return file.delete();\n        } catch (Exception ignored) {\n            return false;\n        }\n    }\n\n    /**\n     * Schedules a directory recursively for deletion on JVM exit.\n     *\n     * @param directory  directory to delete, must not be {@code null}\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException in case deletion is unsuccessful\n     */\n    private static void deleteDirectoryOnExit(File directory) throws IOException {\n        if (!directory.exists()) {\n            return;\n        }\n        directory.deleteOnExit();\n        if (!isSymlink(directory)) {\n            cleanDirectoryOnExit(directory);\n        }\n    }\n\n    /**\n     * Cleans a directory without deleting it.\n     *\n     * @param directory  directory to clean, must not be {@code null}\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException in case cleaning is unsuccessful\n     */\n    private static void cleanDirectoryOnExit(File directory) throws IOException {\n        if (!directory.exists()) {\n            String message = directory + \" does not exist\";\n            throw new IllegalArgumentException(message);\n        }\n        if (!directory.isDirectory()) {\n            String message = directory + \" is not a directory\";\n            throw new IllegalArgumentException(message);\n        }\n        File[] files = directory.listFiles();\n        if (files == null) {  // null if security restricted\n            throw new IOException(\"Failed to list contents of \" + directory);\n        }\n        IOException exception = null;\n        for (File file : files) {\n            try {\n                forceDeleteOnExit(file);\n            } catch (IOException ioe) {\n                exception = ioe;\n            }\n        }\n        if (null != exception) {\n            throw exception;\n        }\n    }\n\n    /**\n     * Determines whether the specified file is a Symbolic Link rather than an actual file.\n     * <p>\n     * Will not return true if there is a Symbolic Link anywhere in the path,\n     * only if the specific file is.\n     * <p>\n     * <b>Note:</b> the current implementation always returns {@code false} if the system\n     * is detected as Windows using {@link FilenameUtils#isSystemWindows()}\n     *\n     * @param file the file to check\n     * @return true if the file is a Symbolic Link\n     * @throws IOException if an IO error occurs while checking the file\n     * @since 2.0\n     */\n    public static boolean isSymlink(File file) throws IOException {\n        if (file == null) {\n            throw new NullPointerException(\"File must not be null\");\n        }\n        if (FilenameUtils.isSystemWindows()) {\n            return false;\n        }\n        File fileInCanonicalDir = null;\n        if (file.getParent() == null) {\n            fileInCanonicalDir = file;\n        } else {\n            File canonicalDir = file.getParentFile().getCanonicalFile();\n            fileInCanonicalDir = new File(canonicalDir, file.getName());\n        }\n        if (fileInCanonicalDir.getCanonicalFile().equals(fileInCanonicalDir.getAbsoluteFile())) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Deletes a file. If file is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * <ul>\n     * <li>A directory to be deleted does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted.\n     *      (java.io.File methods returns a boolean)</li>\n     * </ul>\n     *\n     * @param file  file or directory to delete, must not be {@code null}\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws FileNotFoundException if the file was not found\n     * @throws IOException in case deletion is unsuccessful\n     */\n    public static void forceDelete(File file) throws IOException {\n        if (file.isDirectory()) {\n            deleteDirectory(file);\n        } else {\n            boolean filePresent = file.exists();\n            if (!file.delete()) {\n                if (!filePresent) {\n                    throw new FileNotFoundException(\"File does not exist: \" + file);\n                }\n                String message = \"Unable to delete file: \" + file;\n                throw new IOException(message);\n            }\n        }\n    }\n\n    /**\n     * Schedules a file to be deleted when JVM exits.\n     * If file is directory delete it and all sub-directories.\n     *\n     * @param file  file or directory to delete, must not be {@code null}\n     * @throws NullPointerException if the file is {@code null}\n     * @throws IOException in case deletion is unsuccessful\n     */\n    public static void forceDeleteOnExit(File file) throws IOException {\n        if (file.isDirectory()) {\n            deleteDirectoryOnExit(file);\n        } else {\n            file.deleteOnExit();\n        }\n    }\n}",
            "file_name": "FileUtils.java",
            "human_label": "Delete the file or the whole directory when exiting.",
            "level": "class_runnable",
            "lineno": "769",
            "name": "forceDeleteOnExit",
            "oracle_context": "{ \"apis\" : \"[isDirectory, deleteDirectoryOnExit, deleteOnExit]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
            "package": "net.hasor.utils.io",
            "project": "hasor-master"
        },
        {
            "_id": "636767791a6d9265ec018257",
            "all_context": "{ \"class_level\" : \"import java.awt.BorderLayout;\\nimport java.awt.Color;\\nimport java.awt.Component;\\nimport java.awt.Dimension;\\nimport java.awt.FlowLayout;\\nimport java.awt.Font;\\nimport java.awt.GraphicsEnvironment;\\nimport java.awt.Toolkit;\\nimport java.awt.event.ActionEvent;\\nimport java.awt.event.ActionListener;\\nimport java.awt.event.WindowAdapter;\\nimport java.awt.event.WindowEvent;\\nimport java.io.File;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.net.MalformedURLException;\\nimport java.net.URL;\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.StringTokenizer;\\nimport java.util.Vector;\\nimport javax.swing.BorderFactory;\\nimport javax.swing.ImageIcon;\\nimport javax.swing.JButton;\\nimport javax.swing.JCheckBoxMenuItem;\\nimport javax.swing.JColorChooser;\\nimport javax.swing.JComboBox;\\nimport javax.swing.JFileChooser;\\nimport javax.swing.JFrame;\\nimport javax.swing.JLabel;\\nimport javax.swing.JMenu;\\nimport javax.swing.JMenuBar;\\nimport javax.swing.JMenuItem;\\nimport javax.swing.JOptionPane;\\nimport javax.swing.JPanel;\\nimport javax.swing.JScrollPane;\\nimport javax.swing.JSplitPane;\\nimport javax.swing.JTextArea;\\nimport javax.swing.JToolBar;\\nimport javax.swing.KeyStroke;\\nimport javax.swing.SwingUtilities;\\nimport org.apache.log4j.lf5.LogLevel;\\nimport org.apache.log4j.lf5.LogRecord;\\nimport org.apache.log4j.lf5.LogRecordFilter;\\nimport org.apache.log4j.lf5.util.DateFormatManager;\\nimport org.apache.log4j.lf5.util.LogFileParser;\\nimport org.apache.log4j.lf5.viewer.categoryexplorer.CategoryExplorerTree;\\nimport org.apache.log4j.lf5.viewer.categoryexplorer.CategoryPath;\\nimport org.apache.log4j.lf5.viewer.configure.ConfigurationManager;\\nimport org.apache.log4j.lf5.viewer.configure.MRUFileManager;\\nString DETAILED_VIEW;\\nJFrame _logMonitorFrame;\\nint _logMonitorFrameWidth;\\nint _logMonitorFrameHeight;\\nLogTable _table;\\nCategoryExplorerTree _categoryExplorerTree;\\nString _searchText;\\nString _NDCTextFilter;\\nLogLevel _leastSevereDisplayedLogLevel;\\nJScrollPane _logTableScrollPane;\\nJLabel _statusLabel;\\nObject _lock;\\nJComboBox _fontSizeCombo;\\nint _fontSize;\\nString _fontName;\\nString _currentView;\\nboolean _loadSystemFonts;\\nboolean _trackTableScrollPane;\\nDimension _lastTableViewportSize;\\nboolean _callSystemExitOnClose;\\nList _displayedLogBrokerProperties;\\nMap _logLevelMenuItems;\\nMap _logTableColumnMenuItems;\\nList _levels;\\nList _columns;\\nboolean _isDisposed;\\nConfigurationManager _configurationManager;\\nMRUFileManager _mruFileManager;\\nFile _fileLocation;\\nLogBrokerMonitor _monitor;\\nLogBrokerMonitor(List logLevels);\\nrun();\\nshow();\\ndispose();\\nhide();\\ngetDateFormatManager();\\nsetDateFormatManager(DateFormatManager dfm);\\ngetCallSystemExitOnClose();\\nsetCallSystemExitOnClose(boolean callSystemExitOnClose);\\naddMessage(LogRecord lr);\\nsetMaxNumberOfLogRecords(int maxNumberOfLogRecords);\\ngetBaseFrame();\\nsetTitle(String title);\\nsetFrameSize(int width,int height);\\nsetFontSize(int fontSize);\\naddDisplayedProperty(Object messageLine);\\ngetLogLevelMenuItems();\\ngetLogTableColumnMenuItems();\\ngetTableColumnMenuItem(LogTableColumn column);\\ngetCategoryExplorerTree();\\ngetNDCTextFilter();\\nsetNDCLogRecordFilter(String textFilter);\\nsetSearchText(String text);\\nsetNDCTextFilter(String text);\\nsortByNDC();\\nfindSearchText();\\ngetFirstSelectedRow();\\nselectRow(int foundRow);\\nfindRecord(int startRow,String searchText,List records);\\nmatches(LogRecord record,String text);\\nrefresh(JTextArea textArea);\\nrefreshDetailTextArea();\\nclearDetailTextArea();\\nchangeFontSizeCombo(JComboBox box,int requestedSize);\\nsetFontSizeSilently(int fontSize);\\nsetFontSize(Component component,int fontSize);\\nupdateFrameSize();\\npause(int millis);\\ninitComponents();\\ncreateLogRecordFilter();\\npasses(LogRecord record);\\ncreateNDCLogRecordFilter(String text);\\nupdateStatusLabel();\\ngetRecordsDisplayedMessage();\\naddTableModelProperties();\\ntoString();\\ngetStatusText(int displayedRows,int totalRows);\\nmakeLogTableListenToCategoryExplorer();\\nactionPerformed(ActionEvent e);\\ncreateStatusArea();\\ncreateDetailTextArea();\\ncreateMenuBar();\\ncreateLogLevelMenu();\\ncreateAllLogLevelsMenuItem();\\ncreateNoLogLevelsMenuItem();\\ncreateLogLevelColorMenu();\\ncreateResetLogLevelColorMenuItem();\\nselectAllLogLevels(boolean selected);\\ngetMenuItem(LogLevel level);\\ncreateSubMenuItem(LogLevel level);\\nshowLogLevelColorChangeDialog(JMenuItem result,LogLevel level);\\ncreateMenuItem(LogLevel level);\\ncreateViewMenu();\\ngetLogTableColumnMenuItem(LogTableColumn column);\\ncreateLogTableColumnMenuItem(LogTableColumn column);\\nupdateView();\\ncreateAllLogTableColumnsMenuItem();\\ncreateNoLogTableColumnsMenuItem();\\nselectAllLogTableColumns(boolean selected);\\ncreateFileMenu();\\ncreateOpenMI();\\ncreateOpenURLMI();\\ncreateCloseMI();\\ncreateMRUFileListMI(JMenu menu);\\ncreateExitMI();\\ncreateConfigureMenu();\\ncreateConfigureSave();\\ncreateConfigureReset();\\ncreateConfigureMaxRecords();\\nsaveConfiguration();\\nresetConfiguration();\\nsetMaxRecordConfiguration();\\ncreateHelpMenu();\\ncreateHelpProperties();\\nshowPropertiesDialog(String title);\\ncreateEditMenu();\\ncreateEditFindNextMI();\\ncreateEditFindMI();\\ncreateEditSortNDCMI();\\ncreateEditRestoreAllNDCMI();\\ncreateToolBar();\\nsetView(String viewString,LogTable table);\\ncreateLogLevelCombo();\\nsetLeastSevereDisplayedLogLevel(LogLevel level);\\ntrackTableScrollPane();\\ncenterFrame(JFrame frame);\\nrequestOpen();\\nrequestOpenURL();\\nupdateMRUList();\\nrequestClose();\\nrequestOpenMRU(ActionEvent e);\\nrequestExit();\\ncloseAfterConfirm();\\ngetLogLevels();\\ngetLogTableColumns();\\nloadLogFile(File file);\\nloadLogFile(URL url);\\nLogBrokerMonitorWindowAdaptor(LogBrokerMonitor monitor);\\nwindowClosing(WindowEvent ev);\\nshow(int delay);\\n\", \"repo_level\" : \"public interface LogLevel {public String getLabel();\\npublic boolean encompasses(LogLevel level);\\nstatic LogLevel valueOf(String level);\\nstatic LogLevel register(LogLevel logLevel);\\nstatic void register(LogLevel[] logLevels);\\nstatic void register(List logLevels);\\npublic boolean equals(Object o);\\npublic int hashCode();\\npublic String toString();\\npublic void setLogLevelColorMap(LogLevel level,Color color);\\nstatic void resetLogLevelColorMap();\\nstatic List getLog4JLevels();\\nstatic List getJdk14Levels();\\nstatic List getAllDefaultLevels();\\nstatic Map getLogLevelColorMap();\\nprotected int getPrecedence();\\n }\\npublic interface LogRecord {public LogLevel getLevel();\\npublic void setLevel(LogLevel level);\\nabstract boolean isSevereLevel();\\npublic boolean hasThrown();\\npublic boolean isFatal();\\npublic String getCategory();\\npublic void setCategory(String category);\\npublic String getMessage();\\npublic void setMessage(String message);\\npublic long getSequenceNumber();\\npublic void setSequenceNumber(long number);\\npublic long getMillis();\\npublic void setMillis(long millis);\\npublic String getThreadDescription();\\npublic void setThreadDescription(String threadDescription);\\npublic String getThrownStackTrace();\\npublic void setThrownStackTrace(String trace);\\npublic Throwable getThrown();\\npublic void setThrown(Throwable thrown);\\npublic String toString();\\npublic String getNDC();\\npublic void setNDC(String ndc);\\npublic String getLocation();\\npublic void setLocation(String location);\\nsynchronized void resetSequenceNumber();\\nsynchronized long getNextId();\\n }\\npublic interface LogRecordFilter {public boolean passes(LogRecord record);\\n }\\npublic interface DateFormatManager {synchronized TimeZone getTimeZone();\\nsynchronized void setTimeZone(TimeZone timeZone);\\nsynchronized Locale getLocale();\\nsynchronized void setLocale(Locale locale);\\nsynchronized String getPattern();\\nsynchronized void setPattern(String pattern);\\nsynchronized String getOutputFormat();\\nsynchronized void setOutputFormat(String pattern);\\nsynchronized DateFormat getDateFormatInstance();\\nsynchronized void setDateFormatInstance(DateFormat dateFormat);\\npublic String format(Date date);\\npublic String format(Date date,String pattern);\\npublic Date parse(String date);\\npublic Date parse(String date,String pattern);\\n }\\npublic interface LogFileParser {public void parse(LogBrokerMonitor monitor);\\npublic void run();\\npublic void run();\\nprotected void displayError(String message);\\n }\\npublic interface CategoryExplorerTree {public CategoryExplorerModel getExplorerModel();\\npublic String getToolTipText(MouseEvent e);\\nprotected void init();\\nprotected void expandRootNode();\\nprotected void ensureRootExpansion();\\npublic void treeNodesInserted(TreeModelEvent e);\\n }\\npublic interface CategoryPath {public int size();\\npublic boolean isEmpty();\\npublic void removeAllCategoryElements();\\npublic void addCategoryElement(CategoryElement categoryElement);\\npublic CategoryElement categoryElementAt(int index);\\npublic String toString();\\n }\\npublic interface ConfigurationManager {public void save();\\npublic void reset();\\nstatic String treePathToString(TreePath path);\\nprotected void load();\\nprotected void processRecordFilter(Document doc);\\nprotected void processCategories(Document doc);\\nprotected void processLogLevels(Document doc);\\nprotected void processLogLevelColors(Document doc);\\nprotected void processLogTableColumns(Document doc);\\nprotected String getValue(NamedNodeMap map,String attr);\\nprotected void collapseTree();\\nprotected void selectAllNodes();\\nprotected void store(String s);\\nprotected void deleteConfigurationFile();\\nprotected String getFilename();\\n }\\npublic interface MRUFileManager {public void save();\\npublic int size();\\npublic Object getFile(int index);\\npublic InputStream getInputStream(int index);\\npublic void set(File file);\\npublic void set(URL url);\\npublic String[] getMRUFileList();\\npublic void moveToTop(int index);\\nstatic void createConfigurationDirectory();\\nprotected InputStream getInputStream(File file);\\nprotected InputStream getInputStream(URL url);\\nprotected void setMRU(Object o);\\nprotected void load();\\nprotected String getFilename();\\nprotected void setMaxSize(int maxSize);\\n }\\n\" }",
            "class_name": "LogBrokerMonitor",
            "code": "public void addMessage(final LogRecord lr){\n  if (_isDisposed == true) {\n    return;\n  }\n  SwingUtilities.invokeLater(new Runnable(){\n    public void run(){\n      _categoryExplorerTree.getExplorerModel().addLogRecord(lr);\n      _table.getFilteredLogTableModel().addLogRecord(lr);\n      updateStatusLabel();\n    }\n  }\n);\n}\n",
            "docstring": "/** \n * Add a log record message to be displayed in the LogTable. This method is thread-safe as it posts requests to the SwingThread rather than processing directly.\n */\n",
            "end_lineno": "265",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.log4j.lf5.viewer;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Dimension;\nimport java.awt.FlowLayout;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Toolkit;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\nimport javax.swing.BorderFactory;\nimport javax.swing.ImageIcon;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBoxMenuItem;\nimport javax.swing.JColorChooser;\nimport javax.swing.JComboBox;\nimport javax.swing.JFileChooser;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuBar;\nimport javax.swing.JMenuItem;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JSplitPane;\nimport javax.swing.JTextArea;\nimport javax.swing.JToolBar;\nimport javax.swing.KeyStroke;\nimport javax.swing.SwingUtilities;\n\nimport org.apache.log4j.lf5.LogLevel;\nimport org.apache.log4j.lf5.LogRecord;\nimport org.apache.log4j.lf5.LogRecordFilter;\nimport org.apache.log4j.lf5.util.DateFormatManager;\nimport org.apache.log4j.lf5.util.LogFileParser;\nimport org.apache.log4j.lf5.viewer.categoryexplorer.CategoryExplorerTree;\nimport org.apache.log4j.lf5.viewer.categoryexplorer.CategoryPath;\nimport org.apache.log4j.lf5.viewer.configure.ConfigurationManager;\nimport org.apache.log4j.lf5.viewer.configure.MRUFileManager;\n\n/**\n * LogBrokerMonitor\n *.\n * @author Michael J. Sikorsky\n * @author Robert Shaw\n * @author Brad Marlborough\n * @author Richard Wan\n * @author Brent Sprecher\n * @author Richard Hurst\n */\n\n// Contributed by ThoughtWorks Inc.\n\npublic class LogBrokerMonitor {\n  //--------------------------------------------------------------------------\n  //   Constants:\n  //--------------------------------------------------------------------------\n\n  public static final String DETAILED_VIEW = \"Detailed\";\n//    public static final String STANDARD_VIEW = \"Standard\";\n//    public static final String COMPACT_VIEW = \"Compact\";\n  //--------------------------------------------------------------------------\n  //   Protected Variables:\n  //--------------------------------------------------------------------------\n  protected JFrame _logMonitorFrame;\n  protected int _logMonitorFrameWidth = 550;\n  protected int _logMonitorFrameHeight = 500;\n  protected LogTable _table;\n  protected CategoryExplorerTree _categoryExplorerTree;\n  protected String _searchText;\n  protected String _NDCTextFilter = \"\";\n  protected LogLevel _leastSevereDisplayedLogLevel = LogLevel.DEBUG;\n\n  protected JScrollPane _logTableScrollPane;\n  protected JLabel _statusLabel;\n  protected Object _lock = new Object();\n  protected JComboBox _fontSizeCombo;\n\n  protected int _fontSize = 10;\n  protected String _fontName = \"Dialog\";\n  protected String _currentView = DETAILED_VIEW;\n\n  protected boolean _loadSystemFonts = false;\n  protected boolean _trackTableScrollPane = true;\n  protected Dimension _lastTableViewportSize;\n  protected boolean _callSystemExitOnClose = false;\n  protected List _displayedLogBrokerProperties = new Vector();\n\n  protected Map _logLevelMenuItems = new HashMap();\n  protected Map _logTableColumnMenuItems = new HashMap();\n\n  protected List _levels = null;\n  protected List _columns = null;\n  protected boolean _isDisposed = false;\n\n  protected ConfigurationManager _configurationManager = null;\n  protected MRUFileManager _mruFileManager = null;\n  protected File _fileLocation = null;\n\n  //--------------------------------------------------------------------------\n  //   Private Variables:\n  //--------------------------------------------------------------------------\n\n  //--------------------------------------------------------------------------\n  //   Constructors:\n  //--------------------------------------------------------------------------\n\n  /**\n   * Construct a LogBrokerMonitor.\n   */\n  public LogBrokerMonitor(List logLevels) {\n\n    _levels = logLevels;\n    _columns = LogTableColumn.getLogTableColumns();\n    // This allows us to use the LogBroker in command line tools and\n    // have the option for it to shutdown.\n\n    String callSystemExitOnClose =\n        System.getProperty(\"monitor.exit\");\n    if (callSystemExitOnClose == null) {\n      callSystemExitOnClose = \"false\";\n    }\n    callSystemExitOnClose = callSystemExitOnClose.trim().toLowerCase();\n\n    if (callSystemExitOnClose.equals(\"true\")) {\n      _callSystemExitOnClose = true;\n    }\n\n    initComponents();\n\n\n    _logMonitorFrame.addWindowListener(\n        new LogBrokerMonitorWindowAdaptor(this));\n\n  }\n\n  //--------------------------------------------------------------------------\n  //   Public Methods:\n  //--------------------------------------------------------------------------\n\n  /**\n   * Show the frame for the LogBrokerMonitor. Dispatched to the\n   * swing thread.\n   */\n  public void show(final int delay) {\n    if (_logMonitorFrame.isVisible()) {\n      return;\n    }\n    // This request is very low priority, let other threads execute first.\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        Thread.yield();\n        pause(delay);\n        _logMonitorFrame.setVisible(true);\n      }\n    });\n  }\n\n  public void show() {\n    show(0);\n  }\n\n  /**\n   * Dispose of the frame for the LogBrokerMonitor.\n   */\n  public void dispose() {\n    _logMonitorFrame.dispose();\n    _isDisposed = true;\n\n    if (_callSystemExitOnClose == true) {\n      System.exit(0);\n    }\n  }\n\n  /**\n   * Hide the frame for the LogBrokerMonitor.\n   */\n  public void hide() {\n    _logMonitorFrame.setVisible(false);\n  }\n\n  /**\n   * Get the DateFormatManager for formatting dates.\n   */\n  public DateFormatManager getDateFormatManager() {\n    return _table.getDateFormatManager();\n  }\n\n  /**\n   * Set the date format manager for formatting dates.\n   */\n  public void setDateFormatManager(DateFormatManager dfm) {\n    _table.setDateFormatManager(dfm);\n  }\n\n  /**\n   * Get the value of whether or not System.exit() will be called\n   * when the LogBrokerMonitor is closed.\n   */\n  public boolean getCallSystemExitOnClose() {\n    return _callSystemExitOnClose;\n  }\n\n  /**\n   * Set the value of whether or not System.exit() will be called\n   * when the LogBrokerMonitor is closed.\n   */\n  public void setCallSystemExitOnClose(boolean callSystemExitOnClose) {\n    _callSystemExitOnClose = callSystemExitOnClose;\n  }\n\n  /**\n   * Add a log record message to be displayed in the LogTable.\n   * This method is thread-safe as it posts requests to the SwingThread\n   * rather than processing directly.\n   */\n  public void addMessage(final LogRecord lr) {\n    if (_isDisposed == true) {\n      // If the frame has been disposed of, do not log any more\n      // messages.\n      return;\n    }\n\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        _categoryExplorerTree.getExplorerModel().addLogRecord(lr);\n        _table.getFilteredLogTableModel().addLogRecord(lr); // update table\n        updateStatusLabel(); // show updated counts\n      }\n    });\n  }\n\n  public void setMaxNumberOfLogRecords(int maxNumberOfLogRecords) {\n    _table.getFilteredLogTableModel().setMaxNumberOfLogRecords(maxNumberOfLogRecords);\n  }\n\n  public JFrame getBaseFrame() {\n    return _logMonitorFrame;\n  }\n\n  public void setTitle(String title) {\n    _logMonitorFrame.setTitle(title + \" - LogFactor5\");\n  }\n\n  public void setFrameSize(int width, int height) {\n    Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();\n    if (0 < width && width < screen.width) {\n      _logMonitorFrameWidth = width;\n    }\n    if (0 < height && height < screen.height) {\n      _logMonitorFrameHeight = height;\n    }\n    updateFrameSize();\n  }\n\n  public void setFontSize(int fontSize) {\n    changeFontSizeCombo(_fontSizeCombo, fontSize);\n    // setFontSizeSilently(actualFontSize); - changeFontSizeCombo fires event\n    // refreshDetailTextArea();\n  }\n\n  public void addDisplayedProperty(Object messageLine) {\n    _displayedLogBrokerProperties.add(messageLine);\n  }\n\n  public Map getLogLevelMenuItems() {\n    return _logLevelMenuItems;\n  }\n\n  public Map getLogTableColumnMenuItems() {\n    return _logTableColumnMenuItems;\n  }\n\n  public JCheckBoxMenuItem getTableColumnMenuItem(LogTableColumn column) {\n    return getLogTableColumnMenuItem(column);\n  }\n\n  public CategoryExplorerTree getCategoryExplorerTree() {\n    return _categoryExplorerTree;\n  }\n\n  // Added in version 1.2 - gets the value of the NDC text filter\n  // This value is set back to null each time the Monitor is initialized.\n  public String getNDCTextFilter() {\n    return _NDCTextFilter;\n  }\n\n  // Added in version 1.2 - sets the NDC Filter based on\n  // a String passed in by the user.  This value is persisted\n  // in the XML Configuration file.\n  public void setNDCLogRecordFilter(String textFilter) {\n    _table.getFilteredLogTableModel().\n        setLogRecordFilter(createNDCLogRecordFilter(textFilter));\n  }\n  //--------------------------------------------------------------------------\n  //   Protected Methods:\n  //--------------------------------------------------------------------------\n\n  protected void setSearchText(String text) {\n    _searchText = text;\n  }\n\n  // Added in version 1.2 - Sets the text filter for the NDC\n  protected void setNDCTextFilter(String text) {\n    // if no value is set, set it to a blank string\n    // otherwise use the value provided\n    if (text == null) {\n      _NDCTextFilter = \"\";\n    } else {\n      _NDCTextFilter = text;\n    }\n  }\n\n  // Added in version 1.2 - Uses a different filter that sorts\n  // based on an NDC string passed in by the user.  If the string\n  // is null or is an empty string, we do nothing.\n  protected void sortByNDC() {\n    String text = _NDCTextFilter;\n    if (text == null || text.length() == 0) {\n      return;\n    }\n\n    // Use new NDC filter\n    _table.getFilteredLogTableModel().\n        setLogRecordFilter(createNDCLogRecordFilter(text));\n  }\n\n  protected void findSearchText() {\n    String text = _searchText;\n    if (text == null || text.length() == 0) {\n      return;\n    }\n    int startRow = getFirstSelectedRow();\n    int foundRow = findRecord(\n        startRow,\n        text,\n        _table.getFilteredLogTableModel().getFilteredRecords()\n    );\n    selectRow(foundRow);\n  }\n\n  protected int getFirstSelectedRow() {\n    return _table.getSelectionModel().getMinSelectionIndex();\n  }\n\n  protected void selectRow(int foundRow) {\n    if (foundRow == -1) {\n      String message = _searchText + \" not found.\";\n      JOptionPane.showMessageDialog(\n          _logMonitorFrame,\n          message,\n          \"Text not found\",\n          JOptionPane.INFORMATION_MESSAGE\n      );\n      return;\n    }\n    LF5SwingUtils.selectRow(foundRow, _table, _logTableScrollPane);\n  }\n\n  protected int findRecord(\n      int startRow,\n      String searchText,\n      List records\n      ) {\n    if (startRow < 0) {\n      startRow = 0; // start at first element if no rows are selected\n    } else {\n      startRow++; // start after the first selected row\n    }\n    int len = records.size();\n\n    for (int i = startRow; i < len; i++) {\n      if (matches((LogRecord) records.get(i), searchText)) {\n        return i; // found a record\n      }\n    }\n    // wrap around to beginning if when we reach the end with no match\n    len = startRow;\n    for (int i = 0; i < len; i++) {\n      if (matches((LogRecord) records.get(i), searchText)) {\n        return i; // found a record\n      }\n    }\n    // nothing found\n    return -1;\n  }\n\n  /**\n   * Check to see if the any records contain the search string.\n   * Searching now supports NDC messages and date.\n   */\n  protected boolean matches(LogRecord record, String text) {\n    String message = record.getMessage();\n    String NDC = record.getNDC();\n\n    if (message == null && NDC == null || text == null) {\n      return false;\n    }\n    if (message.toLowerCase().indexOf(text.toLowerCase()) == -1 &&\n        NDC.toLowerCase().indexOf(text.toLowerCase()) == -1) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * When the fontsize of a JTextArea is changed, the word-wrapped lines\n   * may become garbled.  This method clears and resets the text of the\n   * text area.\n   */\n  protected void refresh(JTextArea textArea) {\n    String text = textArea.getText();\n    textArea.setText(\"\");\n    textArea.setText(text);\n  }\n\n  protected void refreshDetailTextArea() {\n    refresh(_table._detailTextArea);\n  }\n\n  protected void clearDetailTextArea() {\n    _table._detailTextArea.setText(\"\");\n  }\n\n  /**\n   * Changes the font selection in the combo box and returns the\n   * size actually selected.\n   * @return -1 if unable to select an appropriate font\n   */\n  protected int changeFontSizeCombo(JComboBox box, int requestedSize) {\n    int len = box.getItemCount();\n    int currentValue;\n    Object currentObject;\n    Object selectedObject = box.getItemAt(0);\n    int selectedValue = Integer.parseInt(String.valueOf(selectedObject));\n    for (int i = 0; i < len; i++) {\n      currentObject = box.getItemAt(i);\n      currentValue = Integer.parseInt(String.valueOf(currentObject));\n      if (selectedValue < currentValue && currentValue <= requestedSize) {\n        selectedValue = currentValue;\n        selectedObject = currentObject;\n      }\n    }\n    box.setSelectedItem(selectedObject);\n    return selectedValue;\n  }\n\n  /**\n   * Does not update gui or cause any events to be fired.\n   */\n  protected void setFontSizeSilently(int fontSize) {\n    _fontSize = fontSize;\n    setFontSize(_table._detailTextArea, fontSize);\n    selectRow(0);\n    setFontSize(_table, fontSize);\n  }\n\n  protected void setFontSize(Component component, int fontSize) {\n    Font oldFont = component.getFont();\n    Font newFont =\n        new Font(oldFont.getFontName(), oldFont.getStyle(), fontSize);\n    component.setFont(newFont);\n  }\n\n  protected void updateFrameSize() {\n    _logMonitorFrame.setSize(_logMonitorFrameWidth, _logMonitorFrameHeight);\n    centerFrame(_logMonitorFrame);\n  }\n\n  protected void pause(int millis) {\n    try {\n      Thread.sleep(millis);\n    } catch (InterruptedException e) {\n\n    }\n  }\n\n  protected void initComponents() {\n    //\n    // Configure the Frame.\n    //\n    _logMonitorFrame = new JFrame(\"LogFactor5\");\n\n    _logMonitorFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\n\n    String resource =\n        \"/org/apache/log4j/lf5/viewer/images/lf5_small_icon.gif\";\n    URL lf5IconURL = getClass().getResource(resource);\n\n    if (lf5IconURL != null) {\n      _logMonitorFrame.setIconImage(new ImageIcon(lf5IconURL).getImage());\n    }\n    updateFrameSize();\n\n    //\n    // Configure the LogTable.\n    //\n    JTextArea detailTA = createDetailTextArea();\n    JScrollPane detailTAScrollPane = new JScrollPane(detailTA);\n    _table = new LogTable(detailTA);\n    setView(_currentView, _table);\n    _table.setFont(new Font(_fontName, Font.PLAIN, _fontSize));\n    _logTableScrollPane = new JScrollPane(_table);\n\n    if (_trackTableScrollPane) {\n      _logTableScrollPane.getVerticalScrollBar().addAdjustmentListener(\n          new TrackingAdjustmentListener()\n      );\n    }\n\n\n    // Configure the SplitPane between the LogTable & DetailTextArea\n    //\n\n    JSplitPane tableViewerSplitPane = new JSplitPane();\n    tableViewerSplitPane.setOneTouchExpandable(true);\n    tableViewerSplitPane.setOrientation(JSplitPane.VERTICAL_SPLIT);\n    tableViewerSplitPane.setLeftComponent(_logTableScrollPane);\n    tableViewerSplitPane.setRightComponent(detailTAScrollPane);\n    // Make sure to do this last..\n    //tableViewerSplitPane.setDividerLocation(1.0); Doesn't work\n    //the same under 1.2.x & 1.3\n    // \"350\" is a magic number that provides the correct default\n    // behaviour under 1.2.x & 1.3.  For example, bumping this\n    // number to 400, causes the pane to be completely open in 1.2.x\n    // and closed in 1.3\n    tableViewerSplitPane.setDividerLocation(350);\n\n    //\n    // Configure the CategoryExplorer\n    //\n\n    _categoryExplorerTree = new CategoryExplorerTree();\n\n    _table.getFilteredLogTableModel().setLogRecordFilter(createLogRecordFilter());\n\n    JScrollPane categoryExplorerTreeScrollPane =\n        new JScrollPane(_categoryExplorerTree);\n    categoryExplorerTreeScrollPane.setPreferredSize(new Dimension(130, 400));\n\n    // Load most recently used file list\n    _mruFileManager = new MRUFileManager();\n\n    //\n    // Configure the SplitPane between the CategoryExplorer & (LogTable/Detail)\n    //\n\n    JSplitPane splitPane = new JSplitPane();\n    splitPane.setOneTouchExpandable(true);\n    splitPane.setRightComponent(tableViewerSplitPane);\n    splitPane.setLeftComponent(categoryExplorerTreeScrollPane);\n    // Do this last.\n    splitPane.setDividerLocation(130);\n    //\n    // Add the MenuBar, StatusArea, CategoryExplorer|LogTable to the\n    // LogMonitorFrame.\n    //\n    _logMonitorFrame.getRootPane().setJMenuBar(createMenuBar());\n    _logMonitorFrame.getContentPane().add(splitPane, BorderLayout.CENTER);\n    _logMonitorFrame.getContentPane().add(createToolBar(),\n        BorderLayout.NORTH);\n    _logMonitorFrame.getContentPane().add(createStatusArea(),\n        BorderLayout.SOUTH);\n\n    makeLogTableListenToCategoryExplorer();\n    addTableModelProperties();\n\n    //\n    // Configure ConfigurationManager\n    //\n    _configurationManager = new ConfigurationManager(this, _table);\n\n  }\n\n  protected LogRecordFilter createLogRecordFilter() {\n    LogRecordFilter result = new LogRecordFilter() {\n      public boolean passes(LogRecord record) {\n        CategoryPath path = new CategoryPath(record.getCategory());\n        return\n            getMenuItem(record.getLevel()).isSelected() &&\n            _categoryExplorerTree.getExplorerModel().isCategoryPathActive(path);\n      }\n    };\n    return result;\n  }\n\n  // Added in version 1.2 - Creates a new filter that sorts records based on\n  // an NDC string passed in by the user.\n  protected LogRecordFilter createNDCLogRecordFilter(String text) {\n    _NDCTextFilter = text;\n    LogRecordFilter result = new LogRecordFilter() {\n      public boolean passes(LogRecord record) {\n        String NDC = record.getNDC();\n        CategoryPath path = new CategoryPath(record.getCategory());\n        if (NDC == null || _NDCTextFilter == null) {\n          return false;\n        } else if (NDC.toLowerCase().indexOf(_NDCTextFilter.toLowerCase()) == -1) {\n          return false;\n        } else {\n          return getMenuItem(record.getLevel()).isSelected() &&\n              _categoryExplorerTree.getExplorerModel().isCategoryPathActive(path);\n        }\n      }\n    };\n\n    return result;\n  }\n\n\n  protected void updateStatusLabel() {\n    _statusLabel.setText(getRecordsDisplayedMessage());\n  }\n\n  protected String getRecordsDisplayedMessage() {\n    FilteredLogTableModel model = _table.getFilteredLogTableModel();\n    return getStatusText(model.getRowCount(), model.getTotalRowCount());\n  }\n\n  protected void addTableModelProperties() {\n    final FilteredLogTableModel model = _table.getFilteredLogTableModel();\n\n    addDisplayedProperty(new Object() {\n      public String toString() {\n        return getRecordsDisplayedMessage();\n      }\n    });\n    addDisplayedProperty(new Object() {\n      public String toString() {\n        return \"Maximum number of displayed LogRecords: \"\n            + model._maxNumberOfLogRecords;\n      }\n    });\n  }\n\n  protected String getStatusText(int displayedRows, int totalRows) {\n    StringBuffer result = new StringBuffer();\n    result.append(\"Displaying: \");\n    result.append(displayedRows);\n    result.append(\" records out of a total of: \");\n    result.append(totalRows);\n    result.append(\" records.\");\n    return result.toString();\n  }\n\n  protected void makeLogTableListenToCategoryExplorer() {\n    ActionListener listener = new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        _table.getFilteredLogTableModel().refresh();\n        updateStatusLabel();\n      }\n    };\n    _categoryExplorerTree.getExplorerModel().addActionListener(listener);\n  }\n\n  protected JPanel createStatusArea() {\n    JPanel statusArea = new JPanel();\n    JLabel status =\n        new JLabel(\"No log records to display.\");\n    _statusLabel = status;\n    status.setHorizontalAlignment(JLabel.LEFT);\n\n    statusArea.setBorder(BorderFactory.createEtchedBorder());\n    statusArea.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));\n    statusArea.add(status);\n\n    return (statusArea);\n  }\n\n  protected JTextArea createDetailTextArea() {\n    JTextArea detailTA = new JTextArea();\n    detailTA.setFont(new Font(\"Monospaced\", Font.PLAIN, 14));\n    detailTA.setTabSize(3);\n    detailTA.setLineWrap(true);\n    detailTA.setWrapStyleWord(false);\n    return (detailTA);\n  }\n\n  protected JMenuBar createMenuBar() {\n    JMenuBar menuBar = new JMenuBar();\n    menuBar.add(createFileMenu());\n    menuBar.add(createEditMenu());\n    menuBar.add(createLogLevelMenu());\n    menuBar.add(createViewMenu());\n    menuBar.add(createConfigureMenu());\n    menuBar.add(createHelpMenu());\n\n    return (menuBar);\n  }\n\n  protected JMenu createLogLevelMenu() {\n    JMenu result = new JMenu(\"Log Level\");\n    result.setMnemonic('l');\n    Iterator levels = getLogLevels();\n    while (levels.hasNext()) {\n      result.add(getMenuItem((LogLevel) levels.next()));\n    }\n\n    result.addSeparator();\n    result.add(createAllLogLevelsMenuItem());\n    result.add(createNoLogLevelsMenuItem());\n    result.addSeparator();\n    result.add(createLogLevelColorMenu());\n    result.add(createResetLogLevelColorMenuItem());\n\n    return result;\n  }\n\n  protected JMenuItem createAllLogLevelsMenuItem() {\n    JMenuItem result = new JMenuItem(\"Show all LogLevels\");\n    result.setMnemonic('s');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        selectAllLogLevels(true);\n        _table.getFilteredLogTableModel().refresh();\n        updateStatusLabel();\n      }\n    });\n    return result;\n  }\n\n  protected JMenuItem createNoLogLevelsMenuItem() {\n    JMenuItem result = new JMenuItem(\"Hide all LogLevels\");\n    result.setMnemonic('h');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        selectAllLogLevels(false);\n        _table.getFilteredLogTableModel().refresh();\n        updateStatusLabel();\n      }\n    });\n    return result;\n  }\n\n  protected JMenu createLogLevelColorMenu() {\n    JMenu colorMenu = new JMenu(\"Configure LogLevel Colors\");\n    colorMenu.setMnemonic('c');\n    Iterator levels = getLogLevels();\n    while (levels.hasNext()) {\n      colorMenu.add(createSubMenuItem((LogLevel) levels.next()));\n    }\n\n    return colorMenu;\n  }\n\n  protected JMenuItem createResetLogLevelColorMenuItem() {\n    JMenuItem result = new JMenuItem(\"Reset LogLevel Colors\");\n    result.setMnemonic('r');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        // reset the level colors in the map\n        LogLevel.resetLogLevelColorMap();\n\n        // refresh the table\n        _table.getFilteredLogTableModel().refresh();\n      }\n    });\n    return result;\n  }\n\n  protected void selectAllLogLevels(boolean selected) {\n    Iterator levels = getLogLevels();\n    while (levels.hasNext()) {\n      getMenuItem((LogLevel) levels.next()).setSelected(selected);\n    }\n  }\n\n  protected JCheckBoxMenuItem getMenuItem(LogLevel level) {\n    JCheckBoxMenuItem result = (JCheckBoxMenuItem) (_logLevelMenuItems.get(level));\n    if (result == null) {\n      result = createMenuItem(level);\n      _logLevelMenuItems.put(level, result);\n    }\n    return result;\n  }\n\n  protected JMenuItem createSubMenuItem(LogLevel level) {\n    final JMenuItem result = new JMenuItem(level.toString());\n    final LogLevel logLevel = level;\n    result.setMnemonic(level.toString().charAt(0));\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        showLogLevelColorChangeDialog(result, logLevel);\n      }\n    });\n\n    return result;\n\n  }\n\n  protected void showLogLevelColorChangeDialog(JMenuItem result, LogLevel level) {\n    JMenuItem menuItem = result;\n    Color newColor = JColorChooser.showDialog(\n        _logMonitorFrame,\n        \"Choose LogLevel Color\",\n        result.getForeground());\n\n    if (newColor != null) {\n      // set the color for the record\n      level.setLogLevelColorMap(level, newColor);\n      _table.getFilteredLogTableModel().refresh();\n    }\n\n  }\n\n  protected JCheckBoxMenuItem createMenuItem(LogLevel level) {\n    JCheckBoxMenuItem result = new JCheckBoxMenuItem(level.toString());\n    result.setSelected(true);\n    result.setMnemonic(level.toString().charAt(0));\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        _table.getFilteredLogTableModel().refresh();\n        updateStatusLabel();\n      }\n    });\n    return result;\n  }\n\n  // view menu\n  protected JMenu createViewMenu() {\n    JMenu result = new JMenu(\"View\");\n    result.setMnemonic('v');\n    Iterator columns = getLogTableColumns();\n    while (columns.hasNext()) {\n      result.add(getLogTableColumnMenuItem((LogTableColumn) columns.next()));\n    }\n\n    result.addSeparator();\n    result.add(createAllLogTableColumnsMenuItem());\n    result.add(createNoLogTableColumnsMenuItem());\n    return result;\n  }\n\n  protected JCheckBoxMenuItem getLogTableColumnMenuItem(LogTableColumn column) {\n    JCheckBoxMenuItem result = (JCheckBoxMenuItem) (_logTableColumnMenuItems.get(column));\n    if (result == null) {\n      result = createLogTableColumnMenuItem(column);\n      _logTableColumnMenuItems.put(column, result);\n    }\n    return result;\n  }\n\n  protected JCheckBoxMenuItem createLogTableColumnMenuItem(LogTableColumn column) {\n    JCheckBoxMenuItem result = new JCheckBoxMenuItem(column.toString());\n\n    result.setSelected(true);\n    result.setMnemonic(column.toString().charAt(0));\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        // update list of columns and reset the view\n        List selectedColumns = updateView();\n        _table.setView(selectedColumns);\n      }\n    });\n    return result;\n  }\n\n  protected List updateView() {\n    ArrayList updatedList = new ArrayList();\n    Iterator columnIterator = _columns.iterator();\n    while (columnIterator.hasNext()) {\n      LogTableColumn column = (LogTableColumn) columnIterator.next();\n      JCheckBoxMenuItem result = getLogTableColumnMenuItem(column);\n      // check and see if the checkbox is checked\n      if (result.isSelected()) {\n        updatedList.add(column);\n      }\n    }\n\n    return updatedList;\n  }\n\n  protected JMenuItem createAllLogTableColumnsMenuItem() {\n    JMenuItem result = new JMenuItem(\"Show all Columns\");\n    result.setMnemonic('s');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        selectAllLogTableColumns(true);\n        // update list of columns and reset the view\n        List selectedColumns = updateView();\n        _table.setView(selectedColumns);\n      }\n    });\n    return result;\n  }\n\n  protected JMenuItem createNoLogTableColumnsMenuItem() {\n    JMenuItem result = new JMenuItem(\"Hide all Columns\");\n    result.setMnemonic('h');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        selectAllLogTableColumns(false);\n        // update list of columns and reset the view\n        List selectedColumns = updateView();\n        _table.setView(selectedColumns);\n      }\n    });\n    return result;\n  }\n\n  protected void selectAllLogTableColumns(boolean selected) {\n    Iterator columns = getLogTableColumns();\n    while (columns.hasNext()) {\n      getLogTableColumnMenuItem((LogTableColumn) columns.next()).setSelected(selected);\n    }\n  }\n\n  protected JMenu createFileMenu() {\n    JMenu fileMenu = new JMenu(\"File\");\n    fileMenu.setMnemonic('f');\n    JMenuItem exitMI;\n    fileMenu.add(createOpenMI());\n    fileMenu.add(createOpenURLMI());\n    fileMenu.addSeparator();\n    fileMenu.add(createCloseMI());\n    createMRUFileListMI(fileMenu);\n    fileMenu.addSeparator();\n    fileMenu.add(createExitMI());\n    return fileMenu;\n  }\n\n  /**\n   * Menu item added to allow log files to be opened with\n   * the LF5 GUI.\n   */\n  protected JMenuItem createOpenMI() {\n    JMenuItem result = new JMenuItem(\"Open...\");\n    result.setMnemonic('o');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        requestOpen();\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Menu item added to allow log files loaded from a URL\n   * to be opened by the LF5 GUI.\n   */\n  protected JMenuItem createOpenURLMI() {\n    JMenuItem result = new JMenuItem(\"Open URL...\");\n    result.setMnemonic('u');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        requestOpenURL();\n      }\n    });\n    return result;\n  }\n\n  protected JMenuItem createCloseMI() {\n    JMenuItem result = new JMenuItem(\"Close\");\n    result.setMnemonic('c');\n    result.setAccelerator(KeyStroke.getKeyStroke(\"control Q\"));\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        requestClose();\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Creates a Most Recently Used file list to be\n   * displayed in the File menu\n   */\n  protected void createMRUFileListMI(JMenu menu) {\n\n    String[] files = _mruFileManager.getMRUFileList();\n\n    if (files != null) {\n      menu.addSeparator();\n      for (int i = 0; i < files.length; i++) {\n        JMenuItem result = new JMenuItem((i + 1) + \" \" + files[i]);\n        result.setMnemonic(i + 1);\n        result.addActionListener(new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            requestOpenMRU(e);\n          }\n        });\n        menu.add(result);\n      }\n    }\n  }\n\n  protected JMenuItem createExitMI() {\n    JMenuItem result = new JMenuItem(\"Exit\");\n    result.setMnemonic('x');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        requestExit();\n      }\n    });\n    return result;\n  }\n\n  protected JMenu createConfigureMenu() {\n    JMenu configureMenu = new JMenu(\"Configure\");\n    configureMenu.setMnemonic('c');\n    configureMenu.add(createConfigureSave());\n    configureMenu.add(createConfigureReset());\n    configureMenu.add(createConfigureMaxRecords());\n\n    return configureMenu;\n  }\n\n  protected JMenuItem createConfigureSave() {\n    JMenuItem result = new JMenuItem(\"Save\");\n    result.setMnemonic('s');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        saveConfiguration();\n      }\n    });\n\n    return result;\n  }\n\n  protected JMenuItem createConfigureReset() {\n    JMenuItem result = new JMenuItem(\"Reset\");\n    result.setMnemonic('r');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        resetConfiguration();\n      }\n    });\n\n    return result;\n  }\n\n  protected JMenuItem createConfigureMaxRecords() {\n    JMenuItem result = new JMenuItem(\"Set Max Number of Records\");\n    result.setMnemonic('m');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        setMaxRecordConfiguration();\n      }\n    });\n\n    return result;\n  }\n\n\n  protected void saveConfiguration() {\n    _configurationManager.save();\n  }\n\n  protected void resetConfiguration() {\n    _configurationManager.reset();\n  }\n\n  protected void setMaxRecordConfiguration() {\n    LogFactor5InputDialog inputDialog = new LogFactor5InputDialog(\n        getBaseFrame(), \"Set Max Number of Records\", \"\", 10);\n\n    String temp = inputDialog.getText();\n\n    if (temp != null) {\n      try {\n        setMaxNumberOfLogRecords(Integer.parseInt(temp));\n      } catch (NumberFormatException e) {\n        LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(\n            getBaseFrame(),\n            \"'\" + temp + \"' is an invalid parameter.\\nPlease try again.\");\n        setMaxRecordConfiguration();\n      }\n    }\n  }\n\n\n  protected JMenu createHelpMenu() {\n    JMenu helpMenu = new JMenu(\"Help\");\n    helpMenu.setMnemonic('h');\n    helpMenu.add(createHelpProperties());\n    return helpMenu;\n  }\n\n  protected JMenuItem createHelpProperties() {\n    final String title = \"LogFactor5 Properties\";\n    final JMenuItem result = new JMenuItem(title);\n    result.setMnemonic('l');\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        showPropertiesDialog(title);\n      }\n    });\n    return result;\n  }\n\n  protected void showPropertiesDialog(String title) {\n    JOptionPane.showMessageDialog(\n        _logMonitorFrame,\n        _displayedLogBrokerProperties.toArray(),\n        title,\n        JOptionPane.PLAIN_MESSAGE\n    );\n  }\n\n  protected JMenu createEditMenu() {\n    JMenu editMenu = new JMenu(\"Edit\");\n    editMenu.setMnemonic('e');\n    editMenu.add(createEditFindMI());\n    editMenu.add(createEditFindNextMI());\n    editMenu.addSeparator();\n    editMenu.add(createEditSortNDCMI());\n    editMenu.add(createEditRestoreAllNDCMI());\n    return editMenu;\n  }\n\n  protected JMenuItem createEditFindNextMI() {\n    JMenuItem editFindNextMI = new JMenuItem(\"Find Next\");\n    editFindNextMI.setMnemonic('n');\n    editFindNextMI.setAccelerator(KeyStroke.getKeyStroke(\"F3\"));\n    editFindNextMI.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        findSearchText();\n      }\n    });\n    return editFindNextMI;\n  }\n\n  protected JMenuItem createEditFindMI() {\n    JMenuItem editFindMI = new JMenuItem(\"Find\");\n    editFindMI.setMnemonic('f');\n    editFindMI.setAccelerator(KeyStroke.getKeyStroke(\"control F\"));\n\n    editFindMI.addActionListener(\n        new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            String inputValue =\n                JOptionPane.showInputDialog(\n                    _logMonitorFrame,\n                    \"Find text: \",\n                    \"Search Record Messages\",\n                    JOptionPane.QUESTION_MESSAGE\n                );\n            setSearchText(inputValue);\n            findSearchText();\n          }\n        }\n\n    );\n    return editFindMI;\n  }\n\n  // Added version 1.2 - Allows users to Sort Log Records by an\n  // NDC text filter. A new LogRecordFilter was created to\n  // sort the records.\n  protected JMenuItem createEditSortNDCMI() {\n    JMenuItem editSortNDCMI = new JMenuItem(\"Sort by NDC\");\n    editSortNDCMI.setMnemonic('s');\n    editSortNDCMI.addActionListener(\n        new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            String inputValue =\n                JOptionPane.showInputDialog(\n                    _logMonitorFrame,\n                    \"Sort by this NDC: \",\n                    \"Sort Log Records by NDC\",\n                    JOptionPane.QUESTION_MESSAGE\n                );\n            setNDCTextFilter(inputValue);\n            sortByNDC();\n            _table.getFilteredLogTableModel().refresh();\n            updateStatusLabel();\n          }\n        }\n\n    );\n    return editSortNDCMI;\n  }\n\n  // Added in version 1.2 - Resets the LogRecordFilter back to default\n  // filter.\n  protected JMenuItem createEditRestoreAllNDCMI() {\n    JMenuItem editRestoreAllNDCMI = new JMenuItem(\"Restore all NDCs\");\n    editRestoreAllNDCMI.setMnemonic('r');\n    editRestoreAllNDCMI.addActionListener(\n        new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            _table.getFilteredLogTableModel().setLogRecordFilter(createLogRecordFilter());\n            // reset the text filter\n            setNDCTextFilter(\"\");\n            _table.getFilteredLogTableModel().refresh();\n            updateStatusLabel();\n          }\n        }\n    );\n    return editRestoreAllNDCMI;\n  }\n\n  protected JToolBar createToolBar() {\n    JToolBar tb = new JToolBar();\n    tb.putClientProperty(\"JToolBar.isRollover\", Boolean.TRUE);\n    JComboBox fontCombo = new JComboBox();\n    JComboBox fontSizeCombo = new JComboBox();\n    _fontSizeCombo = fontSizeCombo;\n\n    ClassLoader cl = this.getClass().getClassLoader();\n    if(cl == null) {\n        cl = ClassLoader.getSystemClassLoader();\n    }\n    URL newIconURL = cl.getResource(\"org/apache/log4j/lf5/viewer/\" +\n        \"images/channelexplorer_new.gif\");\n\n    ImageIcon newIcon = null;\n\n    if (newIconURL != null) {\n      newIcon = new ImageIcon(newIconURL);\n    }\n\n    JButton newButton = new JButton(\"Clear Log Table\");\n\n    if (newIcon != null) {\n      newButton.setIcon(newIcon);\n    }\n\n    newButton.setToolTipText(\"Clear Log Table.\");\n    //newButton.setBorder(BorderFactory.createEtchedBorder());\n\n    newButton.addActionListener(\n        new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            _table.clearLogRecords();\n            _categoryExplorerTree.getExplorerModel().resetAllNodeCounts();\n            updateStatusLabel();\n            clearDetailTextArea();\n            LogRecord.resetSequenceNumber();\n          }\n        }\n    );\n\n    Toolkit tk = Toolkit.getDefaultToolkit();\n    // This will actually grab all the fonts\n\n    String[] fonts;\n\n    if (_loadSystemFonts) {\n      fonts = GraphicsEnvironment.\n          getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n    } else {\n      fonts = tk.getFontList();\n    }\n\n    for (int j = 0; j < fonts.length; j++) {\n      fontCombo.addItem(fonts[j]);\n    }\n\n    fontCombo.setSelectedItem(_fontName);\n\n    fontCombo.addActionListener(\n\n        new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            JComboBox box = (JComboBox) e.getSource();\n            String font = (String) box.getSelectedItem();\n            _table.setFont(new Font(font, Font.PLAIN, _fontSize));\n            _fontName = font;\n          }\n        }\n    );\n\n    fontSizeCombo.addItem(\"8\");\n    fontSizeCombo.addItem(\"9\");\n    fontSizeCombo.addItem(\"10\");\n    fontSizeCombo.addItem(\"12\");\n    fontSizeCombo.addItem(\"14\");\n    fontSizeCombo.addItem(\"16\");\n    fontSizeCombo.addItem(\"18\");\n    fontSizeCombo.addItem(\"24\");\n\n    fontSizeCombo.setSelectedItem(String.valueOf(_fontSize));\n    fontSizeCombo.addActionListener(\n        new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            JComboBox box = (JComboBox) e.getSource();\n            String size = (String) box.getSelectedItem();\n            int s = Integer.valueOf(size).intValue();\n\n            setFontSizeSilently(s);\n            refreshDetailTextArea();\n            _fontSize = s;\n          }\n        }\n    );\n\n    tb.add(new JLabel(\" Font: \"));\n    tb.add(fontCombo);\n    tb.add(fontSizeCombo);\n    tb.addSeparator();\n    tb.addSeparator();\n    tb.add(newButton);\n\n    newButton.setAlignmentY(0.5f);\n    newButton.setAlignmentX(0.5f);\n\n    fontCombo.setMaximumSize(fontCombo.getPreferredSize());\n    fontSizeCombo.setMaximumSize(\n        fontSizeCombo.getPreferredSize());\n\n    return (tb);\n  }\n\n//    protected void setView(String viewString, LogTable table) {\n//        if (STANDARD_VIEW.equals(viewString)) {\n//            table.setStandardView();\n//        } else if (COMPACT_VIEW.equals(viewString)) {\n//            table.setCompactView();\n//        } else if (DETAILED_VIEW.equals(viewString)) {\n//            table.setDetailedView();\n//        } else {\n//            String message = viewString + \"does not match a supported view.\";\n//            throw new IllegalArgumentException(message);\n//        }\n//        _currentView = viewString;\n//    }\n\n  protected void setView(String viewString, LogTable table) {\n    if (DETAILED_VIEW.equals(viewString)) {\n      table.setDetailedView();\n    } else {\n      String message = viewString + \"does not match a supported view.\";\n      throw new IllegalArgumentException(message);\n    }\n    _currentView = viewString;\n  }\n\n  protected JComboBox createLogLevelCombo() {\n    JComboBox result = new JComboBox();\n    Iterator levels = getLogLevels();\n    while (levels.hasNext()) {\n      result.addItem(levels.next());\n    }\n    result.setSelectedItem(_leastSevereDisplayedLogLevel);\n\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        JComboBox box = (JComboBox) e.getSource();\n        LogLevel level = (LogLevel) box.getSelectedItem();\n        setLeastSevereDisplayedLogLevel(level);\n      }\n    });\n    result.setMaximumSize(result.getPreferredSize());\n    return result;\n  }\n\n  protected void setLeastSevereDisplayedLogLevel(LogLevel level) {\n    if (level == null || _leastSevereDisplayedLogLevel == level) {\n      return; // nothing to do\n    }\n    _leastSevereDisplayedLogLevel = level;\n    _table.getFilteredLogTableModel().refresh();\n    updateStatusLabel();\n  }\n\n  /**\n   * Ensures that the Table's ScrollPane Viewport will \"track\" with updates\n   * to the Table.  When the vertical scroll bar is at its bottom anchor\n   * and tracking is enabled then viewport will stay at the bottom most\n   * point of the component.  The purpose of this feature is to allow\n   * a developer to watch the table as messages arrive and not have to\n   * scroll after each new message arrives.  When the vertical scroll bar\n   * is at any other location, then no tracking will happen.\n   * @deprecated tracking is now done automatically.\n   */\n  protected void trackTableScrollPane() {\n    // do nothing\n  }\n\n  protected void centerFrame(JFrame frame) {\n    Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();\n    Dimension comp = frame.getSize();\n\n    frame.setLocation(((screen.width - comp.width) / 2),\n        ((screen.height - comp.height) / 2));\n\n  }\n\n  /**\n   * Uses a JFileChooser to select a file to opened with the\n   * LF5 GUI.\n   */\n  protected void requestOpen() {\n    JFileChooser chooser;\n\n    if (_fileLocation == null) {\n      chooser = new JFileChooser();\n    } else {\n      chooser = new JFileChooser(_fileLocation);\n    }\n\n    int returnVal = chooser.showOpenDialog(_logMonitorFrame);\n    if (returnVal == JFileChooser.APPROVE_OPTION) {\n      File f = chooser.getSelectedFile();\n      if (loadLogFile(f)) {\n        _fileLocation = chooser.getSelectedFile();\n        _mruFileManager.set(f);\n        updateMRUList();\n      }\n    }\n  }\n\n  /**\n   * Uses a Dialog box to accept a URL to a file to be opened\n   * with the LF5 GUI.\n   */\n  protected void requestOpenURL() {\n    LogFactor5InputDialog inputDialog = new LogFactor5InputDialog(\n        getBaseFrame(), \"Open URL\", \"URL:\");\n    String temp = inputDialog.getText();\n\n    if (temp != null) {\n      if (temp.indexOf(\"://\") == -1) {\n        temp = \"http://\" + temp;\n      }\n\n      try {\n        URL url = new URL(temp);\n        if (loadLogFile(url)) {\n          _mruFileManager.set(url);\n          updateMRUList();\n        }\n      } catch (MalformedURLException e) {\n        LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(\n            getBaseFrame(), \"Error reading URL.\");\n      }\n    }\n  }\n\n  /**\n   * Removes old file list and creates a new file list\n   * with the updated MRU list.\n   */\n  protected void updateMRUList() {\n    JMenu menu = _logMonitorFrame.getJMenuBar().getMenu(0);\n    menu.removeAll();\n    menu.add(createOpenMI());\n    menu.add(createOpenURLMI());\n    menu.addSeparator();\n    menu.add(createCloseMI());\n    createMRUFileListMI(menu);\n    menu.addSeparator();\n    menu.add(createExitMI());\n  }\n\n  protected void requestClose() {\n    setCallSystemExitOnClose(false);\n    closeAfterConfirm();\n  }\n\n  /**\n   * Opens a file in the MRU list.\n   */\n  protected void requestOpenMRU(ActionEvent e) {\n    String file = e.getActionCommand();\n    StringTokenizer st = new StringTokenizer(file);\n    String num = st.nextToken().trim();\n    file = st.nextToken(\"\\n\");\n\n    try {\n      int index = Integer.parseInt(num) - 1;\n\n      InputStream in = _mruFileManager.getInputStream(index);\n      LogFileParser lfp = new LogFileParser(in);\n      lfp.parse(this);\n\n      _mruFileManager.moveToTop(index);\n      updateMRUList();\n\n    } catch (Exception me) {\n      LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(\n          getBaseFrame(), \"Unable to load file \" + file);\n    }\n\n  }\n\n  protected void requestExit() {\n    _mruFileManager.save();\n    setCallSystemExitOnClose(true);\n    closeAfterConfirm();\n  }\n\n  protected void closeAfterConfirm() {\n    StringBuffer message = new StringBuffer();\n\n    if (_callSystemExitOnClose == false) {\n      message.append(\"Are you sure you want to close the logging \");\n      message.append(\"console?\\n\");\n      message.append(\"(Note: This will not shut down the Virtual Machine,\\n\");\n      message.append(\"or the Swing event thread.)\");\n    } else {\n      message.append(\"Are you sure you want to exit?\\n\");\n      message.append(\"This will shut down the Virtual Machine.\\n\");\n    }\n\n    String title =\n        \"Are you sure you want to dispose of the Logging Console?\";\n\n    if (_callSystemExitOnClose == true) {\n      title = \"Are you sure you want to exit?\";\n    }\n    int value = JOptionPane.showConfirmDialog(\n        _logMonitorFrame,\n        message.toString(),\n        title,\n        JOptionPane.OK_CANCEL_OPTION,\n        JOptionPane.QUESTION_MESSAGE,\n        null\n    );\n\n    if (value == JOptionPane.OK_OPTION) {\n      dispose();\n    }\n  }\n\n  protected Iterator getLogLevels() {\n    return _levels.iterator();\n  }\n\n  protected Iterator getLogTableColumns() {\n    return _columns.iterator();\n  }\n\n  /**\n   * Loads and parses a log file.\n   */\n  protected boolean loadLogFile(File file) {\n    boolean ok = false;\n    try {\n      LogFileParser lfp = new LogFileParser(file);\n      lfp.parse(this);\n      ok = true;\n    } catch (IOException e) {\n      LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(\n          getBaseFrame(), \"Error reading \" + file.getName());\n    }\n\n    return ok;\n  }\n\n  /**\n   * Loads a parses a log file running on a server.\n   */\n  protected boolean loadLogFile(URL url) {\n    boolean ok = false;\n    try {\n      LogFileParser lfp = new LogFileParser(url.openStream());\n      lfp.parse(this);\n      ok = true;\n    } catch (IOException e) {\n      LogFactor5ErrorDialog error = new LogFactor5ErrorDialog(\n          getBaseFrame(), \"Error reading URL:\" + url.getFile());\n    }\n    return ok;\n  }\n  //--------------------------------------------------------------------------\n  //   Private Methods:\n  //--------------------------------------------------------------------------\n\n  //--------------------------------------------------------------------------\n  //   Nested Top-Level Classes or Interfaces:\n  //--------------------------------------------------------------------------\n\n  class LogBrokerMonitorWindowAdaptor extends WindowAdapter {\n    protected LogBrokerMonitor _monitor;\n\n    public LogBrokerMonitorWindowAdaptor(LogBrokerMonitor monitor) {\n      _monitor = monitor;\n    }\n\n    public void windowClosing(WindowEvent ev) {\n      _monitor.requestClose();\n    }\n  }\n}\n\n\n",
            "file_name": "LogBrokerMonitor.java",
            "human_label": "Add a log record message to be displayed in the LogTable, with the SwingUtilities.",
            "level": "project_runnable",
            "lineno": "246",
            "name": "addMessage",
            "oracle_context": "{ \"apis\" : \"[invokeLater, addLogRecord, getExplorerModel, getFilteredLogTableModel, updateStatusLabel, run]\", \"classes\" : \"[]\", \"vars\" : \"[_isDisposed, _categoryExplorerTree, _table]\" }",
            "package": "org.apache.log4j.lf5.viewer",
            "project": "logging-log4j1-main"
        },
        {
            "_id": "636767641a6d9265ec01817d",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.*;\\nimport org.jgrapht.util.*;\\nimport java.util.*;\\nint sizeA;\\nint sizeB;\\nSet<V> partitionA;\\nSet<V> partitionB;\\nCompleteBipartiteGraphGenerator(int partitionA,int partitionB);\\nCompleteBipartiteGraphGenerator(Set partitionA,Set partitionB);\\n\", \"repo_level\" : \"\" }",
            "class_name": "CompleteBipartiteGraphGenerator",
            "code": "@Override public void generateGraph(Graph<V,E> target,Map<String,V> resultMap){\n  for (int i=0; i < sizeA; i++) {\n    partitionA.add(target.addVertex());\n  }\n  for (int i=0; i < sizeB; i++) {\n    partitionB.add(target.addVertex());\n  }\n  for (  V u : partitionA) {\n    for (    V v : partitionB) {\n      target.addEdge(u,v);\n    }\n  }\n}\n",
            "docstring": "/** \n * Construct a complete bipartite graph\n */\n",
            "end_lineno": "100",
            "file_content": "/*\n * (C) Copyright 2008-2021, by Andrew Newell and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.generate;\n\nimport org.jgrapht.*;\nimport org.jgrapht.util.*;\n\nimport java.util.*;\n\n/**\n * Generates a <a href=\"http://mathworld.wolfram.com/CompleteBipartiteGraph.html\">complete bipartite\n * graph</a> of any size. This is a graph with two partitions; two vertices will contain an edge if\n * and only if they belong to different partitions.\n *\n * @param <V> the graph vertex type\n * @param <E> the graph edge type\n *\n * @author Andrew Newell\n */\npublic class CompleteBipartiteGraphGenerator<V, E>\n    implements\n    GraphGenerator<V, E, V>\n{\n    private final int sizeA, sizeB;\n    private final Set<V> partitionA, partitionB;\n\n    /**\n     * Creates a new CompleteBipartiteGraphGenerator object.\n     *\n     * @param partitionA number of vertices in the first partition\n     * @param partitionB number of vertices in the second partition\n     */\n    public CompleteBipartiteGraphGenerator(int partitionA, int partitionB)\n    {\n        if (partitionA < 0 || partitionB < 0) {\n            throw new IllegalArgumentException(\"partition sizes must be non-negative\");\n        }\n        this.sizeA = partitionA;\n        this.sizeB = partitionB;\n        this.partitionA = CollectionUtil.newLinkedHashSetWithExpectedSize(sizeA);\n        this.partitionB = CollectionUtil.newLinkedHashSetWithExpectedSize(sizeB);\n    }\n\n    /**\n     * Creates a new CompleteBipartiteGraphGenerator object. A complete bipartite graph is generated\n     * on the vertices provided between the vertices provided in the two partitions. Note that\n     * <i>all</i> vertices in both {@code partitionA} and {@code partitionB} must be present in the\n     * graph or an exception will be thrown during the invocation of\n     * {@link #generateGraph(Graph, Map)}\n     *\n     * @param partitionA first partition\n     * @param partitionB second partition\n     */\n    public CompleteBipartiteGraphGenerator(Set<V> partitionA, Set<V> partitionB)\n    {\n        if (partitionA.isEmpty() || partitionB.isEmpty()) {\n            throw new IllegalArgumentException(\"partitions must be non-empty\");\n        }\n        this.sizeA = 0;\n        this.sizeB = 0;\n        this.partitionA = partitionA;\n        this.partitionB = partitionB;\n    }\n\n    /**\n     * Construct a complete bipartite graph\n     */\n    @Override\n    public void generateGraph(Graph<V, E> target, Map<String, V> resultMap)\n    {\n        // Create vertices in each of the partitions\n        for (int i = 0; i < sizeA; i++) {\n            partitionA.add(target.addVertex());\n        }\n        for (int i = 0; i < sizeB; i++) {\n            partitionB.add(target.addVertex());\n        }\n\n        // Add an edge for each pair of vertices in different partitions\n        for (V u : partitionA) {\n            for (V v : partitionB) {\n                target.addEdge(u, v);\n            }\n        }\n    }\n}\n",
            "file_name": "CompleteBipartiteGraphGenerator.java",
            "human_label": "Construct a complete bipartite graph from partitions A and B.",
            "level": "class_runnable",
            "lineno": "80",
            "name": "generateGraph",
            "oracle_context": "{ \"apis\" : \"[add, addVertex, addEdge]\", \"classes\" : \"[]\", \"vars\" : \"[sizeA, partitionA, sizeB, partitionB]\" }",
            "package": "org.jgrapht.generate",
            "project": "jgrapht-master"
        },
        {
            "_id": "636767a41a6d9265ec018582",
            "all_context": "{ \"class_level\" : \"import java.io.DataInput;\\nimport java.io.DataOutput;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.io.OutputStream;\\nimport java.util.ArrayList;\\nimport java.util.List;\\nProtobufIOUtil();\\nnewPipe(byte[] data,int offset,int len);\\nbegin(Pipe.Schema pipeSchema);\\nend(Pipe.Schema pipeSchema,Input input,boolean cleanupOnly);\\nnewPipe(InputStream in);\\nmergeFrom(byte[] data,T message,Schema schema);\\nmergeFrom(byte[] data,int offset,int length,T message,Schema schema);\\nmergeFrom(InputStream in,T message,Schema schema);\\nmergeFrom(InputStream in,T message,Schema schema,LinkedBuffer buffer);\\nmergeDelimitedFrom(InputStream in,T message,Schema schema);\\nmergeDelimitedFrom(InputStream in,T message,Schema schema,LinkedBuffer buffer);\\nmergeDelimitedFrom(DataInput in,T message,Schema schema);\\ntoByteArray(T message,Schema schema,LinkedBuffer buffer);\\nwriteTo(LinkedBuffer buffer,T message,Schema schema);\\nwriteTo(OutputStream out,T message,Schema schema,LinkedBuffer buffer);\\nwriteDelimitedTo(OutputStream out,T message,Schema schema,LinkedBuffer buffer);\\nwriteDelimitedTo(DataOutput out,T message,Schema schema);\\nwriteListTo(OutputStream out,List messages,Schema schema,LinkedBuffer buffer);\\nparseListFrom(InputStream in,Schema schema);\\noptMergeDelimitedFrom(InputStream in,T message,Schema schema,LinkedBuffer buffer);\\noptMergeDelimitedFrom(InputStream in,T message,Schema schema,boolean drainRemainingBytesIfTooLarge,LinkedBuffer buffer);\\noptWriteDelimitedTo(OutputStream out,T message,Schema schema,LinkedBuffer buffer);\\nnewPipe(byte[] data);\\n\", \"repo_level\" : \"\" }",
            "class_name": "ProtobufIOUtil",
            "code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n  if (buffer.start != buffer.offset)   throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\n  final ProtobufOutput output=new ProtobufOutput(buffer);\n  schema.writeTo(output,message);\n  final int size=output.getSize();\n  ProtobufOutput.writeRawVarInt32Bytes(out,size);\n  final int msgSize=LinkedBuffer.writeTo(out,buffer);\n  assert size == msgSize;\n  return size;\n}\n",
            "docstring": "/** \n * Serializes the  {@code message}, prefixed with its length, into an  {@link OutputStream}.\n * @return the size of the message\n */\n",
            "end_lineno": "256",
            "file_content": "//========================================================================\r\n//Copyright 2007-2010 David Yu dyuproject@gmail.com\r\n//------------------------------------------------------------------------\r\n//Licensed under the Apache License, Version 2.0 (the \"License\");\r\n//you may not use this file except in compliance with the License.\r\n//You may obtain a copy of the License at \r\n//http://www.apache.org/licenses/LICENSE-2.0\r\n//Unless required by applicable law or agreed to in writing, software\r\n//distributed under the License is distributed on an \"AS IS\" BASIS,\r\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n//See the License for the specific language governing permissions and\r\n//limitations under the License.\r\n//========================================================================\r\n\r\npackage io.protostuff;\r\n\r\nimport java.io.DataInput;\r\nimport java.io.DataOutput;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * Protobuf ser/deser util for messages/objects.\r\n * \r\n * @author David Yu\r\n * @created Oct 5, 2010\r\n */\r\npublic final class ProtobufIOUtil\r\n{\r\n\r\n    private ProtobufIOUtil()\r\n    {\r\n    }\r\n\r\n    /**\r\n     * Creates a protobuf pipe from a byte array.\r\n     */\r\n    public static Pipe newPipe(byte[] data)\r\n    {\r\n        return newPipe(data, 0, data.length);\r\n    }\r\n\r\n    /**\r\n     * Creates a protobuf pipe from a byte array.\r\n     */\r\n    public static Pipe newPipe(byte[] data, int offset, int len)\r\n    {\r\n        final ByteArrayInput byteArrayInput = new ByteArrayInput(data, offset, len, false);\r\n        return new Pipe()\r\n        {\r\n            @Override\r\n            protected Input begin(Pipe.Schema<?> pipeSchema) throws IOException\r\n            {\r\n                return byteArrayInput;\r\n            }\r\n\r\n            @Override\r\n            protected void end(Pipe.Schema<?> pipeSchema, Input input,\r\n                    boolean cleanupOnly) throws IOException\r\n            {\r\n                if (cleanupOnly)\r\n                    return;\r\n\r\n                assert input == byteArrayInput;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates a protobuf pipe from an {@link InputStream}.\r\n     */\r\n    public static Pipe newPipe(final InputStream in)\r\n    {\r\n        final CodedInput codedInput = new CodedInput(in, false);\r\n        return new Pipe()\r\n        {\r\n            @Override\r\n            protected Input begin(Pipe.Schema<?> pipeSchema) throws IOException\r\n            {\r\n                return codedInput;\r\n            }\r\n\r\n            @Override\r\n            protected void end(Pipe.Schema<?> pipeSchema, Input input,\r\n                    boolean cleanupOnly) throws IOException\r\n            {\r\n                if (cleanupOnly)\r\n                    return;\r\n\r\n                assert input == codedInput;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Merges the {@code message} with the byte array using the given {@code schema}.\r\n     */\r\n    public static <T> void mergeFrom(byte[] data, T message, Schema<T> schema)\r\n    {\r\n        IOUtil.mergeFrom(data, 0, data.length, message, schema, false);\r\n    }\r\n\r\n    /**\r\n     * Merges the {@code message} with the byte array using the given {@code schema}.\r\n     */\r\n    public static <T> void mergeFrom(byte[] data, int offset, int length, T message,\r\n            Schema<T> schema)\r\n    {\r\n        IOUtil.mergeFrom(data, offset, length, message, schema, false);\r\n    }\r\n\r\n    /**\r\n     * Merges the {@code message} from the {@link InputStream} using the given {@code schema}.\r\n     */\r\n    public static <T> void mergeFrom(InputStream in, T message, Schema<T> schema)\r\n            throws IOException\r\n    {\r\n        IOUtil.mergeFrom(in, message, schema, false);\r\n    }\r\n\r\n    /**\r\n     * Merges the {@code message} from the {@link InputStream} using the given {@code schema}.\r\n     * <p>\r\n     * The {@code buffer}'s internal byte array will be used for reading the message.\r\n     */\r\n    public static <T> void mergeFrom(InputStream in, T message, Schema<T> schema,\r\n            LinkedBuffer buffer) throws IOException\r\n    {\r\n        IOUtil.mergeFrom(in, buffer.buffer, message, schema, false);\r\n    }\r\n\r\n    /**\r\n     * Merges the {@code message} (delimited) from the {@link InputStream} using the given {@code schema}.\r\n     * \r\n     * @return the size of the message\r\n     */\r\n    public static <T> int mergeDelimitedFrom(InputStream in, T message, Schema<T> schema)\r\n            throws IOException\r\n    {\r\n        return IOUtil.mergeDelimitedFrom(in, message, schema, false);\r\n    }\r\n\r\n    /**\r\n     * Merges the {@code message} (delimited) from the {@link InputStream} using the given {@code schema}.\r\n     * <p>\r\n     * The delimited message size must not be larger than the {@code buffer}'s size/capacity. {@link ProtobufException}\r\n     * \"size limit exceeded\" is thrown otherwise.\r\n     * \r\n     * @return the size of the message\r\n     */\r\n    public static <T> int mergeDelimitedFrom(InputStream in, T message, Schema<T> schema,\r\n            LinkedBuffer buffer) throws IOException\r\n    {\r\n        return IOUtil.mergeDelimitedFrom(in, buffer.buffer, message, schema, false);\r\n    }\r\n\r\n    /**\r\n     * Used by the code generated messages that implement {@link java.io.Externalizable}. Merges from the\r\n     * {@link DataInput}.\r\n     * \r\n     * @return the size of the message\r\n     */\r\n    public static <T> int mergeDelimitedFrom(DataInput in, T message, Schema<T> schema)\r\n            throws IOException\r\n    {\r\n        return IOUtil.mergeDelimitedFrom(in, message, schema, false);\r\n    }\r\n\r\n    /**\r\n     * Serializes the {@code message} into a byte array using the given schema.\r\n     * \r\n     * @return the byte array containing the data.\r\n     */\r\n    public static <T> byte[] toByteArray(T message, Schema<T> schema, LinkedBuffer buffer)\r\n    {\r\n        if (buffer.start != buffer.offset)\r\n            throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\r\n\r\n        final ProtobufOutput output = new ProtobufOutput(buffer);\r\n        try\r\n        {\r\n            schema.writeTo(output, message);\r\n        }\r\n        catch (IOException e)\r\n        {\r\n            throw new RuntimeException(\"Serializing to a byte array threw an IOException \" +\r\n                    \"(should never happen).\", e);\r\n        }\r\n\r\n        return output.toByteArray();\r\n    }\r\n\r\n    /**\r\n     * Writes the {@code message} into the {@link LinkedBuffer} using the given schema.\r\n     * \r\n     * @return the size of the message\r\n     */\r\n    public static <T> int writeTo(LinkedBuffer buffer, T message, Schema<T> schema)\r\n    {\r\n        if (buffer.start != buffer.offset)\r\n            throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\r\n\r\n        final ProtobufOutput output = new ProtobufOutput(buffer);\r\n        try\r\n        {\r\n            schema.writeTo(output, message);\r\n        }\r\n        catch (IOException e)\r\n        {\r\n            throw new RuntimeException(\"Serializing to a LinkedBuffer threw an IOException \" +\r\n                    \"(should never happen).\", e);\r\n        }\r\n\r\n        return output.getSize();\r\n    }\r\n\r\n    /**\r\n     * Serializes the {@code message} into an {@link OutputStream} using the given schema.\r\n     * \r\n     * @return the size of the message\r\n     */\r\n    public static <T> int writeTo(OutputStream out, T message, Schema<T> schema,\r\n            LinkedBuffer buffer) throws IOException\r\n    {\r\n        if (buffer.start != buffer.offset)\r\n            throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\r\n\r\n        final ProtobufOutput output = new ProtobufOutput(buffer);\r\n        schema.writeTo(output, message);\r\n        return LinkedBuffer.writeTo(out, buffer);\r\n    }\r\n\r\n    /**\r\n     * Serializes the {@code message}, prefixed with its length, into an {@link OutputStream}.\r\n     * \r\n     * @return the size of the message\r\n     */\r\n    public static <T> int writeDelimitedTo(OutputStream out, T message, Schema<T> schema,\r\n            LinkedBuffer buffer) throws IOException\r\n    {\r\n        if (buffer.start != buffer.offset)\r\n            throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\r\n\r\n        final ProtobufOutput output = new ProtobufOutput(buffer);\r\n        schema.writeTo(output, message);\r\n        final int size = output.getSize();\r\n        ProtobufOutput.writeRawVarInt32Bytes(out, size);\r\n        final int msgSize = LinkedBuffer.writeTo(out, buffer);\r\n\r\n        assert size == msgSize;\r\n\r\n        return size;\r\n    }\r\n\r\n    /**\r\n     * Used by the code generated messages that implement {@link java.io.Externalizable}. Writes to the\r\n     * {@link DataOutput} .\r\n     * \r\n     * @return the size of the message.\r\n     */\r\n    public static <T> int writeDelimitedTo(DataOutput out, T message, Schema<T> schema)\r\n            throws IOException\r\n    {\r\n        final LinkedBuffer buffer = new LinkedBuffer(LinkedBuffer.MIN_BUFFER_SIZE);\r\n        final ProtobufOutput output = new ProtobufOutput(buffer);\r\n        schema.writeTo(output, message);\r\n        final int size = output.getSize();\r\n        ProtobufOutput.writeRawVarInt32Bytes(out, size);\r\n\r\n        final int msgSize = LinkedBuffer.writeTo(out, buffer);\r\n\r\n        assert size == msgSize;\r\n\r\n        return size;\r\n    }\r\n\r\n    /**\r\n     * Serializes the {@code messages} (delimited) into an {@link OutputStream} using the given schema.\r\n     * \r\n     * @return the total size of the messages (excluding the length prefix varint)\r\n     */\r\n    public static <T> int writeListTo(OutputStream out, List<T> messages, Schema<T> schema,\r\n            LinkedBuffer buffer) throws IOException\r\n    {\r\n        if (buffer.start != buffer.offset)\r\n            throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\r\n\r\n        final ProtobufOutput output = new ProtobufOutput(buffer);\r\n        int totalSize = 0;\r\n        for (T m : messages)\r\n        {\r\n            schema.writeTo(output, m);\r\n            final int size = output.getSize();\r\n            ProtobufOutput.writeRawVarInt32Bytes(out, size);\r\n            final int msgSize = LinkedBuffer.writeTo(out, buffer);\r\n\r\n            assert size == msgSize;\r\n\r\n            totalSize += size;\r\n            output.clear();\r\n        }\r\n        return totalSize;\r\n    }\r\n\r\n    /**\r\n     * Parses the {@code messages} (delimited) from the {@link InputStream} using the given {@code schema}.\r\n     * \r\n     * @return the list containing the messages.\r\n     */\r\n    public static <T> List<T> parseListFrom(InputStream in, Schema<T> schema) throws IOException\r\n    {\r\n        final ArrayList<T> list = new ArrayList<T>();\r\n        byte[] buf = null;\r\n        int biggestLen = 0;\r\n        LimitedInputStream lin = null;\r\n        for (int size = in.read(); size != -1; size = in.read())\r\n        {\r\n            final T message = schema.newMessage();\r\n            list.add(message);\r\n            final int len = size < 0x80 ? size : CodedInput.readRawVarint32(in, size);\r\n            if (len != 0)\r\n            {\r\n                // not an empty message\r\n                if (len > CodedInput.DEFAULT_BUFFER_SIZE)\r\n                {\r\n                    // message too big\r\n                    if (lin == null)\r\n                        lin = new LimitedInputStream(in);\r\n                    final CodedInput input = new CodedInput(lin.limit(len), false);\r\n                    schema.mergeFrom(input, message);\r\n                    input.checkLastTagWas(0);\r\n                    continue;\r\n                }\r\n\r\n                if (biggestLen < len)\r\n                {\r\n                    // cannot reuse buffer, allocate a bigger buffer\r\n                    // discard the last one for gc\r\n                    buf = new byte[len];\r\n                    biggestLen = len;\r\n                }\r\n                IOUtil.fillBufferFrom(in, buf, 0, len);\r\n                final ByteArrayInput input = new ByteArrayInput(buf, 0, len, false);\r\n                try\r\n                {\r\n                    schema.mergeFrom(input, message);\r\n                }\r\n                catch (ArrayIndexOutOfBoundsException e)\r\n                {\r\n                    throw ProtobufException.truncatedMessage(e);\r\n                }\r\n                input.checkLastTagWas(0);\r\n            }\r\n        }\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * Optimal/Optional mergeDelimitedFrom - If the message does not fit the buffer, no merge is done and this method\r\n     * will return false.\r\n     * <p>\r\n     * This is strictly for reading a single message from the stream because the buffer is aggressively filled when\r\n     * reading the delimited size (which could result into reading more bytes than it has to).\r\n     * <p>\r\n     * The remaining bytes will be drained (consumed and discared) when the message is too large.\r\n     */\r\n    public static <T> boolean optMergeDelimitedFrom(InputStream in,\r\n            T message, Schema<T> schema,\r\n            LinkedBuffer buffer) throws IOException\r\n    {\r\n        return optMergeDelimitedFrom(in, message, schema, true, buffer);\r\n    }\r\n\r\n    /**\r\n     * Optimal/Optional mergeDelimitedFrom - If the message does not fit the buffer, no merge is done and this method\r\n     * will return false.\r\n     * <p>\r\n     * This is strictly for reading a single message from the stream because the buffer is aggressively filled when\r\n     * reading the delimited size (which could result into reading more bytes than it has to).\r\n     */\r\n    public static <T> boolean optMergeDelimitedFrom(InputStream in,\r\n            T message, Schema<T> schema, boolean drainRemainingBytesIfTooLarge,\r\n            LinkedBuffer buffer) throws IOException\r\n    {\r\n        if (buffer.start != buffer.offset)\r\n            throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\r\n\r\n        final int size = IOUtil.fillBufferWithDelimitedMessageFrom(in,\r\n                drainRemainingBytesIfTooLarge, buffer);\r\n\r\n        if (size == 0)\r\n        {\r\n            // empty message\r\n            return true;\r\n        }\r\n\r\n        if (buffer.start == buffer.offset)\r\n        {\r\n            // read offset not set ... message too large\r\n            return false;\r\n        }\r\n\r\n        final ByteArrayInput input = new ByteArrayInput(buffer.buffer,\r\n                buffer.offset, size, false);\r\n        try\r\n        {\r\n            schema.mergeFrom(input, message);\r\n            input.checkLastTagWas(0);\r\n        }\r\n        catch (ArrayIndexOutOfBoundsException e)\r\n        {\r\n            throw ProtobufException.truncatedMessage(e);\r\n        }\r\n        finally\r\n        {\r\n            // reset\r\n            buffer.offset = buffer.start;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Optimal writeDelimitedTo - The varint32 prefix is written to the buffer instead of directly writing to\r\n     * outputstream.\r\n     * \r\n     * @return the size of the message\r\n     */\r\n    public static <T> int optWriteDelimitedTo(OutputStream out, T message,\r\n            Schema<T> schema, LinkedBuffer buffer) throws IOException\r\n    {\r\n        if (buffer.start != buffer.offset)\r\n            throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\r\n\r\n        final ProtobufOutput output = new ProtobufOutput(buffer);\r\n\r\n        // leave space for varint32\r\n        buffer.offset = buffer.start + 5;\r\n        output.size += 5;\r\n\r\n        schema.writeTo(output, message);\r\n\r\n        final int size = output.size - 5;\r\n\r\n        final int delimOffset = IOUtil.putVarInt32AndGetOffset(size, buffer.buffer,\r\n                buffer.start);\r\n\r\n        // write to stream\r\n        out.write(buffer.buffer, delimOffset, buffer.offset - delimOffset);\r\n\r\n        // flush remaining\r\n        if (buffer.next != null)\r\n            LinkedBuffer.writeTo(out, buffer.next);\r\n\r\n        return size;\r\n    }\r\n}\r\n",
            "file_name": "ProtobufIOUtil.java",
            "human_label": "Use ProtobufOutput and the LinkedBuffer to write the message into the given OutputStream out, and return the message size.",
            "level": "project_runnable",
            "lineno": "236",
            "name": "writeDelimitedTo",
            "oracle_context": "{ \"apis\" : \"[writeTo, getSize, writeRawVarInt32Bytes]\", \"classes\" : \"[ProtobufOutput]\", \"vars\" : \"[start, offset]\" }",
            "package": "io.protostuff",
            "project": "protostuff-master"
        },
        {
            "_id": "636767001a6d9265ec01787e",
            "all_context": "{ \"class_level\" : \"import net.hasor.utils.ArrayUtils;\\nimport net.hasor.utils.ClassUtils;\\nimport java.lang.reflect.AccessibleObject;\\nimport java.lang.reflect.Field;\\nimport java.lang.reflect.Modifier;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nboolean appendStatics;\\nboolean appendTransients;\\nString[] excludeFieldNames;\\nClass<?> upToClass;\\ntoString(Object object,ToStringStyle style);\\ntoString(Object object,ToStringStyle style,boolean outputTransients);\\ntoString(Object object,ToStringStyle style,boolean outputTransients,boolean outputStatics);\\ntoString(Object object,ToStringStyle style,boolean outputTransients,boolean outputStatics,Class reflectUpToClass);\\ntoStringExclude(Object object,String excludeFieldName);\\ntoStringExclude(Object object,Collection excludeFieldNames);\\ntoNoNullStringArray(Collection collection);\\ntoNoNullStringArray(Object[] array);\\ntoStringExclude(Object object,String[] excludeFieldNames);\\nReflectionToStringBuilder(Object object);\\nReflectionToStringBuilder(Object object,ToStringStyle style);\\nReflectionToStringBuilder(Object object,ToStringStyle style,StringBuffer buffer);\\nReflectionToStringBuilder(Object object,ToStringStyle style,StringBuffer buffer,Class reflectUpToClass,boolean outputTransients,boolean outputStatics);\\naccept(Field field);\\nappendFieldsIn(Class clazz);\\ngetExcludeFieldNames();\\ngetUpToClass();\\ngetValue(Field field);\\nisAppendStatics();\\nisAppendTransients();\\nreflectionAppendArray(Object array);\\nsetAppendStatics(boolean appendStatics);\\nsetAppendTransients(boolean appendTransients);\\nsetExcludeFieldNames(String[] excludeFieldNamesParam);\\nsetUpToClass(Class clazz);\\ntoString();\\ntoString(Object object);\\n\", \"repo_level\" : \"public interface ArrayUtils {static Map toMap(Object[] array);\\nstatic Object[] clone(Object[] array);\\nstatic long[] clone(long[] array);\\nstatic int[] clone(int[] array);\\nstatic short[] clone(short[] array);\\nstatic char[] clone(char[] array);\\nstatic byte[] clone(byte[] array);\\nstatic double[] clone(double[] array);\\nstatic float[] clone(float[] array);\\nstatic boolean[] clone(boolean[] array);\\nstatic String[] clone(String[] array);\\nstatic Object[] nullToEmpty(Object[] array);\\nstatic String[] nullToEmpty(String[] array);\\nstatic long[] nullToEmpty(long[] array);\\nstatic int[] nullToEmpty(int[] array);\\nstatic short[] nullToEmpty(short[] array);\\nstatic char[] nullToEmpty(char[] array);\\nstatic byte[] nullToEmpty(byte[] array);\\nstatic double[] nullToEmpty(double[] array);\\nstatic float[] nullToEmpty(float[] array);\\nstatic boolean[] nullToEmpty(boolean[] array);\\nstatic Long[] nullToEmpty(Long[] array);\\nstatic Integer[] nullToEmpty(Integer[] array);\\nstatic Short[] nullToEmpty(Short[] array);\\nstatic Character[] nullToEmpty(Character[] array);\\nstatic Byte[] nullToEmpty(Byte[] array);\\nstatic Double[] nullToEmpty(Double[] array);\\nstatic Float[] nullToEmpty(Float[] array);\\nstatic Boolean[] nullToEmpty(Boolean[] array);\\nstatic Object[] subarray(Object[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic long[] subarray(long[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic int[] subarray(int[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic short[] subarray(short[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic char[] subarray(char[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic byte[] subarray(byte[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic double[] subarray(double[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic float[] subarray(float[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic boolean[] subarray(boolean[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic boolean isSameLength(Object[] array1,Object[] array2);\\nstatic boolean isSameLength(long[] array1,long[] array2);\\nstatic boolean isSameLength(int[] array1,int[] array2);\\nstatic boolean isSameLength(short[] array1,short[] array2);\\nstatic boolean isSameLength(char[] array1,char[] array2);\\nstatic boolean isSameLength(byte[] array1,byte[] array2);\\nstatic boolean isSameLength(double[] array1,double[] array2);\\nstatic boolean isSameLength(float[] array1,float[] array2);\\nstatic boolean isSameLength(boolean[] array1,boolean[] array2);\\nstatic int getLength(Object array);\\nstatic boolean isSameType(Object array1,Object array2);\\nstatic void reverse(Object[] array);\\nstatic void reverse(long[] array);\\nstatic void reverse(int[] array);\\nstatic void reverse(short[] array);\\nstatic void reverse(char[] array);\\nstatic void reverse(byte[] array);\\nstatic void reverse(double[] array);\\nstatic void reverse(float[] array);\\nstatic void reverse(boolean[] array);\\nstatic int indexOf(Object[] array,Object objectToFind);\\nstatic int indexOf(Object[] array,Object objectToFind,int startIndex);\\nstatic int lastIndexOf(Object[] array,Object objectToFind);\\nstatic int lastIndexOf(Object[] array,Object objectToFind,int startIndex);\\nstatic boolean contains(Object[] array,Object objectToFind);\\nstatic int indexOf(long[] array,long valueToFind);\\nstatic int indexOf(long[] array,long valueToFind,int startIndex);\\nstatic int lastIndexOf(long[] array,long valueToFind);\\nstatic int lastIndexOf(long[] array,long valueToFind,int startIndex);\\nstatic boolean contains(long[] array,long valueToFind);\\nstatic int indexOf(int[] array,int valueToFind);\\nstatic int indexOf(int[] array,int valueToFind,int startIndex);\\nstatic int lastIndexOf(int[] array,int valueToFind);\\nstatic int lastIndexOf(int[] array,int valueToFind,int startIndex);\\nstatic boolean contains(int[] array,int valueToFind);\\nstatic int indexOf(short[] array,short valueToFind);\\nstatic int indexOf(short[] array,short valueToFind,int startIndex);\\nstatic int lastIndexOf(short[] array,short valueToFind);\\nstatic int lastIndexOf(short[] array,short valueToFind,int startIndex);\\nstatic boolean contains(short[] array,short valueToFind);\\nstatic int indexOf(char[] array,char valueToFind);\\nstatic int indexOf(char[] array,char valueToFind,int startIndex);\\nstatic int lastIndexOf(char[] array,char valueToFind);\\nstatic int lastIndexOf(char[] array,char valueToFind,int startIndex);\\nstatic boolean contains(char[] array,char valueToFind);\\nstatic int indexOf(byte[] array,byte valueToFind);\\nstatic int indexOf(byte[] array,byte valueToFind,int startIndex);\\nstatic int lastIndexOf(byte[] array,byte valueToFind);\\nstatic int lastIndexOf(byte[] array,byte valueToFind,int startIndex);\\nstatic boolean contains(byte[] array,byte valueToFind);\\nstatic int indexOf(double[] array,double valueToFind);\\nstatic int indexOf(double[] array,double valueToFind,double tolerance);\\nstatic int indexOf(double[] array,double valueToFind,int startIndex);\\nstatic int indexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\nstatic int lastIndexOf(double[] array,double valueToFind);\\nstatic int lastIndexOf(double[] array,double valueToFind,double tolerance);\\nstatic int lastIndexOf(double[] array,double valueToFind,int startIndex);\\nstatic int lastIndexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\nstatic boolean contains(double[] array,double valueToFind);\\nstatic boolean contains(double[] array,double valueToFind,double tolerance);\\nstatic int indexOf(float[] array,float valueToFind);\\nstatic int indexOf(float[] array,float valueToFind,int startIndex);\\nstatic int lastIndexOf(float[] array,float valueToFind);\\nstatic int lastIndexOf(float[] array,float valueToFind,int startIndex);\\nstatic boolean contains(float[] array,float valueToFind);\\nstatic int indexOf(boolean[] array,boolean valueToFind);\\nstatic int indexOf(boolean[] array,boolean valueToFind,int startIndex);\\nstatic int lastIndexOf(boolean[] array,boolean valueToFind);\\nstatic int lastIndexOf(boolean[] array,boolean valueToFind,int startIndex);\\nstatic boolean contains(boolean[] array,boolean valueToFind);\\nstatic char[] toPrimitive(Character[] array);\\nstatic char[] toPrimitive(Character[] array,char valueForNull);\\nstatic Character[] toObject(char[] array);\\nstatic long[] toPrimitive(Long[] array);\\nstatic long[] toPrimitive(Long[] array,long valueForNull);\\nstatic Long[] toObject(long[] array);\\nstatic int[] toPrimitive(Integer[] array);\\nstatic int[] toPrimitive(Integer[] array,int valueForNull);\\nstatic Integer[] toObject(int[] array);\\nstatic short[] toPrimitive(Short[] array);\\nstatic short[] toPrimitive(Short[] array,short valueForNull);\\nstatic Short[] toObject(short[] array);\\nstatic byte[] toPrimitive(Byte[] array);\\nstatic byte[] toPrimitive(Byte[] array,byte valueForNull);\\nstatic Byte[] toObject(byte[] array);\\nstatic double[] toPrimitive(Double[] array);\\nstatic double[] toPrimitive(Double[] array,double valueForNull);\\nstatic Double[] toObject(double[] array);\\nstatic float[] toPrimitive(Float[] array);\\nstatic float[] toPrimitive(Float[] array,float valueForNull);\\nstatic Float[] toObject(float[] array);\\nstatic boolean[] toPrimitive(Boolean[] array);\\nstatic boolean[] toPrimitive(Boolean[] array,boolean valueForNull);\\nstatic Boolean[] toObject(boolean[] array);\\nstatic boolean isEmpty(Object[] array);\\nstatic boolean isEmpty(long[] array);\\nstatic boolean isEmpty(int[] array);\\nstatic boolean isEmpty(short[] array);\\nstatic boolean isEmpty(char[] array);\\nstatic boolean isEmpty(byte[] array);\\nstatic boolean isEmpty(double[] array);\\nstatic boolean isEmpty(float[] array);\\nstatic boolean isEmpty(boolean[] array);\\nstatic boolean isNotEmpty(Object[] array);\\nstatic boolean isNotEmpty(long[] array);\\nstatic boolean isNotEmpty(int[] array);\\nstatic boolean isNotEmpty(short[] array);\\nstatic boolean isNotEmpty(char[] array);\\nstatic boolean isNotEmpty(byte[] array);\\nstatic boolean isNotEmpty(double[] array);\\nstatic boolean isNotEmpty(float[] array);\\nstatic boolean isNotEmpty(boolean[] array);\\nstatic Object[] addAll(Object[] array1,Object[] array2);\\nstatic boolean[] addAll(boolean[] array1,boolean[] array2);\\nstatic char[] addAll(char[] array1,char[] array2);\\nstatic byte[] addAll(byte[] array1,byte[] array2);\\nstatic short[] addAll(short[] array1,short[] array2);\\nstatic int[] addAll(int[] array1,int[] array2);\\nstatic long[] addAll(long[] array1,long[] array2);\\nstatic float[] addAll(float[] array1,float[] array2);\\nstatic double[] addAll(double[] array1,double[] array2);\\nstatic String[] addAll(String[] array1,String[] array2);\\nstatic T[] add(T[] array,T element);\\nstatic boolean[] add(boolean[] array,boolean element);\\nstatic byte[] add(byte[] array,byte element);\\nstatic char[] add(char[] array,char element);\\nstatic double[] add(double[] array,double element);\\nstatic float[] add(float[] array,float element);\\nstatic int[] add(int[] array,int element);\\nstatic long[] add(long[] array,long element);\\nstatic short[] add(short[] array,short element);\\nstatic Object[] add(Object[] array,int index,Object element);\\nstatic boolean[] add(boolean[] array,int index,boolean element);\\nstatic char[] add(char[] array,int index,char element);\\nstatic byte[] add(byte[] array,int index,byte element);\\nstatic short[] add(short[] array,int index,short element);\\nstatic int[] add(int[] array,int index,int element);\\nstatic long[] add(long[] array,int index,long element);\\nstatic float[] add(float[] array,int index,float element);\\nstatic double[] add(double[] array,int index,double element);\\nstatic Object[] remove(Object[] array,int index);\\nstatic Object[] removeElement(Object[] array,Object element);\\nstatic boolean[] remove(boolean[] array,int index);\\nstatic boolean[] removeElement(boolean[] array,boolean element);\\nstatic byte[] remove(byte[] array,int index);\\nstatic byte[] removeElement(byte[] array,byte element);\\nstatic char[] remove(char[] array,int index);\\nstatic char[] removeElement(char[] array,char element);\\nstatic double[] remove(double[] array,int index);\\nstatic double[] removeElement(double[] array,double element);\\nstatic float[] remove(float[] array,int index);\\nstatic float[] removeElement(float[] array,float element);\\nstatic int[] remove(int[] array,int index);\\nstatic int[] removeElement(int[] array,int element);\\nstatic long[] remove(long[] array,int index);\\nstatic long[] removeElement(long[] array,long element);\\nstatic short[] remove(short[] array,int index);\\nstatic short[] removeElement(short[] array,short element);\\nstatic Object[] clearNull(Object[] arr);\\n }\\npublic interface ClassUtils {static String getShortClassName(Object object,String valueIfNull);\\nstatic String getShortClassName(Class cls);\\nstatic String getShortClassName(String className);\\nstatic String getPackageName(Object object,String valueIfNull);\\nstatic String getPackageName(Class cls);\\nstatic String getPackageName(String className);\\nstatic List<Class<?>> getAllSuperclasses(Class cls);\\nstatic List<Class<?>> getAllInterfaces(Class cls);\\nstatic List<Class<?>> convertClassNamesToClasses(List classNames);\\nstatic List<String> convertClassesToClassNames(List classes);\\nstatic boolean isAssignable(Class<?>[] classArray,Class<?>[] toClassArray);\\nstatic boolean isAssignable(Class<?>[] classArray,Class<?>[] toClassArray,boolean autoboxing);\\nstatic boolean isAssignable(Class cls,Class toClass);\\nstatic boolean isAssignable(Class cls,Class toClass,boolean autoboxing);\\nstatic Class<?> primitiveToWrapper(Class cls);\\nstatic Class<?>[] primitivesToWrappers(Class<?>[] classes);\\nstatic Class<?> wrapperToPrimitive(Class cls);\\nstatic Class<?>[] wrappersToPrimitives(Class<?>[] classes);\\nstatic boolean isInnerClass(Class cls);\\nstatic Class<?> getClass(ClassLoader classLoader,String className,boolean initialize);\\nstatic Class<?> getClass(ClassLoader classLoader,String className);\\nstatic Class<?> getClass(String className);\\nstatic Class<?> getClass(String className,boolean initialize);\\nstatic Method getPublicMethod(Class cls,String methodName,Class parameterTypes);\\nstatic Class<?>[] toClass(Object[] array);\\nstatic String getShortCanonicalName(Object object,String valueIfNull);\\nstatic String getShortCanonicalName(Class cls);\\nstatic String getShortCanonicalName(String canonicalName);\\nstatic String getPackageCanonicalName(Object object,String valueIfNull);\\nstatic String getPackageCanonicalName(Class cls);\\nstatic String getPackageCanonicalName(String canonicalName);\\nstatic ClassLoader getClassLoader(ClassLoader classLoader);\\nstatic boolean isLangClass(Class target);\\nstatic String getDescName(Class type);\\nstatic String getDescNameWithOutModifiers(Method method);\\nstatic String getDescName(Method method);\\nstatic Class<?> getSuperClassGenricType(Class clazz,int index);\\nstatic T newInstance(Class clazz);\\n }\\n\" }",
            "class_name": "ReflectionToStringBuilder",
            "code": "public String toString(){\n  if (this.getObject() == null) {\n    return this.getStyle().getNullText();\n  }\n  Class<?> clazz=this.getObject().getClass();\n  this.appendFieldsIn(clazz);\n  while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n    clazz=clazz.getSuperclass();\n    this.appendFieldsIn(clazz);\n  }\n  return super.toString();\n}\n",
            "docstring": "/** \n * <p> Gets the String built by this builder. </p>\n * @return the built string\n */\n",
            "end_lineno": "684",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.builder;\nimport net.hasor.utils.ArrayUtils;\nimport net.hasor.utils.ClassUtils;\n\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\n/**\n * <p>\n * Assists in implementing {@link Object#toString()} methods using reflection.\n * </p>\n *\n * <p>\n * This class uses reflection to determine the fields to append. Because these fields are usually private, the class\n * uses {@link java.lang.reflect.AccessibleObject#setAccessible(java.lang.reflect.AccessibleObject[], boolean)} to\n * change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions are\n * set up correctly.\n * </p>\n *\n * <p>\n * A typical invocation for this method would look like:\n * </p>\n *\n * <pre>\n * public String toString() {\n *   return ReflectionToStringBuilder.toString(this);\n * }</pre>\n *\n *\n *\n * <p>\n * You can also use the builder to debug 3rd party objects:\n * </p>\n *\n * <pre>\n * System.out.println(\"An object: \" + ReflectionToStringBuilder.toString(anObject));</pre>\n *\n *\n *\n * <p>\n * A subclass can control field output by overriding the methods:\n * <ul>\n * <li>{@link #accept(java.lang.reflect.Field)}</li>\n * <li>{@link #getValue(java.lang.reflect.Field)}</li>\n * </ul>\n * </p>\n * <p>\n * For example, this method does <i>not</i> include the <code>password</code> field in the returned\n * <code>String</code>:\n * </p>\n *\n * <pre>\n * public String toString() {\n *     return (new ReflectionToStringBuilder(this) {\n *         protected boolean accept(Field f) {\n *             return super.accept(f) && !f.getName().equals(\"password\");\n *         }\n *     }).toString();\n * }</pre>\n *\n *\n *\n * <p>\n * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the\n * constructor.\n * </p>\n *\n * @author Apache Software Foundation\n * @author Gary Gregory\n * @author Pete Gieser\n * @since 2.0\n * @version $Id: ReflectionToStringBuilder.java 905636 2010-02-02 14:03:32Z niallp $\n */\npublic class ReflectionToStringBuilder extends ToStringBuilder {\n    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }\n\n    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object or <code>ToStringStyle</code> is <code>null</code>\n     */\n    public static String toString(Object object, ToStringStyle style) {\n        return toString(object, style, false, false, null);\n    }\n\n    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     *\n     * <p>\n     * Static fields will not be included. Superclass fields will be appended.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\n        return toString(object, style, outputTransients, false, null);\n    }\n\n    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     *\n     * <p>\n     * Static fields will not be included. Superclass fields will be appended.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include transient fields\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\n        return toString(object, style, outputTransients, outputStatics, null);\n    }\n\n    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     *\n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics, Class<?> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics).toString();\n    }\n\n    /**\n     * Builds a String for a toString method excluding the given field name.\n     *\n     * @param object\n     *            The object to \"toString\".\n     * @param excludeFieldName\n     *            The field name to exclude\n     * @return The toString value.\n     */\n    public static String toStringExclude(Object object, final String excludeFieldName) {\n        return toStringExclude(object, new String[] { excludeFieldName });\n    }\n\n    /**\n     * Builds a String for a toString method excluding the given field names.\n     *\n     * @param object\n     *            The object to \"toString\".\n     * @param excludeFieldNames\n     *            The field names to exclude. Null excludes nothing.\n     * @return The toString value.\n     */\n    public static String toStringExclude(Object object, Collection<?> /*String*/ excludeFieldNames) {\n        return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\n    }\n\n    /**\n     * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code>\n     * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element \n     * is <code>null</code>.\n     *\n     * @param collection\n     *            The collection to convert\n     * @return A new array of Strings.\n     */\n    static String[] toNoNullStringArray(Collection<?> collection) {\n        if (collection == null) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        return toNoNullStringArray(collection.toArray());\n    }\n\n    /**\n     * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists\n     * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}\n     * if an array element is <code>null</code>.\n     *\n     * @param array\n     *            The array to check\n     * @return The given array or a new array without null.\n     */\n    static String[] toNoNullStringArray(Object[] array) {\n        ArrayList<String> list = new ArrayList<String>(array.length);\n        for (int i = 0; i < array.length; i++) {\n            Object e = array[i];\n            if (e != null) {\n                list.add(e.toString());\n            }\n        }\n        return (String[]) list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Builds a String for a toString method excluding the given field names.\n     *\n     * @param object\n     *            The object to \"toString\".\n     * @param excludeFieldNames\n     *            The field names to exclude\n     * @return The toString value.\n     */\n    public static String toStringExclude(Object object, String[] excludeFieldNames) {\n        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\n    }\n\n    /**\n     * Whether or not to append static fields.\n     */\n    private boolean  appendStatics    = false;\n    /**\n     * Whether or not to append transient fields.\n     */\n    private boolean  appendTransients = false;\n    /**\n     * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\n     */\n    private String[] excludeFieldNames;\n    /**\n     * The last super class to stop appending fields for.\n     */\n    private Class<?> upToClass        = null;\n\n    /**\n     * <p>\n     * Constructor.\n     * </p>\n     *\n     * <p>\n     * This constructor outputs using the default style set with <code>setDefaultStyle</code>.\n     * </p>\n     *\n     * @param object\n     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the Object passed in is <code>null</code>\n     */\n    public ReflectionToStringBuilder(Object object) {\n        super(object);\n    }\n\n    /**\n     * <p>\n     * Constructor.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default style is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the Object passed in is <code>null</code>\n     */\n    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\n        super(object, style);\n    }\n\n    /**\n     * <p>\n     * Constructor.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default style is used.\n     * </p>\n     *\n     * <p>\n     * If the buffer is <code>null</code>, a new one is created.\n     * </p>\n     *\n     * @param object\n     *            the Object to build a <code>toString</code> for\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param buffer\n     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the Object passed in is <code>null</code>\n     */\n    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n        super(object, style, buffer);\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param object\n     *            the Object to build a <code>toString</code> for\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param buffer\n     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @since 2.1\n     */\n    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer, Class<?> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\n        super(object, style, buffer);\n        this.setUpToClass(reflectUpToClass);\n        this.setAppendTransients(outputTransients);\n        this.setAppendStatics(outputStatics);\n    }\n\n    /**\n     * Returns whether or not to append the given <code>Field</code>.\n     * <ul>\n     * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\n     * <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\n     * <li>Inner class fields are not appened.</li>\n     * </ul>\n     *\n     * @param field The Field to test.\n     * @return Whether or not to append the given <code>Field</code>.\n     */\n    protected boolean accept(Field field) {\n        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n            // Reject field from inner class.\n            return false;\n        }\n        if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n            // Reject transient fields.\n            return false;\n        }\n        if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n            // Reject static fields.\n            return false;\n        }\n        if (this.getExcludeFieldNames() != null && Arrays.binarySearch(this.getExcludeFieldNames(), field.getName()) >= 0) {\n            // Reject fields from the getExcludeFieldNames list.\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     *\n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     *\n     * @param clazz The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length; i++) {\n            Field field = fields[i];\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }\n\n    /**\n     * @return Returns the excludeFieldNames.\n     */\n    public String[] getExcludeFieldNames() {\n        return this.excludeFieldNames;\n    }\n\n    /**\n     * <p>\n     * Gets the last super class to stop appending fields for.\n     * </p>\n     *\n     * @return The last super class to stop appending fields for.\n     */\n    public Class<?> getUpToClass() {\n        return this.upToClass;\n    }\n\n    /**\n     * <p>\n     * Calls <code>java.lang.reflect.Field.get(Object)</code>.\n     * </p>\n     *\n     * @param field The Field to query.\n     * @return The Object from the given Field.\n     *\n     * @throws IllegalArgumentException see {@link java.lang.reflect.Field#get(Object)}\n     * @throws IllegalAccessException see {@link java.lang.reflect.Field#get(Object)}\n     * @see java.lang.reflect.Field#get(Object)\n     */\n    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\n        return field.get(this.getObject());\n    }\n\n    /**\n     * <p>\n     * Gets whether or not to append static fields.\n     * </p>\n     *\n     * @return Whether or not to append static fields.\n     * @since 2.1\n     */\n    public boolean isAppendStatics() {\n        return this.appendStatics;\n    }\n\n    /**\n     * <p>\n     * Gets whether or not to append transient fields.\n     * </p>\n     *\n     * @return Whether or not to append transient fields.\n     */\n    public boolean isAppendTransients() {\n        return this.appendTransients;\n    }\n\n    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     *\n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }\n\n    /**\n     * <p>\n     * Sets whether or not to append static fields.\n     * </p>\n     *\n     * @param appendStatics\n     *            Whether or not to append static fields.\n     * @since 2.1\n     */\n    public void setAppendStatics(boolean appendStatics) {\n        this.appendStatics = appendStatics;\n    }\n\n    /**\n     * <p>\n     * Sets whether or not to append transient fields.\n     * </p>\n     *\n     * @param appendTransients Whether or not to append transient fields.\n     */\n    public void setAppendTransients(boolean appendTransients) {\n        this.appendTransients = appendTransients;\n    }\n\n    /**\n     * Sets the field names to exclude.\n     *\n     * @param excludeFieldNamesParam\n     *            The excludeFieldNames to excluding from toString or <code>null</code>.\n     * @return <code>this</code>\n     */\n    public ReflectionToStringBuilder setExcludeFieldNames(String[] excludeFieldNamesParam) {\n        if (excludeFieldNamesParam == null) {\n            this.excludeFieldNames = null;\n        } else {\n            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\n            Arrays.sort(this.excludeFieldNames);\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Sets the last super class to stop appending fields for.\n     * </p>\n     *\n     * @param clazz\n     *            The last super class to stop appending fields for.\n     */\n    public void setUpToClass(Class<?> clazz) {\n        if (clazz != null) {\n            Object object = getObject();\n            if (object != null && clazz.isInstance(object) == false) {\n                throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n            }\n        }\n        this.upToClass = clazz;\n    }\n\n    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     *\n     * @return the built string\n     */\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }\n}\n",
            "file_name": "ReflectionToStringBuilder.java",
            "human_label": "Return the string built by this string builder.",
            "level": "project_runnable",
            "lineno": "666",
            "name": "toString",
            "oracle_context": "{ \"apis\" : \"[getObject, getNullText, getStyle, getClass, appendFieldsIn, getSuperclass, getUpToClass]\", \"classes\" : \"[Class<?>]\", \"vars\" : \"[]\" }",
            "package": "net.hasor.utils.builder",
            "project": "hasor-master"
        },
        {
            "_id": "636766ef1a6d9265ec01761a",
            "all_context": "{ \"class_level\" : \"ClassWriter classWriter;\\nClassReader sourceClassReader;\\nint majorVersion;\\nString className;\\nint entryCount;\\nEntry[] entries;\\nint constantPoolCount;\\nByteVector constantPool;\\nint bootstrapMethodCount;\\nByteVector bootstrapMethods;\\nint typeCount;\\nEntry[] typeTable;\\nint hashCode;\\nEntry next;\\nSymbolTable(ClassWriter classWriter);\\nSymbolTable(ClassWriter classWriter,ClassReader classReader);\\ngetSource();\\ngetMajorVersion();\\ngetClassName();\\nsetMajorVersionAndClassName(int majorVersion,String className);\\ngetConstantPoolCount();\\ngetConstantPoolLength();\\nputConstantPool(ByteVector output);\\ncomputeBootstrapMethodsSize();\\nputBootstrapMethods(ByteVector output);\\nget(int hashCode);\\nput(Entry entry);\\nadd(Entry entry);\\naddConstant(Object value);\\naddConstantClass(String value);\\naddConstantFieldref(String owner,String name,String descriptor);\\naddConstantMethodref(String owner,String name,String descriptor,boolean isInterface);\\naddConstantMemberReference(int tag,String owner,String name,String descriptor);\\naddConstantMemberReference(int index,int tag,String owner,String name,String descriptor);\\naddConstantString(String value);\\naddConstantInteger(int value);\\naddConstantFloat(float value);\\naddConstantIntegerOrFloat(int tag,int value);\\naddConstantIntegerOrFloat(int index,int tag,int value);\\naddConstantLong(long value);\\naddConstantDouble(double value);\\naddConstantLongOrDouble(int tag,long value);\\naddConstantLongOrDouble(int index,int tag,long value);\\naddConstantNameAndType(String name,String descriptor);\\naddConstantNameAndType(int index,String name,String descriptor);\\naddConstantUtf8(String value);\\naddConstantUtf8(int index,String value);\\naddConstantMethodHandle(int referenceKind,String owner,String name,String descriptor,boolean isInterface);\\naddConstantMethodHandle(int index,int referenceKind,String owner,String name,String descriptor);\\naddConstantMethodType(String methodDescriptor);\\naddConstantDynamic(String name,String descriptor,Handle bootstrapMethodHandle,Object bootstrapMethodArguments);\\naddConstantInvokeDynamic(String name,String descriptor,Handle bootstrapMethodHandle,Object bootstrapMethodArguments);\\naddConstantDynamicOrInvokeDynamicReference(int tag,String name,String descriptor,int bootstrapMethodIndex);\\naddConstantDynamicOrInvokeDynamicReference(int tag,int index,String name,String descriptor,int bootstrapMethodIndex);\\naddConstantModule(String moduleName);\\naddConstantPackage(String packageName);\\naddConstantUtf8Reference(int tag,String value);\\naddConstantUtf8Reference(int index,int tag,String value);\\naddBootstrapMethod(Handle bootstrapMethodHandle,Object bootstrapMethodArguments);\\naddBootstrapMethod(int offset,int length,int hashCode);\\ngetType(int typeIndex);\\naddType(String value);\\naddUninitializedType(String value,int bytecodeOffset);\\naddMergedType(int typeTableIndex1,int typeTableIndex2);\\naddTypeInternal(Entry entry);\\nhash(int tag,int value);\\nhash(int tag,long value);\\nhash(int tag,String value);\\nhash(int tag,String value1,int value2);\\nhash(int tag,String value1,String value2);\\nhash(int tag,String value1,String value2,int value3);\\nhash(int tag,String value1,String value2,String value3);\\nhash(int tag,String value1,String value2,String value3,int value4);\\nEntry(int index,int tag,String owner,String name,String value,long data,int hashCode);\\nEntry(int index,int tag,String value,int hashCode);\\nEntry(int index,int tag,String value,long data,int hashCode);\\nEntry(int index,int tag,String name,String value,int hashCode);\\nEntry(int index,int tag,long data,int hashCode);\\ncopyBootstrapMethods(ClassReader classReader,char[] charBuffer);\\n\", \"repo_level\" : \"\" }",
            "class_name": "SymbolTable",
            "code": "int addType(final String value){\n  int hashCode=hash(Symbol.TYPE_TAG,value);\n  Entry entry=get(hashCode);\n  while (entry != null) {\n    if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {\n      return entry.index;\n    }\n    entry=entry.next;\n  }\n  return addTypeInternal(new Entry(typeCount,Symbol.TYPE_TAG,value,hashCode));\n}\n",
            "docstring": "/** \n * Adds a type in the type table of this symbol table. Does nothing if the type table already contains a similar type.\n * @param value an internal class name.\n * @return the index of a new or already existing type Symbol with the given value.\n */\n",
            "end_lineno": "1019",
            "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage net.hasor.utils.asm;\n/**\n * The constant pool entries, the BootstrapMethods attribute entries and the (ASM specific) type\n * table entries of a class.\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4\">JVMS 4.4</a>\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23\">JVMS 4.7.23</a>\n * @author Eric Bruneton\n */\nfinal class SymbolTable {\n    /**\n     * The ClassWriter to which this SymbolTable belongs. This is only used to get access to {@link\n     * ClassWriter#getCommonSuperClass} and to serialize custom attributes with {@link\n     * Attribute#write}.\n     */\n    final         ClassWriter classWriter;\n    /**\n     * The ClassReader from which this SymbolTable was constructed, or {@literal null} if it was\n     * constructed from scratch.\n     */\n    private final ClassReader sourceClassReader;\n    /** The major version number of the class to which this symbol table belongs. */\n    private       int         majorVersion;\n    /** The internal name of the class to which this symbol table belongs. */\n    private       String      className;\n    /**\n     * The total number of {@link Entry} instances in {@link #entries}. This includes entries that are\n     * accessible (recursively) via {@link Entry#next}.\n     */\n    private       int         entryCount;\n    /**\n     * A hash set of all the entries in this SymbolTable (this includes the constant pool entries, the\n     * bootstrap method entries and the type table entries). Each {@link Entry} instance is stored at\n     * the array index given by its hash code modulo the array size. If several entries must be stored\n     * at the same array index, they are linked together via their {@link Entry#next} field. The\n     * factory methods of this class make sure that this table does not contain duplicated entries.\n     */\n    private       Entry[]     entries;\n    /**\n     * The number of constant pool items in {@link #constantPool}, plus 1. The first constant pool\n     * item has index 1, and long and double items count for two items.\n     */\n    private       int         constantPoolCount;\n    /**\n     * The content of the ClassFile's constant_pool JVMS structure corresponding to this SymbolTable.\n     * The ClassFile's constant_pool_count field is <i>not</i> included.\n     */\n    private       ByteVector  constantPool;\n    /**\n     * The number of bootstrap methods in {@link #bootstrapMethods}. Corresponds to the\n     * BootstrapMethods_attribute's num_bootstrap_methods field value.\n     */\n    private       int         bootstrapMethodCount;\n    /**\n     * The content of the BootstrapMethods attribute 'bootstrap_methods' array corresponding to this\n     * SymbolTable. Note that the first 6 bytes of the BootstrapMethods_attribute, and its\n     * num_bootstrap_methods field, are <i>not</i> included.\n     */\n    private       ByteVector  bootstrapMethods;\n    /**\n     * The actual number of elements in {@link #typeTable}. These elements are stored from index 0 to\n     * typeCount (excluded). The other array entries are empty.\n     */\n    private       int         typeCount;\n    /**\n     * An ASM specific type table used to temporarily store internal names that will not necessarily\n     * be stored in the constant pool. This type table is used by the control flow and data flow\n     * analysis algorithm used to compute stack map frames from scratch. This array stores {@link\n     * Symbol#TYPE_TAG} and {@link Symbol#UNINITIALIZED_TYPE_TAG}) Symbol. The type symbol at index\n     * {@code i} has its {@link Symbol#index} equal to {@code i} (and vice versa).\n     */\n    private       Entry[]     typeTable;\n\n    /**\n     * Constructs a new, empty SymbolTable for the given ClassWriter.\n     *\n     * @param classWriter a ClassWriter.\n     */\n    SymbolTable(final ClassWriter classWriter) {\n        this.classWriter = classWriter;\n        this.sourceClassReader = null;\n        this.entries = new Entry[256];\n        this.constantPoolCount = 1;\n        this.constantPool = new ByteVector();\n    }\n\n    /**\n     * Constructs a new SymbolTable for the given ClassWriter, initialized with the constant pool and\n     * bootstrap methods of the given ClassReader.\n     *\n     * @param classWriter a ClassWriter.\n     * @param classReader the ClassReader whose constant pool and bootstrap methods must be copied to\n     *     initialize the SymbolTable.\n     */\n    SymbolTable(final ClassWriter classWriter, final ClassReader classReader) {\n        this.classWriter = classWriter;\n        this.sourceClassReader = classReader;\n        // Copy the constant pool binary content.\n        byte[] inputBytes = classReader.classFileBuffer;\n        int constantPoolOffset = classReader.getItem(1) - 1;\n        int constantPoolLength = classReader.header - constantPoolOffset;\n        constantPoolCount = classReader.getItemCount();\n        constantPool = new ByteVector(constantPoolLength);\n        constantPool.putByteArray(inputBytes, constantPoolOffset, constantPoolLength);\n        // Add the constant pool items in the symbol table entries. Reserve enough space in 'entries' to\n        // avoid too many hash set collisions (entries is not dynamically resized by the addConstant*\n        // method calls below), and to account for bootstrap method entries.\n        entries = new Entry[constantPoolCount * 2];\n        char[] charBuffer = new char[classReader.getMaxStringLength()];\n        boolean hasBootstrapMethods = false;\n        int itemIndex = 1;\n        while (itemIndex < constantPoolCount) {\n            int itemOffset = classReader.getItem(itemIndex);\n            int itemTag = inputBytes[itemOffset - 1];\n            int nameAndTypeItemOffset;\n            switch (itemTag) {\n            case Symbol.CONSTANT_FIELDREF_TAG:\n            case Symbol.CONSTANT_METHODREF_TAG:\n            case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n                nameAndTypeItemOffset = classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));\n                addConstantMemberReference(itemIndex, itemTag, classReader.readClass(itemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer));\n                break;\n            case Symbol.CONSTANT_INTEGER_TAG:\n            case Symbol.CONSTANT_FLOAT_TAG:\n                addConstantIntegerOrFloat(itemIndex, itemTag, classReader.readInt(itemOffset));\n                break;\n            case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n                addConstantNameAndType(itemIndex, classReader.readUTF8(itemOffset, charBuffer), classReader.readUTF8(itemOffset + 2, charBuffer));\n                break;\n            case Symbol.CONSTANT_LONG_TAG:\n            case Symbol.CONSTANT_DOUBLE_TAG:\n                addConstantLongOrDouble(itemIndex, itemTag, classReader.readLong(itemOffset));\n                break;\n            case Symbol.CONSTANT_UTF8_TAG:\n                addConstantUtf8(itemIndex, classReader.readUtf(itemIndex, charBuffer));\n                break;\n            case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n                int memberRefItemOffset = classReader.getItem(classReader.readUnsignedShort(itemOffset + 1));\n                nameAndTypeItemOffset = classReader.getItem(classReader.readUnsignedShort(memberRefItemOffset + 2));\n                addConstantMethodHandle(itemIndex, classReader.readByte(itemOffset), classReader.readClass(memberRefItemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer));\n                break;\n            case Symbol.CONSTANT_DYNAMIC_TAG:\n            case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n                hasBootstrapMethods = true;\n                nameAndTypeItemOffset = classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));\n                addConstantDynamicOrInvokeDynamicReference(itemTag, itemIndex, classReader.readUTF8(nameAndTypeItemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer), classReader.readUnsignedShort(itemOffset));\n                break;\n            case Symbol.CONSTANT_STRING_TAG:\n            case Symbol.CONSTANT_CLASS_TAG:\n            case Symbol.CONSTANT_METHOD_TYPE_TAG:\n            case Symbol.CONSTANT_MODULE_TAG:\n            case Symbol.CONSTANT_PACKAGE_TAG:\n                addConstantUtf8Reference(itemIndex, itemTag, classReader.readUTF8(itemOffset, charBuffer));\n                break;\n            default:\n                throw new IllegalArgumentException();\n            }\n            itemIndex += (itemTag == Symbol.CONSTANT_LONG_TAG || itemTag == Symbol.CONSTANT_DOUBLE_TAG) ? 2 : 1;\n        }\n        // Copy the BootstrapMethods, if any.\n        if (hasBootstrapMethods) {\n            copyBootstrapMethods(classReader, charBuffer);\n        }\n    }\n\n    /**\n     * Read the BootstrapMethods 'bootstrap_methods' array binary content and add them as entries of\n     * the SymbolTable.\n     *\n     * @param classReader the ClassReader whose bootstrap methods must be copied to initialize the\n     *     SymbolTable.\n     * @param charBuffer a buffer used to read strings in the constant pool.\n     */\n    private void copyBootstrapMethods(final ClassReader classReader, final char[] charBuffer) {\n        // Find attributOffset of the 'bootstrap_methods' array.\n        byte[] inputBytes = classReader.classFileBuffer;\n        int currentAttributeOffset = classReader.getFirstAttributeOffset();\n        for (int i = classReader.readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n            String attributeName = classReader.readUTF8(currentAttributeOffset, charBuffer);\n            if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n                bootstrapMethodCount = classReader.readUnsignedShort(currentAttributeOffset + 6);\n                break;\n            }\n            currentAttributeOffset += 6 + classReader.readInt(currentAttributeOffset + 2);\n        }\n        if (bootstrapMethodCount > 0) {\n            // Compute the offset and the length of the BootstrapMethods 'bootstrap_methods' array.\n            int bootstrapMethodsOffset = currentAttributeOffset + 8;\n            int bootstrapMethodsLength = classReader.readInt(currentAttributeOffset + 2) - 2;\n            bootstrapMethods = new ByteVector(bootstrapMethodsLength);\n            bootstrapMethods.putByteArray(inputBytes, bootstrapMethodsOffset, bootstrapMethodsLength);\n            // Add each bootstrap method in the symbol table entries.\n            int currentOffset = bootstrapMethodsOffset;\n            for (int i = 0; i < bootstrapMethodCount; i++) {\n                int offset = currentOffset - bootstrapMethodsOffset;\n                int bootstrapMethodRef = classReader.readUnsignedShort(currentOffset);\n                currentOffset += 2;\n                int numBootstrapArguments = classReader.readUnsignedShort(currentOffset);\n                currentOffset += 2;\n                int hashCode = classReader.readConst(bootstrapMethodRef, charBuffer).hashCode();\n                while (numBootstrapArguments-- > 0) {\n                    int bootstrapArgument = classReader.readUnsignedShort(currentOffset);\n                    currentOffset += 2;\n                    hashCode ^= classReader.readConst(bootstrapArgument, charBuffer).hashCode();\n                }\n                add(new Entry(i, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode & 0x7FFFFFFF));\n            }\n        }\n    }\n\n    /**\n     * Returns the ClassReader from which this SymbolTable was constructed.\n     *\n     * @return the ClassReader from which this SymbolTable was constructed, or {@literal null} if it\n     *     was constructed from scratch.\n     */\n    ClassReader getSource() {\n        return sourceClassReader;\n    }\n\n    /**\n     * Returns the major version of the class to which this symbol table belongs.\n     *\n     * @return the major version of the class to which this symbol table belongs.\n     */\n    int getMajorVersion() {\n        return majorVersion;\n    }\n\n    /**\n     * Returns the internal name of the class to which this symbol table belongs.\n     *\n     * @return the internal name of the class to which this symbol table belongs.\n     */\n    String getClassName() {\n        return className;\n    }\n\n    /**\n     * Sets the major version and the name of the class to which this symbol table belongs. Also adds\n     * the class name to the constant pool.\n     *\n     * @param majorVersion a major ClassFile version number.\n     * @param className an internal class name.\n     * @return the constant pool index of a new or already existing Symbol with the given class name.\n     */\n    int setMajorVersionAndClassName(final int majorVersion, final String className) {\n        this.majorVersion = majorVersion;\n        this.className = className;\n        return addConstantClass(className).index;\n    }\n\n    /**\n     * Returns the number of items in this symbol table's constant_pool array (plus 1).\n     *\n     * @return the number of items in this symbol table's constant_pool array (plus 1).\n     */\n    int getConstantPoolCount() {\n        return constantPoolCount;\n    }\n\n    /**\n     * Returns the length in bytes of this symbol table's constant_pool array.\n     *\n     * @return the length in bytes of this symbol table's constant_pool array.\n     */\n    int getConstantPoolLength() {\n        return constantPool.length;\n    }\n\n    /**\n     * Puts this symbol table's constant_pool array in the given ByteVector, preceded by the\n     * constant_pool_count value.\n     *\n     * @param output where the JVMS ClassFile's constant_pool array must be put.\n     */\n    void putConstantPool(final ByteVector output) {\n        output.putShort(constantPoolCount).putByteArray(constantPool.data, 0, constantPool.length);\n    }\n\n    /**\n     * Returns the size in bytes of this symbol table's BootstrapMethods attribute. Also adds the\n     * attribute name in the constant pool.\n     *\n     * @return the size in bytes of this symbol table's BootstrapMethods attribute.\n     */\n    int computeBootstrapMethodsSize() {\n        if (bootstrapMethods != null) {\n            addConstantUtf8(Constants.BOOTSTRAP_METHODS);\n            return 8 + bootstrapMethods.length;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * Puts this symbol table's BootstrapMethods attribute in the given ByteVector. This includes the\n     * 6 attribute header bytes and the num_bootstrap_methods value.\n     *\n     * @param output where the JVMS BootstrapMethods attribute must be put.\n     */\n    void putBootstrapMethods(final ByteVector output) {\n        if (bootstrapMethods != null) {\n            output.putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS)).putInt(bootstrapMethods.length + 2).putShort(bootstrapMethodCount).putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length);\n        }\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Generic symbol table entries management.\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the list of entries which can potentially have the given hash code.\n     *\n     * @param hashCode a {@link Entry#hashCode} value.\n     * @return the list of entries which can potentially have the given hash code. The list is stored\n     *     via the {@link Entry#next} field.\n     */\n    private Entry get(final int hashCode) {\n        return entries[hashCode % entries.length];\n    }\n\n    /**\n     * Puts the given entry in the {@link #entries} hash set. This method does <i>not</i> check\n     * whether {@link #entries} already contains a similar entry or not. {@link #entries} is resized\n     * if necessary to avoid hash collisions (multiple entries needing to be stored at the same {@link\n     * #entries} array index) as much as possible, with reasonable memory usage.\n     *\n     * @param entry an Entry (which must not already be contained in {@link #entries}).\n     * @return the given entry\n     */\n    private Entry put(final Entry entry) {\n        if (entryCount > (entries.length * 3) / 4) {\n            int currentCapacity = entries.length;\n            int newCapacity = currentCapacity * 2 + 1;\n            Entry[] newEntries = new Entry[newCapacity];\n            for (int i = currentCapacity - 1; i >= 0; --i) {\n                Entry currentEntry = entries[i];\n                while (currentEntry != null) {\n                    int newCurrentEntryIndex = currentEntry.hashCode % newCapacity;\n                    Entry nextEntry = currentEntry.next;\n                    currentEntry.next = newEntries[newCurrentEntryIndex];\n                    newEntries[newCurrentEntryIndex] = currentEntry;\n                    currentEntry = nextEntry;\n                }\n            }\n            entries = newEntries;\n        }\n        entryCount++;\n        int index = entry.hashCode % entries.length;\n        entry.next = entries[index];\n        return entries[index] = entry;\n    }\n\n    /**\n     * Adds the given entry in the {@link #entries} hash set. This method does <i>not</i> check\n     * whether {@link #entries} already contains a similar entry or not, and does <i>not</i> resize\n     * {@link #entries} if necessary.\n     *\n     * @param entry an Entry (which must not already be contained in {@link #entries}).\n     */\n    private void add(final Entry entry) {\n        entryCount++;\n        int index = entry.hashCode % entries.length;\n        entry.next = entries[index];\n        entries[index] = entry;\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Constant pool entries management.\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Adds a number or string constant to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value the value of the constant to be added to the constant pool. This parameter must be\n     *     an {@link Integer}, {@link Byte}, {@link Character}, {@link Short}, {@link Boolean}, {@link\n     *     Float}, {@link Long}, {@link Double}, {@link String}, {@link Type} or {@link Handle}.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstant(final Object value) {\n        if (value instanceof Integer) {\n            return addConstantInteger(((Integer) value).intValue());\n        } else if (value instanceof Byte) {\n            return addConstantInteger(((Byte) value).intValue());\n        } else if (value instanceof Character) {\n            return addConstantInteger(((Character) value).charValue());\n        } else if (value instanceof Short) {\n            return addConstantInteger(((Short) value).intValue());\n        } else if (value instanceof Boolean) {\n            return addConstantInteger(((Boolean) value).booleanValue() ? 1 : 0);\n        } else if (value instanceof Float) {\n            return addConstantFloat(((Float) value).floatValue());\n        } else if (value instanceof Long) {\n            return addConstantLong(((Long) value).longValue());\n        } else if (value instanceof Double) {\n            return addConstantDouble(((Double) value).doubleValue());\n        } else if (value instanceof String) {\n            return addConstantString((String) value);\n        } else if (value instanceof Type) {\n            Type type = (Type) value;\n            int typeSort = type.getSort();\n            if (typeSort == Type.OBJECT) {\n                return addConstantClass(type.getInternalName());\n            } else if (typeSort == Type.METHOD) {\n                return addConstantMethodType(type.getDescriptor());\n            } else { // type is a primitive or array type.\n                return addConstantClass(type.getDescriptor());\n            }\n        } else if (value instanceof Handle) {\n            Handle handle = (Handle) value;\n            return addConstantMethodHandle(handle.getTag(), handle.getOwner(), handle.getName(), handle.getDesc(), handle.isInterface());\n        } else if (value instanceof ConstantDynamic) {\n            ConstantDynamic constantDynamic = (ConstantDynamic) value;\n            return addConstantDynamic(constantDynamic.getName(), constantDynamic.getDescriptor(), constantDynamic.getBootstrapMethod(), constantDynamic.getBootstrapMethodArgumentsUnsafe());\n        } else {\n            throw new IllegalArgumentException(\"value \" + value);\n        }\n    }\n\n    /**\n     * Adds a CONSTANT_Class_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value the internal name of a class.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantClass(final String value) {\n        return addConstantUtf8Reference(Symbol.CONSTANT_CLASS_TAG, value);\n    }\n\n    /**\n     * Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param owner the internal name of a class.\n     * @param name a field name.\n     * @param descriptor a field descriptor.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantFieldref(final String owner, final String name, final String descriptor) {\n        return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor);\n    }\n\n    /**\n     * Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this\n     * symbol table. Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of a class.\n     * @param name a method name.\n     * @param descriptor a method descriptor.\n     * @param isInterface whether owner is an interface or not.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantMethodref(final String owner, final String name, final String descriptor, final boolean isInterface) {\n        int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG;\n        return addConstantMemberReference(tag, owner, name, descriptor);\n    }\n\n    /**\n     * Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to\n     * the constant pool of this symbol table. Does nothing if the constant pool already contains a\n     * similar item.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\n     *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n     * @param owner the internal name of a class.\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     * @return a new or already existing Symbol with the given value.\n     */\n    private Entry addConstantMemberReference(final int tag, final String owner, final String name, final String descriptor) {\n        int hashCode = hash(tag, owner, name, descriptor);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        constantPool.put122(tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor));\n        return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, 0, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info\n     * to the constant pool of this symbol table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\n     *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n     * @param owner the internal name of a class.\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     */\n    private void addConstantMemberReference(final int index, final int tag, final String owner, final String name, final String descriptor) {\n        add(new Entry(index, tag, owner, name, descriptor, 0, hash(tag, owner, name, descriptor)));\n    }\n\n    /**\n     * Adds a CONSTANT_String_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value a string.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantString(final String value) {\n        return addConstantUtf8Reference(Symbol.CONSTANT_STRING_TAG, value);\n    }\n\n    /**\n     * Adds a CONSTANT_Integer_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value an int.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantInteger(final int value) {\n        return addConstantIntegerOrFloat(Symbol.CONSTANT_INTEGER_TAG, value);\n    }\n\n    /**\n     * Adds a CONSTANT_Float_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value a float.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantFloat(final float value) {\n        return addConstantIntegerOrFloat(Symbol.CONSTANT_FLOAT_TAG, Float.floatToRawIntBits(value));\n    }\n\n    /**\n     * Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n     * @param value an int or float.\n     * @return a constant pool constant with the given tag and primitive values.\n     */\n    private Symbol addConstantIntegerOrFloat(final int tag, final int value) {\n        int hashCode = hash(tag, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        constantPool.putByte(tag).putInt(value);\n        return put(new Entry(constantPoolCount++, tag, value, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\n     * table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n     * @param value an int or float.\n     */\n    private void addConstantIntegerOrFloat(final int index, final int tag, final int value) {\n        add(new Entry(index, tag, value, hash(tag, value)));\n    }\n\n    /**\n     * Adds a CONSTANT_Long_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value a long.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantLong(final long value) {\n        return addConstantLongOrDouble(Symbol.CONSTANT_LONG_TAG, value);\n    }\n\n    /**\n     * Adds a CONSTANT_Double_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value a double.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantDouble(final double value) {\n        return addConstantLongOrDouble(Symbol.CONSTANT_DOUBLE_TAG, Double.doubleToRawLongBits(value));\n    }\n\n    /**\n     * Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n     * @param value a long or double.\n     * @return a constant pool constant with the given tag and primitive values.\n     */\n    private Symbol addConstantLongOrDouble(final int tag, final long value) {\n        int hashCode = hash(tag, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        int index = constantPoolCount;\n        constantPool.putByte(tag).putLong(value);\n        constantPoolCount += 2;\n        return put(new Entry(index, tag, value, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol\n     * table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n     * @param value a long or double.\n     */\n    private void addConstantLongOrDouble(final int index, final int tag, final long value) {\n        add(new Entry(index, tag, value, hash(tag, value)));\n    }\n\n    /**\n     * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     * @return a new or already existing Symbol with the given value.\n     */\n    int addConstantNameAndType(final String name, final String descriptor) {\n        final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;\n        int hashCode = hash(tag, name, descriptor);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.name.equals(name) && entry.value.equals(descriptor)) {\n                return entry.index;\n            }\n            entry = entry.next;\n        }\n        constantPool.put122(tag, addConstantUtf8(name), addConstantUtf8(descriptor));\n        return put(new Entry(constantPoolCount++, tag, name, descriptor, hashCode)).index;\n    }\n\n    /**\n     * Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     */\n    private void addConstantNameAndType(final int index, final String name, final String descriptor) {\n        final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;\n        add(new Entry(index, tag, name, descriptor, hash(tag, name, descriptor)));\n    }\n\n    /**\n     * Adds a CONSTANT_Utf8_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value a string.\n     * @return a new or already existing Symbol with the given value.\n     */\n    int addConstantUtf8(final String value) {\n        int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == Symbol.CONSTANT_UTF8_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {\n                return entry.index;\n            }\n            entry = entry.next;\n        }\n        constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value);\n        return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index;\n    }\n\n    /**\n     * Adds a new CONSTANT_String_info to the constant pool of this symbol table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param value a string.\n     */\n    private void addConstantUtf8(final int index, final String value) {\n        add(new Entry(index, Symbol.CONSTANT_UTF8_TAG, value, hash(Symbol.CONSTANT_UTF8_TAG, value)));\n    }\n\n    /**\n     * Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table. Does nothing if\n     * the constant pool already contains a similar item.\n     *\n     * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\n     *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\n     *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\n     *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n     * @param owner the internal name of a class of interface.\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     * @param isInterface whether owner is an interface or not.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantMethodHandle(final int referenceKind, final String owner, final String name, final String descriptor, final boolean isInterface) {\n        final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;\n        // Note that we don't need to include isInterface in the hash computation, because it is\n        // redundant with owner (we can't have the same owner with different isInterface values).\n        int hashCode = hash(tag, owner, name, descriptor, referenceKind);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.data == referenceKind && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        if (referenceKind <= Opcodes.H_PUTSTATIC) {\n            constantPool.put112(tag, referenceKind, addConstantFieldref(owner, name, descriptor).index);\n        } else {\n            constantPool.put112(tag, referenceKind, addConstantMethodref(owner, name, descriptor, isInterface).index);\n        }\n        return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, referenceKind, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\n     *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\n     *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\n     *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n     * @param owner the internal name of a class of interface.\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     */\n    private void addConstantMethodHandle(final int index, final int referenceKind, final String owner, final String name, final String descriptor) {\n        final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;\n        int hashCode = hash(tag, owner, name, descriptor, referenceKind);\n        add(new Entry(index, tag, owner, name, descriptor, referenceKind, hashCode));\n    }\n\n    /**\n     * Adds a CONSTANT_MethodType_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantMethodType(final String methodDescriptor) {\n        return addConstantUtf8Reference(Symbol.CONSTANT_METHOD_TYPE_TAG, methodDescriptor);\n    }\n\n    /**\n     * Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table. Also adds the related\n     * bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the constant\n     * pool already contains a similar item.\n     *\n     * @param name a method name.\n     * @param descriptor a field descriptor.\n     * @param bootstrapMethodHandle a bootstrap method handle.\n     * @param bootstrapMethodArguments the bootstrap method arguments.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantDynamic(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\n        Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);\n        return addConstantDynamicOrInvokeDynamicReference(Symbol.CONSTANT_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);\n    }\n\n    /**\n     * Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table. Also adds the\n     * related bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param name a method name.\n     * @param descriptor a method descriptor.\n     * @param bootstrapMethodHandle a bootstrap method handle.\n     * @param bootstrapMethodArguments the bootstrap method arguments.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantInvokeDynamic(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\n        Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);\n        return addConstantDynamicOrInvokeDynamicReference(Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);\n    }\n\n    /**\n     * Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol\n     * table. Does nothing if the constant pool already contains a similar item.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\n     *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n     * @param name a method name.\n     * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG) or a method descriptor for\n     *     CONSTANT_INVOKE_DYNAMIC_TAG.\n     * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\n     * @return a new or already existing Symbol with the given value.\n     */\n    private Symbol addConstantDynamicOrInvokeDynamicReference(final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) {\n        int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.data == bootstrapMethodIndex && entry.name.equals(name) && entry.value.equals(descriptor)) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        constantPool.put122(tag, bootstrapMethodIndex, addConstantNameAndType(name, descriptor));\n        return put(new Entry(constantPoolCount++, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this\n     * symbol table.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\n     *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n     * @param index the constant pool index of the new Symbol.\n     * @param name a method name.\n     * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG or a method descriptor for\n     *     CONSTANT_INVOKE_DYNAMIC_TAG.\n     * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\n     */\n    private void addConstantDynamicOrInvokeDynamicReference(final int tag, final int index, final String name, final String descriptor, final int bootstrapMethodIndex) {\n        int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);\n        add(new Entry(index, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));\n    }\n\n    /**\n     * Adds a CONSTANT_Module_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param moduleName a fully qualified name (using dots) of a module.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantModule(final String moduleName) {\n        return addConstantUtf8Reference(Symbol.CONSTANT_MODULE_TAG, moduleName);\n    }\n\n    /**\n     * Adds a CONSTANT_Package_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param packageName the internal name of a package.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantPackage(final String packageName) {\n        return addConstantUtf8Reference(Symbol.CONSTANT_PACKAGE_TAG, packageName);\n    }\n\n    /**\n     * Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\n     * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\n     *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\n     *     Symbol#CONSTANT_PACKAGE_TAG}.\n     * @param value an internal class name, an arbitrary string, a method descriptor, a module or a\n     *     package name, depending on tag.\n     * @return a new or already existing Symbol with the given value.\n     */\n    private Symbol addConstantUtf8Reference(final int tag, final String value) {\n        int hashCode = hash(tag, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.value.equals(value)) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        constantPool.put12(tag, addConstantUtf8(value));\n        return put(new Entry(constantPoolCount++, tag, value, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\n     * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\n     *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\n     *     Symbol#CONSTANT_PACKAGE_TAG}.\n     * @param value an internal class name, an arbitrary string, a method descriptor, a module or a\n     *     package name, depending on tag.\n     */\n    private void addConstantUtf8Reference(final int index, final int tag, final String value) {\n        add(new Entry(index, tag, value, hash(tag, value)));\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Bootstrap method entries management.\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\n     * the BootstrapMethods already contains a similar bootstrap method.\n     *\n     * @param bootstrapMethodHandle a bootstrap method handle.\n     * @param bootstrapMethodArguments the bootstrap method arguments.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addBootstrapMethod(final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\n        ByteVector bootstrapMethodsAttribute = bootstrapMethods;\n        if (bootstrapMethodsAttribute == null) {\n            bootstrapMethodsAttribute = bootstrapMethods = new ByteVector();\n        }\n        // The bootstrap method arguments can be Constant_Dynamic values, which reference other\n        // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool\n        // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified\n        // while adding the given bootstrap method to it, in the rest of this method.\n        for (Object bootstrapMethodArgument : bootstrapMethodArguments) {\n            addConstant(bootstrapMethodArgument);\n        }\n        // Write the bootstrap method in the BootstrapMethods table. This is necessary to be able to\n        // compare it with existing ones, and will be reverted below if there is already a similar\n        // bootstrap method.\n        int bootstrapMethodOffset = bootstrapMethodsAttribute.length;\n        bootstrapMethodsAttribute.putShort(addConstantMethodHandle(bootstrapMethodHandle.getTag(), bootstrapMethodHandle.getOwner(), bootstrapMethodHandle.getName(), bootstrapMethodHandle.getDesc(), bootstrapMethodHandle.isInterface()).index);\n        int numBootstrapArguments = bootstrapMethodArguments.length;\n        bootstrapMethodsAttribute.putShort(numBootstrapArguments);\n        for (Object bootstrapMethodArgument : bootstrapMethodArguments) {\n            bootstrapMethodsAttribute.putShort(addConstant(bootstrapMethodArgument).index);\n        }\n        // Compute the length and the hash code of the bootstrap method.\n        int bootstrapMethodlength = bootstrapMethodsAttribute.length - bootstrapMethodOffset;\n        int hashCode = bootstrapMethodHandle.hashCode();\n        for (Object bootstrapMethodArgument : bootstrapMethodArguments) {\n            hashCode ^= bootstrapMethodArgument.hashCode();\n        }\n        hashCode &= 0x7FFFFFFF;\n        // Add the bootstrap method to the symbol table or revert the above changes.\n        return addBootstrapMethod(bootstrapMethodOffset, bootstrapMethodlength, hashCode);\n    }\n\n    /**\n     * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\n     * the BootstrapMethods already contains a similar bootstrap method (more precisely, reverts the\n     * content of {@link #bootstrapMethods} to remove the last, duplicate bootstrap method).\n     *\n     * @param offset the offset of the last bootstrap method in {@link #bootstrapMethods}, in bytes.\n     * @param length the length of this bootstrap method in {@link #bootstrapMethods}, in bytes.\n     * @param hashCode the hash code of this bootstrap method.\n     * @return a new or already existing Symbol with the given value.\n     */\n    private Symbol addBootstrapMethod(final int offset, final int length, final int hashCode) {\n        final byte[] bootstrapMethodsData = bootstrapMethods.data;\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == Symbol.BOOTSTRAP_METHOD_TAG && entry.hashCode == hashCode) {\n                int otherOffset = (int) entry.data;\n                boolean isSameBootstrapMethod = true;\n                for (int i = 0; i < length; ++i) {\n                    if (bootstrapMethodsData[offset + i] != bootstrapMethodsData[otherOffset + i]) {\n                        isSameBootstrapMethod = false;\n                        break;\n                    }\n                }\n                if (isSameBootstrapMethod) {\n                    bootstrapMethods.length = offset; // Revert to old position.\n                    return entry;\n                }\n            }\n            entry = entry.next;\n        }\n        return put(new Entry(bootstrapMethodCount++, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode));\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Type table entries management.\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the type table element whose index is given.\n     *\n     * @param typeIndex a type table index.\n     * @return the type table element whose index is given.\n     */\n    Symbol getType(final int typeIndex) {\n        return typeTable[typeIndex];\n    }\n\n    /**\n     * Adds a type in the type table of this symbol table. Does nothing if the type table already\n     * contains a similar type.\n     *\n     * @param value an internal class name.\n     * @return the index of a new or already existing type Symbol with the given value.\n     */\n    int addType(final String value) {\n        int hashCode = hash(Symbol.TYPE_TAG, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {\n                return entry.index;\n            }\n            entry = entry.next;\n        }\n        return addTypeInternal(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode));\n    }\n\n    /**\n     * Adds an {@link Frame#ITEM_UNINITIALIZED} type in the type table of this symbol table. Does\n     * nothing if the type table already contains a similar type.\n     *\n     * @param value an internal class name.\n     * @param bytecodeOffset the bytecode offset of the NEW instruction that created this {@link\n     *     Frame#ITEM_UNINITIALIZED} type value.\n     * @return the index of a new or already existing type Symbol with the given value.\n     */\n    int addUninitializedType(final String value, final int bytecodeOffset) {\n        int hashCode = hash(Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == Symbol.UNINITIALIZED_TYPE_TAG && entry.hashCode == hashCode && entry.data == bytecodeOffset && entry.value.equals(value)) {\n                return entry.index;\n            }\n            entry = entry.next;\n        }\n        return addTypeInternal(new Entry(typeCount, Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset, hashCode));\n    }\n\n    /**\n     * Adds a merged type in the type table of this symbol table. Does nothing if the type table\n     * already contains a similar type.\n     *\n     * @param typeTableIndex1 a {@link Symbol#TYPE_TAG} type, specified by its index in the type\n     *     table.\n     * @param typeTableIndex2 another {@link Symbol#TYPE_TAG} type, specified by its index in the type\n     *     table.\n     * @return the index of a new or already existing {@link Symbol#TYPE_TAG} type Symbol,\n     *     corresponding to the common super class of the given types.\n     */\n    int addMergedType(final int typeTableIndex1, final int typeTableIndex2) {\n        long data = typeTableIndex1 < typeTableIndex2 ? typeTableIndex1 | (((long) typeTableIndex2) << 32) : typeTableIndex2 | (((long) typeTableIndex1) << 32);\n        int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == Symbol.MERGED_TYPE_TAG && entry.hashCode == hashCode && entry.data == data) {\n                return entry.info;\n            }\n            entry = entry.next;\n        }\n        String type1 = typeTable[typeTableIndex1].value;\n        String type2 = typeTable[typeTableIndex2].value;\n        int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2));\n        put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG, data, hashCode)).info = commonSuperTypeIndex;\n        return commonSuperTypeIndex;\n    }\n\n    /**\n     * Adds the given type Symbol to {@link #typeTable}.\n     *\n     * @param entry a {@link Symbol#TYPE_TAG} or {@link Symbol#UNINITIALIZED_TYPE_TAG} type symbol.\n     *     The index of this Symbol must be equal to the current value of {@link #typeCount}.\n     * @return the index in {@link #typeTable} where the given type was added, which is also equal to\n     *     entry's index by hypothesis.\n     */\n    private int addTypeInternal(final Entry entry) {\n        if (typeTable == null) {\n            typeTable = new Entry[16];\n        }\n        if (typeCount == typeTable.length) {\n            Entry[] newTypeTable = new Entry[2 * typeTable.length];\n            System.arraycopy(typeTable, 0, newTypeTable, 0, typeTable.length);\n            typeTable = newTypeTable;\n        }\n        typeTable[typeCount++] = entry;\n        return put(entry).index;\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Static helper methods to compute hash codes.\n    // -----------------------------------------------------------------------------------------------\n\n    private static int hash(final int tag, final int value) {\n        return 0x7FFFFFFF & (tag + value);\n    }\n\n    private static int hash(final int tag, final long value) {\n        return 0x7FFFFFFF & (tag + (int) value + (int) (value >>> 32));\n    }\n\n    private static int hash(final int tag, final String value) {\n        return 0x7FFFFFFF & (tag + value.hashCode());\n    }\n\n    private static int hash(final int tag, final String value1, final int value2) {\n        return 0x7FFFFFFF & (tag + value1.hashCode() + value2);\n    }\n\n    private static int hash(final int tag, final String value1, final String value2) {\n        return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode());\n    }\n\n    private static int hash(final int tag, final String value1, final String value2, final int value3) {\n        return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * (value3 + 1));\n    }\n\n    private static int hash(final int tag, final String value1, final String value2, final String value3) {\n        return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode());\n    }\n\n    private static int hash(final int tag, final String value1, final String value2, final String value3, final int value4) {\n        return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode() * value4);\n    }\n\n    /**\n     * An entry of a SymbolTable. This concrete and private subclass of {@link Symbol} adds two fields\n     * which are only used inside SymbolTable, to implement hash sets of symbols (in order to avoid\n     * duplicate symbols). See {@link #entries}.\n     *\n     * @author Eric Bruneton\n     */\n    private static class Entry extends Symbol {\n        /** The hash code of this entry. */\n        final int hashCode;\n        /**\n         * Another entry (and so on recursively) having the same hash code (modulo the size of {@link\n         * #entries}) as this one.\n         */\n        Entry next;\n\n        Entry(final int index, final int tag, final String owner, final String name, final String value, final long data, final int hashCode) {\n            super(index, tag, owner, name, value, data);\n            this.hashCode = hashCode;\n        }\n\n        Entry(final int index, final int tag, final String value, final int hashCode) {\n            super(index, tag, /* owner = */ null, /* name = */ null, value, /* data = */ 0);\n            this.hashCode = hashCode;\n        }\n\n        Entry(final int index, final int tag, final String value, final long data, final int hashCode) {\n            super(index, tag, /* owner = */ null, /* name = */ null, value, data);\n            this.hashCode = hashCode;\n        }\n\n        Entry(final int index, final int tag, final String name, final String value, final int hashCode) {\n            super(index, tag, /* owner = */ null, name, value, /* data = */ 0);\n            this.hashCode = hashCode;\n        }\n\n        Entry(final int index, final int tag, final long data, final int hashCode) {\n            super(index, tag, /* owner = */ null, /* name = */ null, /* value = */ null, data);\n            this.hashCode = hashCode;\n        }\n    }\n}\n",
            "file_name": "SymbolTable.java",
            "human_label": "Add a new type entry of the given value into the type table of this symbol table. Does nothing if the type table already contains a similar type. Return the index of the type entry in the symbol table.",
            "level": "project_runnable",
            "lineno": "1002",
            "name": "addType",
            "oracle_context": "{ \"apis\" : \"[hash, get, equals, addTypeInternal, Entry]\", \"classes\" : \"[Entry, Symbol]\", \"vars\" : \"[TYPE_TAG, tag, index, next, typeCount]\" }",
            "package": "net.hasor.utils.asm",
            "project": "hasor-master"
        },
        {
            "_id": "636766821a6d9265ec0174b6",
            "all_context": "{ \"class_level\" : \"import java.lang.ref.Reference;\\nimport java.lang.ref.WeakReference;\\nimport java.lang.reflect.Array;\\nimport java.lang.reflect.GenericArrayType;\\nimport java.lang.reflect.ParameterizedType;\\nimport java.lang.reflect.Type;\\nimport java.lang.reflect.TypeVariable;\\nimport java.util.Collections;\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.WeakHashMap;\\nMap<Class<?>,Reference<Map<TypeVariable<?>,Type>>> typeVariableCache;\\nboolean cacheEnabled;\\nTypeResolver();\\nUnknown();\\ndisableCache();\\nresolveArgument(Class initialType,Class targetType);\\nresolveArgument(Type genericType,Class targetType);\\nresolveArguments(Class initialType,Class targetType);\\nresolveArguments(Type genericType,Class targetType);\\nresolveGenericType(Type initialType,Class targetType);\\nresolveClass(Type genericType,Class targetType);\\ngetTypeVariableMap(Class targetType);\\nbuildTypeVariableMap(Type[] types,Map map);\\nbuildTypeVariableMap(ParameterizedType type,Map typeVariableMap);\\nresolveBound(TypeVariable typeVariable);\\nenableCache();\\n\", \"repo_level\" : \"\" }",
            "class_name": "TypeResolver",
            "code": "public static Class<?>[] resolveArguments(Type genericType,Class<?> targetType){\n  Class<?>[] result=null;\n  if (genericType instanceof ParameterizedType) {\n    ParameterizedType paramType=(ParameterizedType)genericType;\n    Type[] arguments=paramType.getActualTypeArguments();\n    result=new Class[arguments.length];\n    for (int i=0; i < arguments.length; i++)     result[i]=resolveClass(arguments[i],targetType);\n  }\n else   if (genericType instanceof TypeVariable) {\n    result=new Class[1];\n    result[0]=resolveClass(genericType,targetType);\n  }\n  return result;\n}\n",
            "docstring": "/** \n * Resolves the arguments for the  {@code genericType} using the type variable information for the{@code targetType}. Returns  {@code null} if {@code genericType} is not parameterized or ifarguments cannot be resolved.\n */\n",
            "end_lineno": "158",
            "file_content": "/*\n * Copyright 2008-2022 Async-IO.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n/**\n * Copyright 2002-2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * This class is from https://github.com/jhalterman/typetools\n */\npackage org.atmosphere.config.managed;\n\nimport java.lang.ref.Reference;\nimport java.lang.ref.WeakReference;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.WeakHashMap;\n\n/**\n * Enhanced type resolution utilities. Based on org.springframework.core.GenericTypeResolver.\n *\n * @author Jonathan Halterman\n */\npublic final class TypeResolver {\n    private TypeResolver() {\n    }\n\n    /** An unknown type. */\n    public static final class Unknown {\n        private Unknown() {\n        }\n    }\n\n    /** Cache of type variable/argument pairs */\n    private static final Map<Class<?>, Reference<Map<TypeVariable<?>, Type>>> typeVariableCache = Collections.synchronizedMap(new WeakHashMap<>());\n    private static boolean cacheEnabled = true;\n\n    /**\n     * Enables the internal caching of TypeVariables.\n     */\n    public static void enableCache() {\n        cacheEnabled = true;\n    }\n\n    /**\n     * Disables the internal caching of TypeVariables.\n     */\n    public static void disableCache() {\n        typeVariableCache.clear();\n        cacheEnabled = false;\n    }\n\n    /**\n     * Returns the raw class representing the type argument for the {@code targetType} resolved\n     * upwards from the {@code initialType}. If no arguments can be resolved then\n     * {@code Unknown.class} is returned.\n     *\n     * @param initialType to resolve upwards from\n     * @param targetType to resolve arguments for\n     * @return type argument for {@code initialType} else {@code null} if no type arguments are\n     *         declared\n     * @throws IllegalArgumentException if more or less than one type argument is resolved for the\n     *           give types\n     */\n    public static <T, I extends T> Class<?> resolveArgument(Class<I> initialType, Class<T> targetType) {\n        return resolveArgument(resolveGenericType(initialType, targetType), initialType);\n    }\n\n    /**\n     * Resolves the type argument for the {@code genericType} using type variable information from the\n     * {@code sourceType}. If {@code genericType} is an instance of class, then {@code genericType} is\n     * returned. If no arguments can be resolved then {@code Unknown.class} is returned.\n     *\n     * @param genericType to resolve upwards from\n     * @param targetType to resolve arguments for\n     * @return type argument for {@code initialType} else {@code null} if no type arguments are\n     *         declared\n     * @throws IllegalArgumentException if more or less than one type argument is resolved for the\n     *           give types\n     */\n    public static Class<?> resolveArgument(Type genericType, Class<?> targetType) {\n        Class<?>[] arguments = resolveArguments(genericType, targetType);\n        if (arguments == null)\n            return Unknown.class;\n\n        if (arguments.length != 1)\n            throw new IllegalArgumentException(\"Expected 1 type argument on generic type \"\n                    + targetType.getName() + \" but found \" + arguments.length);\n\n        return arguments[0];\n    }\n\n    /**\n     * Returns an array of raw classes representing type arguments for the {@code targetType} resolved\n     * upwards from the {@code initialType}. Arguments for {@code targetType} that cannot be resolved\n     * to a Class are returned as {@code Unknown.class}. If no arguments can be resolved then\n     * {@code null} is returned.\n     *\n     * @param initialType to resolve upwards from\n     * @param targetType to resolve arguments for\n     * @return array of raw classes representing type arguments for {@code initialType} else\n     *         {@code null} if no type arguments are declared\n     */\n    public static <T, I extends T> Class<?>[] resolveArguments(Class<I> initialType,\n                                                               Class<T> targetType) {\n        return resolveArguments(resolveGenericType(initialType, targetType), initialType);\n    }\n\n    /**\n     * Resolves the arguments for the {@code genericType} using the type variable information for the\n     * {@code targetType}. Returns {@code null} if {@code genericType} is not parameterized or if\n     * arguments cannot be resolved.\n     */\n    public static Class<?>[] resolveArguments(Type genericType, Class<?> targetType) {\n        Class<?>[] result = null;\n\n        if (genericType instanceof ParameterizedType) {\n            ParameterizedType paramType = (ParameterizedType) genericType;\n            Type[] arguments = paramType.getActualTypeArguments();\n            result = new Class[arguments.length];\n            for (int i = 0; i < arguments.length; i++)\n                result[i] = resolveClass(arguments[i], targetType);\n        } else if (genericType instanceof TypeVariable) {\n            result = new Class[1];\n            result[0] = resolveClass(genericType, targetType);\n        }\n\n        return result;\n    }\n\n    /**\n     * Resolves the generic Type for the {@code targetType} by walking the type hierarchy upwards from\n     * the {@code initialType}.\n     */\n    public static Type resolveGenericType(Type initialType, Class<?> targetType) {\n        Class<?> rawType;\n        if (initialType instanceof ParameterizedType)\n            rawType = (Class<?>) ((ParameterizedType) initialType).getRawType();\n        else\n            rawType = (Class<?>) initialType;\n\n        if (targetType.equals(rawType))\n            return initialType;\n\n        Type result;\n        if (targetType.isInterface()) {\n            for (Type superInterface : rawType.getGenericInterfaces())\n                if (superInterface != null && !superInterface.equals(Object.class))\n                    if ((result = resolveGenericType(superInterface, targetType)) != null)\n                        return result;\n        }\n\n        Type superType = rawType.getGenericSuperclass();\n        if (superType != null && !superType.equals(Object.class))\n            if ((result = resolveGenericType(superType, targetType)) != null)\n                return result;\n\n        return null;\n    }\n\n    /**\n     * Resolves the raw class for the given {@code genericType}, using the type variable information\n     * from the {@code targetType}.\n     */\n    public static Class<?> resolveClass(Type genericType, Class<?> targetType) {\n        if (genericType instanceof Class) {\n            return (Class<?>) genericType;\n        } else if (genericType instanceof ParameterizedType) {\n            return resolveClass(((ParameterizedType) genericType).getRawType(), targetType);\n        } else if (genericType instanceof GenericArrayType) {\n            GenericArrayType arrayType = (GenericArrayType) genericType;\n            Class<?> compoment = resolveClass(arrayType.getGenericComponentType(), targetType);\n            return Array.newInstance(compoment, 0).getClass();\n        } else if (genericType instanceof TypeVariable) {\n            TypeVariable<?> variable = (TypeVariable<?>) genericType;\n            genericType = getTypeVariableMap(targetType).get(variable);\n            genericType = genericType == null ? resolveBound(variable) : resolveClass(genericType,\n                    targetType);\n        }\n\n        return genericType instanceof Class ? (Class<?>) genericType : Unknown.class;\n    }\n\n    private static Map<TypeVariable<?>, Type> getTypeVariableMap(final Class<?> targetType) {\n        Reference<Map<TypeVariable<?>, Type>> ref = typeVariableCache.get(targetType);\n        Map<TypeVariable<?>, Type> map = ref != null ? ref.get() : null;\n\n        if (map == null) {\n            map = new HashMap<>();\n\n            // Populate interfaces\n            buildTypeVariableMap(targetType.getGenericInterfaces(), map);\n\n            // Populate super classes and interfaces\n            Type genericType = targetType.getGenericSuperclass();\n            Class<?> type = targetType.getSuperclass();\n            while (type != null && !Object.class.equals(type)) {\n                if (genericType instanceof ParameterizedType)\n                    buildTypeVariableMap((ParameterizedType) genericType, map);\n                buildTypeVariableMap(type.getGenericInterfaces(), map);\n\n                genericType = type.getGenericSuperclass();\n                type = type.getSuperclass();\n            }\n\n            // Populate enclosing classes\n            type = targetType;\n            while (type.isMemberClass()) {\n                genericType = type.getGenericSuperclass();\n                if (genericType instanceof ParameterizedType)\n                    buildTypeVariableMap((ParameterizedType) genericType, map);\n\n                type = type.getEnclosingClass();\n            }\n\n            if (cacheEnabled)\n                typeVariableCache.put(targetType, new WeakReference<>(map));\n        }\n\n        return map;\n    }\n\n    /**\n     * Populates the {@code map} with with variable/argument pairs for the given {@code types}.\n     */\n    static void buildTypeVariableMap(final Type[] types, final Map<TypeVariable<?>, Type> map) {\n        for (Type type : types) {\n            if (type instanceof ParameterizedType) {\n                ParameterizedType parameterizedType = (ParameterizedType) type;\n                buildTypeVariableMap(parameterizedType, map);\n                Type rawType = parameterizedType.getRawType();\n                if (rawType instanceof Class)\n                    buildTypeVariableMap(((Class<?>) rawType).getGenericInterfaces(), map);\n            } else if (type instanceof Class) {\n                buildTypeVariableMap(((Class<?>) type).getGenericInterfaces(), map);\n            }\n        }\n    }\n\n    /**\n     * Populates the {@code typeVariableMap} with type arguments and parameters for the given\n     * {@code type}.\n     */\n    private static void buildTypeVariableMap(ParameterizedType type,\n                                             Map<TypeVariable<?>, Type> typeVariableMap) {\n        if (type.getRawType() instanceof Class) {\n            TypeVariable<?>[] typeVariables = ((Class<?>) type.getRawType()).getTypeParameters();\n            Type[] typeArguments = type.getActualTypeArguments();\n\n            for (int i = 0; i < typeArguments.length; i++) {\n                TypeVariable<?> variable = typeVariables[i];\n                Type typeArgument = typeArguments[i];\n\n                if (typeArgument instanceof Class) {\n                    typeVariableMap.put(variable, typeArgument);\n                } else if (typeArgument instanceof GenericArrayType) {\n                    typeVariableMap.put(variable, typeArgument);\n                } else if (typeArgument instanceof ParameterizedType) {\n                    typeVariableMap.put(variable, typeArgument);\n                } else if (typeArgument instanceof TypeVariable) {\n                    TypeVariable<?> typeVariableArgument = (TypeVariable<?>) typeArgument;\n                    Type resolvedType = typeVariableMap.get(typeVariableArgument);\n                    if (resolvedType == null)\n                        resolvedType = resolveBound(typeVariableArgument);\n                    typeVariableMap.put(variable, resolvedType);\n                }\n            }\n        }\n    }\n\n    /**\n     * Resolves the first bound for the {@code typeVariable}, returning {@code Unknown.class} if none\n     * can be resolved.\n     */\n    public static Type resolveBound(TypeVariable<?> typeVariable) {\n        Type[] bounds = typeVariable.getBounds();\n        if (bounds.length == 0)\n            return Unknown.class;\n\n        Type bound = bounds[0];\n        if (bound instanceof TypeVariable)\n            bound = resolveBound((TypeVariable<?>) bound);\n\n        return bound == Object.class ? Unknown.class : bound;\n    }\n}\n",
            "file_name": "TypeResolver.java",
            "human_label": "Resolve and return the arguments for the genericType using the type variable information for the targetType. Returns null if  genericType is not parameterized or if arguments cannot be resolved.",
            "level": "class_runnable",
            "lineno": "138",
            "name": "resolveArguments",
            "oracle_context": "{ \"apis\" : \"[getActualTypeArguments, resolveClass]\", \"classes\" : \"[Class<?>[], ParameterizedType, Type[]]\", \"vars\" : \"[length]\" }",
            "package": "org.atmosphere.config.managed",
            "project": "atmosphere-atmosphere-2.7.x"
        },
        {
            "_id": "636766f81a6d9265ec01775b",
            "all_context": "{ \"class_level\" : \"import java.io.ByteArrayOutputStream;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nint SKIP_CODE;\\nint SKIP_DEBUG;\\nint SKIP_FRAMES;\\nint EXPAND_FRAMES;\\nint EXPAND_ASM_INSNS;\\nint INPUT_STREAM_DATA_CHUNK_SIZE;\\nbyte[] b;\\nbyte[] classFileBuffer;\\nint[] cpInfoOffsets;\\nString[] constantUtf8Values;\\nConstantDynamic[] constantDynamicValues;\\nint[] bootstrapMethodOffsets;\\nint maxStringLength;\\nint header;\\nClassReader(byte[] classFile);\\nClassReader(byte[] classFileBuffer,int classFileOffset,int classFileLength);\\nClassReader(byte[] classFileBuffer,int classFileOffset,boolean checkClassVersion);\\nClassReader(InputStream inputStream);\\nClassReader(String className);\\ngetAccess();\\ngetClassName();\\ngetSuperName();\\ngetInterfaces();\\naccept(ClassVisitor classVisitor,int parsingOptions);\\naccept(ClassVisitor classVisitor,Attribute[] attributePrototypes,int parsingOptions);\\nreadModuleAttributes(ClassVisitor classVisitor,Context context,int moduleOffset,int modulePackagesOffset,String moduleMainClass);\\nreadRecordComponent(ClassVisitor classVisitor,Context context,int recordComponentOffset);\\nreadField(ClassVisitor classVisitor,Context context,int fieldInfoOffset);\\nreadMethod(ClassVisitor classVisitor,Context context,int methodInfoOffset);\\nreadCode(MethodVisitor methodVisitor,Context context,int codeOffset);\\nreadLabel(int bytecodeOffset,Label[] labels);\\ncreateLabel(int bytecodeOffset,Label[] labels);\\ncreateDebugLabel(int bytecodeOffset,Label[] labels);\\nreadTypeAnnotations(MethodVisitor methodVisitor,Context context,int runtimeTypeAnnotationsOffset,boolean visible);\\ngetTypeAnnotationBytecodeOffset(int[] typeAnnotationOffsets,int typeAnnotationIndex);\\nreadTypeAnnotationTarget(Context context,int typeAnnotationOffset);\\nreadParameterAnnotations(MethodVisitor methodVisitor,Context context,int runtimeParameterAnnotationsOffset,boolean visible);\\nreadElementValues(AnnotationVisitor annotationVisitor,int annotationOffset,boolean named,char[] charBuffer);\\nreadElementValue(AnnotationVisitor annotationVisitor,int elementValueOffset,String elementName,char[] charBuffer);\\ncomputeImplicitFrame(Context context);\\nreadStackMapFrame(int stackMapFrameOffset,boolean compressed,boolean expand,Context context);\\nreadVerificationTypeInfo(int verificationTypeInfoOffset,Object[] frame,int index,char[] charBuffer,Label[] labels);\\ngetFirstAttributeOffset();\\nreadBootstrapMethodsAttribute(int maxStringLength);\\nreadAttribute(Attribute[] attributePrototypes,String type,int offset,int length,char[] charBuffer,int codeAttributeOffset,Label[] labels);\\ngetItemCount();\\ngetItem(int constantPoolEntryIndex);\\ngetMaxStringLength();\\nreadByte(int offset);\\nreadUnsignedShort(int offset);\\nreadShort(int offset);\\nreadInt(int offset);\\nreadLong(int offset);\\nreadUTF8(int offset,char[] charBuffer);\\nreadUtf(int constantPoolEntryIndex,char[] charBuffer);\\nreadUtf(int utfOffset,int utfLength,char[] charBuffer);\\nreadStringish(int offset,char[] charBuffer);\\nreadClass(int offset,char[] charBuffer);\\nreadModule(int offset,char[] charBuffer);\\nreadPackage(int offset,char[] charBuffer);\\nreadConstantDynamic(int constantPoolEntryIndex,char[] charBuffer);\\nreadConst(int constantPoolEntryIndex,char[] charBuffer);\\nreadStream(InputStream inputStream,boolean close);\\n\", \"repo_level\" : \"\" }",
            "class_name": "ClassReader",
            "code": "public long readLong(final int offset){\n  long l1=readInt(offset);\n  long l0=readInt(offset + 4) & 0xFFFFFFFFL;\n  return (l1 << 32) | l0;\n}\n",
            "docstring": "/** \n * Reads a signed long value in this  {@link ClassReader}. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\n * @return the read value.\n */\n",
            "end_lineno": "3134",
            "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage net.hasor.utils.asm;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * A parser to make a {@link ClassVisitor} visit a ClassFile structure, as defined in the Java\n * Virtual Machine Specification (JVMS). This class parses the ClassFile content and calls the\n * appropriate visit methods of a given {@link ClassVisitor} for each field, method and bytecode\n * instruction encountered.\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html\">JVMS 4</a>\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic class ClassReader {\n    /**\n     * A flag to skip the Code attributes. If this flag is set the Code attributes are neither parsed\n     * nor visited.\n     */\n    public static final  int               SKIP_CODE                    = 1;\n    /**\n     * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable,\n     * LocalVariableTypeTable, LineNumberTable and MethodParameters attributes. If this flag is set\n     * these attributes are neither parsed nor visited (i.e. {@link ClassVisitor#visitSource}, {@link\n     * MethodVisitor#visitLocalVariable}, {@link MethodVisitor#visitLineNumber} and {@link\n     * MethodVisitor#visitParameter} are not called).\n     */\n    public static final  int               SKIP_DEBUG                   = 2;\n    /**\n     * A flag to skip the StackMap and StackMapTable attributes. If this flag is set these attributes\n     * are neither parsed nor visited (i.e. {@link MethodVisitor#visitFrame} is not called). This flag\n     * is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is used: it avoids visiting frames\n     * that will be ignored and recomputed from scratch.\n     */\n    public static final  int               SKIP_FRAMES                  = 4;\n    /**\n     * A flag to expand the stack map frames. By default stack map frames are visited in their\n     * original format (i.e. \"expanded\" for classes whose version is less than V1_6, and \"compressed\"\n     * for the other classes). If this flag is set, stack map frames are always visited in expanded\n     * format (this option adds a decompression/compression step in ClassReader and ClassWriter which\n     * degrades performance quite a lot).\n     */\n    public static final  int               EXPAND_FRAMES                = 8;\n    /**\n     * A flag to expand the ASM specific instructions into an equivalent sequence of standard bytecode\n     * instructions. When resolving a forward jump it may happen that the signed 2 bytes offset\n     * reserved for it is not sufficient to store the bytecode offset. In this case the jump\n     * instruction is replaced with a temporary ASM specific instruction using an unsigned 2 bytes\n     * offset (see {@link Label#resolve}). This internal flag is used to re-read classes containing\n     * such instructions, in order to replace them with standard instructions. In addition, when this\n     * flag is used, goto_w and jsr_w are <i>not</i> converted into goto and jsr, to make sure that\n     * infinite loops where a goto_w is replaced with a goto in ClassReader and converted back to a\n     * goto_w in ClassWriter cannot occur.\n     */\n    static final         int               EXPAND_ASM_INSNS             = 256;\n    /** The size of the temporary byte array used to read class input streams chunk by chunk. */\n    private static final int               INPUT_STREAM_DATA_CHUNK_SIZE = 4096;\n    /**\n     * A byte array containing the JVMS ClassFile structure to be parsed.\n     *\n     * @deprecated Use {@link #readByte(int)} and the other read methods instead. This field will\n     *     eventually be deleted.\n     */\n    @Deprecated\n    // DontCheck(MemberName): can't be renamed (for backward binary compatibility).\n    public final         byte[]            b;\n    /**\n     * A byte array containing the JVMS ClassFile structure to be parsed. <i>The content of this array\n     * must not be modified. This field is intended for {@link Attribute} sub classes, and is normally\n     * not needed by class visitors.</i>\n     *\n     * <p>NOTE: the ClassFile structure can start at any offset within this array, i.e. it does not\n     * necessarily start at offset 0. Use {@link #getItem} and {@link #header} to get correct\n     * ClassFile element offsets within this byte array.\n     */\n    final                byte[]            classFileBuffer;\n    /**\n     * The offset in bytes, in {@link #classFileBuffer}, of each cp_info entry of the ClassFile's\n     * constant_pool array, <i>plus one</i>. In other words, the offset of constant pool entry i is\n     * given by cpInfoOffsets[i] - 1, i.e. its cp_info's tag field is given by b[cpInfoOffsets[i] -\n     * 1].\n     */\n    private final        int[]             cpInfoOffsets;\n    /**\n     * The String objects corresponding to the CONSTANT_Utf8 constant pool items. This cache avoids\n     * multiple parsing of a given CONSTANT_Utf8 constant pool item.\n     */\n    private final        String[]          constantUtf8Values;\n    /**\n     * The ConstantDynamic objects corresponding to the CONSTANT_Dynamic constant pool items. This\n     * cache avoids multiple parsing of a given CONSTANT_Dynamic constant pool item.\n     */\n    private final        ConstantDynamic[] constantDynamicValues;\n    /**\n     * The start offsets in {@link #classFileBuffer} of each element of the bootstrap_methods array\n     * (in the BootstrapMethods attribute).\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23\">JVMS\n     *     4.7.23</a>\n     */\n    private final        int[]             bootstrapMethodOffsets;\n    /**\n     * A conservative estimate of the maximum length of the strings contained in the constant pool of\n     * the class.\n     */\n    private final        int               maxStringLength;\n    /** The offset in bytes of the ClassFile's access_flags field. */\n    public final         int               header;\n    // -----------------------------------------------------------------------------------------------\n    // Constructors\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param classFile the JVMS ClassFile structure to be read.\n     */\n    public ClassReader(final byte[] classFile) {\n        this(classFile, 0, classFile.length);\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.\n     * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.\n     * @param classFileLength the length in bytes of the ClassFile to be read.\n     */\n    public ClassReader(final byte[] classFileBuffer, final int classFileOffset, final int classFileLength) { // NOPMD(UnusedFormalParameter) used for backward compatibility.\n        this(classFileBuffer, classFileOffset, /* checkClassVersion = */ true);\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object. <i>This internal constructor must not be exposed\n     * as a public API</i>.\n     *\n     * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.\n     * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.\n     * @param checkClassVersion whether to check the class version or not.\n     */\n    ClassReader(final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {\n        this.classFileBuffer = classFileBuffer;\n        this.b = classFileBuffer;\n        // Check the class' major_version. This field is after the magic and minor_version fields, which\n        // use 4 and 2 bytes respectively.\n        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V15) {\n            throw new IllegalArgumentException(\"Unsupported class file major version \" + readShort(classFileOffset + 6));\n        }\n        // Create the constant pool arrays. The constant_pool_count field is after the magic,\n        // minor_version and major_version fields, which use 4, 2 and 2 bytes respectively.\n        int constantPoolCount = readUnsignedShort(classFileOffset + 8);\n        cpInfoOffsets = new int[constantPoolCount];\n        constantUtf8Values = new String[constantPoolCount];\n        // Compute the offset of each constant pool entry, as well as a conservative estimate of the\n        // maximum length of the constant pool strings. The first constant pool entry is after the\n        // magic, minor_version, major_version and constant_pool_count fields, which use 4, 2, 2 and 2\n        // bytes respectively.\n        int currentCpInfoIndex = 1;\n        int currentCpInfoOffset = classFileOffset + 10;\n        int currentMaxStringLength = 0;\n        boolean hasBootstrapMethods = false;\n        boolean hasConstantDynamic = false;\n        // The offset of the other entries depend on the total size of all the previous entries.\n        while (currentCpInfoIndex < constantPoolCount) {\n            cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;\n            int cpInfoSize;\n            switch (classFileBuffer[currentCpInfoOffset]) {\n            case Symbol.CONSTANT_FIELDREF_TAG:\n            case Symbol.CONSTANT_METHODREF_TAG:\n            case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n            case Symbol.CONSTANT_INTEGER_TAG:\n            case Symbol.CONSTANT_FLOAT_TAG:\n            case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n                cpInfoSize = 5;\n                break;\n            case Symbol.CONSTANT_DYNAMIC_TAG:\n                cpInfoSize = 5;\n                hasBootstrapMethods = true;\n                hasConstantDynamic = true;\n                break;\n            case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n                cpInfoSize = 5;\n                hasBootstrapMethods = true;\n                break;\n            case Symbol.CONSTANT_LONG_TAG:\n            case Symbol.CONSTANT_DOUBLE_TAG:\n                cpInfoSize = 9;\n                currentCpInfoIndex++;\n                break;\n            case Symbol.CONSTANT_UTF8_TAG:\n                cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);\n                if (cpInfoSize > currentMaxStringLength) {\n                    // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate\n                    // of the length in characters of the corresponding string, and is much cheaper to\n                    // compute than this exact length.\n                    currentMaxStringLength = cpInfoSize;\n                }\n                break;\n            case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n                cpInfoSize = 4;\n                break;\n            case Symbol.CONSTANT_CLASS_TAG:\n            case Symbol.CONSTANT_STRING_TAG:\n            case Symbol.CONSTANT_METHOD_TYPE_TAG:\n            case Symbol.CONSTANT_PACKAGE_TAG:\n            case Symbol.CONSTANT_MODULE_TAG:\n                cpInfoSize = 3;\n                break;\n            default:\n                throw new IllegalArgumentException();\n            }\n            currentCpInfoOffset += cpInfoSize;\n        }\n        maxStringLength = currentMaxStringLength;\n        // The Classfile's access_flags field is just after the last constant pool entry.\n        header = currentCpInfoOffset;\n        // Allocate the cache of ConstantDynamic values, if there is at least one.\n        constantDynamicValues = hasConstantDynamic ? new ConstantDynamic[constantPoolCount] : null;\n        // Read the BootstrapMethods attribute, if any (only get the offset of each method).\n        bootstrapMethodOffsets = hasBootstrapMethods ? readBootstrapMethodsAttribute(currentMaxStringLength) : null;\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param inputStream an input stream of the JVMS ClassFile structure to be read. This input\n     *     stream must contain nothing more than the ClassFile structure itself. It is read from its\n     *     current position to its end.\n     * @throws IOException if a problem occurs during reading.\n     */\n    public ClassReader(final InputStream inputStream) throws IOException {\n        this(readStream(inputStream, false));\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param className the fully qualified name of the class to be read. The ClassFile structure is\n     *     retrieved with the current class loader's {@link ClassLoader#getSystemResourceAsStream}.\n     * @throws IOException if an exception occurs during reading.\n     */\n    public ClassReader(final String className) throws IOException {\n        this(readStream(ClassLoader.getSystemResourceAsStream(className.replace('.', '/') + \".class\"), true));\n    }\n\n    /**\n     * Reads the given input stream and returns its content as a byte array.\n     *\n     * @param inputStream an input stream.\n     * @param close true to close the input stream after reading.\n     * @return the content of the given input stream.\n     * @throws IOException if a problem occurs during reading.\n     */\n    private static byte[] readStream(final InputStream inputStream, final boolean close) throws IOException {\n        if (inputStream == null) {\n            throw new IOException(\"Class not found\");\n        }\n        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n            byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {\n                outputStream.write(data, 0, bytesRead);\n            }\n            outputStream.flush();\n            return outputStream.toByteArray();\n        } finally {\n            if (close) {\n                inputStream.close();\n            }\n        }\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Accessors\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the class's access flags (see {@link Opcodes}). This value may not reflect Deprecated\n     * and Synthetic flags when bytecode is before 1.5 and those flags are represented by attributes.\n     *\n     * @return the class access flags.\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public int getAccess() {\n        return readUnsignedShort(header);\n    }\n\n    /**\n     * Returns the internal name of the class (see {@link Type#getInternalName()}).\n     *\n     * @return the internal class name.\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getClassName() {\n        // this_class is just after the access_flags field (using 2 bytes).\n        return readClass(header + 2, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal of name of the super class (see {@link Type#getInternalName()}). For\n     * interfaces, the super class is {@link Object}.\n     *\n     * @return the internal name of the super class, or {@literal null} for {@link Object} class.\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getSuperName() {\n        // super_class is after the access_flags and this_class fields (2 bytes each).\n        return readClass(header + 4, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal names of the implemented interfaces (see {@link Type#getInternalName()}).\n     *\n     * @return the internal names of the directly implemented interfaces. Inherited implemented\n     *     interfaces are not returned.\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String[] getInterfaces() {\n        // interfaces_count is after the access_flags, this_class and super_class fields (2 bytes each).\n        int currentOffset = header + 6;\n        int interfacesCount = readUnsignedShort(currentOffset);\n        String[] interfaces = new String[interfacesCount];\n        if (interfacesCount > 0) {\n            char[] charBuffer = new char[maxStringLength];\n            for (int i = 0; i < interfacesCount; ++i) {\n                currentOffset += 2;\n                interfaces[i] = readClass(currentOffset, charBuffer);\n            }\n        }\n        return interfaces;\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Public methods\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this\n     * {@link ClassReader}.\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param parsingOptions the options to use to parse this class. One or more of {@link\n     *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.\n     */\n    public void accept(final ClassVisitor classVisitor, final int parsingOptions) {\n        accept(classVisitor, new Attribute[0], parsingOptions);\n    }\n\n    /**\n     * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this\n     * {@link ClassReader}.\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of\n     *     the class. Any attribute whose type is not equal to the type of one the prototypes will not\n     *     be parsed: its byte array value will be passed unchanged to the ClassWriter. <i>This may\n     *     corrupt it if this value contains references to the constant pool, or has syntactic or\n     *     semantic links with a class element that has been transformed by a class adapter between\n     *     the reader and the writer</i>.\n     * @param parsingOptions the options to use to parse this class. One or more of {@link\n     *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.\n     */\n    public void accept(final ClassVisitor classVisitor, final Attribute[] attributePrototypes, final int parsingOptions) {\n        Context context = new Context();\n        context.attributePrototypes = attributePrototypes;\n        context.parsingOptions = parsingOptions;\n        context.charBuffer = new char[maxStringLength];\n        // Read the access_flags, this_class, super_class, interface_count and interfaces fields.\n        char[] charBuffer = context.charBuffer;\n        int currentOffset = header;\n        int accessFlags = readUnsignedShort(currentOffset);\n        String thisClass = readClass(currentOffset + 2, charBuffer);\n        String superClass = readClass(currentOffset + 4, charBuffer);\n        String[] interfaces = new String[readUnsignedShort(currentOffset + 6)];\n        currentOffset += 8;\n        for (int i = 0; i < interfaces.length; ++i) {\n            interfaces[i] = readClass(currentOffset, charBuffer);\n            currentOffset += 2;\n        }\n        // Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).\n        // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n        // - The offset of the InnerClasses attribute, or 0.\n        int innerClassesOffset = 0;\n        // - The offset of the EnclosingMethod attribute, or 0.\n        int enclosingMethodOffset = 0;\n        // - The string corresponding to the Signature attribute, or null.\n        String signature = null;\n        // - The string corresponding to the SourceFile attribute, or null.\n        String sourceFile = null;\n        // - The string corresponding to the SourceDebugExtension attribute, or null.\n        String sourceDebugExtension = null;\n        // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n        int runtimeVisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n        int runtimeInvisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n        int runtimeVisibleTypeAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n        int runtimeInvisibleTypeAnnotationsOffset = 0;\n        // - The offset of the Module attribute, or 0.\n        int moduleOffset = 0;\n        // - The offset of the ModulePackages attribute, or 0.\n        int modulePackagesOffset = 0;\n        // - The string corresponding to the ModuleMainClass attribute, or null.\n        String moduleMainClass = null;\n        // - The string corresponding to the NestHost attribute, or null.\n        String nestHostClass = null;\n        // - The offset of the NestMembers attribute, or 0.\n        int nestMembersOffset = 0;\n        // - The offset of the PermittedSubtypes attribute, or 0\n        int permittedSubtypesOffset = 0;\n        // - The offset of the Record attribute, or 0.\n        int recordOffset = 0;\n        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n        Attribute attributes = null;\n        int currentAttributeOffset = getFirstAttributeOffset();\n        for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentAttributeOffset, charBuffer);\n            int attributeLength = readInt(currentAttributeOffset + 2);\n            currentAttributeOffset += 6;\n            // The tests are sorted in decreasing frequency order (based on frequencies observed on\n            // typical classes).\n            if (Constants.SOURCE_FILE.equals(attributeName)) {\n                sourceFile = readUTF8(currentAttributeOffset, charBuffer);\n            } else if (Constants.INNER_CLASSES.equals(attributeName)) {\n                innerClassesOffset = currentAttributeOffset;\n            } else if (Constants.ENCLOSING_METHOD.equals(attributeName)) {\n                enclosingMethodOffset = currentAttributeOffset;\n            } else if (Constants.NEST_HOST.equals(attributeName)) {\n                nestHostClass = readClass(currentAttributeOffset, charBuffer);\n            } else if (Constants.NEST_MEMBERS.equals(attributeName)) {\n                nestMembersOffset = currentAttributeOffset;\n            } else if (Constants.PERMITTED_SUBTYPES.equals(attributeName)) {\n                permittedSubtypesOffset = currentAttributeOffset;\n            } else if (Constants.SIGNATURE.equals(attributeName)) {\n                signature = readUTF8(currentAttributeOffset, charBuffer);\n            } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleAnnotationsOffset = currentAttributeOffset;\n            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;\n            } else if (Constants.DEPRECATED.equals(attributeName)) {\n                accessFlags |= Opcodes.ACC_DEPRECATED;\n            } else if (Constants.SYNTHETIC.equals(attributeName)) {\n                accessFlags |= Opcodes.ACC_SYNTHETIC;\n            } else if (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {\n                sourceDebugExtension = readUtf(currentAttributeOffset, attributeLength, new char[attributeLength]);\n            } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleAnnotationsOffset = currentAttributeOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;\n            } else if (Constants.RECORD.equals(attributeName)) {\n                recordOffset = currentAttributeOffset;\n            } else if (Constants.MODULE.equals(attributeName)) {\n                moduleOffset = currentAttributeOffset;\n            } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {\n                moduleMainClass = readClass(currentAttributeOffset, charBuffer);\n            } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {\n                modulePackagesOffset = currentAttributeOffset;\n            } else if (!Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n                // The BootstrapMethods attribute is read in the constructor.\n                Attribute attribute = readAttribute(attributePrototypes, attributeName, currentAttributeOffset, attributeLength, charBuffer, -1, null);\n                attribute.nextAttribute = attributes;\n                attributes = attribute;\n            }\n            currentAttributeOffset += attributeLength;\n        }\n        // Visit the class declaration. The minor_version and major_version fields start 6 bytes before\n        // the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).\n        classVisitor.visit(readInt(cpInfoOffsets[1] - 7), accessFlags, thisClass, signature, superClass, interfaces);\n        // Visit the SourceFile and SourceDebugExtenstion attributes.\n        if ((parsingOptions & SKIP_DEBUG) == 0 && (sourceFile != null || sourceDebugExtension != null)) {\n            classVisitor.visitSource(sourceFile, sourceDebugExtension);\n        }\n        // Visit the Module, ModulePackages and ModuleMainClass attributes.\n        if (moduleOffset != 0) {\n            readModuleAttributes(classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);\n        }\n        // Visit the NestHost attribute.\n        if (nestHostClass != null) {\n            classVisitor.visitNestHost(nestHostClass);\n        }\n        // Visit the EnclosingMethod attribute.\n        if (enclosingMethodOffset != 0) {\n            String className = readClass(enclosingMethodOffset, charBuffer);\n            int methodIndex = readUnsignedShort(enclosingMethodOffset + 2);\n            String name = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex], charBuffer);\n            String type = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex] + 2, charBuffer);\n            classVisitor.visitOuterClass(className, name, type);\n        }\n        // Visit the RuntimeVisibleAnnotations attribute.\n        if (runtimeVisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleAnnotations attribute.\n        if (runtimeInvisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeVisibleTypeAnnotations attribute.\n        if (runtimeVisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(classVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleTypeAnnotations attribute.\n        if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(classVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the non standard attributes.\n        while (attributes != null) {\n            // Copy and reset the nextAttribute field so that it can also be used in ClassWriter.\n            Attribute nextAttribute = attributes.nextAttribute;\n            attributes.nextAttribute = null;\n            classVisitor.visitAttribute(attributes);\n            attributes = nextAttribute;\n        }\n        // Visit the NestedMembers attribute.\n        if (nestMembersOffset != 0) {\n            int numberOfNestMembers = readUnsignedShort(nestMembersOffset);\n            int currentNestMemberOffset = nestMembersOffset + 2;\n            while (numberOfNestMembers-- > 0) {\n                classVisitor.visitNestMember(readClass(currentNestMemberOffset, charBuffer));\n                currentNestMemberOffset += 2;\n            }\n        }\n        // Visit the PermittedSubtypes attribute.\n        if (permittedSubtypesOffset != 0) {\n            int numberOfPermittedSubtypes = readUnsignedShort(permittedSubtypesOffset);\n            int currentPermittedSubtypeOffset = permittedSubtypesOffset + 2;\n            while (numberOfPermittedSubtypes-- > 0) {\n                classVisitor.visitPermittedSubtypeExperimental(readClass(currentPermittedSubtypeOffset, charBuffer));\n                currentPermittedSubtypeOffset += 2;\n            }\n        }\n        // Visit the InnerClasses attribute.\n        if (innerClassesOffset != 0) {\n            int numberOfClasses = readUnsignedShort(innerClassesOffset);\n            int currentClassesOffset = innerClassesOffset + 2;\n            while (numberOfClasses-- > 0) {\n                classVisitor.visitInnerClass(readClass(currentClassesOffset, charBuffer), readClass(currentClassesOffset + 2, charBuffer), readUTF8(currentClassesOffset + 4, charBuffer), readUnsignedShort(currentClassesOffset + 6));\n                currentClassesOffset += 8;\n            }\n        }\n        // Visit Record components.\n        if (recordOffset != 0) {\n            int recordComponentsCount = readUnsignedShort(recordOffset);\n            recordOffset += 2;\n            while (recordComponentsCount-- > 0) {\n                recordOffset = readRecordComponent(classVisitor, context, recordOffset);\n            }\n        }\n        // Visit the fields and methods.\n        int fieldsCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (fieldsCount-- > 0) {\n            currentOffset = readField(classVisitor, context, currentOffset);\n        }\n        int methodsCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (methodsCount-- > 0) {\n            currentOffset = readMethod(classVisitor, context, currentOffset);\n        }\n        // Visit the end of the class.\n        classVisitor.visitEnd();\n    }\n    // ----------------------------------------------------------------------------------------------\n    // Methods to parse modules, fields and methods\n    // ----------------------------------------------------------------------------------------------\n\n    /**\n     * Reads the Module, ModulePackages and ModuleMainClass attributes and visit them.\n     *\n     * @param classVisitor the current class visitor\n     * @param context information about the class being parsed.\n     * @param moduleOffset the offset of the Module attribute (excluding the attribute_info's\n     *     attribute_name_index and attribute_length fields).\n     * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the\n     *     attribute_info's attribute_name_index and attribute_length fields), or 0.\n     * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or {@literal\n     *     null}.\n     */\n    private void readModuleAttributes(final ClassVisitor classVisitor, final Context context, final int moduleOffset, final int modulePackagesOffset, final String moduleMainClass) {\n        char[] buffer = context.charBuffer;\n        // Read the module_name_index, module_flags and module_version_index fields and visit them.\n        int currentOffset = moduleOffset;\n        String moduleName = readModule(currentOffset, buffer);\n        int moduleFlags = readUnsignedShort(currentOffset + 2);\n        String moduleVersion = readUTF8(currentOffset + 4, buffer);\n        currentOffset += 6;\n        ModuleVisitor moduleVisitor = classVisitor.visitModule(moduleName, moduleFlags, moduleVersion);\n        if (moduleVisitor == null) {\n            return;\n        }\n        // Visit the ModuleMainClass attribute.\n        if (moduleMainClass != null) {\n            moduleVisitor.visitMainClass(moduleMainClass);\n        }\n        // Visit the ModulePackages attribute.\n        if (modulePackagesOffset != 0) {\n            int packageCount = readUnsignedShort(modulePackagesOffset);\n            int currentPackageOffset = modulePackagesOffset + 2;\n            while (packageCount-- > 0) {\n                moduleVisitor.visitPackage(readPackage(currentPackageOffset, buffer));\n                currentPackageOffset += 2;\n            }\n        }\n        // Read the 'requires_count' and 'requires' fields.\n        int requiresCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (requiresCount-- > 0) {\n            // Read the requires_index, requires_flags and requires_version fields and visit them.\n            String requires = readModule(currentOffset, buffer);\n            int requiresFlags = readUnsignedShort(currentOffset + 2);\n            String requiresVersion = readUTF8(currentOffset + 4, buffer);\n            currentOffset += 6;\n            moduleVisitor.visitRequire(requires, requiresFlags, requiresVersion);\n        }\n        // Read the 'exports_count' and 'exports' fields.\n        int exportsCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (exportsCount-- > 0) {\n            // Read the exports_index, exports_flags, exports_to_count and exports_to_index fields\n            // and visit them.\n            String exports = readPackage(currentOffset, buffer);\n            int exportsFlags = readUnsignedShort(currentOffset + 2);\n            int exportsToCount = readUnsignedShort(currentOffset + 4);\n            currentOffset += 6;\n            String[] exportsTo = null;\n            if (exportsToCount != 0) {\n                exportsTo = new String[exportsToCount];\n                for (int i = 0; i < exportsToCount; ++i) {\n                    exportsTo[i] = readModule(currentOffset, buffer);\n                    currentOffset += 2;\n                }\n            }\n            moduleVisitor.visitExport(exports, exportsFlags, exportsTo);\n        }\n        // Reads the 'opens_count' and 'opens' fields.\n        int opensCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (opensCount-- > 0) {\n            // Read the opens_index, opens_flags, opens_to_count and opens_to_index fields and visit them.\n            String opens = readPackage(currentOffset, buffer);\n            int opensFlags = readUnsignedShort(currentOffset + 2);\n            int opensToCount = readUnsignedShort(currentOffset + 4);\n            currentOffset += 6;\n            String[] opensTo = null;\n            if (opensToCount != 0) {\n                opensTo = new String[opensToCount];\n                for (int i = 0; i < opensToCount; ++i) {\n                    opensTo[i] = readModule(currentOffset, buffer);\n                    currentOffset += 2;\n                }\n            }\n            moduleVisitor.visitOpen(opens, opensFlags, opensTo);\n        }\n        // Read the 'uses_count' and 'uses' fields.\n        int usesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (usesCount-- > 0) {\n            moduleVisitor.visitUse(readClass(currentOffset, buffer));\n            currentOffset += 2;\n        }\n        // Read the  'provides_count' and 'provides' fields.\n        int providesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (providesCount-- > 0) {\n            // Read the provides_index, provides_with_count and provides_with_index fields and visit them.\n            String provides = readClass(currentOffset, buffer);\n            int providesWithCount = readUnsignedShort(currentOffset + 2);\n            currentOffset += 4;\n            String[] providesWith = new String[providesWithCount];\n            for (int i = 0; i < providesWithCount; ++i) {\n                providesWith[i] = readClass(currentOffset, buffer);\n                currentOffset += 2;\n            }\n            moduleVisitor.visitProvide(provides, providesWith);\n        }\n        // Visit the end of the module attributes.\n        moduleVisitor.visitEnd();\n    }\n\n    /**\n     * Reads a record component and visit it.\n     *\n     * @param classVisitor the current class visitor\n     * @param context information about the class being parsed.\n     * @param recordComponentOffset the offset of the current record component.\n     * @return the offset of the first byte following the record component.\n     */\n    private int readRecordComponent(final ClassVisitor classVisitor, final Context context, final int recordComponentOffset) {\n        char[] charBuffer = context.charBuffer;\n        int currentOffset = recordComponentOffset;\n        String name = readUTF8(currentOffset, charBuffer);\n        String descriptor = readUTF8(currentOffset + 2, charBuffer);\n        currentOffset += 4;\n        // Read the record component attributes (the variables are ordered as in Section 4.7 of the\n        // JVMS).\n        int accessFlags = 0;\n        // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n        // - The string corresponding to the Signature attribute, or null.\n        String signature = null;\n        // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n        int runtimeVisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n        int runtimeInvisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n        int runtimeVisibleTypeAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n        int runtimeInvisibleTypeAnnotationsOffset = 0;\n        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n        Attribute attributes = null;\n        int attributesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (attributesCount-- > 0) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentOffset, charBuffer);\n            int attributeLength = readInt(currentOffset + 2);\n            currentOffset += 6;\n            // The tests are sorted in decreasing frequency order (based on frequencies observed on\n            // typical classes).\n            if (Constants.SIGNATURE.equals(attributeName)) {\n                signature = readUTF8(currentOffset, charBuffer);\n            } else if (Constants.DEPRECATED.equals(attributeName)) {\n                accessFlags |= Opcodes.ACC_DEPRECATED;\n            } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleTypeAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleTypeAnnotationsOffset = currentOffset;\n            } else {\n                Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, -1, null);\n                attribute.nextAttribute = attributes;\n                attributes = attribute;\n            }\n            currentOffset += attributeLength;\n        }\n        RecordComponentVisitor recordComponentVisitor = classVisitor.visitRecordComponentExperimental(accessFlags, name, descriptor, signature);\n        if (recordComponentVisitor == null) {\n            return currentOffset;\n        }\n        // Visit the RuntimeVisibleAnnotations attribute.\n        if (runtimeVisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(recordComponentVisitor.visitAnnotationExperimental(annotationDescriptor, /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleAnnotations attribute.\n        if (runtimeInvisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(recordComponentVisitor.visitAnnotationExperimental(annotationDescriptor, /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeVisibleTypeAnnotations attribute.\n        if (runtimeVisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(recordComponentVisitor.visitTypeAnnotationExperimental(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleTypeAnnotations attribute.\n        if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(recordComponentVisitor.visitTypeAnnotationExperimental(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the non standard attributes.\n        while (attributes != null) {\n            // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.\n            Attribute nextAttribute = attributes.nextAttribute;\n            attributes.nextAttribute = null;\n            recordComponentVisitor.visitAttributeExperimental(attributes);\n            attributes = nextAttribute;\n        }\n        // Visit the end of the field.\n        recordComponentVisitor.visitEndExperimental();\n        return currentOffset;\n    }\n\n    /**\n     * Reads a JVMS field_info structure and makes the given visitor visit it.\n     *\n     * @param classVisitor the visitor that must visit the field.\n     * @param context information about the class being parsed.\n     * @param fieldInfoOffset the start offset of the field_info structure.\n     * @return the offset of the first byte following the field_info structure.\n     */\n    private int readField(final ClassVisitor classVisitor, final Context context, final int fieldInfoOffset) {\n        char[] charBuffer = context.charBuffer;\n        // Read the access_flags, name_index and descriptor_index fields.\n        int currentOffset = fieldInfoOffset;\n        int accessFlags = readUnsignedShort(currentOffset);\n        String name = readUTF8(currentOffset + 2, charBuffer);\n        String descriptor = readUTF8(currentOffset + 4, charBuffer);\n        currentOffset += 6;\n        // Read the field attributes (the variables are ordered as in Section 4.7 of the JVMS).\n        // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n        // - The value corresponding to the ConstantValue attribute, or null.\n        Object constantValue = null;\n        // - The string corresponding to the Signature attribute, or null.\n        String signature = null;\n        // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n        int runtimeVisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n        int runtimeInvisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n        int runtimeVisibleTypeAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n        int runtimeInvisibleTypeAnnotationsOffset = 0;\n        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n        Attribute attributes = null;\n        int attributesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (attributesCount-- > 0) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentOffset, charBuffer);\n            int attributeLength = readInt(currentOffset + 2);\n            currentOffset += 6;\n            // The tests are sorted in decreasing frequency order (based on frequencies observed on\n            // typical classes).\n            if (Constants.CONSTANT_VALUE.equals(attributeName)) {\n                int constantvalueIndex = readUnsignedShort(currentOffset);\n                constantValue = constantvalueIndex == 0 ? null : readConst(constantvalueIndex, charBuffer);\n            } else if (Constants.SIGNATURE.equals(attributeName)) {\n                signature = readUTF8(currentOffset, charBuffer);\n            } else if (Constants.DEPRECATED.equals(attributeName)) {\n                accessFlags |= Opcodes.ACC_DEPRECATED;\n            } else if (Constants.SYNTHETIC.equals(attributeName)) {\n                accessFlags |= Opcodes.ACC_SYNTHETIC;\n            } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleTypeAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleTypeAnnotationsOffset = currentOffset;\n            } else {\n                Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, -1, null);\n                attribute.nextAttribute = attributes;\n                attributes = attribute;\n            }\n            currentOffset += attributeLength;\n        }\n        // Visit the field declaration.\n        FieldVisitor fieldVisitor = classVisitor.visitField(accessFlags, name, descriptor, signature, constantValue);\n        if (fieldVisitor == null) {\n            return currentOffset;\n        }\n        // Visit the RuntimeVisibleAnnotations attribute.\n        if (runtimeVisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(fieldVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleAnnotations attribute.\n        if (runtimeInvisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(fieldVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeVisibleTypeAnnotations attribute.\n        if (runtimeVisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(fieldVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleTypeAnnotations attribute.\n        if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(fieldVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the non standard attributes.\n        while (attributes != null) {\n            // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.\n            Attribute nextAttribute = attributes.nextAttribute;\n            attributes.nextAttribute = null;\n            fieldVisitor.visitAttribute(attributes);\n            attributes = nextAttribute;\n        }\n        // Visit the end of the field.\n        fieldVisitor.visitEnd();\n        return currentOffset;\n    }\n\n    /**\n     * Reads a JVMS method_info structure and makes the given visitor visit it.\n     *\n     * @param classVisitor the visitor that must visit the method.\n     * @param context information about the class being parsed.\n     * @param methodInfoOffset the start offset of the method_info structure.\n     * @return the offset of the first byte following the method_info structure.\n     */\n    private int readMethod(final ClassVisitor classVisitor, final Context context, final int methodInfoOffset) {\n        char[] charBuffer = context.charBuffer;\n        // Read the access_flags, name_index and descriptor_index fields.\n        int currentOffset = methodInfoOffset;\n        context.currentMethodAccessFlags = readUnsignedShort(currentOffset);\n        context.currentMethodName = readUTF8(currentOffset + 2, charBuffer);\n        context.currentMethodDescriptor = readUTF8(currentOffset + 4, charBuffer);\n        currentOffset += 6;\n        // Read the method attributes (the variables are ordered as in Section 4.7 of the JVMS).\n        // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n        // - The offset of the Code attribute, or 0.\n        int codeOffset = 0;\n        // - The offset of the Exceptions attribute, or 0.\n        int exceptionsOffset = 0;\n        // - The strings corresponding to the Exceptions attribute, or null.\n        String[] exceptions = null;\n        // - Whether the method has a Synthetic attribute.\n        boolean synthetic = false;\n        // - The constant pool index contained in the Signature attribute, or 0.\n        int signatureIndex = 0;\n        // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n        int runtimeVisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n        int runtimeInvisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeVisibleParameterAnnotations attribute, or 0.\n        int runtimeVisibleParameterAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleParameterAnnotations attribute, or 0.\n        int runtimeInvisibleParameterAnnotationsOffset = 0;\n        // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n        int runtimeVisibleTypeAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n        int runtimeInvisibleTypeAnnotationsOffset = 0;\n        // - The offset of the AnnotationDefault attribute, or 0.\n        int annotationDefaultOffset = 0;\n        // - The offset of the MethodParameters attribute, or 0.\n        int methodParametersOffset = 0;\n        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n        Attribute attributes = null;\n        int attributesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (attributesCount-- > 0) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentOffset, charBuffer);\n            int attributeLength = readInt(currentOffset + 2);\n            currentOffset += 6;\n            // The tests are sorted in decreasing frequency order (based on frequencies observed on\n            // typical classes).\n            if (Constants.CODE.equals(attributeName)) {\n                if ((context.parsingOptions & SKIP_CODE) == 0) {\n                    codeOffset = currentOffset;\n                }\n            } else if (Constants.EXCEPTIONS.equals(attributeName)) {\n                exceptionsOffset = currentOffset;\n                exceptions = new String[readUnsignedShort(exceptionsOffset)];\n                int currentExceptionOffset = exceptionsOffset + 2;\n                for (int i = 0; i < exceptions.length; ++i) {\n                    exceptions[i] = readClass(currentExceptionOffset, charBuffer);\n                    currentExceptionOffset += 2;\n                }\n            } else if (Constants.SIGNATURE.equals(attributeName)) {\n                signatureIndex = readUnsignedShort(currentOffset);\n            } else if (Constants.DEPRECATED.equals(attributeName)) {\n                context.currentMethodAccessFlags |= Opcodes.ACC_DEPRECATED;\n            } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleTypeAnnotationsOffset = currentOffset;\n            } else if (Constants.ANNOTATION_DEFAULT.equals(attributeName)) {\n                annotationDefaultOffset = currentOffset;\n            } else if (Constants.SYNTHETIC.equals(attributeName)) {\n                synthetic = true;\n                context.currentMethodAccessFlags |= Opcodes.ACC_SYNTHETIC;\n            } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleTypeAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleParameterAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleParameterAnnotationsOffset = currentOffset;\n            } else if (Constants.METHOD_PARAMETERS.equals(attributeName)) {\n                methodParametersOffset = currentOffset;\n            } else {\n                Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, -1, null);\n                attribute.nextAttribute = attributes;\n                attributes = attribute;\n            }\n            currentOffset += attributeLength;\n        }\n        // Visit the method declaration.\n        MethodVisitor methodVisitor = classVisitor.visitMethod(context.currentMethodAccessFlags, context.currentMethodName, context.currentMethodDescriptor, signatureIndex == 0 ? null : readUtf(signatureIndex, charBuffer), exceptions);\n        if (methodVisitor == null) {\n            return currentOffset;\n        }\n        // If the returned MethodVisitor is in fact a MethodWriter, it means there is no method\n        // adapter between the reader and the writer. In this case, it might be possible to copy\n        // the method attributes directly into the writer. If so, return early without visiting\n        // the content of these attributes.\n        if (methodVisitor instanceof MethodWriter) {\n            MethodWriter methodWriter = (MethodWriter) methodVisitor;\n            if (methodWriter.canCopyMethodAttributes(this, synthetic, (context.currentMethodAccessFlags & Opcodes.ACC_DEPRECATED) != 0, readUnsignedShort(methodInfoOffset + 4), signatureIndex, exceptionsOffset)) {\n                methodWriter.setMethodAttributesSource(methodInfoOffset, currentOffset - methodInfoOffset);\n                return currentOffset;\n            }\n        }\n        // Visit the MethodParameters attribute.\n        if (methodParametersOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {\n            int parametersCount = readByte(methodParametersOffset);\n            int currentParameterOffset = methodParametersOffset + 1;\n            while (parametersCount-- > 0) {\n                // Read the name_index and access_flags fields and visit them.\n                methodVisitor.visitParameter(readUTF8(currentParameterOffset, charBuffer), readUnsignedShort(currentParameterOffset + 2));\n                currentParameterOffset += 4;\n            }\n        }\n        // Visit the AnnotationDefault attribute.\n        if (annotationDefaultOffset != 0) {\n            AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();\n            readElementValue(annotationVisitor, annotationDefaultOffset, null, charBuffer);\n            if (annotationVisitor != null) {\n                annotationVisitor.visitEnd();\n            }\n        }\n        // Visit the RuntimeVisibleAnnotations attribute.\n        if (runtimeVisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(methodVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleAnnotations attribute.\n        if (runtimeInvisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(methodVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeVisibleTypeAnnotations attribute.\n        if (runtimeVisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(methodVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleTypeAnnotations attribute.\n        if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(methodVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeVisibleParameterAnnotations attribute.\n        if (runtimeVisibleParameterAnnotationsOffset != 0) {\n            readParameterAnnotations(methodVisitor, context, runtimeVisibleParameterAnnotationsOffset, /* visible = */ true);\n        }\n        // Visit the RuntimeInvisibleParameterAnnotations attribute.\n        if (runtimeInvisibleParameterAnnotationsOffset != 0) {\n            readParameterAnnotations(methodVisitor, context, runtimeInvisibleParameterAnnotationsOffset,\n                    /* visible = */ false);\n        }\n        // Visit the non standard attributes.\n        while (attributes != null) {\n            // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.\n            Attribute nextAttribute = attributes.nextAttribute;\n            attributes.nextAttribute = null;\n            methodVisitor.visitAttribute(attributes);\n            attributes = nextAttribute;\n        }\n        // Visit the Code attribute.\n        if (codeOffset != 0) {\n            methodVisitor.visitCode();\n            readCode(methodVisitor, context, codeOffset);\n        }\n        // Visit the end of the method.\n        methodVisitor.visitEnd();\n        return currentOffset;\n    }\n    // ----------------------------------------------------------------------------------------------\n    // Methods to parse a Code attribute\n    // ----------------------------------------------------------------------------------------------\n\n    /**\n     * Reads a JVMS 'Code' attribute and makes the given visitor visit it.\n     *\n     * @param methodVisitor the visitor that must visit the Code attribute.\n     * @param context information about the class being parsed.\n     * @param codeOffset the start offset in {@link #classFileBuffer} of the Code attribute, excluding\n     *     its attribute_name_index and attribute_length fields.\n     */\n    private void readCode(final MethodVisitor methodVisitor, final Context context, final int codeOffset) {\n        int currentOffset = codeOffset;\n        // Read the max_stack, max_locals and code_length fields.\n        final byte[] classBuffer = classFileBuffer;\n        final char[] charBuffer = context.charBuffer;\n        final int maxStack = readUnsignedShort(currentOffset);\n        final int maxLocals = readUnsignedShort(currentOffset + 2);\n        final int codeLength = readInt(currentOffset + 4);\n        currentOffset += 8;\n        // Read the bytecode 'code' array to create a label for each referenced instruction.\n        final int bytecodeStartOffset = currentOffset;\n        final int bytecodeEndOffset = currentOffset + codeLength;\n        final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];\n        while (currentOffset < bytecodeEndOffset) {\n            final int bytecodeOffset = currentOffset - bytecodeStartOffset;\n            final int opcode = classBuffer[currentOffset] & 0xFF;\n            switch (opcode) {\n            case Constants.NOP:\n            case Constants.ACONST_NULL:\n            case Constants.ICONST_M1:\n            case Constants.ICONST_0:\n            case Constants.ICONST_1:\n            case Constants.ICONST_2:\n            case Constants.ICONST_3:\n            case Constants.ICONST_4:\n            case Constants.ICONST_5:\n            case Constants.LCONST_0:\n            case Constants.LCONST_1:\n            case Constants.FCONST_0:\n            case Constants.FCONST_1:\n            case Constants.FCONST_2:\n            case Constants.DCONST_0:\n            case Constants.DCONST_1:\n            case Constants.IALOAD:\n            case Constants.LALOAD:\n            case Constants.FALOAD:\n            case Constants.DALOAD:\n            case Constants.AALOAD:\n            case Constants.BALOAD:\n            case Constants.CALOAD:\n            case Constants.SALOAD:\n            case Constants.IASTORE:\n            case Constants.LASTORE:\n            case Constants.FASTORE:\n            case Constants.DASTORE:\n            case Constants.AASTORE:\n            case Constants.BASTORE:\n            case Constants.CASTORE:\n            case Constants.SASTORE:\n            case Constants.POP:\n            case Constants.POP2:\n            case Constants.DUP:\n            case Constants.DUP_X1:\n            case Constants.DUP_X2:\n            case Constants.DUP2:\n            case Constants.DUP2_X1:\n            case Constants.DUP2_X2:\n            case Constants.SWAP:\n            case Constants.IADD:\n            case Constants.LADD:\n            case Constants.FADD:\n            case Constants.DADD:\n            case Constants.ISUB:\n            case Constants.LSUB:\n            case Constants.FSUB:\n            case Constants.DSUB:\n            case Constants.IMUL:\n            case Constants.LMUL:\n            case Constants.FMUL:\n            case Constants.DMUL:\n            case Constants.IDIV:\n            case Constants.LDIV:\n            case Constants.FDIV:\n            case Constants.DDIV:\n            case Constants.IREM:\n            case Constants.LREM:\n            case Constants.FREM:\n            case Constants.DREM:\n            case Constants.INEG:\n            case Constants.LNEG:\n            case Constants.FNEG:\n            case Constants.DNEG:\n            case Constants.ISHL:\n            case Constants.LSHL:\n            case Constants.ISHR:\n            case Constants.LSHR:\n            case Constants.IUSHR:\n            case Constants.LUSHR:\n            case Constants.IAND:\n            case Constants.LAND:\n            case Constants.IOR:\n            case Constants.LOR:\n            case Constants.IXOR:\n            case Constants.LXOR:\n            case Constants.I2L:\n            case Constants.I2F:\n            case Constants.I2D:\n            case Constants.L2I:\n            case Constants.L2F:\n            case Constants.L2D:\n            case Constants.F2I:\n            case Constants.F2L:\n            case Constants.F2D:\n            case Constants.D2I:\n            case Constants.D2L:\n            case Constants.D2F:\n            case Constants.I2B:\n            case Constants.I2C:\n            case Constants.I2S:\n            case Constants.LCMP:\n            case Constants.FCMPL:\n            case Constants.FCMPG:\n            case Constants.DCMPL:\n            case Constants.DCMPG:\n            case Constants.IRETURN:\n            case Constants.LRETURN:\n            case Constants.FRETURN:\n            case Constants.DRETURN:\n            case Constants.ARETURN:\n            case Constants.RETURN:\n            case Constants.ARRAYLENGTH:\n            case Constants.ATHROW:\n            case Constants.MONITORENTER:\n            case Constants.MONITOREXIT:\n            case Constants.ILOAD_0:\n            case Constants.ILOAD_1:\n            case Constants.ILOAD_2:\n            case Constants.ILOAD_3:\n            case Constants.LLOAD_0:\n            case Constants.LLOAD_1:\n            case Constants.LLOAD_2:\n            case Constants.LLOAD_3:\n            case Constants.FLOAD_0:\n            case Constants.FLOAD_1:\n            case Constants.FLOAD_2:\n            case Constants.FLOAD_3:\n            case Constants.DLOAD_0:\n            case Constants.DLOAD_1:\n            case Constants.DLOAD_2:\n            case Constants.DLOAD_3:\n            case Constants.ALOAD_0:\n            case Constants.ALOAD_1:\n            case Constants.ALOAD_2:\n            case Constants.ALOAD_3:\n            case Constants.ISTORE_0:\n            case Constants.ISTORE_1:\n            case Constants.ISTORE_2:\n            case Constants.ISTORE_3:\n            case Constants.LSTORE_0:\n            case Constants.LSTORE_1:\n            case Constants.LSTORE_2:\n            case Constants.LSTORE_3:\n            case Constants.FSTORE_0:\n            case Constants.FSTORE_1:\n            case Constants.FSTORE_2:\n            case Constants.FSTORE_3:\n            case Constants.DSTORE_0:\n            case Constants.DSTORE_1:\n            case Constants.DSTORE_2:\n            case Constants.DSTORE_3:\n            case Constants.ASTORE_0:\n            case Constants.ASTORE_1:\n            case Constants.ASTORE_2:\n            case Constants.ASTORE_3:\n                currentOffset += 1;\n                break;\n            case Constants.IFEQ:\n            case Constants.IFNE:\n            case Constants.IFLT:\n            case Constants.IFGE:\n            case Constants.IFGT:\n            case Constants.IFLE:\n            case Constants.IF_ICMPEQ:\n            case Constants.IF_ICMPNE:\n            case Constants.IF_ICMPLT:\n            case Constants.IF_ICMPGE:\n            case Constants.IF_ICMPGT:\n            case Constants.IF_ICMPLE:\n            case Constants.IF_ACMPEQ:\n            case Constants.IF_ACMPNE:\n            case Constants.GOTO:\n            case Constants.JSR:\n            case Constants.IFNULL:\n            case Constants.IFNONNULL:\n                createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);\n                currentOffset += 3;\n                break;\n            case Constants.ASM_IFEQ:\n            case Constants.ASM_IFNE:\n            case Constants.ASM_IFLT:\n            case Constants.ASM_IFGE:\n            case Constants.ASM_IFGT:\n            case Constants.ASM_IFLE:\n            case Constants.ASM_IF_ICMPEQ:\n            case Constants.ASM_IF_ICMPNE:\n            case Constants.ASM_IF_ICMPLT:\n            case Constants.ASM_IF_ICMPGE:\n            case Constants.ASM_IF_ICMPGT:\n            case Constants.ASM_IF_ICMPLE:\n            case Constants.ASM_IF_ACMPEQ:\n            case Constants.ASM_IF_ACMPNE:\n            case Constants.ASM_GOTO:\n            case Constants.ASM_JSR:\n            case Constants.ASM_IFNULL:\n            case Constants.ASM_IFNONNULL:\n                createLabel(bytecodeOffset + readUnsignedShort(currentOffset + 1), labels);\n                currentOffset += 3;\n                break;\n            case Constants.GOTO_W:\n            case Constants.JSR_W:\n            case Constants.ASM_GOTO_W:\n                createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);\n                currentOffset += 5;\n                break;\n            case Constants.WIDE:\n                switch (classBuffer[currentOffset + 1] & 0xFF) {\n                case Constants.ILOAD:\n                case Constants.FLOAD:\n                case Constants.ALOAD:\n                case Constants.LLOAD:\n                case Constants.DLOAD:\n                case Constants.ISTORE:\n                case Constants.FSTORE:\n                case Constants.ASTORE:\n                case Constants.LSTORE:\n                case Constants.DSTORE:\n                case Constants.RET:\n                    currentOffset += 4;\n                    break;\n                case Constants.IINC:\n                    currentOffset += 6;\n                    break;\n                default:\n                    throw new IllegalArgumentException();\n                }\n                break;\n            case Constants.TABLESWITCH:\n                // Skip 0 to 3 padding bytes.\n                currentOffset += 4 - (bytecodeOffset & 3);\n                // Read the default label and the number of table entries.\n                createLabel(bytecodeOffset + readInt(currentOffset), labels);\n                int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;\n                currentOffset += 12;\n                // Read the table labels.\n                while (numTableEntries-- > 0) {\n                    createLabel(bytecodeOffset + readInt(currentOffset), labels);\n                    currentOffset += 4;\n                }\n                break;\n            case Constants.LOOKUPSWITCH:\n                // Skip 0 to 3 padding bytes.\n                currentOffset += 4 - (bytecodeOffset & 3);\n                // Read the default label and the number of switch cases.\n                createLabel(bytecodeOffset + readInt(currentOffset), labels);\n                int numSwitchCases = readInt(currentOffset + 4);\n                currentOffset += 8;\n                // Read the switch labels.\n                while (numSwitchCases-- > 0) {\n                    createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);\n                    currentOffset += 8;\n                }\n                break;\n            case Constants.ILOAD:\n            case Constants.LLOAD:\n            case Constants.FLOAD:\n            case Constants.DLOAD:\n            case Constants.ALOAD:\n            case Constants.ISTORE:\n            case Constants.LSTORE:\n            case Constants.FSTORE:\n            case Constants.DSTORE:\n            case Constants.ASTORE:\n            case Constants.RET:\n            case Constants.BIPUSH:\n            case Constants.NEWARRAY:\n            case Constants.LDC:\n                currentOffset += 2;\n                break;\n            case Constants.SIPUSH:\n            case Constants.LDC_W:\n            case Constants.LDC2_W:\n            case Constants.GETSTATIC:\n            case Constants.PUTSTATIC:\n            case Constants.GETFIELD:\n            case Constants.PUTFIELD:\n            case Constants.INVOKEVIRTUAL:\n            case Constants.INVOKESPECIAL:\n            case Constants.INVOKESTATIC:\n            case Constants.NEW:\n            case Constants.ANEWARRAY:\n            case Constants.CHECKCAST:\n            case Constants.INSTANCEOF:\n            case Constants.IINC:\n                currentOffset += 3;\n                break;\n            case Constants.INVOKEINTERFACE:\n            case Constants.INVOKEDYNAMIC:\n                currentOffset += 5;\n                break;\n            case Constants.MULTIANEWARRAY:\n                currentOffset += 4;\n                break;\n            default:\n                throw new IllegalArgumentException();\n            }\n        }\n        // Read the 'exception_table_length' and 'exception_table' field to create a label for each\n        // referenced instruction, and to make methodVisitor visit the corresponding try catch blocks.\n        int exceptionTableLength = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (exceptionTableLength-- > 0) {\n            Label start = createLabel(readUnsignedShort(currentOffset), labels);\n            Label end = createLabel(readUnsignedShort(currentOffset + 2), labels);\n            Label handler = createLabel(readUnsignedShort(currentOffset + 4), labels);\n            String catchType = readUTF8(cpInfoOffsets[readUnsignedShort(currentOffset + 6)], charBuffer);\n            currentOffset += 8;\n            methodVisitor.visitTryCatchBlock(start, end, handler, catchType);\n        }\n        // Read the Code attributes to create a label for each referenced instruction (the variables\n        // are ordered as in Section 4.7 of the JVMS). Attribute offsets exclude the\n        // attribute_name_index and attribute_length fields.\n        // - The offset of the current 'stack_map_frame' in the StackMap[Table] attribute, or 0.\n        // Initially, this is the offset of the first 'stack_map_frame' entry. Then this offset is\n        // updated after each stack_map_frame is read.\n        int stackMapFrameOffset = 0;\n        // - The end offset of the StackMap[Table] attribute, or 0.\n        int stackMapTableEndOffset = 0;\n        // - Whether the stack map frames are compressed (i.e. in a StackMapTable) or not.\n        boolean compressedFrames = true;\n        // - The offset of the LocalVariableTable attribute, or 0.\n        int localVariableTableOffset = 0;\n        // - The offset of the LocalVariableTypeTable attribute, or 0.\n        int localVariableTypeTableOffset = 0;\n        // - The offset of each 'type_annotation' entry in the RuntimeVisibleTypeAnnotations\n        // attribute, or null.\n        int[] visibleTypeAnnotationOffsets = null;\n        // - The offset of each 'type_annotation' entry in the RuntimeInvisibleTypeAnnotations\n        // attribute, or null.\n        int[] invisibleTypeAnnotationOffsets = null;\n        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n        Attribute attributes = null;\n        int attributesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (attributesCount-- > 0) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentOffset, charBuffer);\n            int attributeLength = readInt(currentOffset + 2);\n            currentOffset += 6;\n            if (Constants.LOCAL_VARIABLE_TABLE.equals(attributeName)) {\n                if ((context.parsingOptions & SKIP_DEBUG) == 0) {\n                    localVariableTableOffset = currentOffset;\n                    // Parse the attribute to find the corresponding (debug only) labels.\n                    int currentLocalVariableTableOffset = currentOffset;\n                    int localVariableTableLength = readUnsignedShort(currentLocalVariableTableOffset);\n                    currentLocalVariableTableOffset += 2;\n                    while (localVariableTableLength-- > 0) {\n                        int startPc = readUnsignedShort(currentLocalVariableTableOffset);\n                        createDebugLabel(startPc, labels);\n                        int length = readUnsignedShort(currentLocalVariableTableOffset + 2);\n                        createDebugLabel(startPc + length, labels);\n                        // Skip the name_index, descriptor_index and index fields (2 bytes each).\n                        currentLocalVariableTableOffset += 10;\n                    }\n                }\n            } else if (Constants.LOCAL_VARIABLE_TYPE_TABLE.equals(attributeName)) {\n                localVariableTypeTableOffset = currentOffset;\n                // Here we do not extract the labels corresponding to the attribute content. We assume they\n                // are the same or a subset of those of the LocalVariableTable attribute.\n            } else if (Constants.LINE_NUMBER_TABLE.equals(attributeName)) {\n                if ((context.parsingOptions & SKIP_DEBUG) == 0) {\n                    // Parse the attribute to find the corresponding (debug only) labels.\n                    int currentLineNumberTableOffset = currentOffset;\n                    int lineNumberTableLength = readUnsignedShort(currentLineNumberTableOffset);\n                    currentLineNumberTableOffset += 2;\n                    while (lineNumberTableLength-- > 0) {\n                        int startPc = readUnsignedShort(currentLineNumberTableOffset);\n                        int lineNumber = readUnsignedShort(currentLineNumberTableOffset + 2);\n                        currentLineNumberTableOffset += 4;\n                        createDebugLabel(startPc, labels);\n                        labels[startPc].addLineNumber(lineNumber);\n                    }\n                }\n            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                visibleTypeAnnotationOffsets = readTypeAnnotations(methodVisitor, context, currentOffset, /* visible = */ true);\n                // Here we do not extract the labels corresponding to the attribute content. This would\n                // require a full parsing of the attribute, which would need to be repeated when parsing\n                // the bytecode instructions (see below). Instead, the content of the attribute is read one\n                // type annotation at a time (i.e. after a type annotation has been visited, the next type\n                // annotation is read), and the labels it contains are also extracted one annotation at a\n                // time. This assumes that type annotations are ordered by increasing bytecode offset.\n            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                invisibleTypeAnnotationOffsets = readTypeAnnotations(methodVisitor, context, currentOffset, /* visible = */ false);\n                // Same comment as above for the RuntimeVisibleTypeAnnotations attribute.\n            } else if (Constants.STACK_MAP_TABLE.equals(attributeName)) {\n                if ((context.parsingOptions & SKIP_FRAMES) == 0) {\n                    stackMapFrameOffset = currentOffset + 2;\n                    stackMapTableEndOffset = currentOffset + attributeLength;\n                }\n                // Here we do not extract the labels corresponding to the attribute content. This would\n                // require a full parsing of the attribute, which would need to be repeated when parsing\n                // the bytecode instructions (see below). Instead, the content of the attribute is read one\n                // frame at a time (i.e. after a frame has been visited, the next frame is read), and the\n                // labels it contains are also extracted one frame at a time. Thanks to the ordering of\n                // frames, having only a \"one frame lookahead\" is not a problem, i.e. it is not possible to\n                // see an offset smaller than the offset of the current instruction and for which no Label\n                // exist. Except for UNINITIALIZED type offsets. We solve this by parsing the stack map\n                // table without a full decoding (see below).\n            } else if (\"StackMap\".equals(attributeName)) {\n                if ((context.parsingOptions & SKIP_FRAMES) == 0) {\n                    stackMapFrameOffset = currentOffset + 2;\n                    stackMapTableEndOffset = currentOffset + attributeLength;\n                    compressedFrames = false;\n                }\n                // IMPORTANT! Here we assume that the frames are ordered, as in the StackMapTable attribute,\n                // although this is not guaranteed by the attribute format. This allows an incremental\n                // extraction of the labels corresponding to this attribute (see the comment above for the\n                // StackMapTable attribute).\n            } else {\n                Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, codeOffset, labels);\n                attribute.nextAttribute = attributes;\n                attributes = attribute;\n            }\n            currentOffset += attributeLength;\n        }\n        // Initialize the context fields related to stack map frames, and generate the first\n        // (implicit) stack map frame, if needed.\n        final boolean expandFrames = (context.parsingOptions & EXPAND_FRAMES) != 0;\n        if (stackMapFrameOffset != 0) {\n            // The bytecode offset of the first explicit frame is not offset_delta + 1 but only\n            // offset_delta. Setting the implicit frame offset to -1 allows us to use of the\n            // \"offset_delta + 1\" rule in all cases.\n            context.currentFrameOffset = -1;\n            context.currentFrameType = 0;\n            context.currentFrameLocalCount = 0;\n            context.currentFrameLocalCountDelta = 0;\n            context.currentFrameLocalTypes = new Object[maxLocals];\n            context.currentFrameStackCount = 0;\n            context.currentFrameStackTypes = new Object[maxStack];\n            if (expandFrames) {\n                computeImplicitFrame(context);\n            }\n            // Find the labels for UNINITIALIZED frame types. Instead of decoding each element of the\n            // stack map table, we look for 3 consecutive bytes that \"look like\" an UNINITIALIZED type\n            // (tag ITEM_Uninitialized, offset within bytecode bounds, NEW instruction at this offset).\n            // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,\n            // and the only consequence will be the creation of an unneeded label. This is better than\n            // creating a label for each NEW instruction, and faster than fully decoding the whole stack\n            // map table.\n            for (int offset = stackMapFrameOffset; offset < stackMapTableEndOffset - 2; ++offset) {\n                if (classBuffer[offset] == Frame.ITEM_UNINITIALIZED) {\n                    int potentialBytecodeOffset = readUnsignedShort(offset + 1);\n                    if (potentialBytecodeOffset >= 0 && potentialBytecodeOffset < codeLength && (classBuffer[bytecodeStartOffset + potentialBytecodeOffset] & 0xFF) == Opcodes.NEW) {\n                        createLabel(potentialBytecodeOffset, labels);\n                    }\n                }\n            }\n        }\n        if (expandFrames && (context.parsingOptions & EXPAND_ASM_INSNS) != 0) {\n            // Expanding the ASM specific instructions can introduce F_INSERT frames, even if the method\n            // does not currently have any frame. These inserted frames must be computed by simulating the\n            // effect of the bytecode instructions, one by one, starting from the implicit first frame.\n            // For this, MethodWriter needs to know maxLocals before the first instruction is visited. To\n            // ensure this, we visit the implicit first frame here (passing only maxLocals - the rest is\n            // computed in MethodWriter).\n            methodVisitor.visitFrame(Opcodes.F_NEW, maxLocals, null, 0, null);\n        }\n        // Visit the bytecode instructions. First, introduce state variables for the incremental parsing\n        // of the type annotations.\n        // Index of the next runtime visible type annotation to read (in the\n        // visibleTypeAnnotationOffsets array).\n        int currentVisibleTypeAnnotationIndex = 0;\n        // The bytecode offset of the next runtime visible type annotation to read, or -1.\n        int currentVisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, 0);\n        // Index of the next runtime invisible type annotation to read (in the\n        // invisibleTypeAnnotationOffsets array).\n        int currentInvisibleTypeAnnotationIndex = 0;\n        // The bytecode offset of the next runtime invisible type annotation to read, or -1.\n        int currentInvisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, 0);\n        // Whether a F_INSERT stack map frame must be inserted before the current instruction.\n        boolean insertFrame = false;\n        // The delta to subtract from a goto_w or jsr_w opcode to get the corresponding goto or jsr\n        // opcode, or 0 if goto_w and jsr_w must be left unchanged (i.e. when expanding ASM specific\n        // instructions).\n        final int wideJumpOpcodeDelta = (context.parsingOptions & EXPAND_ASM_INSNS) == 0 ? Constants.WIDE_JUMP_OPCODE_DELTA : 0;\n        currentOffset = bytecodeStartOffset;\n        while (currentOffset < bytecodeEndOffset) {\n            final int currentBytecodeOffset = currentOffset - bytecodeStartOffset;\n            // Visit the label and the line number(s) for this bytecode offset, if any.\n            Label currentLabel = labels[currentBytecodeOffset];\n            if (currentLabel != null) {\n                currentLabel.accept(methodVisitor, (context.parsingOptions & SKIP_DEBUG) == 0);\n            }\n            // Visit the stack map frame for this bytecode offset, if any.\n            while (stackMapFrameOffset != 0 && (context.currentFrameOffset == currentBytecodeOffset || context.currentFrameOffset == -1)) {\n                // If there is a stack map frame for this offset, make methodVisitor visit it, and read the\n                // next stack map frame if there is one.\n                if (context.currentFrameOffset != -1) {\n                    if (!compressedFrames || expandFrames) {\n                        methodVisitor.visitFrame(Opcodes.F_NEW, context.currentFrameLocalCount, context.currentFrameLocalTypes, context.currentFrameStackCount, context.currentFrameStackTypes);\n                    } else {\n                        methodVisitor.visitFrame(context.currentFrameType, context.currentFrameLocalCountDelta, context.currentFrameLocalTypes, context.currentFrameStackCount, context.currentFrameStackTypes);\n                    }\n                    // Since there is already a stack map frame for this bytecode offset, there is no need to\n                    // insert a new one.\n                    insertFrame = false;\n                }\n                if (stackMapFrameOffset < stackMapTableEndOffset) {\n                    stackMapFrameOffset = readStackMapFrame(stackMapFrameOffset, compressedFrames, expandFrames, context);\n                } else {\n                    stackMapFrameOffset = 0;\n                }\n            }\n            // Insert a stack map frame for this bytecode offset, if requested by setting insertFrame to\n            // true during the previous iteration. The actual frame content is computed in MethodWriter.\n            if (insertFrame) {\n                if ((context.parsingOptions & EXPAND_FRAMES) != 0) {\n                    methodVisitor.visitFrame(Constants.F_INSERT, 0, null, 0, null);\n                }\n                insertFrame = false;\n            }\n            // Visit the instruction at this bytecode offset.\n            int opcode = classBuffer[currentOffset] & 0xFF;\n            switch (opcode) {\n            case Constants.NOP:\n            case Constants.ACONST_NULL:\n            case Constants.ICONST_M1:\n            case Constants.ICONST_0:\n            case Constants.ICONST_1:\n            case Constants.ICONST_2:\n            case Constants.ICONST_3:\n            case Constants.ICONST_4:\n            case Constants.ICONST_5:\n            case Constants.LCONST_0:\n            case Constants.LCONST_1:\n            case Constants.FCONST_0:\n            case Constants.FCONST_1:\n            case Constants.FCONST_2:\n            case Constants.DCONST_0:\n            case Constants.DCONST_1:\n            case Constants.IALOAD:\n            case Constants.LALOAD:\n            case Constants.FALOAD:\n            case Constants.DALOAD:\n            case Constants.AALOAD:\n            case Constants.BALOAD:\n            case Constants.CALOAD:\n            case Constants.SALOAD:\n            case Constants.IASTORE:\n            case Constants.LASTORE:\n            case Constants.FASTORE:\n            case Constants.DASTORE:\n            case Constants.AASTORE:\n            case Constants.BASTORE:\n            case Constants.CASTORE:\n            case Constants.SASTORE:\n            case Constants.POP:\n            case Constants.POP2:\n            case Constants.DUP:\n            case Constants.DUP_X1:\n            case Constants.DUP_X2:\n            case Constants.DUP2:\n            case Constants.DUP2_X1:\n            case Constants.DUP2_X2:\n            case Constants.SWAP:\n            case Constants.IADD:\n            case Constants.LADD:\n            case Constants.FADD:\n            case Constants.DADD:\n            case Constants.ISUB:\n            case Constants.LSUB:\n            case Constants.FSUB:\n            case Constants.DSUB:\n            case Constants.IMUL:\n            case Constants.LMUL:\n            case Constants.FMUL:\n            case Constants.DMUL:\n            case Constants.IDIV:\n            case Constants.LDIV:\n            case Constants.FDIV:\n            case Constants.DDIV:\n            case Constants.IREM:\n            case Constants.LREM:\n            case Constants.FREM:\n            case Constants.DREM:\n            case Constants.INEG:\n            case Constants.LNEG:\n            case Constants.FNEG:\n            case Constants.DNEG:\n            case Constants.ISHL:\n            case Constants.LSHL:\n            case Constants.ISHR:\n            case Constants.LSHR:\n            case Constants.IUSHR:\n            case Constants.LUSHR:\n            case Constants.IAND:\n            case Constants.LAND:\n            case Constants.IOR:\n            case Constants.LOR:\n            case Constants.IXOR:\n            case Constants.LXOR:\n            case Constants.I2L:\n            case Constants.I2F:\n            case Constants.I2D:\n            case Constants.L2I:\n            case Constants.L2F:\n            case Constants.L2D:\n            case Constants.F2I:\n            case Constants.F2L:\n            case Constants.F2D:\n            case Constants.D2I:\n            case Constants.D2L:\n            case Constants.D2F:\n            case Constants.I2B:\n            case Constants.I2C:\n            case Constants.I2S:\n            case Constants.LCMP:\n            case Constants.FCMPL:\n            case Constants.FCMPG:\n            case Constants.DCMPL:\n            case Constants.DCMPG:\n            case Constants.IRETURN:\n            case Constants.LRETURN:\n            case Constants.FRETURN:\n            case Constants.DRETURN:\n            case Constants.ARETURN:\n            case Constants.RETURN:\n            case Constants.ARRAYLENGTH:\n            case Constants.ATHROW:\n            case Constants.MONITORENTER:\n            case Constants.MONITOREXIT:\n                methodVisitor.visitInsn(opcode);\n                currentOffset += 1;\n                break;\n            case Constants.ILOAD_0:\n            case Constants.ILOAD_1:\n            case Constants.ILOAD_2:\n            case Constants.ILOAD_3:\n            case Constants.LLOAD_0:\n            case Constants.LLOAD_1:\n            case Constants.LLOAD_2:\n            case Constants.LLOAD_3:\n            case Constants.FLOAD_0:\n            case Constants.FLOAD_1:\n            case Constants.FLOAD_2:\n            case Constants.FLOAD_3:\n            case Constants.DLOAD_0:\n            case Constants.DLOAD_1:\n            case Constants.DLOAD_2:\n            case Constants.DLOAD_3:\n            case Constants.ALOAD_0:\n            case Constants.ALOAD_1:\n            case Constants.ALOAD_2:\n            case Constants.ALOAD_3:\n                opcode -= Constants.ILOAD_0;\n                methodVisitor.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\n                currentOffset += 1;\n                break;\n            case Constants.ISTORE_0:\n            case Constants.ISTORE_1:\n            case Constants.ISTORE_2:\n            case Constants.ISTORE_3:\n            case Constants.LSTORE_0:\n            case Constants.LSTORE_1:\n            case Constants.LSTORE_2:\n            case Constants.LSTORE_3:\n            case Constants.FSTORE_0:\n            case Constants.FSTORE_1:\n            case Constants.FSTORE_2:\n            case Constants.FSTORE_3:\n            case Constants.DSTORE_0:\n            case Constants.DSTORE_1:\n            case Constants.DSTORE_2:\n            case Constants.DSTORE_3:\n            case Constants.ASTORE_0:\n            case Constants.ASTORE_1:\n            case Constants.ASTORE_2:\n            case Constants.ASTORE_3:\n                opcode -= Constants.ISTORE_0;\n                methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);\n                currentOffset += 1;\n                break;\n            case Constants.IFEQ:\n            case Constants.IFNE:\n            case Constants.IFLT:\n            case Constants.IFGE:\n            case Constants.IFGT:\n            case Constants.IFLE:\n            case Constants.IF_ICMPEQ:\n            case Constants.IF_ICMPNE:\n            case Constants.IF_ICMPLT:\n            case Constants.IF_ICMPGE:\n            case Constants.IF_ICMPGT:\n            case Constants.IF_ICMPLE:\n            case Constants.IF_ACMPEQ:\n            case Constants.IF_ACMPNE:\n            case Constants.GOTO:\n            case Constants.JSR:\n            case Constants.IFNULL:\n            case Constants.IFNONNULL:\n                methodVisitor.visitJumpInsn(opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);\n                currentOffset += 3;\n                break;\n            case Constants.GOTO_W:\n            case Constants.JSR_W:\n                methodVisitor.visitJumpInsn(opcode - wideJumpOpcodeDelta, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);\n                currentOffset += 5;\n                break;\n            case Constants.ASM_IFEQ:\n            case Constants.ASM_IFNE:\n            case Constants.ASM_IFLT:\n            case Constants.ASM_IFGE:\n            case Constants.ASM_IFGT:\n            case Constants.ASM_IFLE:\n            case Constants.ASM_IF_ICMPEQ:\n            case Constants.ASM_IF_ICMPNE:\n            case Constants.ASM_IF_ICMPLT:\n            case Constants.ASM_IF_ICMPGE:\n            case Constants.ASM_IF_ICMPGT:\n            case Constants.ASM_IF_ICMPLE:\n            case Constants.ASM_IF_ACMPEQ:\n            case Constants.ASM_IF_ACMPNE:\n            case Constants.ASM_GOTO:\n            case Constants.ASM_JSR:\n            case Constants.ASM_IFNULL:\n            case Constants.ASM_IFNONNULL: {\n                // A forward jump with an offset > 32767. In this case we automatically replace ASM_GOTO\n                // with GOTO_W, ASM_JSR with JSR_W and ASM_IFxxx <l> with IFNOTxxx <L> GOTO_W <l> L:...,\n                // where IFNOTxxx is the \"opposite\" opcode of ASMS_IFxxx (e.g. IFNE for ASM_IFEQ) and\n                // where <L> designates the instruction just after the GOTO_W.\n                // First, change the ASM specific opcodes ASM_IFEQ ... ASM_JSR, ASM_IFNULL and\n                // ASM_IFNONNULL to IFEQ ... JSR, IFNULL and IFNONNULL.\n                opcode = opcode < Constants.ASM_IFNULL ? opcode - Constants.ASM_OPCODE_DELTA : opcode - Constants.ASM_IFNULL_OPCODE_DELTA;\n                Label target = labels[currentBytecodeOffset + readUnsignedShort(currentOffset + 1)];\n                if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {\n                    // Replace GOTO with GOTO_W and JSR with JSR_W.\n                    methodVisitor.visitJumpInsn(opcode + Constants.WIDE_JUMP_OPCODE_DELTA, target);\n                } else {\n                    // Compute the \"opposite\" of opcode. This can be done by flipping the least\n                    // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ\n                    // (with a pre and post offset by 1).\n                    opcode = opcode < Opcodes.GOTO ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1;\n                    Label endif = createLabel(currentBytecodeOffset + 3, labels);\n                    methodVisitor.visitJumpInsn(opcode, endif);\n                    methodVisitor.visitJumpInsn(Constants.GOTO_W, target);\n                    // endif designates the instruction just after GOTO_W, and is visited as part of the\n                    // next instruction. Since it is a jump target, we need to insert a frame here.\n                    insertFrame = true;\n                }\n                currentOffset += 3;\n                break;\n            }\n            case Constants.ASM_GOTO_W:\n                // Replace ASM_GOTO_W with GOTO_W.\n                methodVisitor.visitJumpInsn(Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);\n                // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns\n                // IFNOTxxx <L> ASM_GOTO_W <l> L:..., see MethodWriter), so we need to insert a frame\n                // here.\n                insertFrame = true;\n                currentOffset += 5;\n                break;\n            case Constants.WIDE:\n                opcode = classBuffer[currentOffset + 1] & 0xFF;\n                if (opcode == Opcodes.IINC) {\n                    methodVisitor.visitIincInsn(readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));\n                    currentOffset += 6;\n                } else {\n                    methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));\n                    currentOffset += 4;\n                }\n                break;\n            case Constants.TABLESWITCH: {\n                // Skip 0 to 3 padding bytes.\n                currentOffset += 4 - (currentBytecodeOffset & 3);\n                // Read the instruction.\n                Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];\n                int low = readInt(currentOffset + 4);\n                int high = readInt(currentOffset + 8);\n                currentOffset += 12;\n                Label[] table = new Label[high - low + 1];\n                for (int i = 0; i < table.length; ++i) {\n                    table[i] = labels[currentBytecodeOffset + readInt(currentOffset)];\n                    currentOffset += 4;\n                }\n                methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);\n                break;\n            }\n            case Constants.LOOKUPSWITCH: {\n                // Skip 0 to 3 padding bytes.\n                currentOffset += 4 - (currentBytecodeOffset & 3);\n                // Read the instruction.\n                Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];\n                int numPairs = readInt(currentOffset + 4);\n                currentOffset += 8;\n                int[] keys = new int[numPairs];\n                Label[] values = new Label[numPairs];\n                for (int i = 0; i < numPairs; ++i) {\n                    keys[i] = readInt(currentOffset);\n                    values[i] = labels[currentBytecodeOffset + readInt(currentOffset + 4)];\n                    currentOffset += 8;\n                }\n                methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);\n                break;\n            }\n            case Constants.ILOAD:\n            case Constants.LLOAD:\n            case Constants.FLOAD:\n            case Constants.DLOAD:\n            case Constants.ALOAD:\n            case Constants.ISTORE:\n            case Constants.LSTORE:\n            case Constants.FSTORE:\n            case Constants.DSTORE:\n            case Constants.ASTORE:\n            case Constants.RET:\n                methodVisitor.visitVarInsn(opcode, classBuffer[currentOffset + 1] & 0xFF);\n                currentOffset += 2;\n                break;\n            case Constants.BIPUSH:\n            case Constants.NEWARRAY:\n                methodVisitor.visitIntInsn(opcode, classBuffer[currentOffset + 1]);\n                currentOffset += 2;\n                break;\n            case Constants.SIPUSH:\n                methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));\n                currentOffset += 3;\n                break;\n            case Constants.LDC:\n                methodVisitor.visitLdcInsn(readConst(classBuffer[currentOffset + 1] & 0xFF, charBuffer));\n                currentOffset += 2;\n                break;\n            case Constants.LDC_W:\n            case Constants.LDC2_W:\n                methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));\n                currentOffset += 3;\n                break;\n            case Constants.GETSTATIC:\n            case Constants.PUTSTATIC:\n            case Constants.GETFIELD:\n            case Constants.PUTFIELD:\n            case Constants.INVOKEVIRTUAL:\n            case Constants.INVOKESPECIAL:\n            case Constants.INVOKESTATIC:\n            case Constants.INVOKEINTERFACE: {\n                int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];\n                int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\n                String owner = readClass(cpInfoOffset, charBuffer);\n                String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\n                String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\n                if (opcode < Opcodes.INVOKEVIRTUAL) {\n                    methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);\n                } else {\n                    boolean isInterface = classBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;\n                    methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n                }\n                if (opcode == Opcodes.INVOKEINTERFACE) {\n                    currentOffset += 5;\n                } else {\n                    currentOffset += 3;\n                }\n                break;\n            }\n            case Constants.INVOKEDYNAMIC: {\n                int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];\n                int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\n                String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\n                String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\n                int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];\n                Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\n                Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];\n                bootstrapMethodOffset += 4;\n                for (int i = 0; i < bootstrapMethodArguments.length; i++) {\n                    bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\n                    bootstrapMethodOffset += 2;\n                }\n                methodVisitor.visitInvokeDynamicInsn(name, descriptor, handle, bootstrapMethodArguments);\n                currentOffset += 5;\n                break;\n            }\n            case Constants.NEW:\n            case Constants.ANEWARRAY:\n            case Constants.CHECKCAST:\n            case Constants.INSTANCEOF:\n                methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));\n                currentOffset += 3;\n                break;\n            case Constants.IINC:\n                methodVisitor.visitIincInsn(classBuffer[currentOffset + 1] & 0xFF, classBuffer[currentOffset + 2]);\n                currentOffset += 3;\n                break;\n            case Constants.MULTIANEWARRAY:\n                methodVisitor.visitMultiANewArrayInsn(readClass(currentOffset + 1, charBuffer), classBuffer[currentOffset + 3] & 0xFF);\n                currentOffset += 4;\n                break;\n            default:\n                throw new AssertionError();\n            }\n            // Visit the runtime visible instruction annotations, if any.\n            while (visibleTypeAnnotationOffsets != null && currentVisibleTypeAnnotationIndex < visibleTypeAnnotationOffsets.length && currentVisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {\n                if (currentVisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {\n                    // Parse the target_type, target_info and target_path fields.\n                    int currentAnnotationOffset = readTypeAnnotationTarget(context, visibleTypeAnnotationOffsets[currentVisibleTypeAnnotationIndex]);\n                    // Parse the type_index field.\n                    String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                    currentAnnotationOffset += 2;\n                    // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                    readElementValues(methodVisitor.visitInsnAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                            /* visible = */ true), currentAnnotationOffset,\n                            /* named = */ true, charBuffer);\n                }\n                currentVisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, ++currentVisibleTypeAnnotationIndex);\n            }\n            // Visit the runtime invisible instruction annotations, if any.\n            while (invisibleTypeAnnotationOffsets != null && currentInvisibleTypeAnnotationIndex < invisibleTypeAnnotationOffsets.length && currentInvisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {\n                if (currentInvisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {\n                    // Parse the target_type, target_info and target_path fields.\n                    int currentAnnotationOffset = readTypeAnnotationTarget(context, invisibleTypeAnnotationOffsets[currentInvisibleTypeAnnotationIndex]);\n                    // Parse the type_index field.\n                    String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                    currentAnnotationOffset += 2;\n                    // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                    readElementValues(methodVisitor.visitInsnAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                            /* visible = */ false), currentAnnotationOffset,\n                            /* named = */ true, charBuffer);\n                }\n                currentInvisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, ++currentInvisibleTypeAnnotationIndex);\n            }\n        }\n        if (labels[codeLength] != null) {\n            methodVisitor.visitLabel(labels[codeLength]);\n        }\n        // Visit LocalVariableTable and LocalVariableTypeTable attributes.\n        if (localVariableTableOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {\n            // The (start_pc, index, signature_index) fields of each entry of the LocalVariableTypeTable.\n            int[] typeTable = null;\n            if (localVariableTypeTableOffset != 0) {\n                typeTable = new int[readUnsignedShort(localVariableTypeTableOffset) * 3];\n                currentOffset = localVariableTypeTableOffset + 2;\n                int typeTableIndex = typeTable.length;\n                while (typeTableIndex > 0) {\n                    // Store the offset of 'signature_index', and the value of 'index' and 'start_pc'.\n                    typeTable[--typeTableIndex] = currentOffset + 6;\n                    typeTable[--typeTableIndex] = readUnsignedShort(currentOffset + 8);\n                    typeTable[--typeTableIndex] = readUnsignedShort(currentOffset);\n                    currentOffset += 10;\n                }\n            }\n            int localVariableTableLength = readUnsignedShort(localVariableTableOffset);\n            currentOffset = localVariableTableOffset + 2;\n            while (localVariableTableLength-- > 0) {\n                int startPc = readUnsignedShort(currentOffset);\n                int length = readUnsignedShort(currentOffset + 2);\n                String name = readUTF8(currentOffset + 4, charBuffer);\n                String descriptor = readUTF8(currentOffset + 6, charBuffer);\n                int index = readUnsignedShort(currentOffset + 8);\n                currentOffset += 10;\n                String signature = null;\n                if (typeTable != null) {\n                    for (int i = 0; i < typeTable.length; i += 3) {\n                        if (typeTable[i] == startPc && typeTable[i + 1] == index) {\n                            signature = readUTF8(typeTable[i + 2], charBuffer);\n                            break;\n                        }\n                    }\n                }\n                methodVisitor.visitLocalVariable(name, descriptor, signature, labels[startPc], labels[startPc + length], index);\n            }\n        }\n        // Visit the local variable type annotations of the RuntimeVisibleTypeAnnotations attribute.\n        if (visibleTypeAnnotationOffsets != null) {\n            for (int typeAnnotationOffset : visibleTypeAnnotationOffsets) {\n                int targetType = readByte(typeAnnotationOffset);\n                if (targetType == TypeReference.LOCAL_VARIABLE || targetType == TypeReference.RESOURCE_VARIABLE) {\n                    // Parse the target_type, target_info and target_path fields.\n                    currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);\n                    // Parse the type_index field.\n                    String annotationDescriptor = readUTF8(currentOffset, charBuffer);\n                    currentOffset += 2;\n                    // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                    readElementValues(methodVisitor.visitLocalVariableAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, context.currentLocalVariableAnnotationRangeStarts, context.currentLocalVariableAnnotationRangeEnds, context.currentLocalVariableAnnotationRangeIndices, annotationDescriptor,\n                            /* visible = */ true), currentOffset,\n                            /* named = */ true, charBuffer);\n                }\n            }\n        }\n        // Visit the local variable type annotations of the RuntimeInvisibleTypeAnnotations attribute.\n        if (invisibleTypeAnnotationOffsets != null) {\n            for (int typeAnnotationOffset : invisibleTypeAnnotationOffsets) {\n                int targetType = readByte(typeAnnotationOffset);\n                if (targetType == TypeReference.LOCAL_VARIABLE || targetType == TypeReference.RESOURCE_VARIABLE) {\n                    // Parse the target_type, target_info and target_path fields.\n                    currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);\n                    // Parse the type_index field.\n                    String annotationDescriptor = readUTF8(currentOffset, charBuffer);\n                    currentOffset += 2;\n                    // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                    readElementValues(methodVisitor.visitLocalVariableAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, context.currentLocalVariableAnnotationRangeStarts, context.currentLocalVariableAnnotationRangeEnds, context.currentLocalVariableAnnotationRangeIndices, annotationDescriptor,\n                            /* visible = */ false), currentOffset,\n                            /* named = */ true, charBuffer);\n                }\n            }\n        }\n        // Visit the non standard attributes.\n        while (attributes != null) {\n            // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.\n            Attribute nextAttribute = attributes.nextAttribute;\n            attributes.nextAttribute = null;\n            methodVisitor.visitAttribute(attributes);\n            attributes = nextAttribute;\n        }\n        // Visit the max stack and max locals values.\n        methodVisitor.visitMaxs(maxStack, maxLocals);\n    }\n\n    /**\n     * Returns the label corresponding to the given bytecode offset. The default implementation of\n     * this method creates a label for the given offset if it has not been already created.\n     *\n     * @param bytecodeOffset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset. If a label already exists\n     *     for bytecodeOffset this method must not create a new one. Otherwise it must store the new\n     *     label in this array.\n     * @return a non null Label, which must be equal to labels[bytecodeOffset].\n     */\n    protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n        if (labels[bytecodeOffset] == null) {\n            labels[bytecodeOffset] = new Label();\n        }\n        return labels[bytecodeOffset];\n    }\n\n    /**\n     * Creates a label without the {@link Label#FLAG_DEBUG_ONLY} flag set, for the given bytecode\n     * offset. The label is created with a call to {@link #readLabel} and its {@link\n     * Label#FLAG_DEBUG_ONLY} flag is cleared.\n     *\n     * @param bytecodeOffset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset.\n     * @return a Label without the {@link Label#FLAG_DEBUG_ONLY} flag set.\n     */\n    private Label createLabel(final int bytecodeOffset, final Label[] labels) {\n        Label label = readLabel(bytecodeOffset, labels);\n        label.flags &= ~Label.FLAG_DEBUG_ONLY;\n        return label;\n    }\n\n    /**\n     * Creates a label with the {@link Label#FLAG_DEBUG_ONLY} flag set, if there is no already\n     * existing label for the given bytecode offset (otherwise does nothing). The label is created\n     * with a call to {@link #readLabel}.\n     *\n     * @param bytecodeOffset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset.\n     */\n    private void createDebugLabel(final int bytecodeOffset, final Label[] labels) {\n        if (labels[bytecodeOffset] == null) {\n            readLabel(bytecodeOffset, labels).flags |= Label.FLAG_DEBUG_ONLY;\n        }\n    }\n    // ----------------------------------------------------------------------------------------------\n    // Methods to parse annotations, type annotations and parameter annotations\n    // ----------------------------------------------------------------------------------------------\n\n    /**\n     * Parses a Runtime[In]VisibleTypeAnnotations attribute to find the offset of each type_annotation\n     * entry it contains, to find the corresponding labels, and to visit the try catch block\n     * annotations.\n     *\n     * @param methodVisitor the method visitor to be used to visit the try catch block annotations.\n     * @param context information about the class being parsed.\n     * @param runtimeTypeAnnotationsOffset the start offset of a Runtime[In]VisibleTypeAnnotations\n     *     attribute, excluding the attribute_info's attribute_name_index and attribute_length fields.\n     * @param visible true if the attribute to parse is a RuntimeVisibleTypeAnnotations attribute,\n     *     false it is a RuntimeInvisibleTypeAnnotations attribute.\n     * @return the start offset of each entry of the Runtime[In]VisibleTypeAnnotations_attribute's\n     *     'annotations' array field.\n     */\n    private int[] readTypeAnnotations(final MethodVisitor methodVisitor, final Context context, final int runtimeTypeAnnotationsOffset, final boolean visible) {\n        char[] charBuffer = context.charBuffer;\n        int currentOffset = runtimeTypeAnnotationsOffset;\n        // Read the num_annotations field and create an array to store the type_annotation offsets.\n        int[] typeAnnotationsOffsets = new int[readUnsignedShort(currentOffset)];\n        currentOffset += 2;\n        // Parse the 'annotations' array field.\n        for (int i = 0; i < typeAnnotationsOffsets.length; ++i) {\n            typeAnnotationsOffsets[i] = currentOffset;\n            // Parse the type_annotation's target_type and the target_info fields. The size of the\n            // target_info field depends on the value of target_type.\n            int targetType = readInt(currentOffset);\n            switch (targetType >>> 24) {\n            case TypeReference.LOCAL_VARIABLE:\n            case TypeReference.RESOURCE_VARIABLE:\n                // A localvar_target has a variable size, which depends on the value of their table_length\n                // field. It also references bytecode offsets, for which we need labels.\n                int tableLength = readUnsignedShort(currentOffset + 1);\n                currentOffset += 3;\n                while (tableLength-- > 0) {\n                    int startPc = readUnsignedShort(currentOffset);\n                    int length = readUnsignedShort(currentOffset + 2);\n                    // Skip the index field (2 bytes).\n                    currentOffset += 6;\n                    createLabel(startPc, context.currentMethodLabels);\n                    createLabel(startPc + length, context.currentMethodLabels);\n                }\n                break;\n            case TypeReference.CAST:\n            case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\n            case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:\n            case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\n            case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:\n                currentOffset += 4;\n                break;\n            case TypeReference.CLASS_EXTENDS:\n            case TypeReference.CLASS_TYPE_PARAMETER_BOUND:\n            case TypeReference.METHOD_TYPE_PARAMETER_BOUND:\n            case TypeReference.THROWS:\n            case TypeReference.EXCEPTION_PARAMETER:\n            case TypeReference.INSTANCEOF:\n            case TypeReference.NEW:\n            case TypeReference.CONSTRUCTOR_REFERENCE:\n            case TypeReference.METHOD_REFERENCE:\n                currentOffset += 3;\n                break;\n            case TypeReference.CLASS_TYPE_PARAMETER:\n            case TypeReference.METHOD_TYPE_PARAMETER:\n            case TypeReference.METHOD_FORMAL_PARAMETER:\n            case TypeReference.FIELD:\n            case TypeReference.METHOD_RETURN:\n            case TypeReference.METHOD_RECEIVER:\n            default:\n                // TypeReference type which can't be used in Code attribute, or which is unknown.\n                throw new IllegalArgumentException();\n            }\n            // Parse the rest of the type_annotation structure, starting with the target_path structure\n            // (whose size depends on its path_length field).\n            int pathLength = readByte(currentOffset);\n            if ((targetType >>> 24) == TypeReference.EXCEPTION_PARAMETER) {\n                // Parse the target_path structure and create a corresponding TypePath.\n                TypePath path = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);\n                currentOffset += 1 + 2 * pathLength;\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentOffset, charBuffer);\n                currentOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentOffset = readElementValues(methodVisitor.visitTryCatchAnnotation(targetType & 0xFFFFFF00, path, annotationDescriptor, visible), currentOffset,\n                        /* named = */ true, charBuffer);\n            } else {\n                // We don't want to visit the other target_type annotations, so we just skip them (which\n                // requires some parsing because the element_value_pairs array has a variable size). First,\n                // skip the target_path structure:\n                currentOffset += 3 + 2 * pathLength;\n                // Then skip the num_element_value_pairs and element_value_pairs fields (by reading them\n                // with a null AnnotationVisitor).\n                currentOffset = readElementValues(\n                        /* annotationVisitor = */ null, currentOffset, /* named = */ true, charBuffer);\n            }\n        }\n        return typeAnnotationsOffsets;\n    }\n\n    /**\n     * Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or\n     * -1 if there is no such type_annotation of if it does not have a bytecode offset.\n     *\n     * @param typeAnnotationOffsets the offset of each 'type_annotation' entry in a\n     *     Runtime[In]VisibleTypeAnnotations attribute, or {@literal null}.\n     * @param typeAnnotationIndex the index a 'type_annotation' entry in typeAnnotationOffsets.\n     * @return bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or -1\n     *     if there is no such type_annotation of if it does not have a bytecode offset.\n     */\n    private int getTypeAnnotationBytecodeOffset(final int[] typeAnnotationOffsets, final int typeAnnotationIndex) {\n        if (typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets.length || readByte(typeAnnotationOffsets[typeAnnotationIndex]) < TypeReference.INSTANCEOF) {\n            return -1;\n        }\n        return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1);\n    }\n\n    /**\n     * Parses the header of a JVMS type_annotation structure to extract its target_type, target_info\n     * and target_path (the result is stored in the given context), and returns the start offset of\n     * the rest of the type_annotation structure.\n     *\n     * @param context information about the class being parsed. This is where the extracted\n     *     target_type and target_path must be stored.\n     * @param typeAnnotationOffset the start offset of a type_annotation structure.\n     * @return the start offset of the rest of the type_annotation structure.\n     */\n    private int readTypeAnnotationTarget(final Context context, final int typeAnnotationOffset) {\n        int currentOffset = typeAnnotationOffset;\n        // Parse and store the target_type structure.\n        int targetType = readInt(typeAnnotationOffset);\n        switch (targetType >>> 24) {\n        case TypeReference.CLASS_TYPE_PARAMETER:\n        case TypeReference.METHOD_TYPE_PARAMETER:\n        case TypeReference.METHOD_FORMAL_PARAMETER:\n            targetType &= 0xFFFF0000;\n            currentOffset += 2;\n            break;\n        case TypeReference.FIELD:\n        case TypeReference.METHOD_RETURN:\n        case TypeReference.METHOD_RECEIVER:\n            targetType &= 0xFF000000;\n            currentOffset += 1;\n            break;\n        case TypeReference.LOCAL_VARIABLE:\n        case TypeReference.RESOURCE_VARIABLE:\n            targetType &= 0xFF000000;\n            int tableLength = readUnsignedShort(currentOffset + 1);\n            currentOffset += 3;\n            context.currentLocalVariableAnnotationRangeStarts = new Label[tableLength];\n            context.currentLocalVariableAnnotationRangeEnds = new Label[tableLength];\n            context.currentLocalVariableAnnotationRangeIndices = new int[tableLength];\n            for (int i = 0; i < tableLength; ++i) {\n                int startPc = readUnsignedShort(currentOffset);\n                int length = readUnsignedShort(currentOffset + 2);\n                int index = readUnsignedShort(currentOffset + 4);\n                currentOffset += 6;\n                context.currentLocalVariableAnnotationRangeStarts[i] = createLabel(startPc, context.currentMethodLabels);\n                context.currentLocalVariableAnnotationRangeEnds[i] = createLabel(startPc + length, context.currentMethodLabels);\n                context.currentLocalVariableAnnotationRangeIndices[i] = index;\n            }\n            break;\n        case TypeReference.CAST:\n        case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\n        case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:\n        case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\n        case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:\n            targetType &= 0xFF0000FF;\n            currentOffset += 4;\n            break;\n        case TypeReference.CLASS_EXTENDS:\n        case TypeReference.CLASS_TYPE_PARAMETER_BOUND:\n        case TypeReference.METHOD_TYPE_PARAMETER_BOUND:\n        case TypeReference.THROWS:\n        case TypeReference.EXCEPTION_PARAMETER:\n            targetType &= 0xFFFFFF00;\n            currentOffset += 3;\n            break;\n        case TypeReference.INSTANCEOF:\n        case TypeReference.NEW:\n        case TypeReference.CONSTRUCTOR_REFERENCE:\n        case TypeReference.METHOD_REFERENCE:\n            targetType &= 0xFF000000;\n            currentOffset += 3;\n            break;\n        default:\n            throw new IllegalArgumentException();\n        }\n        context.currentTypeAnnotationTarget = targetType;\n        // Parse and store the target_path structure.\n        int pathLength = readByte(currentOffset);\n        context.currentTypeAnnotationTargetPath = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);\n        // Return the start offset of the rest of the type_annotation structure.\n        return currentOffset + 1 + 2 * pathLength;\n    }\n\n    /**\n     * Reads a Runtime[In]VisibleParameterAnnotations attribute and makes the given visitor visit it.\n     *\n     * @param methodVisitor the visitor that must visit the parameter annotations.\n     * @param context information about the class being parsed.\n     * @param runtimeParameterAnnotationsOffset the start offset of a\n     *     Runtime[In]VisibleParameterAnnotations attribute, excluding the attribute_info's\n     *     attribute_name_index and attribute_length fields.\n     * @param visible true if the attribute to parse is a RuntimeVisibleParameterAnnotations\n     *     attribute, false it is a RuntimeInvisibleParameterAnnotations attribute.\n     */\n    private void readParameterAnnotations(final MethodVisitor methodVisitor, final Context context, final int runtimeParameterAnnotationsOffset, final boolean visible) {\n        int currentOffset = runtimeParameterAnnotationsOffset;\n        int numParameters = classFileBuffer[currentOffset++] & 0xFF;\n        methodVisitor.visitAnnotableParameterCount(numParameters, visible);\n        char[] charBuffer = context.charBuffer;\n        for (int i = 0; i < numParameters; ++i) {\n            int numAnnotations = readUnsignedShort(currentOffset);\n            currentOffset += 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentOffset, charBuffer);\n                currentOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentOffset = readElementValues(methodVisitor.visitParameterAnnotation(i, annotationDescriptor, visible), currentOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n    }\n\n    /**\n     * Reads the element values of a JVMS 'annotation' structure and makes the given visitor visit\n     * them. This method can also be used to read the values of the JVMS 'array_value' field of an\n     * annotation's 'element_value'.\n     *\n     * @param annotationVisitor the visitor that must visit the values.\n     * @param annotationOffset the start offset of an 'annotation' structure (excluding its type_index\n     *     field) or of an 'array_value' structure.\n     * @param named if the annotation values are named or not. This should be true to parse the values\n     *     of a JVMS 'annotation' structure, and false to parse the JVMS 'array_value' of an\n     *     annotation's element_value.\n     * @param charBuffer the buffer used to read strings in the constant pool.\n     * @return the end offset of the JVMS 'annotation' or 'array_value' structure.\n     */\n    private int readElementValues(final AnnotationVisitor annotationVisitor, final int annotationOffset, final boolean named, final char[] charBuffer) {\n        int currentOffset = annotationOffset;\n        // Read the num_element_value_pairs field (or num_values field for an array_value).\n        int numElementValuePairs = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        if (named) {\n            // Parse the element_value_pairs array.\n            while (numElementValuePairs-- > 0) {\n                String elementName = readUTF8(currentOffset, charBuffer);\n                currentOffset = readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer);\n            }\n        } else {\n            // Parse the array_value array.\n            while (numElementValuePairs-- > 0) {\n                currentOffset = readElementValue(annotationVisitor, currentOffset, /* named = */ null, charBuffer);\n            }\n        }\n        if (annotationVisitor != null) {\n            annotationVisitor.visitEnd();\n        }\n        return currentOffset;\n    }\n\n    /**\n     * Reads a JVMS 'element_value' structure and makes the given visitor visit it.\n     *\n     * @param annotationVisitor the visitor that must visit the element_value structure.\n     * @param elementValueOffset the start offset in {@link #classFileBuffer} of the element_value\n     *     structure to be read.\n     * @param elementName the name of the element_value structure to be read, or {@literal null}.\n     * @param charBuffer the buffer used to read strings in the constant pool.\n     * @return the end offset of the JVMS 'element_value' structure.\n     */\n    private int readElementValue(final AnnotationVisitor annotationVisitor, final int elementValueOffset, final String elementName, final char[] charBuffer) {\n        int currentOffset = elementValueOffset;\n        if (annotationVisitor == null) {\n            switch (classFileBuffer[currentOffset] & 0xFF) {\n            case 'e': // enum_const_value\n                return currentOffset + 5;\n            case '@': // annotation_value\n                return readElementValues(null, currentOffset + 3, /* named = */ true, charBuffer);\n            case '[': // array_value\n                return readElementValues(null, currentOffset + 1, /* named = */ false, charBuffer);\n            default:\n                return currentOffset + 3;\n            }\n        }\n        switch (classFileBuffer[currentOffset++] & 0xFF) {\n        case 'B': // const_value_index, CONSTANT_Integer\n            annotationVisitor.visit(elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\n            currentOffset += 2;\n            break;\n        case 'C': // const_value_index, CONSTANT_Integer\n            annotationVisitor.visit(elementName, (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\n            currentOffset += 2;\n            break;\n        case 'D': // const_value_index, CONSTANT_Double\n        case 'F': // const_value_index, CONSTANT_Float\n        case 'I': // const_value_index, CONSTANT_Integer\n        case 'J': // const_value_index, CONSTANT_Long\n            annotationVisitor.visit(elementName, readConst(readUnsignedShort(currentOffset), charBuffer));\n            currentOffset += 2;\n            break;\n        case 'S': // const_value_index, CONSTANT_Integer\n            annotationVisitor.visit(elementName, (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\n            currentOffset += 2;\n            break;\n        case 'Z': // const_value_index, CONSTANT_Integer\n            annotationVisitor.visit(elementName, readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\n            currentOffset += 2;\n            break;\n        case 's': // const_value_index, CONSTANT_Utf8\n            annotationVisitor.visit(elementName, readUTF8(currentOffset, charBuffer));\n            currentOffset += 2;\n            break;\n        case 'e': // enum_const_value\n            annotationVisitor.visitEnum(elementName, readUTF8(currentOffset, charBuffer), readUTF8(currentOffset + 2, charBuffer));\n            currentOffset += 4;\n            break;\n        case 'c': // class_info\n            annotationVisitor.visit(elementName, Type.getType(readUTF8(currentOffset, charBuffer)));\n            currentOffset += 2;\n            break;\n        case '@': // annotation_value\n            currentOffset = readElementValues(annotationVisitor.visitAnnotation(elementName, readUTF8(currentOffset, charBuffer)), currentOffset + 2, true, charBuffer);\n            break;\n        case '[': // array_value\n            int numValues = readUnsignedShort(currentOffset);\n            currentOffset += 2;\n            if (numValues == 0) {\n                return readElementValues(annotationVisitor.visitArray(elementName), currentOffset - 2,\n                        /* named = */ false, charBuffer);\n            }\n            switch (classFileBuffer[currentOffset] & 0xFF) {\n            case 'B':\n                byte[] byteValues = new byte[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, byteValues);\n                break;\n            case 'Z':\n                boolean[] booleanValues = new boolean[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    booleanValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]) != 0;\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, booleanValues);\n                break;\n            case 'S':\n                short[] shortValues = new short[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    shortValues[i] = (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, shortValues);\n                break;\n            case 'C':\n                char[] charValues = new char[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    charValues[i] = (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, charValues);\n                break;\n            case 'I':\n                int[] intValues = new int[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    intValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, intValues);\n                break;\n            case 'J':\n                long[] longValues = new long[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    longValues[i] = readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, longValues);\n                break;\n            case 'F':\n                float[] floatValues = new float[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    floatValues[i] = Float.intBitsToFloat(readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, floatValues);\n                break;\n            case 'D':\n                double[] doubleValues = new double[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    doubleValues[i] = Double.longBitsToDouble(readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, doubleValues);\n                break;\n            default:\n                currentOffset = readElementValues(annotationVisitor.visitArray(elementName), currentOffset - 2,\n                        /* named = */ false, charBuffer);\n                break;\n            }\n            break;\n        default:\n            throw new IllegalArgumentException();\n        }\n        return currentOffset;\n    }\n    // ----------------------------------------------------------------------------------------------\n    // Methods to parse stack map frames\n    // ----------------------------------------------------------------------------------------------\n\n    /**\n     * Computes the implicit frame of the method currently being parsed (as defined in the given\n     * {@link Context}) and stores it in the given context.\n     *\n     * @param context information about the class being parsed.\n     */\n    private void computeImplicitFrame(final Context context) {\n        String methodDescriptor = context.currentMethodDescriptor;\n        Object[] locals = context.currentFrameLocalTypes;\n        int numLocal = 0;\n        if ((context.currentMethodAccessFlags & Opcodes.ACC_STATIC) == 0) {\n            if (\"<init>\".equals(context.currentMethodName)) {\n                locals[numLocal++] = Opcodes.UNINITIALIZED_THIS;\n            } else {\n                locals[numLocal++] = readClass(header + 2, context.charBuffer);\n            }\n        }\n        // Parse the method descriptor, one argument type descriptor at each iteration. Start by\n        // skipping the first method descriptor character, which is always '('.\n        int currentMethodDescritorOffset = 1;\n        while (true) {\n            int currentArgumentDescriptorStartOffset = currentMethodDescritorOffset;\n            switch (methodDescriptor.charAt(currentMethodDescritorOffset++)) {\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                locals[numLocal++] = Opcodes.INTEGER;\n                break;\n            case 'F':\n                locals[numLocal++] = Opcodes.FLOAT;\n                break;\n            case 'J':\n                locals[numLocal++] = Opcodes.LONG;\n                break;\n            case 'D':\n                locals[numLocal++] = Opcodes.DOUBLE;\n                break;\n            case '[':\n                while (methodDescriptor.charAt(currentMethodDescritorOffset) == '[') {\n                    ++currentMethodDescritorOffset;\n                }\n                if (methodDescriptor.charAt(currentMethodDescritorOffset) == 'L') {\n                    ++currentMethodDescritorOffset;\n                    while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {\n                        ++currentMethodDescritorOffset;\n                    }\n                }\n                locals[numLocal++] = methodDescriptor.substring(currentArgumentDescriptorStartOffset, ++currentMethodDescritorOffset);\n                break;\n            case 'L':\n                while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {\n                    ++currentMethodDescritorOffset;\n                }\n                locals[numLocal++] = methodDescriptor.substring(currentArgumentDescriptorStartOffset + 1, currentMethodDescritorOffset++);\n                break;\n            default:\n                context.currentFrameLocalCount = numLocal;\n                return;\n            }\n        }\n    }\n\n    /**\n     * Reads a JVMS 'stack_map_frame' structure and stores the result in the given {@link Context}\n     * object. This method can also be used to read a full_frame structure, excluding its frame_type\n     * field (this is used to parse the legacy StackMap attributes).\n     *\n     * @param stackMapFrameOffset the start offset in {@link #classFileBuffer} of the\n     *     stack_map_frame_value structure to be read, or the start offset of a full_frame structure\n     *     (excluding its frame_type field).\n     * @param compressed true to read a 'stack_map_frame' structure, false to read a 'full_frame'\n     *     structure without its frame_type field.\n     * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.\n     * @param context where the parsed stack map frame must be stored.\n     * @return the end offset of the JVMS 'stack_map_frame' or 'full_frame' structure.\n     */\n    private int readStackMapFrame(final int stackMapFrameOffset, final boolean compressed, final boolean expand, final Context context) {\n        int currentOffset = stackMapFrameOffset;\n        final char[] charBuffer = context.charBuffer;\n        final Label[] labels = context.currentMethodLabels;\n        int frameType;\n        if (compressed) {\n            // Read the frame_type field.\n            frameType = classFileBuffer[currentOffset++] & 0xFF;\n        } else {\n            frameType = Frame.FULL_FRAME;\n            context.currentFrameOffset = -1;\n        }\n        int offsetDelta;\n        context.currentFrameLocalCountDelta = 0;\n        if (frameType < Frame.SAME_LOCALS_1_STACK_ITEM_FRAME) {\n            offsetDelta = frameType;\n            context.currentFrameType = Opcodes.F_SAME;\n            context.currentFrameStackCount = 0;\n        } else if (frameType < Frame.RESERVED) {\n            offsetDelta = frameType - Frame.SAME_LOCALS_1_STACK_ITEM_FRAME;\n            currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);\n            context.currentFrameType = Opcodes.F_SAME1;\n            context.currentFrameStackCount = 1;\n        } else if (frameType >= Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n            offsetDelta = readUnsignedShort(currentOffset);\n            currentOffset += 2;\n            if (frameType == Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n                currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);\n                context.currentFrameType = Opcodes.F_SAME1;\n                context.currentFrameStackCount = 1;\n            } else if (frameType >= Frame.CHOP_FRAME && frameType < Frame.SAME_FRAME_EXTENDED) {\n                context.currentFrameType = Opcodes.F_CHOP;\n                context.currentFrameLocalCountDelta = Frame.SAME_FRAME_EXTENDED - frameType;\n                context.currentFrameLocalCount -= context.currentFrameLocalCountDelta;\n                context.currentFrameStackCount = 0;\n            } else if (frameType == Frame.SAME_FRAME_EXTENDED) {\n                context.currentFrameType = Opcodes.F_SAME;\n                context.currentFrameStackCount = 0;\n            } else if (frameType < Frame.FULL_FRAME) {\n                int local = expand ? context.currentFrameLocalCount : 0;\n                for (int k = frameType - Frame.SAME_FRAME_EXTENDED; k > 0; k--) {\n                    currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameLocalTypes, local++, charBuffer, labels);\n                }\n                context.currentFrameType = Opcodes.F_APPEND;\n                context.currentFrameLocalCountDelta = frameType - Frame.SAME_FRAME_EXTENDED;\n                context.currentFrameLocalCount += context.currentFrameLocalCountDelta;\n                context.currentFrameStackCount = 0;\n            } else {\n                final int numberOfLocals = readUnsignedShort(currentOffset);\n                currentOffset += 2;\n                context.currentFrameType = Opcodes.F_FULL;\n                context.currentFrameLocalCountDelta = numberOfLocals;\n                context.currentFrameLocalCount = numberOfLocals;\n                for (int local = 0; local < numberOfLocals; ++local) {\n                    currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameLocalTypes, local, charBuffer, labels);\n                }\n                final int numberOfStackItems = readUnsignedShort(currentOffset);\n                currentOffset += 2;\n                context.currentFrameStackCount = numberOfStackItems;\n                for (int stack = 0; stack < numberOfStackItems; ++stack) {\n                    currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, stack, charBuffer, labels);\n                }\n            }\n        } else {\n            throw new IllegalArgumentException();\n        }\n        context.currentFrameOffset += offsetDelta + 1;\n        createLabel(context.currentFrameOffset, labels);\n        return currentOffset;\n    }\n\n    /**\n     * Reads a JVMS 'verification_type_info' structure and stores it at the given index in the given\n     * array.\n     *\n     * @param verificationTypeInfoOffset the start offset of the 'verification_type_info' structure to\n     *     read.\n     * @param frame the array where the parsed type must be stored.\n     * @param index the index in 'frame' where the parsed type must be stored.\n     * @param charBuffer the buffer used to read strings in the constant pool.\n     * @param labels the labels of the method currently being parsed, indexed by their offset. If the\n     *     parsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is\n     *     stored in this array if it does not already exist.\n     * @return the end offset of the JVMS 'verification_type_info' structure.\n     */\n    private int readVerificationTypeInfo(final int verificationTypeInfoOffset, final Object[] frame, final int index, final char[] charBuffer, final Label[] labels) {\n        int currentOffset = verificationTypeInfoOffset;\n        int tag = classFileBuffer[currentOffset++] & 0xFF;\n        switch (tag) {\n        case Frame.ITEM_TOP:\n            frame[index] = Opcodes.TOP;\n            break;\n        case Frame.ITEM_INTEGER:\n            frame[index] = Opcodes.INTEGER;\n            break;\n        case Frame.ITEM_FLOAT:\n            frame[index] = Opcodes.FLOAT;\n            break;\n        case Frame.ITEM_DOUBLE:\n            frame[index] = Opcodes.DOUBLE;\n            break;\n        case Frame.ITEM_LONG:\n            frame[index] = Opcodes.LONG;\n            break;\n        case Frame.ITEM_NULL:\n            frame[index] = Opcodes.NULL;\n            break;\n        case Frame.ITEM_UNINITIALIZED_THIS:\n            frame[index] = Opcodes.UNINITIALIZED_THIS;\n            break;\n        case Frame.ITEM_OBJECT:\n            frame[index] = readClass(currentOffset, charBuffer);\n            currentOffset += 2;\n            break;\n        case Frame.ITEM_UNINITIALIZED:\n            frame[index] = createLabel(readUnsignedShort(currentOffset), labels);\n            currentOffset += 2;\n            break;\n        default:\n            throw new IllegalArgumentException();\n        }\n        return currentOffset;\n    }\n    // ----------------------------------------------------------------------------------------------\n    // Methods to parse attributes\n    // ----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array\n     * field entry.\n     *\n     * @return the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array\n     *     field entry.\n     */\n    final int getFirstAttributeOffset() {\n        // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes\n        // each), as well as the interfaces array field (2 bytes per interface).\n        int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;\n        // Read the fields_count field.\n        int fieldsCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        // Skip the 'fields' array field.\n        while (fieldsCount-- > 0) {\n            // Invariant: currentOffset is the offset of a field_info structure.\n            // Skip the access_flags, name_index and descriptor_index fields (2 bytes each), and read the\n            // attributes_count field.\n            int attributesCount = readUnsignedShort(currentOffset + 6);\n            currentOffset += 8;\n            // Skip the 'attributes' array field.\n            while (attributesCount-- > 0) {\n                // Invariant: currentOffset is the offset of an attribute_info structure.\n                // Read the attribute_length field (2 bytes after the start of the attribute_info) and skip\n                // this many bytes, plus 6 for the attribute_name_index and attribute_length fields\n                // (yielding the total size of the attribute_info structure).\n                currentOffset += 6 + readInt(currentOffset + 2);\n            }\n        }\n        // Skip the methods_count and 'methods' fields, using the same method as above.\n        int methodsCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (methodsCount-- > 0) {\n            int attributesCount = readUnsignedShort(currentOffset + 6);\n            currentOffset += 8;\n            while (attributesCount-- > 0) {\n                currentOffset += 6 + readInt(currentOffset + 2);\n            }\n        }\n        // Skip the ClassFile's attributes_count field.\n        return currentOffset + 2;\n    }\n\n    /**\n     * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.\n     *\n     * @param maxStringLength a conservative estimate of the maximum length of the strings contained\n     *     in the constant pool of the class.\n     * @return the offsets of the bootstrap methods.\n     */\n    private int[] readBootstrapMethodsAttribute(final int maxStringLength) {\n        char[] charBuffer = new char[maxStringLength];\n        int currentAttributeOffset = getFirstAttributeOffset();\n        int[] currentBootstrapMethodOffsets = null;\n        for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentAttributeOffset, charBuffer);\n            int attributeLength = readInt(currentAttributeOffset + 2);\n            currentAttributeOffset += 6;\n            if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n                // Read the num_bootstrap_methods field and create an array of this size.\n                currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];\n                // Compute and store the offset of each 'bootstrap_methods' array field entry.\n                int currentBootstrapMethodOffset = currentAttributeOffset + 2;\n                for (int j = 0; j < currentBootstrapMethodOffsets.length; ++j) {\n                    currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;\n                    // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),\n                    // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).\n                    currentBootstrapMethodOffset += 4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;\n                }\n                return currentBootstrapMethodOffsets;\n            }\n            currentAttributeOffset += attributeLength;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    /**\n     * Reads a non standard JVMS 'attribute' structure in {@link #classFileBuffer}.\n     *\n     * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of\n     *     the class. Any attribute whose type is not equal to the type of one the prototypes will not\n     *     be parsed: its byte array value will be passed unchanged to the ClassWriter.\n     * @param type the type of the attribute.\n     * @param offset the start offset of the JVMS 'attribute' structure in {@link #classFileBuffer}.\n     *     The 6 attribute header bytes (attribute_name_index and attribute_length) are not taken into\n     *     account here.\n     * @param length the length of the attribute's content (excluding the 6 attribute header bytes).\n     * @param charBuffer the buffer to be used to read strings in the constant pool.\n     * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link\n     *     #classFileBuffer}, or -1 if the attribute to be read is not a code attribute. The 6\n     *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\n     *     account here.\n     * @param labels the labels of the method's code, or {@literal null} if the attribute to be read\n     *     is not a code attribute.\n     * @return the attribute that has been read.\n     */\n    private Attribute readAttribute(final Attribute[] attributePrototypes, final String type, final int offset, final int length, final char[] charBuffer, final int codeAttributeOffset, final Label[] labels) {\n        for (Attribute attributePrototype : attributePrototypes) {\n            if (attributePrototype.type.equals(type)) {\n                return attributePrototype.read(this, offset, length, charBuffer, codeAttributeOffset, labels);\n            }\n        }\n        return new Attribute(type).read(this, offset, length, null, -1, null);\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Utility methods: low level parsing\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the number of entries in the class's constant pool table.\n     *\n     * @return the number of entries in the class's constant pool table.\n     */\n    public int getItemCount() {\n        return cpInfoOffsets.length;\n    }\n\n    /**\n     * Returns the start offset in this {@link ClassReader} of a JVMS 'cp_info' structure (i.e. a\n     * constant pool entry), plus one. <i>This method is intended for {@link Attribute} sub classes,\n     * and is normally not needed by class generators or adapters.</i>\n     *\n     * @param constantPoolEntryIndex the index a constant pool entry in the class's constant pool\n     *     table.\n     * @return the start offset in this {@link ClassReader} of the corresponding JVMS 'cp_info'\n     *     structure, plus one.\n     */\n    public int getItem(final int constantPoolEntryIndex) {\n        return cpInfoOffsets[constantPoolEntryIndex];\n    }\n\n    /**\n     * Returns a conservative estimate of the maximum length of the strings contained in the class's\n     * constant pool table.\n     *\n     * @return a conservative estimate of the maximum length of the strings contained in the class's\n     *     constant pool table.\n     */\n    public int getMaxStringLength() {\n        return maxStringLength;\n    }\n\n    /**\n     * Reads a byte value in this {@link ClassReader}. <i>This method is intended for {@link\n     * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n     *\n     * @param offset the start offset of the value to be read in this {@link ClassReader}.\n     * @return the read value.\n     */\n    public int readByte(final int offset) {\n        return classFileBuffer[offset] & 0xFF;\n    }\n\n    /**\n     * Reads an unsigned short value in this {@link ClassReader}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n     *\n     * @param offset the start index of the value to be read in this {@link ClassReader}.\n     * @return the read value.\n     */\n    public int readUnsignedShort(final int offset) {\n        byte[] classBuffer = classFileBuffer;\n        return ((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF);\n    }\n\n    /**\n     * Reads a signed short value in this {@link ClassReader}. <i>This method is intended for {@link\n     * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n     *\n     * @param offset the start offset of the value to be read in this {@link ClassReader}.\n     * @return the read value.\n     */\n    public short readShort(final int offset) {\n        byte[] classBuffer = classFileBuffer;\n        return (short) (((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF));\n    }\n\n    /**\n     * Reads a signed int value in this {@link ClassReader}. <i>This method is intended for {@link\n     * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n     *\n     * @param offset the start offset of the value to be read in this {@link ClassReader}.\n     * @return the read value.\n     */\n    public int readInt(final int offset) {\n        byte[] classBuffer = classFileBuffer;\n        return ((classBuffer[offset] & 0xFF) << 24) | ((classBuffer[offset + 1] & 0xFF) << 16) | ((classBuffer[offset + 2] & 0xFF) << 8) | (classBuffer[offset + 3] & 0xFF);\n    }\n\n    /**\n     * Reads a signed long value in this {@link ClassReader}. <i>This method is intended for {@link\n     * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n     *\n     * @param offset the start offset of the value to be read in this {@link ClassReader}.\n     * @return the read value.\n     */\n    public long readLong(final int offset) {\n        long l1 = readInt(offset);\n        long l0 = readInt(offset + 4) & 0xFFFFFFFFL;\n        return (l1 << 32) | l0;\n    }\n\n    /**\n     * Reads a CONSTANT_Utf8 constant pool entry in this {@link ClassReader}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n     *     value is the index of a CONSTANT_Utf8 entry in the class's constant pool table.\n     * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified CONSTANT_Utf8 entry.\n     */\n    // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\n    public String readUTF8(final int offset, final char[] charBuffer) {\n        int constantPoolEntryIndex = readUnsignedShort(offset);\n        if (offset == 0 || constantPoolEntryIndex == 0) {\n            return null;\n        }\n        return readUtf(constantPoolEntryIndex, charBuffer);\n    }\n\n    /**\n     * Reads a CONSTANT_Utf8 constant pool entry in {@link #classFileBuffer}.\n     *\n     * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pool\n     *     table.\n     * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified CONSTANT_Utf8 entry.\n     */\n    final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n        String value = constantUtf8Values[constantPoolEntryIndex];\n        if (value != null) {\n            return value;\n        }\n        int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\n        return constantUtf8Values[constantPoolEntryIndex] = readUtf(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);\n    }\n\n    /**\n     * Reads an UTF8 string in {@link #classFileBuffer}.\n     *\n     * @param utfOffset the start offset of the UTF8 string to be read.\n     * @param utfLength the length of the UTF8 string to be read.\n     * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 string.\n     */\n    private String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {\n        int currentOffset = utfOffset;\n        int endOffset = currentOffset + utfLength;\n        int strLength = 0;\n        byte[] classBuffer = classFileBuffer;\n        while (currentOffset < endOffset) {\n            int currentByte = classBuffer[currentOffset++];\n            if ((currentByte & 0x80) == 0) {\n                charBuffer[strLength++] = (char) (currentByte & 0x7F);\n            } else if ((currentByte & 0xE0) == 0xC0) {\n                charBuffer[strLength++] = (char) (((currentByte & 0x1F) << 6) + (classBuffer[currentOffset++] & 0x3F));\n            } else {\n                charBuffer[strLength++] = (char) (((currentByte & 0xF) << 12) + ((classBuffer[currentOffset++] & 0x3F) << 6) + (classBuffer[currentOffset++] & 0x3F));\n            }\n        }\n        return new String(charBuffer, 0, strLength);\n    }\n\n    /**\n     * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or\n     * CONSTANT_Package constant pool entry in {@link #classFileBuffer}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param offset the start offset of an unsigned short value in {@link #classFileBuffer}, whose\n     *     value is the index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,\n     *     CONSTANT_Module or CONSTANT_Package entry in class's constant pool table.\n     * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified constant pool entry.\n     */\n    private String readStringish(final int offset, final char[] charBuffer) {\n        // Get the start offset of the cp_info structure (plus one), and read the CONSTANT_Utf8 entry\n        // designated by the first two bytes of this cp_info.\n        return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);\n    }\n\n    /**\n     * Reads a CONSTANT_Class constant pool entry in this {@link ClassReader}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n     *     value is the index of a CONSTANT_Class entry in class's constant pool table.\n     * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified CONSTANT_Class entry.\n     */\n    public String readClass(final int offset, final char[] charBuffer) {\n        return readStringish(offset, charBuffer);\n    }\n\n    /**\n     * Reads a CONSTANT_Module constant pool entry in this {@link ClassReader}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n     *     value is the index of a CONSTANT_Module entry in class's constant pool table.\n     * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified CONSTANT_Module entry.\n     */\n    public String readModule(final int offset, final char[] charBuffer) {\n        return readStringish(offset, charBuffer);\n    }\n\n    /**\n     * Reads a CONSTANT_Package constant pool entry in this {@link ClassReader}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n     *     value is the index of a CONSTANT_Package entry in class's constant pool table.\n     * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified CONSTANT_Package entry.\n     */\n    public String readPackage(final int offset, final char[] charBuffer) {\n        return readStringish(offset, charBuffer);\n    }\n\n    /**\n     * Reads a CONSTANT_Dynamic constant pool entry in {@link #classFileBuffer}.\n     *\n     * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class's constant\n     *     pool table.\n     * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the ConstantDynamic corresponding to the specified CONSTANT_Dynamic entry.\n     */\n    private ConstantDynamic readConstantDynamic(final int constantPoolEntryIndex, final char[] charBuffer) {\n        ConstantDynamic constantDynamic = constantDynamicValues[constantPoolEntryIndex];\n        if (constantDynamic != null) {\n            return constantDynamic;\n        }\n        int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\n        int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\n        String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\n        String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\n        int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];\n        Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\n        Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];\n        bootstrapMethodOffset += 4;\n        for (int i = 0; i < bootstrapMethodArguments.length; i++) {\n            bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\n            bootstrapMethodOffset += 2;\n        }\n        return constantDynamicValues[constantPoolEntryIndex] = new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);\n    }\n\n    /**\n     * Reads a numeric or string constant pool entry in this {@link ClassReader}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,\n     *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,\n     *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class's constant pool.\n     * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String},\n     *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified\n     *     constant pool entry.\n     */\n    public Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {\n        int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\n        switch (classFileBuffer[cpInfoOffset - 1]) {\n        case Symbol.CONSTANT_INTEGER_TAG:\n            return readInt(cpInfoOffset);\n        case Symbol.CONSTANT_FLOAT_TAG:\n            return Float.intBitsToFloat(readInt(cpInfoOffset));\n        case Symbol.CONSTANT_LONG_TAG:\n            return readLong(cpInfoOffset);\n        case Symbol.CONSTANT_DOUBLE_TAG:\n            return Double.longBitsToDouble(readLong(cpInfoOffset));\n        case Symbol.CONSTANT_CLASS_TAG:\n            return Type.getObjectType(readUTF8(cpInfoOffset, charBuffer));\n        case Symbol.CONSTANT_STRING_TAG:\n            return readUTF8(cpInfoOffset, charBuffer);\n        case Symbol.CONSTANT_METHOD_TYPE_TAG:\n            return Type.getMethodType(readUTF8(cpInfoOffset, charBuffer));\n        case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n            int referenceKind = readByte(cpInfoOffset);\n            int referenceCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 1)];\n            int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];\n            String owner = readClass(referenceCpInfoOffset, charBuffer);\n            String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\n            String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\n            boolean isInterface = classFileBuffer[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;\n            return new Handle(referenceKind, owner, name, descriptor, isInterface);\n        case Symbol.CONSTANT_DYNAMIC_TAG:\n            return readConstantDynamic(constantPoolEntryIndex, charBuffer);\n        default:\n            throw new IllegalArgumentException();\n        }\n    }\n}\n",
            "file_name": "ClassReader.java",
            "human_label": "Read a signed long value.",
            "level": "class_runnable",
            "lineno": "3123",
            "name": "readLong",
            "oracle_context": "{ \"apis\" : \"[readInt]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
            "package": "net.hasor.utils.asm",
            "project": "hasor-master"
        },
        {
            "_id": "636767a51a6d9265ec01859d",
            "all_context": "{ \"class_level\" : \"import static io.protostuff.StringSerializer.STRING;\\nimport java.io.DataOutput;\\nimport java.io.IOException;\\nimport java.io.OutputStream;\\nimport java.io.UnsupportedEncodingException;\\nimport java.nio.ByteBuffer;\\nbyte[] bytes;\\nString EMPTY_STRING;\\nbyte[] EMPTY_BYTE_ARRAY;\\nByteString EMPTY;\\nint hash;\\nwrap(byte[] bytes);\\ngetBytes();\\nwriteTo(DataOutput out,ByteString bs);\\nwriteTo(Output output,ByteString bs,int fieldNumber,boolean repeated);\\ntoString();\\nByteString(byte[] bytes);\\nbyteAt(int index);\\nsize();\\nisEmpty();\\ncopyFrom(byte[] bytes,int offset,int size);\\ncopyFrom(byte[] bytes);\\ncopyFrom(String text,String charsetName);\\ncopyFromUtf8(String text);\\ncopyTo(byte[] target,int offset);\\ncopyTo(byte[] target,int sourceOffset,int targetOffset,int size);\\ntoByteArray();\\nasReadOnlyByteBuffer();\\ntoStringUtf8();\\nequals(Object o);\\nequals(ByteString bs,ByteString other,boolean checkHash);\\nequals(byte[] data);\\nequals(byte[] data,int offset,int len);\\nhashCode();\\nstringDefaultValue(String bytes);\\nbytesDefaultValue(String bytes);\\nbyteArrayDefaultValue(String bytes);\\nwriteTo(OutputStream out,ByteString bs);\\n\", \"repo_level\" : \"\" }",
            "class_name": "ByteString",
            "code": "public boolean equals(final byte[] data,int offset,final int len){\n  final byte[] bytes=this.bytes;\n  if (len != bytes.length)   return false;\n  for (int i=0; i < len; ) {\n    if (bytes[i++] != data[offset++]) {\n      return false;\n    }\n  }\n  return true;\n}\n",
            "docstring": "/** \n * Returns true if the contents of the internal array and the provided array match.\n */\n",
            "end_lineno": "353",
            "file_content": "//========================================================================\n//Copyright 2007-2009 David Yu dyuproject@gmail.com\n//------------------------------------------------------------------------\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at \n//http://www.apache.org/licenses/LICENSE-2.0\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//========================================================================\n\n// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// http://code.google.com/p/protobuf/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npackage io.protostuff;\n\nimport static io.protostuff.StringSerializer.STRING;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.ByteBuffer;\n\n/**\n * Immutable array of bytes.\n * \n * @author crazybob@google.com Bob Lee\n * @author kenton@google.com Kenton Varda\n * @author David Yu\n */\npublic final class ByteString\n{\n    // START EXTRA\n    // internal package access to avoid double memory allocation\n    static ByteString wrap(byte[] bytes)\n    {\n        return new ByteString(bytes);\n    }\n\n    // internal package access to avoid double memory allocation\n    byte[] getBytes()\n    {\n        return bytes;\n    }\n\n    /**\n     * Writes the bytes to the {@link OutputStream}.\n     */\n    public static void writeTo(OutputStream out, ByteString bs) throws IOException\n    {\n        out.write(bs.bytes);\n    }\n\n    /**\n     * Writes the bytes to the {@link DataOutput}.\n     */\n    public static void writeTo(DataOutput out, ByteString bs) throws IOException\n    {\n        out.write(bs.bytes);\n    }\n\n    /**\n     * Writes the bytes to the {@link Output}.\n     */\n    public static void writeTo(Output output, ByteString bs, int fieldNumber,\n            boolean repeated) throws IOException\n    {\n        output.writeByteArray(fieldNumber, bs.bytes, repeated);\n    }\n\n    @Override\n    public String toString()\n    {\n        return String.format(\"<ByteString@%s size=%d>\",\n                Integer.toHexString(System.identityHashCode(this)), size());\n    }\n\n    // END EXTRA\n    private final byte[] bytes;\n\n    private ByteString(final byte[] bytes)\n    {\n        this.bytes = bytes;\n    }\n\n    /**\n     * Gets the byte at the given index.\n     * \n     * @throws ArrayIndexOutOfBoundsException\n     *             {@code index} is &lt; 0 or &gt;= size\n     */\n    public byte byteAt(final int index)\n    {\n        return bytes[index];\n    }\n\n    /**\n     * Gets the number of bytes.\n     */\n    public int size()\n    {\n        return bytes.length;\n    }\n\n    /**\n     * Returns {@code true} if the size is {@code 0}, {@code false} otherwise.\n     */\n    public boolean isEmpty()\n    {\n        return bytes.length == 0;\n    }\n\n    // =================================================================\n    // byte[] -> ByteString\n\n    /**\n     * Empty String.\n     */\n    public static final String EMPTY_STRING = \"\";\n\n    /**\n     * Empty byte array.\n     */\n    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n\n    /**\n     * Empty ByteString.\n     */\n    public static final ByteString EMPTY = new ByteString(EMPTY_BYTE_ARRAY);\n\n    /**\n     * Copies the given bytes into a {@code ByteString}.\n     */\n    public static ByteString copyFrom(final byte[] bytes, final int offset,\n            final int size)\n    {\n        final byte[] copy = new byte[size];\n        System.arraycopy(bytes, offset, copy, 0, size);\n        return new ByteString(copy);\n    }\n\n    /**\n     * Copies the given bytes into a {@code ByteString}.\n     */\n    public static ByteString copyFrom(final byte[] bytes)\n    {\n        return copyFrom(bytes, 0, bytes.length);\n    }\n\n    /**\n     * Encodes {@code text} into a sequence of bytes using the named charset and returns the result as a\n     * {@code ByteString}.\n     */\n    public static ByteString copyFrom(final String text, final String charsetName)\n    {\n        try\n        {\n            return new ByteString(text.getBytes(charsetName));\n        }\n        catch (UnsupportedEncodingException e)\n        {\n            throw new RuntimeException(charsetName + \" not supported?\", e);\n        }\n    }\n\n    /**\n     * Encodes {@code text} into a sequence of UTF-8 bytes and returns the result as a {@code ByteString}.\n     */\n    public static ByteString copyFromUtf8(final String text)\n    {\n        return new ByteString(STRING.ser(text));\n        /*\n         * @try { return new ByteString(text.getBytes(\"UTF-8\")); } catch (UnsupportedEncodingException e) { throw new\n         * RuntimeException(\"UTF-8 not supported?\", e); }\n         */\n    }\n\n    // =================================================================\n    // ByteString -> byte[]\n\n    /**\n     * Copies bytes into a buffer at the given offset.\n     * \n     * @param target\n     *            buffer to copy into\n     * @param offset\n     *            in the target buffer\n     */\n    public void copyTo(final byte[] target, final int offset)\n    {\n        System.arraycopy(bytes, 0, target, offset, bytes.length);\n    }\n\n    /**\n     * Copies bytes into a buffer.\n     * \n     * @param target\n     *            buffer to copy into\n     * @param sourceOffset\n     *            offset within these bytes\n     * @param targetOffset\n     *            offset within the target buffer\n     * @param size\n     *            number of bytes to copy\n     */\n    public void copyTo(final byte[] target, final int sourceOffset,\n            final int targetOffset,\n            final int size)\n    {\n        System.arraycopy(bytes, sourceOffset, target, targetOffset, size);\n    }\n\n    /**\n     * Copies bytes to a {@code byte[]}.\n     */\n    public byte[] toByteArray()\n    {\n        final int size = bytes.length;\n        final byte[] copy = new byte[size];\n        System.arraycopy(bytes, 0, copy, 0, size);\n        return copy;\n    }\n\n    /**\n     * Constructs a new read-only {@code java.nio.ByteBuffer} with the same backing byte array.\n     */\n    public ByteBuffer asReadOnlyByteBuffer()\n    {\n        final ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n        return byteBuffer.asReadOnlyBuffer();\n    }\n\n    /*\n     * @ Constructs a new {@code String} by decoding the bytes using the specified charset.\n     */\n    /*\n     * @public String unsignedIntToString(final String charsetName) throws UnsupportedEncodingException { return new String(bytes,\n     * charsetName); }\n     */\n\n    /**\n     * Constructs a new {@code String} by decoding the bytes as UTF-8.\n     */\n    public String toStringUtf8()\n    {\n        return STRING.deser(bytes);\n        /*\n         * @try { return new String(bytes, \"UTF-8\"); } catch (UnsupportedEncodingException e) { throw new\n         * RuntimeException(\"UTF-8 not supported?\", e); }\n         */\n    }\n\n    // =================================================================\n    // equals() and hashCode()\n\n    @Override\n    public boolean equals(final Object o)\n    {\n        return o == this || (o instanceof ByteString && equals(this, (ByteString) o, false));\n    }\n\n    /**\n     * Returns true if the contents of both match.\n     */\n    public static boolean equals(ByteString bs, ByteString other, boolean checkHash)\n    {\n        final int size = bs.bytes.length;\n        if (size != other.bytes.length)\n        {\n            return false;\n        }\n\n        if (checkHash)\n        {\n            // volatile reads\n            final int h1 = bs.hash, h2 = other.hash;\n            if (h1 != 0 && h2 != 0 && h1 != h2)\n            {\n                return false;\n            }\n        }\n\n        final byte[] thisBytes = bs.bytes;\n        final byte[] otherBytes = other.bytes;\n        for (int i = 0; i < size; i++)\n        {\n            if (thisBytes[i] != otherBytes[i])\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns true if the contents of the internal array and the provided array match.\n     */\n    public boolean equals(final byte[] data)\n    {\n        return equals(data, 0, data.length);\n    }\n\n    /**\n     * Returns true if the contents of the internal array and the provided array match.\n     */\n    public boolean equals(final byte[] data, int offset, final int len)\n    {\n        final byte[] bytes = this.bytes;\n        if (len != bytes.length)\n            return false;\n\n        for (int i = 0; i < len;)\n        {\n            if (bytes[i++] != data[offset++])\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private volatile int hash = 0;\n\n    @Override\n    public int hashCode()\n    {\n        int h = hash;\n\n        if (h == 0)\n        {\n            final byte[] thisBytes = bytes;\n            final int size = bytes.length;\n\n            h = size;\n            for (int i = 0; i < size; i++)\n            {\n                h = h * 31 + thisBytes[i];\n            }\n            if (h == 0)\n            {\n                h = 1;\n            }\n\n            hash = h;\n        }\n\n        return h;\n    }\n\n    // =================================================================\n    // Input stream\n\n    /*\n     * @ Creates an {@code InputStream} which can be used to read the bytes.\n     */\n    /*\n     * @public InputStream newInput() { return new ByteArrayInputStream(bytes); }\n     */\n\n    /*\n     * @ Creates a {@link CodedInputStream} which can be used to read the bytes. Using this is more efficient than\n     * creating a {@link CodedInputStream} wrapping the result of {@link #newInput()}.\n     */\n    /*\n     * @public CodedInputStream newCodedInput() { // We trust CodedInputStream not to modify the bytes, or to give\n     * anyone // else access to them. return CodedInputStream.newInstance(bytes); }\n     */\n\n    // =================================================================\n    // Output stream\n\n    /*\n     * @ Creates a new {@link Output} with the given initial capacity.\n     */\n    /*\n     * @public static Output newOutput(final int initialCapacity) { return new Output(new\n     * ByteArrayOutputStream(initialCapacity)); }\n     */\n\n    /*\n     * @ Creates a new {@link Output}.\n     */\n    /*\n     * @public static Output newOutput() { return newOutput(32); }\n     */\n\n    /*\n     * @ Outputs to a {@code ByteString} instance. Call {@link #toByteString()} to create the {@code ByteString}\n     * instance.\n     */\n    /*\n     * @public static final class Output extends FilterOutputStream { private final ByteArrayOutputStream bout;\n     * \n     * /** Constructs a new output with the given initial capacity.\n     * \n     * @ private Output(final ByteArrayOutputStream bout) { super(bout); this.bout = bout; }\n     * \n     * /** Creates a {@code ByteString} instance from this {@code Output}.\n     * \n     * @ public ByteString toByteString() { final byte[] byteArray = bout.toByteArray(); return new\n     * ByteString(byteArray); } }\n     * \n     * /** Constructs a new ByteString builder, which allows you to efficiently construct a {@code ByteString} by\n     * writing to a {@link CodedOutputStream}. Using this is much more efficient than calling {@code newOutput()} and\n     * wrapping that in a {@code CodedOutputStream}.\n     * \n     * <p>This is package-private because it's a somewhat confusing interface. Users can call {@link\n     * Message#toByteString()} instead of calling this directly.\n     * \n     * @param size The target byte size of the {@code ByteString}. You must write exactly this many bytes before\n     * building the result.\n     * \n     * @ static CodedBuilder newCodedBuilder(final int size) { return new CodedBuilder(size); }\n     * \n     * /** See {@link ByteString#newCodedBuilder(int)}. *@ static final class CodedBuilder { private final\n     * CodedOutputStream output; private final byte[] buffer;\n     * \n     * private CodedBuilder(final int size) { buffer = new byte[size]; output = CodedOutputStream.newInstance(buffer); }\n     * \n     * public ByteString build() { output.checkNoSpaceLeft();\n     * \n     * // We can be confident that the CodedOutputStream will not modify the // underlying bytes anymore because it\n     * already wrote all of them. So, // no need to make a copy. return new ByteString(buffer); }\n     * \n     * public CodedOutputStream getCodedOutput() { return output; } }\n     */\n\n    // moved from Internal.java\n\n    /**\n     * Helper called by generated code to construct default values for string fields.\n     * <p>\n     * The protocol compiler does not actually contain a UTF-8 decoder -- it just pushes UTF-8-encoded text around\n     * without touching it. The one place where this presents a problem is when generating Java string literals. Unicode\n     * characters in the string literal would normally need to be encoded using a Unicode escape sequence, which would\n     * require decoding them. To get around this, protoc instead embeds the UTF-8 bytes into the generated code and\n     * leaves it to the runtime library to decode them.\n     * <p>\n     * It gets worse, though. If protoc just generated a byte array, like: new byte[] {0x12, 0x34, 0x56, 0x78} Java\n     * actually generates *code* which allocates an array and then fills in each value. This is much less efficient than\n     * just embedding the bytes directly into the bytecode. To get around this, we need another work-around. String\n     * literals are embedded directly, so protoc actually generates a string literal corresponding to the bytes. The\n     * easiest way to do this is to use the ISO-8859-1 character set, which corresponds to the first 256 characters of\n     * the Unicode range. Protoc can then use good old CEscape to generate the string.\n     * <p>\n     * So we have a string literal which represents a set of bytes which represents another string. This function --\n     * stringDefaultValue -- converts from the generated string to the string we actually want. The generated code calls\n     * this automatically.\n     */\n    public static String stringDefaultValue(String bytes)\n    {\n        try\n        {\n            return new String(bytes.getBytes(\"ISO-8859-1\"), \"UTF-8\");\n        }\n        catch (UnsupportedEncodingException e)\n        {\n            // This should never happen since all JVMs are required to implement\n            // both of the above character sets.\n            throw new IllegalStateException(\n                    \"Java VM does not support a standard character set.\", e);\n        }\n    }\n\n    /**\n     * Helper called by generated code to construct default values for bytes fields.\n     * <p>\n     * This is a lot like {@link #stringDefaultValue}, but for bytes fields. In this case we only need the second of the\n     * two hacks -- allowing us to embed raw bytes as a string literal with ISO-8859-1 encoding.\n     */\n    public static ByteString bytesDefaultValue(String bytes)\n    {\n        return new ByteString(byteArrayDefaultValue(bytes));\n    }\n\n    /**\n     * Helper called by generated code to construct default values for byte array fields.\n     * <p>\n     * This is a lot like {@link #stringDefaultValue}, but for bytes fields. In this case we only need the second of the\n     * two hacks -- allowing us to embed raw bytes as a string literal with ISO-8859-1 encoding.\n     */\n    public static byte[] byteArrayDefaultValue(String bytes)\n    {\n        try\n        {\n            return bytes.getBytes(\"ISO-8859-1\");\n        }\n        catch (UnsupportedEncodingException e)\n        {\n            // This should never happen since all JVMs are required to implement\n            // ISO-8859-1.\n            throw new IllegalStateException(\n                    \"Java VM does not support a standard character set.\", e);\n        }\n    }\n}\n",
            "file_name": "ByteString.java",
            "human_label": "Return true if the contents of the internal array bytes and the provided array data match.",
            "level": "class_runnable",
            "lineno": "335",
            "name": "equals",
            "oracle_context": "{ \"apis\" : \"[]\", \"classes\" : \"[byte[]]\", \"vars\" : \"[length]\" }",
            "package": "io.protostuff",
            "project": "protostuff-master"
        },
        {
            "_id": "6367674b1a6d9265ec017dc0",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.*;\\nimport org.jgrapht.alg.interfaces.*;\\nimport org.jgrapht.alg.util.*;\\nimport java.util.*;\\nboolean DEFAULT_USE_HEURISTICS;\\nGraph<V,E> graph;\\nComparator<Double> comparator;\\nboolean useHeuristics;\\nint WORK_ARRAY_INITIAL_SIZE;\\ndouble[] a;\\nPathGrowingWeightedMatching(Graph graph);\\nPathGrowingWeightedMatching(Graph graph,boolean useHeuristics);\\nPathGrowingWeightedMatching(Graph graph,boolean useHeuristics,double epsilon);\\ngetMatching();\\nrun();\\nrunWithHeuristics();\\ngetMaximumWeightMatching(Graph g,LinkedList path);\\n\", \"repo_level\" : \"\" }",
            "class_name": "PathGrowingWeightedMatching",
            "code": "private Set<V> initVisibleVertices(){\n  Set<V> visibleVertex=new HashSet<>();\n  for (  E e : graph.edgeSet()) {\n    V s=graph.getEdgeSource(e);\n    V t=graph.getEdgeTarget(e);\n    if (!s.equals(t)) {\n      visibleVertex.add(s);\n      visibleVertex.add(t);\n    }\n  }\n  return visibleVertex;\n}\n",
            "docstring": "/** \n * Compute all vertices that have positive degree by iterating over the edges on purpose. This keeps the complexity to $O(m)$ where $m$ is the number of edges.\n * @return set of vertices with positive degree\n */\n",
            "end_lineno": "156",
            "file_content": "/*\n * (C) Copyright 2016-2021, by Dimitrios Michail and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.alg.matching;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.interfaces.*;\nimport org.jgrapht.alg.util.*;\n\nimport java.util.*;\n\n/**\n * A linear time $\\frac{1}{2}$-approximation algorithm for finding a maximum weight matching in an\n * arbitrary graph. Linear time here means $O(m)$ where m is the cardinality of the edge set, even\n * if the graph contains isolated vertices. $\\frac{1}{2}$-approximation means that for any graph\n * instance, the algorithm computes a matching whose weight is at least half of the weight of a\n * maximum weight matching. The implementation accepts directed and undirected graphs which may\n * contain self-loops and multiple edges. There is no assumption on the edge weights, i.e. they can\n * also be negative or zero.\n * \n * <p>\n * The algorithm is due to Drake and Hougardy, described in detail in the following paper:\n * <ul>\n * <li>D.E. Drake, S. Hougardy, A Simple Approximation Algorithm for the Weighted Matching Problem,\n * Information Processing Letters 85, 211-213, 2003.</li>\n * </ul>\n * \n * <p>\n * This particular implementation uses by default two additional heuristics discussed by the authors\n * which also take linear time but improve the quality of the matchings. These heuristics can be\n * disabled by calling the constructor {@link #PathGrowingWeightedMatching(Graph, boolean)}.\n * Disabling the heuristics has the effect of fewer passes over the edge set of the input graph,\n * probably at the expense of the total weight of the matching.\n * \n * <p>\n * For a discussion on engineering approximate weighted matching algorithms see the following paper:\n * <ul>\n * <li>Jens Maue and Peter Sanders. Engineering algorithms for approximate weighted matching.\n * International Workshop on Experimental and Efficient Algorithms, Springer, 2007.</li>\n * </ul>\n *\n * @see GreedyWeightedMatching\n * \n * @param <V> the graph vertex type\n * @param <E> the graph edge type\n *\n * @author Dimitrios Michail\n */\npublic class PathGrowingWeightedMatching<V, E>\n    implements\n    MatchingAlgorithm<V, E>\n{\n    /**\n     * Default value on whether to use extra heuristics to improve the result.\n     */\n    public static final boolean DEFAULT_USE_HEURISTICS = true;\n\n    private final Graph<V, E> graph;\n    private final Comparator<Double> comparator;\n    private final boolean useHeuristics;\n\n    /**\n     * Construct a new instance of the path growing algorithm. Floating point values are compared\n     * using {@link #DEFAULT_EPSILON} tolerance. By default two additional linear time heuristics\n     * are used in order to improve the quality of the matchings.\n     * \n     * @param graph the input graph\n     */\n    public PathGrowingWeightedMatching(Graph<V, E> graph)\n    {\n        this(graph, DEFAULT_USE_HEURISTICS, DEFAULT_EPSILON);\n    }\n\n    /**\n     * Construct a new instance of the path growing algorithm. Floating point values are compared\n     * using {@link #DEFAULT_EPSILON} tolerance.\n     * \n     * @param graph the input graph\n     * @param useHeuristics if true an improved version with additional heuristics is executed. The\n     *        running time remains linear but performs a few more passes over the input. While the\n     *        approximation factor remains $\\frac{1}{2}$, in most cases the heuristics produce\n     *        matchings of higher quality.\n     */\n    public PathGrowingWeightedMatching(Graph<V, E> graph, boolean useHeuristics)\n    {\n        this(graph, useHeuristics, DEFAULT_EPSILON);\n    }\n\n    /**\n     * Construct a new instance of the path growing algorithm.\n     * \n     * @param graph the input graph\n     * @param useHeuristics if true an improved version with additional heuristics is executed. The\n     *        running time remains linear but performs a few more passes over the input. While the\n     *        approximation factor remains $\\frac{1}{2}$, in most cases the heuristics produce\n     *        matchings of higher quality.\n     * @param epsilon tolerance when comparing floating point values\n     */\n    public PathGrowingWeightedMatching(Graph<V, E> graph, boolean useHeuristics, double epsilon)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Input graph cannot be null\");\n        }\n        this.graph = graph;\n        this.comparator = new ToleranceDoubleComparator(epsilon);\n        this.useHeuristics = useHeuristics;\n    }\n\n    /**\n     * Get a matching that is a $\\frac{1}{2}$-approximation of the maximum weighted matching.\n     * \n     * @return a matching\n     */\n    @Override\n    public Matching<V, E> getMatching()\n    {\n        if (useHeuristics) {\n            return runWithHeuristics();\n        } else {\n            return run();\n        }\n    }\n\n    /**\n     * Compute all vertices that have positive degree by iterating over the edges on purpose. This\n     * keeps the complexity to $O(m)$ where $m$ is the number of edges.\n     * \n     * @return set of vertices with positive degree\n     */\n    private Set<V> initVisibleVertices()\n    {\n        Set<V> visibleVertex = new HashSet<>();\n        for (E e : graph.edgeSet()) {\n            V s = graph.getEdgeSource(e);\n            V t = graph.getEdgeTarget(e);\n            if (!s.equals(t)) {\n                visibleVertex.add(s);\n                visibleVertex.add(t);\n            }\n        }\n        return visibleVertex;\n    }\n\n    // the algorithm (no heuristics)\n    private Matching<V, E> run()\n    {\n        // lookup all relevant vertices\n        Set<V> visibleVertex = initVisibleVertices();\n\n        // run algorithm\n        Set<E> m1 = new HashSet<>();\n        Set<E> m2 = new HashSet<>();\n        double m1Weight = 0d, m2Weight = 0d;\n        int i = 1;\n        while (!visibleVertex.isEmpty()) {\n            // find vertex arbitrarily\n            V x = visibleVertex.stream().findAny().get();\n\n            // grow path from x\n            while (x != null) {\n                // first heaviest edge incident to vertex x (among visible neighbors)\n                double maxWeight = 0d;\n                E maxWeightedEdge = null;\n                V maxWeightedNeighbor = null;\n                for (E e : graph.edgesOf(x)) {\n                    V other = Graphs.getOppositeVertex(graph, e, x);\n                    if (visibleVertex.contains(other) && !other.equals(x)) {\n                        double curWeight = graph.getEdgeWeight(e);\n                        if (comparator.compare(curWeight, 0d) > 0 && (maxWeightedEdge == null\n                            || comparator.compare(curWeight, maxWeight) > 0))\n                        {\n                            maxWeight = curWeight;\n                            maxWeightedEdge = e;\n                            maxWeightedNeighbor = other;\n                        }\n                    }\n                }\n\n                // add it to either m1 or m2, alternating between them\n                if (maxWeightedEdge != null) {\n                    switch (i) {\n                    case 1:\n                        m1.add(maxWeightedEdge);\n                        m1Weight += maxWeight;\n                        break;\n                    case 2:\n                        m2.add(maxWeightedEdge);\n                        m2Weight += maxWeight;\n                        break;\n                    default:\n                        throw new RuntimeException(\n                            \"Failed to figure out matching, seems to be a bug\");\n                    }\n                    i = 3 - i;\n                }\n\n                // remove x and incident edges\n                visibleVertex.remove(x);\n\n                // go to next vertex\n                x = maxWeightedNeighbor;\n            }\n        }\n\n        // return best matching\n        if (comparator.compare(m1Weight, m2Weight) > 0) {\n            return new MatchingImpl<>(graph, m1, m1Weight);\n        } else {\n            return new MatchingImpl<>(graph, m2, m2Weight);\n        }\n    }\n\n    // the algorithm (improved with additional heuristics)\n    private Matching<V, E> runWithHeuristics()\n    {\n        // lookup all relevant vertices\n        Set<V> visibleVertex = initVisibleVertices();\n\n        // create solver for paths\n        DynamicProgrammingPathSolver pathSolver = new DynamicProgrammingPathSolver();\n\n        Set<E> matching = new HashSet<>();\n        double matchingWeight = 0d;\n        Set<V> matchedVertices = new HashSet<>();\n\n        // run algorithm\n        while (!visibleVertex.isEmpty()) {\n            // find vertex arbitrarily\n            V x = visibleVertex.stream().findAny().get();\n\n            // grow path from x\n            LinkedList<E> path = new LinkedList<>();\n            while (x != null) {\n                // first heaviest edge incident to vertex x (among visible neighbors)\n                double maxWeight = 0d;\n                E maxWeightedEdge = null;\n                V maxWeightedNeighbor = null;\n                for (E e : graph.edgesOf(x)) {\n                    V other = Graphs.getOppositeVertex(graph, e, x);\n                    if (visibleVertex.contains(other) && !other.equals(x)) {\n                        double curWeight = graph.getEdgeWeight(e);\n                        if (comparator.compare(curWeight, 0d) > 0 && (maxWeightedEdge == null\n                            || comparator.compare(curWeight, maxWeight) > 0))\n                        {\n                            maxWeight = curWeight;\n                            maxWeightedEdge = e;\n                            maxWeightedNeighbor = other;\n                        }\n                    }\n                }\n\n                // add edge to path and remove x\n                if (maxWeightedEdge != null) {\n                    path.add(maxWeightedEdge);\n                }\n                visibleVertex.remove(x);\n\n                // go to next vertex\n                x = maxWeightedNeighbor;\n            }\n\n            // find maximum weight matching of path using dynamic programming\n            Pair<Double, Set<E>> pathMatching = pathSolver.getMaximumWeightMatching(graph, path);\n\n            // add it to result while keeping track of matched vertices\n            matchingWeight += pathMatching.getFirst();\n            for (E e : pathMatching.getSecond()) {\n                V s = graph.getEdgeSource(e);\n                V t = graph.getEdgeTarget(e);\n                if (!matchedVertices.add(s)) {\n                    throw new RuntimeException(\n                        \"Set is not a valid matching, please submit a bug report\");\n                }\n                if (!matchedVertices.add(t)) {\n                    throw new RuntimeException(\n                        \"Set is not a valid matching, please submit a bug report\");\n                }\n                matching.add(e);\n            }\n        }\n\n        // extend matching to maximal cardinality (out of edges with positive weight)\n        for (E e : graph.edgeSet()) {\n            double edgeWeight = graph.getEdgeWeight(e);\n            if (comparator.compare(edgeWeight, 0d) <= 0) {\n                // ignore zero or negative weight\n                continue;\n            }\n            V s = graph.getEdgeSource(e);\n            if (matchedVertices.contains(s)) {\n                // matched vertex, ignore\n                continue;\n            }\n            V t = graph.getEdgeTarget(e);\n            if (matchedVertices.contains(t)) {\n                // matched vertex, ignore\n                continue;\n            }\n            // add edge to matching\n            matching.add(e);\n            matchingWeight += edgeWeight;\n        }\n\n        // return extended matching\n        return new MatchingImpl<>(graph, matching, matchingWeight);\n    }\n\n    /**\n     * Helper class for repeatedly solving the maximum weight matching on paths.\n     * \n     * The work array used in the dynamic programming algorithm is reused between invocations. In\n     * case its size is smaller than the path provided, its length is increased. This class is not\n     * thread-safe.\n     */\n    class DynamicProgrammingPathSolver\n    {\n        private static final int WORK_ARRAY_INITIAL_SIZE = 256;\n\n        // work array\n        private double[] a = new double[WORK_ARRAY_INITIAL_SIZE];\n\n        /**\n         * Find the maximum weight matching of a path using dynamic programming.\n         * \n         * @param path a list of edges. The code assumes that the list of edges is a valid simple\n         *        path, and that is not a cycle.\n         * @return a maximum weight matching of the path\n         */\n        public Pair<Double, Set<E>> getMaximumWeightMatching(Graph<V, E> g, LinkedList<E> path)\n        {\n            int pathLength = path.size();\n\n            // special cases\n            switch (pathLength) {\n            case 0:\n                // special case, empty path\n                return Pair.of(0d, Collections.emptySet());\n            case 1:\n                // special case, one edge\n                E e = path.getFirst();\n                double eWeight = g.getEdgeWeight(e);\n                if (comparator.compare(eWeight, 0d) > 0) {\n                    return Pair.of(eWeight, Collections.singleton(e));\n                } else {\n                    return Pair.of(0d, Collections.emptySet());\n                }\n            }\n\n            // make sure work array has enough space\n            if (a.length < pathLength + 1) {\n                a = new double[pathLength + 1];\n            }\n\n            // first pass to find solution\n            Iterator<E> it = path.iterator();\n            E e = it.next();\n            double eWeight = g.getEdgeWeight(e);\n            a[0] = 0d;\n            a[1] = (comparator.compare(eWeight, 0d) > 0) ? eWeight : 0d;\n            for (int i = 2; i <= pathLength; i++) {\n                e = it.next();\n                eWeight = g.getEdgeWeight(e);\n                if (comparator.compare(a[i - 1], a[i - 2] + eWeight) > 0) {\n                    a[i] = a[i - 1];\n                } else {\n                    a[i] = a[i - 2] + eWeight;\n                }\n            }\n\n            // reverse second pass to build solution\n            Set<E> matching = new HashSet<>();\n            it = path.descendingIterator();\n            int i = pathLength;\n            while (i >= 1) {\n                e = it.next();\n                if (comparator.compare(a[i], a[i - 1]) > 0) {\n                    matching.add(e);\n                    // skip next edge\n                    if (i > 1) {\n                        e = it.next();\n                    }\n                    i--;\n                }\n                i--;\n            }\n\n            // return solution\n            return Pair.of(a[pathLength], matching);\n        }\n\n    }\n\n}\n",
            "file_name": "PathGrowingWeightedMatching.java",
            "human_label": "Compute all vertices by iterating over the edges of this graph.",
            "level": "class_runnable",
            "lineno": "138",
            "name": "initVisibleVertices",
            "oracle_context": "{ \"apis\" : \"[edgeSet, getEdgeSource, getEdgeTarget, equals, add]\", \"classes\" : \"[Set<V>, V]\", \"vars\" : \"[graph]\" }",
            "package": "org.jgrapht.alg.matching",
            "project": "jgrapht-master"
        },
        {
            "_id": "636766ff1a6d9265ec01783b",
            "all_context": "{ \"class_level\" : \"import net.hasor.core.Singleton;\\nimport net.hasor.dataql.UdfSourceAssembly;\\nimport net.hasor.utils.StringUtils;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nPattern linePattern;\\nPattern humpPattern;\\nstartsWithIgnoreCase(String str,String prefix);\\nendsWith(String str,String suffix);\\nendsWithIgnoreCase(String str,String suffix);\\n_startsWith(String str,String prefix,boolean ignoreCase);\\n_endsWith(String str,String suffix,boolean ignoreCase);\\nlineToHump(String str);\\nhumpToLine(String str);\\nfirstCharToUpperCase(String value);\\nfirstCharToLowerCase(String value);\\ntoUpperCase(String value);\\ntoLowerCase(String value);\\nindexOf(String str,String searchStr);\\nindexOfWithStart(String str,String searchStr,int startPos);\\nindexOfIgnoreCase(String str,String searchStr);\\nindexOfIgnoreCaseWithStart(String str,String searchStr,int startPos);\\nlastIndexOf(String str,String searchStr);\\nlastIndexOfWithStart(String str,String searchChar,int startPos);\\nlastIndexOfIgnoreCase(String str,String searchStr);\\nlastIndexOfIgnoreCaseWithStart(String str,String searchStr,int startPos);\\ncontains(String str,String searchStr);\\ncontainsIgnoreCase(String str,String searchStr);\\ncontainsAny(String str,List searchStrArray);\\ncontainsAnyIgnoreCase(String str,List searchStrArray);\\ntrim(String str);\\nsub(String str,int start,int end);\\nleft(String str,int len);\\nright(String str,int len);\\nalignRight(String str,String padChar,int len);\\nalignLeft(String str,String padChar,int len);\\nalignCenter(String str,String padChar,int len);\\ncompareString(String str1,String str2);\\ncompareStringIgnoreCase(String str1,String str2);\\nsplit(String str,String separatorChars);\\njoin(List array,String separator);\\nisEmpty(String str);\\nequalsIgnoreCase(String str1,String str2);\\nstartsWith(String str,String prefix);\\n\", \"repo_level\" : \"public interface UdfSourceAssembly {default Supplier<?> getSupplier(Class targetType,Finder finder);\\ndefault Predicate<Method> getPredicate(Class targetType);\\npublic Object[] allParams();\\ndefault Supplier<Map<String,Udf>> getUdfResource(Finder finder);\\npublic Class<? extends Annotation> annotationType();\\npublic String value();\\npublic Object call(Hints readOnly,Object values);\\npublic Object call(Hints readOnly,Object values);\\n }\\npublic interface StringUtils {static boolean isEmpty(String str);\\nstatic boolean isNotEmpty(String str);\\nstatic boolean isBlank(String str);\\nstatic boolean isNotBlank(String str);\\nstatic String trim(String str);\\nstatic String trimToNull(String str);\\nstatic String trimToEmpty(String str);\\nstatic String strip(String str);\\nstatic String stripToNull(String str);\\nstatic String stripToEmpty(String str);\\nstatic String strip(String str,String stripChars);\\nstatic String stripStart(String str,String stripChars);\\nstatic String stripEnd(String str,String stripChars);\\nstatic String[] stripAll(String[] strs);\\nstatic String[] stripAll(String[] strs,String stripChars);\\nstatic boolean equals(String str1,String str2);\\nstatic boolean equalsIgnoreCase(String str1,String str2);\\nstatic int indexOf(String str,char searchChar);\\nstatic int indexOf(String str,char searchChar,int startPos);\\nstatic int indexOf(String str,String searchStr);\\nstatic int ordinalIndexOf(String str,String searchStr,int ordinal);\\nstatic int indexOf(String str,String searchStr,int startPos);\\nstatic int indexOfIgnoreCase(String str,String searchStr);\\nstatic int indexOfIgnoreCase(String str,String searchStr,int startPos);\\nstatic int lastIndexOf(String str,char searchChar);\\nstatic int lastIndexOf(String str,char searchChar,int startPos);\\nstatic int lastIndexOf(String str,String searchStr);\\nstatic int lastOrdinalIndexOf(String str,String searchStr,int ordinal);\\nstatic int lastIndexOf(String str,String searchStr,int startPos);\\nstatic int lastIndexOfIgnoreCase(String str,String searchStr);\\nstatic int lastIndexOfIgnoreCase(String str,String searchStr,int startPos);\\nstatic boolean contains(String str,char searchChar);\\nstatic boolean contains(String str,String searchStr);\\nstatic boolean containsIgnoreCase(String str,String searchStr);\\nstatic int indexOfAny(String str,char[] searchChars);\\nstatic int indexOfAny(String str,String searchChars);\\nstatic boolean containsAny(String str,char[] searchChars);\\nstatic boolean containsAny(String str,String searchChars);\\nstatic int indexOfAnyBut(String str,char[] searchChars);\\nstatic int indexOfAnyBut(String str,String searchChars);\\nstatic boolean containsOnly(String str,char[] valid);\\nstatic boolean containsOnly(String str,String validChars);\\nstatic boolean containsNone(String str,char[] searchChars);\\nstatic boolean containsNone(String str,String invalidChars);\\nstatic int indexOfAny(String str,String[] searchStrs);\\nstatic int lastIndexOfAny(String str,String[] searchStrs);\\nstatic String substring(String str,int start);\\nstatic String substring(String str,int start,int end);\\nstatic String left(String str,int len);\\nstatic String right(String str,int len);\\nstatic String mid(String str,int pos,int len);\\nstatic String substringBefore(String str,String separator);\\nstatic String substringAfter(String str,String separator);\\nstatic String substringBeforeLast(String str,String separator);\\nstatic String substringAfterLast(String str,String separator);\\nstatic String substringBetween(String str,String tag);\\nstatic String substringBetween(String str,String open,String close);\\nstatic String[] substringsBetween(String str,String open,String close);\\nstatic String[] splitKeep(String str,char separatorChar);\\nstatic String[] splitKeep(String str,String separatorStr);\\nstatic String[] split(String str);\\nstatic String[] split(String str,char separatorChar);\\nstatic String[] split(String str,String separatorChars);\\nstatic String[] split(String str,String separatorChars,int max);\\nstatic String[] splitByWholeSeparator(String str,String separator);\\nstatic String[] splitByWholeSeparator(String str,String separator,int max);\\nstatic String[] splitByWholeSeparatorPreserveAllTokens(String str,String separator);\\nstatic String[] splitByWholeSeparatorPreserveAllTokens(String str,String separator,int max);\\nstatic String[] splitPreserveAllTokens(String str);\\nstatic String[] splitPreserveAllTokens(String str,char separatorChar);\\nstatic String[] splitPreserveAllTokens(String str,String separatorChars);\\nstatic String[] splitPreserveAllTokens(String str,String separatorChars,int max);\\nstatic String[] splitByCharacterType(String str);\\nstatic String[] splitByCharacterTypeCamelCase(String str);\\nstatic String join(Object[] array);\\nstatic String join(Object[] array,char separator);\\nstatic String join(Object[] array,char separator,int startIndex,int endIndex);\\nstatic String join(Object[] array,String separator);\\nstatic String join(Object[] array,String separator,int startIndex,int endIndex);\\nstatic String deleteWhitespace(String str);\\nstatic String removeStart(String str,String remove);\\nstatic String removeStartIgnoreCase(String str,String remove);\\nstatic String removeEnd(String str,String remove);\\nstatic String removeEndIgnoreCase(String str,String remove);\\nstatic String remove(String str,String remove);\\nstatic String remove(String str,char remove);\\nstatic String replaceOnce(String text,String searchString,String replacement);\\nstatic String replace(String text,String searchString,String replacement);\\nstatic String replace(String text,String searchString,String replacement,int max);\\nstatic String replaceEach(String text,String[] searchList,String[] replacementList);\\nstatic String replaceEachRepeatedly(String text,String[] searchList,String[] replacementList);\\nstatic String replaceChars(String str,char searchChar,char replaceChar);\\nstatic String replaceChars(String str,String searchChars,String replaceChars);\\nstatic String overlay(String str,String overlay,int start,int end);\\nstatic String chomp(String str);\\nstatic String chomp(String str,String separator);\\nstatic String chop(String str);\\nstatic String repeat(char character,int repeat);\\nstatic String repeat(String str,int repeat);\\nstatic String repeat(String str,String separator,int repeat);\\nstatic String rightPad(String str,int size);\\nstatic String rightPad(String str,int size,char padChar);\\nstatic String rightPad(String str,int size,String padStr);\\nstatic String leftPad(String str,int size);\\nstatic String leftPad(String str,int size,char padChar);\\nstatic String leftPad(String str,int size,String padStr);\\nstatic int length(String str);\\nstatic String center(String str,int size);\\nstatic String center(String str,int size,char padChar);\\nstatic String center(String str,int size,String padStr);\\nstatic String upperCase(String str);\\nstatic String upperCase(String str,Locale locale);\\nstatic String lowerCase(String str);\\nstatic String lowerCase(String str,Locale locale);\\nstatic String capitalize(String str);\\nstatic String uncapitalize(String str);\\nstatic String swapCase(String str);\\nstatic int countMatches(String str,String sub);\\nstatic boolean isAlpha(String str);\\nstatic boolean isAlphaSpace(String str);\\nstatic boolean isAlphanumeric(String str);\\nstatic boolean isAlphanumericSpace(String str);\\nstatic boolean isAsciiPrintable(String str);\\nstatic boolean isNumeric(String str);\\nstatic boolean isNumericSpace(String str);\\nstatic boolean isWhitespace(String str);\\nstatic boolean isAllLowerCase(String str);\\nstatic boolean isAllUpperCase(String str);\\nstatic String defaultString(String str);\\nstatic String defaultString(String str,String defaultStr);\\nstatic String defaultIfBlank(String str,String defaultStr);\\nstatic String defaultIfEmpty(String str,String defaultStr);\\nstatic String reverse(String str);\\nstatic String reverseDelimited(String str,char separatorChar);\\nstatic String abbreviate(String str,int maxWidth);\\nstatic String abbreviate(String str,int offset,int maxWidth);\\nstatic String abbreviateMiddle(String str,String middle,int length);\\nstatic String difference(String str1,String str2);\\nstatic int indexOfDifference(String str1,String str2);\\nstatic int indexOfDifference(String[] strs);\\nstatic String getCommonPrefix(String[] strs);\\nstatic int getLevenshteinDistance(String s,String t);\\nstatic boolean startsWith(String str,String prefix);\\nstatic boolean startsWithIgnoreCase(String str,String prefix);\\nstatic boolean startsWithAny(String string,String[] searchStrings);\\nstatic boolean endsWith(String str,String suffix);\\nstatic boolean endsWithIgnoreCase(String str,String suffix);\\nstatic String normalizeSpace(String str);\\nstatic boolean endsWithAny(String string,String[] searchStrings);\\nstatic String firstCharToUpperCase(String value);\\nstatic String firstCharToLowerCase(String value);\\nstatic boolean equalsBlankIgnoreCase(String str1,String str2);\\nstatic String quote(String input);\\nstatic void quote(Appendable buffer,String input);\\nstatic String toString(Object object);\\n }\\n\" }",
            "class_name": "StringUdfSource",
            "code": "public static String sub(String str,int start,int end){\n  return StringUtils.substring(str,start,end);\n}\n",
            "docstring": "/** \n * Gets a substring from the specified String avoiding exceptions. \n */\n",
            "end_lineno": "234",
            "file_content": "/*\n * Copyright 2008-2009 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.dataql.fx.basic;\nimport net.hasor.core.Singleton;\nimport net.hasor.dataql.UdfSourceAssembly;\nimport net.hasor.utils.StringUtils;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n *  <code>import 'net.hasor.dataql.fx.basic.StringUdfSource' as string;</code>\n * @version : 2019-12-12\n */\n@Singleton\npublic class StringUdfSource implements UdfSourceAssembly {\n    // startsWith/endsWith\n    //-----------------------------------------------------------------------\n\n    /** Check if a String starts with a specified prefix. */\n    public static boolean startsWith(String str, String prefix) {\n        return _startsWith(str, prefix, false);\n    }\n\n    /** Case insensitive check if a String starts with a specified prefix. */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        return _startsWith(str, prefix, true);\n    }\n\n    /** Case insensitive check if a String ends with a specified suffix. */\n    public static boolean endsWith(String str, String suffix) {\n        return _endsWith(str, suffix, false);\n    }\n\n    /** Case insensitive check if a String ends with a specified suffix. */\n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        return _endsWith(str, suffix, true);\n    }\n\n    private static boolean _startsWith(String str, String prefix, boolean ignoreCase) {\n        if (str == null || prefix == null) {\n            return str == null && prefix == null;\n        }\n        if (prefix.length() > str.length()) {\n            return false;\n        }\n        return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n    }\n\n    private static boolean _endsWith(String str, String suffix, boolean ignoreCase) {\n        if (str == null || suffix == null) {\n            return str == null && suffix == null;\n        }\n        if (suffix.length() > str.length()) {\n            return false;\n        }\n        int strOffset = str.length() - suffix.length();\n        return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n    }\n\n    // Hump\n    //-----------------------------------------------------------------------\n    private static final Pattern linePattern = Pattern.compile(\"_(\\\\w)\");\n    private static final Pattern humpPattern = Pattern.compile(\"[A-Z]\");\n\n    /**  */\n    public static String lineToHump(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = str.toLowerCase();\n        Matcher matcher = linePattern.matcher(str);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            matcher.appendReplacement(sb, matcher.group(1).toUpperCase());\n        }\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n\n    /**  */\n    public static String humpToLine(String str) {\n        if (str == null) {\n            return null;\n        }\n        Matcher matcher = humpPattern.matcher(str);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            matcher.appendReplacement(sb, \"_\" + matcher.group(0).toLowerCase());\n        }\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n    // UpperCase/LowerCase\n    //-----------------------------------------------------------------------\n\n    /**  */\n    public static String firstCharToUpperCase(String value) {\n        return StringUtils.firstCharToUpperCase(value);\n    }\n\n    /**  */\n    public static String firstCharToLowerCase(String value) {\n        return StringUtils.firstCharToLowerCase(value);\n    }\n\n    /**  */\n    public static String toUpperCase(String value) {\n        return StringUtils.upperCase(value);\n    }\n\n    /**  */\n    public static String toLowerCase(String value) {\n        return StringUtils.lowerCase(value);\n    }\n    // IndexOf/lastIndexOf\n    //-----------------------------------------------------------------------\n\n    /** Finds the first index within a String, handling <code>null</code>. This method uses {@link String#indexOf(String)}. */\n    public static int indexOf(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchStr);\n    }\n\n    /** Finds the first index within a String from a start position, handling <code>null</code>. This method uses {@link String#indexOf(String, int)}. */\n    public static int indexOfWithStart(String str, String searchStr, int startPos) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchStr, startPos);\n    }\n\n    /** Case in-sensitive find of the first index within a String. */\n    public static int indexOfIgnoreCase(String str, String searchStr) {\n        return StringUtils.indexOfIgnoreCase(str, searchStr, 0);\n    }\n\n    /** Case in-sensitive find of the first index within a String from the specified position. */\n    public static int indexOfIgnoreCaseWithStart(String str, String searchStr, int startPos) {\n        return StringUtils.indexOfIgnoreCase(str, searchStr, startPos);\n    }\n\n    /** Finds the last index within a String, handling <code>null</code>. This method uses {@link String#lastIndexOf(String)}. */\n    public static int lastIndexOf(String str, String searchStr) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchStr);\n    }\n\n    /** Finds the last index within a String from a start position, handling <code>null</code>. This method uses {@link String#lastIndexOf(String, int)}. */\n    public static int lastIndexOfWithStart(String str, String searchChar, int startPos) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchChar, startPos);\n    }\n\n    /** Case in-sensitive find of the last index within a String from the specified position. */\n    public static int lastIndexOfIgnoreCase(String str, String searchStr) {\n        return StringUtils.lastIndexOfIgnoreCase(str, searchStr, 0);\n    }\n\n    /** Case in-sensitive find of the last index within a String from the specified position. */\n    public static int lastIndexOfIgnoreCaseWithStart(String str, String searchStr, int startPos) {\n        return StringUtils.lastIndexOfIgnoreCase(str, searchStr, startPos);\n    }\n    // Contains\n    //-----------------------------------------------------------------------\n\n    /** Checks if String contains a search String, handling <code>null</code>. This method uses {@link String#indexOf(String)}. */\n    public static boolean contains(String str, String searchStr) {\n        return StringUtils.contains(str, searchStr);\n    }\n\n    /** Checks if String contains a search String irrespective of case, handling <code>null</code>. Case-insensitivity is defined as by {@link String#equalsIgnoreCase(String)}. */\n    public static boolean containsIgnoreCase(String str, String searchStr) {\n        return StringUtils.containsIgnoreCase(str, searchStr);\n    }\n\n    /** Checks if the String contains any character in the given set of string. */\n    public static boolean containsAny(String str, List<String> searchStrArray) {\n        if (StringUtils.isEmpty(str) || searchStrArray == null || searchStrArray.isEmpty()) {\n            return false;\n        }\n        for (String item : searchStrArray) {\n            if (contains(str, item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /** Case in-sensitive Checks if the String contains any character in the given set of string. */\n    public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n        if (StringUtils.isEmpty(str) || searchStrArray == null || searchStrArray.isEmpty()) {\n            return false;\n        }\n        for (String item : searchStrArray) {\n            if (containsIgnoreCase(str, item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // trim/Sub/left/right\n    //-----------------------------------------------------------------------\n\n    /**  */\n    public static String trim(final String str) {\n        return str == null ? null : str.trim();\n    }\n\n    /** Gets a substring from the specified String avoiding exceptions. */\n    public static String sub(String str, int start, int end) {\n        return StringUtils.substring(str, start, end);\n    }\n\n    /** Gets the leftmost <code>len</code> characters of a String. */\n    public static String left(String str, int len) {\n        return StringUtils.left(str, len);\n    }\n\n    /** Gets the rightmost <code>len</code> characters of a String. */\n    public static String right(String str, int len) {\n        return StringUtils.right(str, len);\n    }\n    // align/pading\n    //-----------------------------------------------------------------------\n\n    /** padChar */\n    public static String alignRight(String str, String padChar, int len) {\n        if (str != null) {\n            if (str.length() > len) {\n                return str;\n            }\n        }\n        char pad = padChar.length() == 0 ? ' ' : padChar.charAt(0);\n        return StringUtils.rightPad(str, len, pad);\n    }\n\n    /** padChar */\n    public static String alignLeft(String str, String padChar, int len) {\n        if (str != null) {\n            if (str.length() > len) {\n                return str;\n            }\n        }\n        char pad = padChar.length() == 0 ? ' ' : padChar.charAt(0);\n        return StringUtils.leftPad(str, len, pad);\n    }\n\n    /** padChar */\n    public static String alignCenter(String str, String padChar, int len) {\n        if (str != null) {\n            if (str.length() > len) {\n                return str;\n            }\n        }\n        char pad = padChar.length() == 0 ? ' ' : padChar.charAt(0);\n        return StringUtils.center(str, len, pad);\n    }\n    // compare\n    //-----------------------------------------------------------------------\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * <p>\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let <i>k</i> be the smallest such index; then the string\n     * whose character at position <i>k</i> has the smaller value, as\n     * determined by using the &lt; operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * <blockquote><pre>\n     * this.charAt(k)-anotherString.charAt(k)\n     * </pre></blockquote>\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * <blockquote><pre>\n     * this.length()-anotherString.length()\n     * </pre></blockquote>\n     *\n     * @param   str1   the {@code String} to be compared.\n     * @param   str2   the {@code String} to be compared.\n     * @return the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public static int compareString(String str1, String str2) {\n        str1 = str1 == null ? \"\" : str1;\n        str2 = str2 == null ? \"\" : str2;\n        return str1.compareTo(str2);\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with normalized versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(character))} on\n     * each character.\n     * <p>\n     * Note that this method does <em>not</em> take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The java.text package provides <em>collators</em> to allow\n     * locale-sensitive ordering.\n     *\n     * @param   str1   the {@code String} to be compared.\n     * @param   str2   the {@code String} to be compared.\n     * @return a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator#compare(String, String)\n     * @since 1.2\n     */\n    public static int compareStringIgnoreCase(String str1, String str2) {\n        str1 = str1 == null ? \"\" : str1;\n        str2 = str2 == null ? \"\" : str2;\n        return str1.compareToIgnoreCase(str2);\n    }\n    // other\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Splits the provided text into an array, separators specified.\n     * This is an alternative to using StringTokenizer.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as one separator.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separatorChars splits on whitespace.</p>\n     *\n     * <pre>\n     * StringUtils.split(null, *)         = null\n     * StringUtils.split(\"\", *)           = []\n     * StringUtils.split(\"abc def\", null) = [\"abc\", \"def\"]\n     * StringUtils.split(\"abc def\", \" \")  = [\"abc\", \"def\"]\n     * StringUtils.split(\"abc  def\", \" \") = [\"abc\", \"def\"]\n     * StringUtils.split(\"ab:cd:ef\", \":\") = [\"ab\", \"cd\", \"ef\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separatorChars  the characters used as the delimiters, <code>null</code> splits on whitespace\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    public static List<String> split(String str, String separatorChars) {\n        return Arrays.asList(StringUtils.split(str, separatorChars));\n    }\n\n    /** Joins the elements of the provided array into a single String containing the provided list of elements. */\n    public static String join(List<Object> array, String separator) {\n        if (array == null) {\n            return null;\n        }\n        return StringUtils.join(array.toArray(), separator);\n    }\n\n    /** Checks if a String is empty (\"\") or null.*/\n    public static boolean isEmpty(String str) {\n        return str == null || str.length() == 0;\n    }\n\n    /**  */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n}\n",
            "file_name": "StringUdfSource.java",
            "human_label": "Get a substring from the specified String avoiding exceptions. ",
            "level": "project_runnable",
            "lineno": "231",
            "name": "sub",
            "oracle_context": "{ \"apis\" : \"[substring]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
            "package": "net.hasor.dataql.fx.basic",
            "project": "hasor-master"
        },
        {
            "_id": "6367671a1a6d9265ec017c15",
            "all_context": "{ \"class_level\" : \"byte[] data;\\nint length;\\nByteVector();\\nByteVector(int initialCapacity);\\nByteVector(byte[] data);\\nput11(int byteValue1,int byteValue2);\\nputShort(int shortValue);\\nput12(int byteValue,int shortValue);\\nput112(int byteValue1,int byteValue2,int shortValue);\\nputInt(int intValue);\\nput122(int byteValue,int shortValue1,int shortValue2);\\nputLong(long longValue);\\nputUTF8(String stringValue);\\nencodeUtf8(String stringValue,int offset,int maxByteLength);\\nputByteArray(byte[] byteArrayValue,int byteOffset,int byteLength);\\nenlarge(int size);\\nputByte(int byteValue);\\n\", \"repo_level\" : \"\" }",
            "class_name": "ByteVector",
            "code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n  if (length + byteLength > data.length) {\n    enlarge(byteLength);\n  }\n  if (byteArrayValue != null) {\n    System.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);\n  }\n  length+=byteLength;\n  return this;\n}\n",
            "docstring": "/** \n * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.\n * @param byteOffset index of the first byte of byteArrayValue that must be copied.\n * @param byteLength number of bytes of byteArrayValue that must be copied.\n * @return this byte vector.\n */\n",
            "end_lineno": "343",
            "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage net.hasor.utils.asm;\n/**\n * A dynamically extensible vector of bytes. This class is roughly equivalent to a DataOutputStream\n * on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n */\npublic class ByteVector {\n    /** The content of this vector. Only the first {@link #length} bytes contain real data. */\n    byte[] data;\n    /** The actual number of bytes in this vector. */\n    int    length;\n\n    /** Constructs a new {@link ByteVector} with a default initial capacity. */\n    public ByteVector() {\n        data = new byte[64];\n    }\n\n    /**\n     * Constructs a new {@link ByteVector} with the given initial capacity.\n     *\n     * @param initialCapacity the initial capacity of the byte vector to be constructed.\n     */\n    public ByteVector(final int initialCapacity) {\n        data = new byte[initialCapacity];\n    }\n\n    /**\n     * Constructs a new {@link ByteVector} from the given initial data.\n     *\n     * @param data the initial data of the new byte vector.\n     */\n    ByteVector(final byte[] data) {\n        this.data = data;\n        this.length = data.length;\n    }\n\n    /**\n     * Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue a byte.\n     * @return this byte vector.\n     */\n    public ByteVector putByte(final int byteValue) {\n        int currentLength = length;\n        if (currentLength + 1 > data.length) {\n            enlarge(1);\n        }\n        data[currentLength++] = (byte) byteValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue1 a byte.\n     * @param byteValue2 another byte.\n     * @return this byte vector.\n     */\n    final ByteVector put11(final int byteValue1, final int byteValue2) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue1;\n        currentData[currentLength++] = (byte) byteValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    public ByteVector putShort(final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteValue a byte.\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    final ByteVector put12(final int byteValue, final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 3 > data.length) {\n            enlarge(3);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts two bytes and a short into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteValue1 a byte.\n     * @param byteValue2 another byte.\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    final ByteVector put112(final int byteValue1, final int byteValue2, final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue1;\n        currentData[currentLength++] = (byte) byteValue2;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param intValue an int.\n     * @return this byte vector.\n     */\n    public ByteVector putInt(final int intValue) {\n        int currentLength = length;\n        if (currentLength + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\n     * if necessary.\n     *\n     * @param byteValue a byte.\n     * @param shortValue1 a short.\n     * @param shortValue2 another short.\n     * @return this byte vector.\n     */\n    final ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) {\n        int currentLength = length;\n        if (currentLength + 5 > data.length) {\n            enlarge(5);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue1 >>> 8);\n        currentData[currentLength++] = (byte) shortValue1;\n        currentData[currentLength++] = (byte) (shortValue2 >>> 8);\n        currentData[currentLength++] = (byte) shortValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param longValue a long.\n     * @return this byte vector.\n     */\n    public ByteVector putLong(final long longValue) {\n        int currentLength = length;\n        if (currentLength + 8 > data.length) {\n            enlarge(8);\n        }\n        byte[] currentData = data;\n        int intValue = (int) (longValue >>> 32);\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        intValue = (int) longValue;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param stringValue a String whose UTF8 encoded length must be less than 65536.\n     * @return this byte vector.\n     */\n    // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\n    public ByteVector putUTF8(final String stringValue) {\n        int charLength = stringValue.length();\n        if (charLength > 65535) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        int currentLength = length;\n        if (currentLength + 2 + charLength > data.length) {\n            enlarge(2 + charLength);\n        }\n        byte[] currentData = data;\n        // Optimistic algorithm: instead of computing the byte length and then serializing the string\n        // (which requires two loops), we assume the byte length is equal to char length (which is the\n        // most frequent case), and we start serializing the string right away. During the\n        // serialization, if we find that this assumption is wrong, we continue with the general method.\n        currentData[currentLength++] = (byte) (charLength >>> 8);\n        currentData[currentLength++] = (byte) charLength;\n        for (int i = 0; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= '\\u0001' && charValue <= '\\u007F') {\n                currentData[currentLength++] = (byte) charValue;\n            } else {\n                length = currentLength;\n                return encodeUtf8(stringValue, i, 65535);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary. The string length is encoded in two bytes before the encoded characters, if there is\n     * space for that (i.e. if this.length - offset - 2 &gt;= 0).\n     *\n     * @param stringValue the String to encode.\n     * @param offset the index of the first character to encode. The previous characters are supposed\n     *     to have already been encoded, using only one byte per character.\n     * @param maxByteLength the maximum byte length of the encoded string, including the already\n     *     encoded characters.\n     * @return this byte vector.\n     */\n    final ByteVector encodeUtf8(final String stringValue, final int offset, final int maxByteLength) {\n        int charLength = stringValue.length();\n        int byteLength = offset;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                byteLength++;\n            } else if (charValue <= 0x07FF) {\n                byteLength += 2;\n            } else {\n                byteLength += 3;\n            }\n        }\n        if (byteLength > maxByteLength) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        // Compute where 'byteLength' must be stored in 'data', and store it at this location.\n        int byteLengthOffset = length - offset - 2;\n        if (byteLengthOffset >= 0) {\n            data[byteLengthOffset] = (byte) (byteLength >>> 8);\n            data[byteLengthOffset + 1] = (byte) byteLength;\n        }\n        if (length + byteLength - offset > data.length) {\n            enlarge(byteLength - offset);\n        }\n        int currentLength = length;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                data[currentLength++] = (byte) charValue;\n            } else if (charValue <= 0x07FF) {\n                data[currentLength++] = (byte) (0xC0 | charValue >> 6 & 0x1F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            } else {\n                data[currentLength++] = (byte) (0xE0 | charValue >> 12 & 0xF);\n                data[currentLength++] = (byte) (0x80 | charValue >> 6 & 0x3F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\n     *     bytes into this byte vector.\n     * @param byteOffset index of the first byte of byteArrayValue that must be copied.\n     * @param byteLength number of bytes of byteArrayValue that must be copied.\n     * @return this byte vector.\n     */\n    public ByteVector putByteArray(final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n        if (length + byteLength > data.length) {\n            enlarge(byteLength);\n        }\n        if (byteArrayValue != null) {\n            System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength);\n        }\n        length += byteLength;\n        return this;\n    }\n\n    /**\n     * Enlarges this byte vector so that it can receive 'size' more bytes.\n     *\n     * @param size number of additional bytes that this byte vector should be able to receive.\n     */\n    private void enlarge(final int size) {\n        int doubleCapacity = 2 * data.length;\n        int minimalCapacity = length + size;\n        byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\n        System.arraycopy(data, 0, newData, 0, length);\n        data = newData;\n    }\n}\n",
            "file_name": "ByteVector.java",
            "human_label": "Put an array of bytes into this byte vector, enlarge the byte vector automatically if necessary.",
            "level": "class_runnable",
            "lineno": "324",
            "name": "putByteArray",
            "oracle_context": "{ \"apis\" : \"[enlarge, arraycopy, ByteVector]\", \"classes\" : \"[data]\", \"vars\" : \"[length, data]\" }",
            "package": "net.hasor.utils.asm",
            "project": "hasor-master"
        },
        {
            "_id": "636766821a6d9265ec0174d2",
            "all_context": "{ \"class_level\" : \"import org.atmosphere.util.FakeHttpSession;\\nimport org.atmosphere.util.QueryStringDecoder;\\nimport org.atmosphere.util.ReaderInputStream;\\nimport org.slf4j.Logger;\\nimport org.slf4j.LoggerFactory;\\nimport javax.servlet.AsyncContext;\\nimport javax.servlet.AsyncListener;\\nimport javax.servlet.DispatcherType;\\nimport javax.servlet.RequestDispatcher;\\nimport javax.servlet.ServletContext;\\nimport javax.servlet.ServletException;\\nimport javax.servlet.ServletInputStream;\\nimport javax.servlet.ServletRequest;\\nimport javax.servlet.ServletResponse;\\nimport javax.servlet.http.Cookie;\\nimport javax.servlet.http.HttpServletRequest;\\nimport javax.servlet.http.HttpServletRequestWrapper;\\nimport javax.servlet.http.HttpServletResponse;\\nimport javax.servlet.http.HttpSession;\\nimport javax.servlet.http.Part;\\nimport java.io.BufferedReader;\\nimport java.io.ByteArrayInputStream;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.io.InputStreamReader;\\nimport java.io.Reader;\\nimport java.io.StringReader;\\nimport java.io.UnsupportedEncodingException;\\nimport java.net.InetSocketAddress;\\nimport java.nio.charset.StandardCharsets;\\nimport java.security.Principal;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nimport java.util.Collections;\\nimport java.util.Enumeration;\\nimport java.util.HashMap;\\nimport java.util.HashSet;\\nimport java.util.List;\\nimport java.util.Locale;\\nimport java.util.Map;\\nimport java.util.Objects;\\nimport java.util.Set;\\nimport java.util.concurrent.Callable;\\nimport java.util.concurrent.atomic.AtomicBoolean;\\nimport static org.atmosphere.cpr.HeaderConfig.X_ATMOSPHERE;\\nLogger logger;\\nServletInputStream bis;\\nBufferedReader br;\\nBuilder b;\\nAtomicBoolean destroyed;\\nboolean queryComputed;\\nboolean cookieComputed;\\nBufferedReader voidReader;\\nServletInputStream voidStream;\\nAtomicBoolean streamSet;\\nAtomicBoolean readerSet;\\nString uuid;\\nboolean noopsAsyncContextStarted;\\nByteArrayInputStream bis;\\nBody NULL_BODY;\\nHttpServletRequest request;\\nString pathInfo;\\nString encoding;\\nString methodType;\\nString contentType;\\nboolean noContentType;\\nLong contentLength;\\nMap<String,String> headers;\\nMap<String,String[]> queryStrings;\\nString servletPath;\\nString requestURI;\\nString requestURL;\\nInputStream inputStream;\\nReader reader;\\nString remoteAddr;\\nString remoteHost;\\nint remotePort;\\nString localAddr;\\nString localName;\\nint localPort;\\nboolean dispatchRequestAsynchronously;\\nboolean destroyable;\\nSet<Cookie> cookies;\\nSet<Locale> locales;\\nPrincipal principal;\\nString authType;\\nString contextPath;\\nString serverName;\\nint serverPort;\\nHttpSession webSocketFakeSession;\\nString queryString;\\nboolean isSecure;\\nLazyComputation lazyRemote;\\nLazyComputation lazyLocal;\\nBody body;\\nLocalAttributes localAttributes;\\nString data;\\nbyte[] dataBytes;\\nint offset;\\nint length;\\nboolean isEmpty;\\nInputStream innerStream;\\nboolean throwExceptionOnCloned;\\nHttpSession fake;\\nEnumeration<String> EMPTY_ENUM_STRING;\\nEnumeration<Locale> EMPTY_ENUM_LOCALE;\\nList<Part> EMPTY_ENUM_PART;\\nMap<String,String[]> EMPTY_MAP_STRING;\\nString[] EMPTY_ARRAY;\\nStringBuffer EMPTY_STRING_BUFFER;\\nCookie[] EMPTY_COOKIE;\\nCallable<InetSocketAddress> callable;\\nInetSocketAddress address;\\nAsyncContext context;\\nCompletionAware callback;\\nServletRequest request;\\nServletResponse response;\\nlong timeout;\\nAtmosphereRequestImpl(Builder b);\\ngetVoidReader();\\nconfigureStream();\\nconfigureReader();\\ndestroyed();\\ndestroyable(boolean destroyable);\\ngetPathInfo();\\ngetPathTranslated();\\ngetQueryString();\\ntoQs();\\ngetRemoteUser();\\ngetRequestedSessionId();\\ngetMethod();\\ngetPart(String name);\\ngetParts();\\ngetContentType();\\ngetDispatcherType();\\ngetServletPath();\\ngetRequestURI();\\ngetRequestURL();\\ngetHeaders(String name);\\ngetIntHeader(String name);\\ngetHeaderNames();\\nauthenticate(HttpServletResponse response);\\ngetAuthType();\\ngetContextPath();\\ngetCookies();\\ngetDateHeader(String name);\\ngetHeader(String s);\\nwrappedRequest();\\ngetHeader(String s,boolean checkCase);\\ngetParameter(String s);\\ngetParameterMap();\\ngetParameterNames();\\ngetParameterValues(String s);\\ngetProtocol();\\ngetInputStream();\\ngetReader();\\ngetRealPath(String path);\\nheaders(Map headers);\\nheader(String name,String value);\\nqueryString(String qs);\\nheadersMap();\\nqueryStringsMap();\\nmethod(String m);\\ncontentType(String m);\\nbody(String body);\\nbody(byte[] bytes);\\nbody(InputStream body);\\nbody(Reader body);\\nbody();\\nservletPath(String servletPath);\\ncontextPath(String contextPath);\\nrequestURI(String requestURI);\\nByteInputStream(byte[] data,int offset,int length);\\nread();\\nsetAttribute(String s,Object o);\\nsetCharacterEncoding(String env);\\nstartAsync();\\nstartAsync(ServletRequest request,ServletResponse response);\\ngetAsyncContext();\\ngetAttribute(String s);\\nremoveAttribute(String name);\\nattributes();\\ngetSession();\\ngetSession(boolean create);\\ngetUserPrincipal();\\nisRequestedSessionIdFromCookie();\\nisRequestedSessionIdFromUrl();\\nisRequestedSessionIdFromURL();\\nisRequestedSessionIdValid();\\nisUserInRole(String role);\\nlogin(String username,String password);\\nlogout();\\ngetRemoteAddr();\\ngetRemoteHost();\\ngetRemotePort();\\ngetRequestDispatcher(String path);\\ngetScheme();\\ngetServerName();\\ngetServerPort();\\ngetServletContext();\\nisAsyncStarted();\\nisAsyncSupported();\\nisSecure();\\ngetLocalName();\\ngetLocalPort();\\ngetLocalAddr();\\nisNotNoOps();\\ngetLocale();\\nresource();\\ngetLocales();\\ndispatchRequestAsynchronously();\\nisDestroyable();\\npathInfo(String pathInfo);\\ngetAttributeNames();\\nattributeWithoutException(HttpServletRequest request,String attribute);\\nlocalAttributes();\\ngetCharacterEncoding();\\ngetContentLength();\\nuuid();\\ndestroy();\\ndestroy(boolean force);\\nsetRequest(ServletRequest request);\\nBuilder();\\ncookies(Set cookies);\\ndispatchRequestAsynchronously(boolean dispatchRequestAsynchronously);\\nremoteAddr(String remoteAddr);\\nremoteHost(String remoteHost);\\nremotePort(int remotePort);\\nlocalAddr(String localAddr);\\nlocalName(String localName);\\nlocalPort(int localPort);\\nremoteInetSocketAddress(Callable remoteAddr);\\nlocalInetSocketAddress(Callable localAddr);\\nattributes(Map attributes);\\nrequest(HttpServletRequest request);\\nrequestURL(String requestURL);\\nqueryString(String queryString);\\nbody(byte[] dataBytes);\\nbody(byte[] dataBytes,int offset,int length);\\nencoding(String encoding);\\nmethod(String methodType);\\ncontentType(String contentType);\\ncontentLength(Long contentLength);\\nbody(String data);\\ninputStream(InputStream inputStream);\\nreader(Reader reader);\\nbuild();\\nqueryStrings(Map queryStrings);\\nserverName(String serverName);\\nserverPort(int serverPort);\\nsession(HttpSession session);\\nprincipal(Principal principal);\\nauthType(String authType);\\nisSSecure(boolean isSecure);\\nlocale(Locale locale);\\nuserPrincipal(Principal userPrincipal);\\nBody(String data,byte[] dataBytes,int offset,int length);\\nhasBytes();\\nasString();\\nasBytes();\\nbyteOffset();\\nbyteLength();\\nisEmpty();\\nIS(InputStream innerStream);\\nread(byte[] bytes);\\nread(byte[] bytes,int i,int i1);\\nskip(long l);\\navailable();\\nclose();\\nmark(int i);\\nreset();\\nmarkSupported();\\nnewInstance();\\nwrap(HttpServletRequest request);\\ncloneRequest(HttpServletRequest request,boolean loadInMemory,boolean copySession,boolean isDestroyable,boolean createSession);\\nNoOpsRequest();\\nNoOpsRequest(boolean throwExceptionOnCloned);\\ngetHeader(String name);\\ninvalidate();\\ngetAttribute(String name);\\ngetParameter(String name);\\ngetParameterValues(String name);\\nsetAttribute(String name,Object o);\\nLazyComputation(Callable callable);\\naddress();\\ngetPort();\\ngetHostAddress();\\ngetHostName();\\nisCompletionAware();\\nCompletionAwareAsyncContext(AsyncContext context,CompletionAware callback);\\naddListener(AsyncListener listener);\\naddListener(AsyncListener listener,ServletRequest request,ServletResponse response);\\ncomplete();\\ncreateListener(Class clazz);\\ndispatch();\\ndispatch(ServletContext servletContext,String path);\\ndispatch(String path);\\ngetRequest();\\ngetResponse();\\ngetTimeout();\\nhasOriginalRequestAndResponse();\\nsetTimeout(long timeoutMilliseconds);\\nstart(Runnable run);\\nNoOpsAsyncContext(ServletRequest request,ServletResponse response);\\nsetTimeout(long timeout);\\nload(HttpServletRequest request,Builder b);\\ntoString();\\nrequestURL();\\nhasString();\\n\", \"repo_level\" : \"public interface FakeHttpSession {public void destroy();\\npublic long getCreationTime();\\npublic String getId();\\npublic long getLastAccessedTime();\\npublic ServletContext getServletContext();\\npublic void setMaxInactiveInterval(int interval);\\npublic int getMaxInactiveInterval();\\npublic HttpSessionContext getSessionContext();\\npublic Object getAttribute(String name);\\npublic Object getValue(String name);\\npublic Enumeration<String> getAttributeNames();\\npublic String[] getValueNames();\\npublic void setAttribute(String name,Object value);\\npublic void putValue(String name,Object value);\\npublic void removeAttribute(String name);\\npublic void removeValue(String name);\\npublic FakeHttpSession copyAttributes(HttpSession httpSession);\\npublic void invalidate();\\npublic boolean isNew();\\n }\\npublic interface QueryStringDecoder {public String getPath();\\npublic Map<String,List<String>> getParameters();\\nstatic String decodeComponent(String s);\\nstatic String decodeComponent(String s,Charset charset);\\n }\\npublic interface ReaderInputStream {public int read(byte[] b,int off,int len);\\npublic int read(byte[] b);\\npublic int read();\\npublic void close();\\n }\\n\" }",
            "class_name": "AtmosphereRequestImpl",
            "code": "public static AtmosphereRequest wrap(HttpServletRequest request){\n  if (AtmosphereRequestImpl.class.isAssignableFrom(request.getClass())) {\n    return (AtmosphereRequestImpl)request;\n  }\n  Builder b=new Builder();\n  Enumeration<String> e=request.getAttributeNames();\n  String s;\n  while (e.hasMoreElements()) {\n    s=e.nextElement();\n    b.localAttributes.put(s,attributeWithoutException(request,s));\n  }\n  return b.request(request).build();\n}\n",
            "docstring": "/** \n * Wrap an  {@link HttpServletRequest}.\n * @param request {@link HttpServletRequest}\n * @return an {@link AtmosphereRequest}\n */\n",
            "end_lineno": "1423",
            "file_content": "/*\n * Copyright 2008-2022 Async-IO.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.atmosphere.cpr;\n\nimport org.atmosphere.util.FakeHttpSession;\nimport org.atmosphere.util.QueryStringDecoder;\nimport org.atmosphere.util.ReaderInputStream;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.AsyncContext;\nimport javax.servlet.AsyncListener;\nimport javax.servlet.DispatcherType;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletInputStream;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport javax.servlet.http.Part;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.security.Principal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.atmosphere.cpr.HeaderConfig.X_ATMOSPHERE;\n\n/**\n * An Atmosphere request representation. An {@link AtmosphereRequest} is a two-way communication channel between the\n * client and the server. If the {@link AtmosphereRequestImpl#isDestroyable()} is set to false, or if its\n * associated {@link AtmosphereResource} has been suspended, this object can be re-used at any moment between requests.\n * You can use its associated {@link AtmosphereResponse} to write bytes at any moment, making this object bi-directional.\n * <br/>\n *\n * @author Jeanfrancois Arcand\n */\npublic class AtmosphereRequestImpl extends HttpServletRequestWrapper implements AtmosphereRequest {\n\n    private final static Logger logger = LoggerFactory.getLogger(AtmosphereRequestImpl.class);\n    private ServletInputStream bis;\n    private BufferedReader br;\n    private final Builder b;\n    private final AtomicBoolean destroyed = new AtomicBoolean(false);\n    private boolean queryComputed;\n    private boolean cookieComputed;\n    private volatile BufferedReader voidReader;\n    private final ServletInputStream voidStream = new IS(new ByteArrayInputStream(new byte[0]));\n    private final AtomicBoolean streamSet = new AtomicBoolean();\n    private final AtomicBoolean readerSet = new AtomicBoolean();\n    private String uuid;\n    private boolean noopsAsyncContextStarted;\n\n    private AtmosphereRequestImpl(Builder b) {\n        super(b.request == null ? new NoOpsRequest() : b.request);\n        if (b.request == null) b.request(new NoOpsRequest());\n\n        this.b = b;\n        this.uuid = resource() != null ? resource().uuid() : \"0\";\n    }\n\n    private BufferedReader getVoidReader() {\n        if (voidReader == null) {\n            voidReader = new BufferedReader(new StringReader(\"\"), 5);\n        }\n        return voidReader;\n    }\n\n    private void configureStream() {\n        if (bis == null && !streamSet.getAndSet(true)) {\n            if (b.inputStream != null) {\n                bis = new IS(b.inputStream);\n            } else if (b.reader == null) {\n                if (b.body.dataBytes != null) {\n                    bis = new ByteInputStream(b.body.dataBytes, b.body.offset, b.body.length);\n                } else if (b.body.data != null) {\n                    byte[] bytes = b.body.data.getBytes(StandardCharsets.UTF_8);\n                    bis = new ByteInputStream(bytes, 0, bytes.length);\n                }\n            } else {\n                bis = new IS(new ReaderInputStream(b.reader));\n            }\n        }\n    }\n\n    private void configureReader() {\n        if (br == null && !readerSet.getAndSet(false)) {\n            if (b.reader != null) {\n                br = new BufferedReader(b.reader);\n            } else if (b.inputStream == null) {\n                try {\n                    if (b.body.dataBytes != null) {\n                        br = new BufferedReader(new StringReader(new String(b.body.dataBytes, b.body.offset, b.body.length, b.encoding)));\n                    } else if (b.body.data != null) {\n                        br = new BufferedReader(new StringReader(b.body.data));\n                    }\n                } catch (UnsupportedEncodingException e) {\n                    throw new RuntimeException(e);\n                }\n            } else {\n                br = new BufferedReader(new InputStreamReader(b.inputStream));\n            }\n        }\n    }\n\n    @Override\n    public boolean destroyed() {\n        return destroyed.get();\n    }\n\n    @Override\n    public AtmosphereRequest destroyable(boolean destroyable) {\n        b.destroyable = destroyable;\n        return this;\n    }\n\n    @Override\n    public String getPathInfo() {\n        return !Objects.equals(b.pathInfo, \"\") ? b.pathInfo : isNotNoOps() ? b.request.getPathInfo() : \"\";\n    }\n\n    @Override\n    public String getPathTranslated() {\n        return b.request.getPathTranslated();\n    }\n\n    @Override\n    public String getQueryString() {\n        return !Objects.equals(b.queryString, \"\") ? b.queryString : isNotNoOps() ? b.request.getQueryString() : toQs();\n    }\n\n    private String toQs() {\n        StringBuilder q = new StringBuilder();\n        for (Map.Entry<String, String[]> e : b.queryStrings.entrySet()) {\n            for (String k : e.getValue()) {\n                q.append(e.getKey()).append(\"=\").append(k).append(\"&\");\n            }\n        }\n        if (q.length() > 0) q.deleteCharAt(q.length() - 1);\n        return q.toString();\n    }\n\n    @Override\n    public String getRemoteUser() {\n        return b.principal != null ? b.principal.getName() : b.request.getRemoteUser();\n    }\n\n    @Override\n    public String getRequestedSessionId() {\n        return b.request.getRequestedSessionId();\n    }\n\n    @Override\n    public String getMethod() {\n        return b.methodType != null ? b.methodType : b.request.getMethod();\n    }\n\n    @Override\n    public Part getPart(String name) throws IOException, ServletException {\n        return b.request.getPart(name);\n    }\n\n    @Override\n    public Collection<Part> getParts() throws IOException, ServletException {\n        return b.request.getParts();\n    }\n\n    @Override\n    public String getContentType() {\n        return b.contentType != null || b.noContentType ? b.contentType : b.request.getContentType();\n    }\n\n    @Override\n    public DispatcherType getDispatcherType() {\n        return b.request.getDispatcherType();\n    }\n\n    @Override\n    public String getServletPath() {\n        return !Objects.equals(b.servletPath, \"\") ? b.servletPath : (isNotNoOps() ? b.request.getServletPath() : \"\");\n    }\n\n    @Override\n    public String getRequestURI() {\n        return b.requestURI != null ? b.requestURI : (isNotNoOps() ? b.request.getRequestURI() : \"\");\n    }\n\n    @Override\n    public StringBuffer getRequestURL() {\n        return b.requestURL != null ? new StringBuffer(b.requestURL) : (isNotNoOps() ? b.request.getRequestURL() : new StringBuffer());\n    }\n\n    @Override\n    public Enumeration getHeaders(String name) {\n\n        ArrayList<? super Object> list = new ArrayList<>();\n        // Never override the parent Request\n        if (!name.equalsIgnoreCase(\"content-type\")) {\n            Enumeration<String> e = b.request.getHeaders(name);\n            while (e.hasMoreElements())\n                list.add(e.nextElement());\n        }\n\n        if (name.equalsIgnoreCase(\"content-type\")) {\n            String s = getContentType();\n            if (s != null) {\n                list.add(s);\n            }\n        } else {\n            if (b.headers.get(name) != null) {\n                list.add(b.headers.get(name));\n            }\n\n            if (isNotNoOps()) {\n                if (list.isEmpty() && name.startsWith(X_ATMOSPHERE)) {\n                    if (attributeWithoutException(b.request, name) != null) {\n                        list.add(attributeWithoutException(b.request, name));\n                    }\n                }\n            }\n        }\n        return Collections.enumeration(list);\n    }\n\n    @Override\n    public int getIntHeader(String name) {\n        return b.request.getIntHeader(name);\n    }\n\n    @Override\n    public Enumeration<String> getHeaderNames() {\n        Set<String> list = new HashSet<>();\n        list.addAll(b.headers.keySet());\n\n        list.addAll(Collections.list(b.request.getHeaderNames()));\n        if (b.request != null) {\n            Enumeration<String> e = b.request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String name = e.nextElement();\n                if (name.startsWith(X_ATMOSPHERE)) {\n                    list.add(name);\n                }\n            }\n        }\n\n        if (b.contentType != null) {\n            list.add(\"Content-Type\");\n        }\n        return Collections.enumeration(list);\n    }\n\n    @Override\n    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n        return b.request.authenticate(response);\n    }\n\n    @Override\n    public String getAuthType() {\n        return b.authType != null ? b.authType : b.request.getAuthType();\n    }\n\n    @Override\n    public String getContextPath() {\n        String c = \"/\";\n        try {\n            c = isNotNoOps() && b.request.getContextPath() != null ? b.request.getContextPath() : b.contextPath != null ? b.contextPath : \"\";\n        } catch (NullPointerException ex) {\n            // https://github.com/Atmosphere/atmosphere/issues/1804\n            logger.warn(\"Unexpected getContextPath exception. Forcing `/`\", ex);\n        }\n        return c;\n    }\n\n    @Override\n    public Cookie[] getCookies() {\n        if (!cookieComputed) {\n            if (b.cookies == null)\n                return new Cookie[0];\n            cookieComputed = true;\n            Cookie[] c = b.request.getCookies();\n            if (c != null && c.length > 0) {\n                b.cookies.addAll(Arrays.asList(c));\n            }\n        }\n        return b.cookies.toArray(new Cookie[]{});\n    }\n\n    @Override\n    public long getDateHeader(String name) {\n        return b.request.getDateHeader(name);\n    }\n\n    @Override\n    public String getHeader(String s) {\n        return getHeader(s, true);\n    }\n\n    @Override\n    public HttpServletRequest wrappedRequest() {\n        return b.request;\n    }\n\n    @Override\n    public String getHeader(String s, boolean checkCase) {\n\n        if (\"content-type\".equalsIgnoreCase(s)) {\n            return getContentType();\n        }\n\n        String name = b.request.getHeader(s);\n        if (name == null) {\n            if (b.headers.get(s) != null) {\n                return b.headers.get(s);\n            }\n\n            if (s.startsWith(X_ATMOSPHERE) && isNotNoOps()) {\n                // Craziness with Struts 2 who wraps String attribute as BigDecimal\n                // https://github.com/Atmosphere/atmosphere/issues/1367\n                Object o = attributeWithoutException(b.request, s);\n                if (o == null || String.class.isAssignableFrom(o.getClass())) {\n                    name = (String) o;\n                } else {\n                    try {\n                        if (HttpServletRequestWrapper.class.isAssignableFrom(b.request.getClass())) {\n                            HttpServletRequest hsr = b.request;\n                            while (hsr instanceof HttpServletRequestWrapper) {\n                                hsr = (HttpServletRequest) ((HttpServletRequestWrapper) hsr).getRequest();\n                                o = attributeWithoutException(hsr, s);\n                                if (o == null || String.class.isAssignableFrom(o.getClass())) {\n                                    name = (String) o;\n                                    break;\n                                }\n                            }\n                        }\n                    } catch (Exception ex) {\n                        logger.warn(\"\", ex);\n                    }\n                }\n            }\n        }\n\n        if (name == null && checkCase) {\n            return getHeader(s.toLowerCase(), false);\n        }\n\n        if (name == null && \"connection\".equalsIgnoreCase(s)) {\n            return \"keep-alive\";\n        }\n\n        return name;\n    }\n\n    @Override\n    public String getParameter(String s) {\n        String name = isNotNoOps() ? b.request.getParameter(s) : null;\n        if (name == null) {\n            if (b.queryStrings.get(s) != null) {\n                return b.queryStrings.get(s)[0];\n            }\n        }\n        return name;\n    }\n\n    @Override\n    public Map<String, String[]> getParameterMap() {\n        if (!queryComputed) {\n            queryComputed = true;\n            Map<String, String[]> m = (isNotNoOps() ? b.request.getParameterMap() : Collections.emptyMap());\n            for (String e : m.keySet()) {\n                b.queryStrings.put(e, getParameterValues(e));\n            }\n        }\n        return Collections.unmodifiableMap(b.queryStrings);\n    }\n\n    @Override\n    public Enumeration<String> getParameterNames() {\n        return Collections.enumeration(getParameterMap().keySet());\n    }\n\n    @Override\n    public String[] getParameterValues(String s) {\n        String[] list = b.request.getParameterValues(s);\n        if (list != null && b.queryStrings.get(s) != null) {\n            String[] newList = b.queryStrings.get(s);\n            if (!Arrays.deepEquals(list, newList)) {\n                String[] s1 = new String[list.length + newList.length];\n                System.arraycopy(list, 0, s1, 0, list.length);\n                System.arraycopy(newList, 0, s1, list.length, newList.length);\n                return s1;\n            } else {\n                return list;\n            }\n        } else {\n            return list == null ? b.queryStrings.get(s) : list;\n        }\n    }\n\n    @Override\n    public String getProtocol() {\n        return b.request.getProtocol();\n    }\n\n    @Override\n    public ServletInputStream getInputStream() throws IOException {\n        if (b.body.isEmpty()) {\n            configureStream();\n            return bis == null ? (isNotNoOps() ? b.request.getInputStream() : voidStream) : bis;\n        } else if (b.body.hasString()) {\n            bis = new IS(new ByteArrayInputStream(b.body.asString().getBytes()));\n        } else if (b.body.hasBytes()) {\n            bis = new IS(new ByteArrayInputStream(b.body.asBytes(), b.body.offset, b.body.byteLength()));\n        }\n        return bis;\n    }\n\n    @Override\n    public BufferedReader getReader() throws IOException {\n        if (b.body.isEmpty()) {\n            configureReader();\n            return br == null ? (isNotNoOps() ? b.request.getReader() : getVoidReader()) : br;\n        } else if (b.body.hasString()) {\n            br = new BufferedReader(new StringReader(body().asString()));\n        } else if (b.body.hasBytes()) {\n            br = new BufferedReader(new StringReader(new String(body().asBytes(), body().byteOffset(), body().length)));\n        }\n        return br;\n    }\n\n    @Override\n    public String getRealPath(String path) {\n        return b.request.getRealPath(path);\n    }\n\n    @Override\n    public AtmosphereRequest headers(Map<String, String> headers) {\n        b.headers.putAll(headers);\n        return this;\n    }\n\n    @Override\n    public AtmosphereRequest header(String name, String value) {\n        b.headers.put(name, value);\n        return this;\n    }\n\n    @Override\n    public AtmosphereRequest queryString(String qs) {\n\n        if (qs == null) return this;\n\n        if (!qs.isEmpty()) {\n            QueryStringDecoder decoder = new QueryStringDecoder(getRequestURI() + \"?\" + qs);\n            Map<String, List<String>> m = decoder.getParameters();\n            Map<String, String[]> newM = new HashMap<>();\n            for (Map.Entry<String, List<String>> q : m.entrySet()) {\n                newM.put(q.getKey(), q.getValue().toArray(new String[0]));\n            }\n            b.queryStrings(newM);\n        }\n        b.queryString = qs;\n        return this;\n    }\n\n    @Override\n    public Map<String, String> headersMap() {\n        return b.headers;\n    }\n\n    @Override\n    public Map<String, String[]> queryStringsMap() {\n        return b.queryStrings;\n    }\n\n    @Override\n    public AtmosphereRequest method(String m) {\n        b.method(m);\n        return this;\n    }\n\n    @Override\n    public AtmosphereRequest contentType(String m) {\n        b.contentType(m);\n        return this;\n    }\n\n    @Override\n    public AtmosphereRequest body(String body) {\n        b.body = new Body(body, null, 0, 0);\n        return this;\n    }\n\n    @Override\n    public AtmosphereRequest body(byte[] bytes) {\n        b.body = new Body(null, bytes, 0, bytes.length);\n        return this;\n    }\n\n    @Override\n    public AtmosphereRequest body(InputStream body) {\n        bis = new IS(body);\n        br = new BufferedReader(new InputStreamReader(body));\n        return this;\n    }\n\n    @Override\n    public AtmosphereRequest body(Reader body) {\n        bis = new IS(new ReaderInputStream(body));\n        br = new BufferedReader(body);\n        return this;\n    }\n\n    @Override\n    public Body body() {\n        return b.body;\n    }\n\n    @Override\n    public AtmosphereRequest servletPath(String servletPath) {\n        b.servletPath = servletPath;\n        return this;\n    }\n\n    @Override\n    public AtmosphereRequest contextPath(String contextPath) {\n        b.contextPath = contextPath;\n        return this;\n    }\n\n    @Override\n    public AtmosphereRequest requestURI(String requestURI) {\n        b.requestURI = requestURI;\n        return this;\n    }\n\n    private final static class ByteInputStream extends ServletInputStream {\n\n        private final ByteArrayInputStream bis;\n\n        public ByteInputStream(byte[] data, int offset, int length) {\n            this.bis = new ByteArrayInputStream(data, offset, length);\n        }\n\n        @Override\n        public int read() throws IOException {\n            return bis.read();\n        }\n    }\n\n    @Override\n    public void setAttribute(String s, Object o) {\n        if (o == null) {\n            removeAttribute(s);\n            return;\n        }\n        b.localAttributes.put(s, o);\n        if (isNotNoOps() && !destroyed.get()) {\n            try {\n                synchronized (b.request) {\n                    b.request.setAttribute(s, o);\n                }\n            } catch (NullPointerException ex) {\n                // https://github.com/Atmosphere/atmosphere/issues/1806\n                logger.trace(\"\", ex);\n            }\n        }\n    }\n\n    @Override\n    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n        b.request.setCharacterEncoding(env);\n    }\n\n    @Override\n    public AsyncContext startAsync() {\n        AsyncContext ac;\n        if (AtmosphereResource.TRANSPORT.WEBSOCKET == resource().transport()) {\n            noopsAsyncContextStarted = true;\n            ac = new NoOpsAsyncContext(getRequest(), resource().getResponse().getResponse());\n        } else {\n            ac = b.request.startAsync();\n        }\n        return isCompletionAware()\n                ? new CompletionAwareAsyncContext(ac, (CompletionAware) resource().getResponse()) : ac;\n    }\n\n    @Override\n    public AsyncContext startAsync(ServletRequest request, ServletResponse response) {\n        AsyncContext ac;\n        if (AtmosphereResource.TRANSPORT.WEBSOCKET == resource().transport()) {\n            noopsAsyncContextStarted = true;\n            ac = new NoOpsAsyncContext(request, response);\n        } else {\n            ac = b.request.startAsync(request, response);\n        }\n        return isCompletionAware()\n                ? new CompletionAwareAsyncContext(ac, (CompletionAware) resource().getResponse()) : ac;\n    }\n\n    @Override\n    public AsyncContext getAsyncContext() {\n        AsyncContext ac;\n        if (AtmosphereResource.TRANSPORT.WEBSOCKET == resource().transport()) {\n            noopsAsyncContextStarted = true;\n            ac = new NoOpsAsyncContext(getRequest(), resource().getResponse().getResponse());\n        } else {\n            ac = b.request.getAsyncContext();\n        }\n        return isCompletionAware()\n                ? new CompletionAwareAsyncContext(ac, (CompletionAware) resource().getResponse()) : ac;\n    }\n\n    @Override\n    public Object getAttribute(String s) {\n        return b.localAttributes.get(s) != null ? b.localAttributes.get(s) : (isNotNoOps() ? attributeWithoutException(b.request, s) : null);\n    }\n\n    @Override\n    public void removeAttribute(String name) {\n\n        b.localAttributes.remove(name);\n        if (isNotNoOps() && !destroyed.get()) {\n            synchronized (b.request) {\n                b.request.removeAttribute(name);\n            }\n        }\n    }\n\n    @Override\n    public LocalAttributes attributes() {\n        return b.localAttributes;\n    }\n\n    @Override\n    public HttpSession getSession() {\n        return getSession(true);\n    }\n\n    @Override\n    public HttpSession getSession(boolean create) {\n        if (b.webSocketFakeSession != null) {\n            return b.webSocketFakeSession;\n        }\n\n        if (resource() != null) {\n            // UGLY, but we need to prevent looping here.\n            HttpSession session = ((AtmosphereResourceImpl) resource()).session;\n            try {\n                if (session != null) {\n                    // check if session is valid (isNew() will throw if not)\n                    session.isNew();\n                    return session;\n                }\n            } catch (IllegalStateException e) {\n                // session has been invalidated\n            }\n        }\n\n        try {\n            return b.request.getSession(create);\n        } catch (java.lang.IllegalStateException ex) {\n            // JettyAsyncSupportListenerAdapter\n            if (ex.getMessage() != null && ex.getMessage().equals(\"No SessionManager\")) {\n                return null;\n            }\n            throw ex;\n        } catch (NullPointerException ex) {\n            // GLASSFISH http://java.net/jira/browse/GLASSFISH-18856\n            try {\n                return b.request.getSession(create);\n            } catch (Exception e) {\n                logger.trace(\"\", ex);\n                return null;\n            }\n        } catch (RuntimeException ex) {\n            // https://github.com/Atmosphere/atmosphere/issues/1974\n            logger.trace(\"\", ex);\n            if (ex.getMessage() != null && ex.getMessage().contains(\"SESN0007E\")) {\n                return null;\n            }\n            throw ex;\n        }\n    }\n\n    @Override\n    public Principal getUserPrincipal() {\n        return b.principal != null ? b.principal : b.request.getUserPrincipal();\n    }\n\n    @Override\n    public boolean isRequestedSessionIdFromCookie() {\n        return b.request.isRequestedSessionIdFromCookie();\n    }\n\n    @Override\n    public boolean isRequestedSessionIdFromUrl() {\n        return b.request.isRequestedSessionIdFromUrl();\n    }\n\n    @Override\n    public boolean isRequestedSessionIdFromURL() {\n        return b.request.isRequestedSessionIdFromURL();\n    }\n\n    @Override\n    public boolean isRequestedSessionIdValid() {\n        return b.request.isRequestedSessionIdValid();\n    }\n\n    @Override\n    public boolean isUserInRole(String role) {\n        return b.request.isUserInRole(role);\n    }\n\n    @Override\n    public void login(String username, String password) throws ServletException {\n        b.request.login(username, password);\n    }\n\n    @Override\n    public void logout() throws ServletException {\n        b.request.logout();\n    }\n\n    @Override\n    public String getRemoteAddr() {\n        return isNotNoOps() ? b.request.getRemoteAddr() : b.lazyRemote != null ? b.lazyRemote.getHostAddress() : b.remoteAddr;\n    }\n\n    @Override\n    public String getRemoteHost() {\n        return isNotNoOps() ? b.request.getRemoteHost() : b.lazyRemote != null ? b.lazyRemote.getHostName() : b.remoteHost;\n    }\n\n    @Override\n    public int getRemotePort() {\n        return isNotNoOps() ? b.request.getRemotePort() : b.lazyRemote != null ? b.lazyRemote.getPort() : b.remotePort;\n    }\n\n    @Override\n    public RequestDispatcher getRequestDispatcher(String path) {\n        return b.request.getRequestDispatcher(path);\n    }\n\n    @Override\n    public String getScheme() {\n        return b.request.getScheme();\n    }\n\n    @Override\n    public String getServerName() {\n        return !b.serverName.equals(\"\") ? b.serverName : b.request.getServerName();\n    }\n\n    @Override\n    public int getServerPort() {\n        return b.serverPort != 0 ? b.serverPort : b.request.getServerPort();\n    }\n\n    @Override\n    public ServletContext getServletContext() {\n        return b.request.getServletContext();\n    }\n\n    @Override\n    public boolean isAsyncStarted() {\n        if (resource() != null && AtmosphereResource.TRANSPORT.WEBSOCKET == resource().transport()) {\n            return noopsAsyncContextStarted;\n        }\n        try {\n            return b.request.isAsyncStarted();\n        } catch (Throwable ex) {\n            logger.trace(\"\", ex);\n            return false;\n        }\n    }\n\n    @Override\n    public boolean isAsyncSupported() {\n        try {\n            return b.request.isAsyncSupported();\n        } catch (Throwable ex) {\n            // Servlet 2.5 incompatible API.\n            logger.trace(\"\", ex);\n            return false;\n        }\n    }\n\n    @Override\n    public boolean isSecure() {\n        return isNotNoOps() ? b.request.isSecure() : b.isSecure;\n    }\n\n    @Override\n    public String getLocalName() {\n        return isNotNoOps() ? b.request.getLocalName() : b.lazyLocal != null ? b.lazyLocal.getHostName() : b.localName;\n    }\n\n    @Override\n    public int getLocalPort() {\n        return isNotNoOps() ? b.request.getLocalPort() : b.lazyLocal != null ? b.lazyLocal.getPort() : b.localPort;\n    }\n\n    @Override\n    public String getLocalAddr() {\n        return isNotNoOps() ? b.request.getLocalAddr() : b.lazyLocal != null ? b.lazyLocal.getHostAddress() : b.localAddr;\n    }\n\n    private boolean isNotNoOps() {\n        return !NoOpsRequest.class.isAssignableFrom(b.request.getClass());\n    }\n\n    @Override\n    public Locale getLocale() {\n        return isNotNoOps() ? b.request.getLocale() : b.locales.iterator().hasNext() ? b.locales.iterator().next() : Locale.getDefault();\n    }\n\n    @Override\n    public AtmosphereResource resource() {\n        try {\n            Object o = getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n            if (!(o instanceof AtmosphereResource)) {\n                // WebSphere is in trouble.\n                return null;\n            }\n            return (AtmosphereResource) getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n        } catch (Exception ex) {\n            logger.warn(\"\", ex);\n            return null;\n        }\n    }\n\n    @Override\n    public Enumeration<Locale> getLocales() {\n        return isNotNoOps() ? b.request.getLocales() : Collections.enumeration(b.locales);\n    }\n\n    @Override\n    public boolean dispatchRequestAsynchronously() {\n        return b.dispatchRequestAsynchronously;\n    }\n\n    @Override\n    public boolean isDestroyable() {\n        return b.destroyable;\n    }\n\n    @Override\n    public AtmosphereRequest pathInfo(String pathInfo) {\n        b.pathInfo = pathInfo;\n        return this;\n    }\n\n    @Override\n    public Enumeration<String> getAttributeNames() {\n        Set<String> l = new HashSet<>(b.localAttributes.unmodifiableMap().keySet());\n\n        if (isNotNoOps()) {\n            synchronized (b.request) {\n                l.addAll(Collections.list(b.request.getAttributeNames()));\n            }\n        }\n        return Collections.enumeration(l);\n    }\n\n    private static Object attributeWithoutException(HttpServletRequest request, String attribute) {\n        try {\n            return request.getAttribute(attribute);\n        } catch (NullPointerException ex) {\n            // https://github.com/Atmosphere/atmosphere/issues/1732\n            logger.trace(\"Unexpected NPE\", ex);\n            return \"\";\n        }\n    }\n\n    @Override\n    public LocalAttributes localAttributes() {\n        return b.localAttributes;\n    }\n\n    @Override\n    public String getCharacterEncoding() {\n        return b.request.getCharacterEncoding() == null ? b.encoding : b.request.getCharacterEncoding();\n    }\n\n    @Override\n    public int getContentLength() {\n        if (b.contentLength == null) {\n            return b.request.getContentLength();\n        } else {\n            return b.contentLength.intValue();\n        }\n    }\n\n    @Override\n    public String uuid() {\n        if (Objects.equals(uuid, \"0\")) {\n            this.uuid = resource() != null ? resource().uuid() : \"0\";\n        }\n        return uuid;\n    }\n\n    @Override\n    public void destroy() {\n        destroy(b.destroyable);\n    }\n\n    @Override\n    public void destroy(boolean force) {\n        if (!force) return;\n        destroyed.set(true);\n        b.localAttributes.clear();\n        if (bis != null) {\n            try {\n                bis.close();\n            } catch (IOException e) {\n            }\n        }\n\n        if (br != null) {\n            try {\n                br.close();\n            } catch (IOException e) {\n            }\n        }\n\n        b.headers.clear();\n        b.queryStrings.clear();\n    }\n\n    @Override\n    public void setRequest(ServletRequest request) {\n        super.setRequest(request);\n        if (HttpServletRequest.class.isAssignableFrom(request.getClass())) {\n            b.request = (HttpServletRequest) request;\n        }\n    }\n\n    public final static class Builder implements AtmosphereRequest.Builder {\n        private final static Body NULL_BODY = new Body(null, null, 0, 0);\n        private HttpServletRequest request;\n        private String pathInfo = \"\";\n        private String encoding = \"UTF-8\";\n        private String methodType;\n        private String contentType;\n        private boolean noContentType;\n        private Long contentLength;\n        private Map<String, String> headers = Collections.synchronizedMap(new HashMap<>());\n        private Map<String, String[]> queryStrings = Collections.synchronizedMap(new HashMap<>());\n        private String servletPath = \"\";\n        private String requestURI;\n        private String requestURL;\n        private InputStream inputStream;\n        private Reader reader;\n        private String remoteAddr = \"\";\n        private String remoteHost = \"\";\n        private int remotePort;\n        private String localAddr = \"\";\n        private String localName = \"\";\n        private int localPort;\n        private boolean dispatchRequestAsynchronously;\n        private boolean destroyable = true;\n        private Set<Cookie> cookies = Collections.synchronizedSet(new HashSet<>());\n        private final Set<Locale> locales = Collections.synchronizedSet(new HashSet<>());\n        private Principal principal;\n        private String authType;\n        private String contextPath = \"\";\n        private String serverName = \"\";\n        private int serverPort;\n        private HttpSession webSocketFakeSession;\n        private String queryString = \"\";\n        private boolean isSecure;\n        // Callable to lazily execute.\n        private LazyComputation lazyRemote;\n        private LazyComputation lazyLocal;\n        public Body body;\n        private LocalAttributes localAttributes = new LocalAttributes();\n\n        public Builder() {\n        }\n\n        @Override\n        public Builder destroyable(boolean destroyable) {\n            this.destroyable = destroyable;\n            return this;\n        }\n\n        @Override\n        public Builder headers(Map<String, String> headers) {\n            this.headers = Collections.synchronizedMap(headers);\n            return this;\n        }\n\n        @Override\n        public Builder cookies(Set<Cookie> cookies) {\n            this.cookies = cookies;\n            return this;\n        }\n\n        @Override\n        public Builder dispatchRequestAsynchronously(boolean dispatchRequestAsynchronously) {\n            this.dispatchRequestAsynchronously = dispatchRequestAsynchronously;\n            return this;\n        }\n\n        @Override\n        public Builder remoteAddr(String remoteAddr) {\n            this.remoteAddr = remoteAddr;\n            return this;\n        }\n\n        @Override\n        public Builder remoteHost(String remoteHost) {\n            this.remoteHost = remoteHost;\n            return this;\n        }\n\n        @Override\n        public Builder remotePort(int remotePort) {\n            this.remotePort = remotePort;\n            return this;\n        }\n\n        @Override\n        public Builder localAddr(String localAddr) {\n            this.localAddr = localAddr;\n            return this;\n        }\n\n        @Override\n        public Builder localName(String localName) {\n            this.localName = localName;\n            return this;\n        }\n\n        @Override\n        public Builder localPort(int localPort) {\n            this.localPort = localPort;\n            return this;\n        }\n\n        @Override\n        public Builder remoteInetSocketAddress(Callable remoteAddr) {\n            this.lazyRemote = new LazyComputation(remoteAddr);\n            return this;\n        }\n\n        @Override\n        public Builder localInetSocketAddress(Callable localAddr) {\n            this.lazyLocal = new LazyComputation(localAddr);\n            return this;\n        }\n\n        @Override\n        public Builder attributes(Map<String, Object> attributes) {\n            localAttributes = new LocalAttributes(attributes);\n            return this;\n        }\n\n        @Override\n        public Builder request(HttpServletRequest request) {\n            this.request = request;\n            return this;\n        }\n\n        @Override\n        public Builder servletPath(String servletPath) {\n            this.servletPath = servletPath;\n            return this;\n        }\n\n        @Override\n        public Builder requestURI(String requestURI) {\n            this.requestURI = requestURI;\n            return this;\n        }\n\n        @Override\n        public Builder requestURL(String requestURL) {\n            this.requestURL = requestURL;\n            return this;\n        }\n\n        @Override\n        public Builder pathInfo(String pathInfo) {\n            this.pathInfo = pathInfo;\n            return this;\n        }\n\n        @Override\n        public Builder queryString(String queryString) {\n            this.queryString = queryString;\n            return this;\n        }\n\n        @Override\n        public Builder body(byte[] dataBytes) {\n            return body(dataBytes, 0, dataBytes.length);\n        }\n\n        @Override\n        public Builder body(byte[] dataBytes, int offset, int length) {\n            this.body = new Body(null, dataBytes, offset, length);\n            return this;\n        }\n\n        @Override\n        public Builder encoding(String encoding) {\n            this.encoding = encoding;\n            return this;\n        }\n\n        @Override\n        public Builder method(String methodType) {\n            this.methodType = methodType;\n            return this;\n        }\n\n        @Override\n        public Builder contentType(String contentType) {\n            this.contentType = contentType;\n            if (contentType == null) {\n                noContentType = true;\n            }\n            return this;\n        }\n\n        @Override\n        public Builder contentLength(Long contentLength) {\n            this.contentLength = contentLength;\n            return this;\n        }\n\n        @Override\n        public Builder body(String data) {\n            this.body = new Body(data, null, 0, 0);\n            return this;\n        }\n\n        @Override\n        public Builder inputStream(InputStream inputStream) {\n            this.inputStream = inputStream;\n            return this;\n        }\n\n        @Override\n        public Builder reader(Reader reader) {\n            this.reader = reader;\n            return this;\n        }\n\n        @Override\n        public AtmosphereRequest build() {\n            if (body == null) {\n                body = NULL_BODY;\n            }\n            return new AtmosphereRequestImpl(this);\n        }\n\n        @Override\n        public Builder queryStrings(Map<String, String[]> queryStrings) {\n            this.queryStrings = Collections.synchronizedMap(queryStrings);\n            return this;\n        }\n\n        @Override\n        public Builder contextPath(String contextPath) {\n            this.contextPath = contextPath == null ? \"\" : contextPath;\n            return this;\n        }\n\n        @Override\n        public Builder serverName(String serverName) {\n            this.serverName = serverName;\n            return this;\n        }\n\n        @Override\n        public Builder serverPort(int serverPort) {\n            this.serverPort = serverPort;\n            return this;\n        }\n\n        @Override\n        public Builder session(HttpSession session) {\n            if (request == null) {\n                request = new NoOpsRequest();\n            }\n\n            if (NoOpsRequest.class.isAssignableFrom(request.getClass())) {\n                ((NoOpsRequest) request).fake = session;\n            } else {\n                webSocketFakeSession = session;\n            }\n            return this;\n        }\n\n        @Override\n        public Builder principal(Principal principal) {\n            this.principal = principal;\n            return this;\n        }\n\n        @Override\n        public Builder authType(String authType) {\n            this.authType = authType;\n            return this;\n        }\n\n        @Override\n        public Builder isSSecure(boolean isSecure) {\n            this.isSecure = isSecure;\n            return this;\n        }\n\n        @Override\n        public Builder locale(Locale locale) {\n            locales.add(locale);\n            return this;\n        }\n\n        @Override\n        public Builder userPrincipal(Principal userPrincipal) {\n            this.principal = userPrincipal;\n            return this;\n        }\n    }\n\n    public final static class Body {\n        private final String data;\n        private final byte[] dataBytes;\n        private final int offset;\n        private final int length;\n        private final boolean isEmpty;\n\n        public Body(String data, byte[] dataBytes, int offset, int length) {\n            this.data = data;\n            this.dataBytes = dataBytes;\n            this.offset = offset;\n            this.length = length;\n            isEmpty = data == null && dataBytes == null;\n        }\n\n        /**\n         * True is the body is a String\n         *\n         * @return True is the body is a String\n         */\n        public boolean hasString() {\n            return data != null;\n        }\n\n        /**\n         * True is the body is a byte array\n         *\n         * @return True is the body is a byte array\n         */\n        public boolean hasBytes() {\n            return dataBytes != null;\n        }\n\n        /**\n         * Return the request body as a String. If the body was a byte array, this method will return null.\n         *\n         * @return the request body as a String. If the body was a byte array, this method will return null.\n         */\n        public String asString() {\n            return data;\n        }\n\n        /**\n         * Return the request body as a byte array. If the body was String, this method will return null.\n         *\n         * @return the request body as a byte array. If the body was String, this method will return null.\n         */\n        public byte[] asBytes() {\n            return dataBytes;\n        }\n\n        /**\n         * The {@link #asBytes()} offset\n         *\n         * @return The {@link #asBytes()} offset\n         */\n        public int byteOffset() {\n            return offset;\n        }\n\n        /**\n         * The {@link #asBytes()} length\n         *\n         * @return The {@link #asBytes()} length\n         */\n        public int byteLength() {\n            return length;\n        }\n\n        /**\n         * True if this object is empty\n         *\n         * @return True if this object is empty\n         */\n        public boolean isEmpty() {\n            return isEmpty;\n        }\n    }\n\n    private final static class IS extends ServletInputStream {\n\n        private final InputStream innerStream;\n\n        public IS(InputStream innerStream) {\n            super();\n            this.innerStream = innerStream;\n        }\n\n        public int read() throws java.io.IOException {\n            return innerStream.read();\n        }\n\n        public int read(byte[] bytes) throws java.io.IOException {\n            return innerStream.read(bytes);\n        }\n\n        public int read(byte[] bytes, int i, int i1) throws java.io.IOException {\n            return innerStream.read(bytes, i, i1);\n        }\n\n\n        public long skip(long l) throws java.io.IOException {\n            return innerStream.skip(l);\n        }\n\n        public int available() throws java.io.IOException {\n            return innerStream.available();\n        }\n\n        public void close() throws java.io.IOException {\n            innerStream.close();\n        }\n\n        public synchronized void mark(int i) {\n            innerStream.mark(i);\n        }\n\n        public synchronized void reset() throws java.io.IOException {\n            innerStream.reset();\n        }\n\n        public boolean markSupported() {\n            return innerStream.markSupported();\n        }\n    }\n\n    /**\n     * Create an instance of this class without an associated {@link HttpServletRequest}.\n     *\n     * @return an instance of this class without an associated {@link HttpServletRequest}\n     */\n    public static AtmosphereRequest newInstance() {\n        return new Builder().build();\n    }\n\n    /**\n     * Wrap an {@link HttpServletRequest}.\n     *\n     * @param request {@link HttpServletRequest}\n     * @return an {@link AtmosphereRequest}\n     */\n    public static AtmosphereRequest wrap(HttpServletRequest request) {\n        // Do not rewrap.\n        if (AtmosphereRequestImpl.class.isAssignableFrom(request.getClass())) {\n            return (AtmosphereRequestImpl) request;\n        }\n\n        Builder b = new Builder();\n        Enumeration<String> e = request.getAttributeNames();\n        String s;\n        while (e.hasMoreElements()) {\n            s = e.nextElement();\n            b.localAttributes.put(s, attributeWithoutException(request, s));\n        }\n        return b.request(request).build();\n    }\n\n\n    /**\n     * Copy the HttpServletRequest content inside an AtmosphereRequest. By default the returned AtmosphereRequest\n     * is not destroyable.\n     *\n     * @param request {@link HttpServletRequest}\n     * @return an {@link AtmosphereRequest}\n     */\n    public static AtmosphereRequest cloneRequest(HttpServletRequest request, boolean loadInMemory, boolean copySession, boolean isDestroyable, boolean createSession) {\n        Builder b;\n        HttpServletRequest r;\n\n        Cookie[] cs = request.getCookies();\n        Set<Cookie> hs = Collections.synchronizedSet(new HashSet<>());\n        if (cs != null) {\n            Collections.addAll(hs, cs);\n        }\n\n        boolean isWrapped = false;\n        if (AtmosphereRequestImpl.class.isAssignableFrom(request.getClass())) {\n            b = ((AtmosphereRequestImpl) request).b;\n            isWrapped = true;\n        } else {\n            b = new Builder();\n            b.request(request);\n        }\n\n        HttpSession session = request.getSession(false);\n        if (copySession) {\n            session = request.getSession(createSession);\n            if (session != null) {\n                session = new FakeHttpSession(session);\n            } else {\n                session = new FakeHttpSession(\"\", null, System.currentTimeMillis(), -1);\n            }\n        }\n\n        b.servletPath(request.getServletPath())\n                .pathInfo(request.getPathInfo())\n                .contextPath(request.getContextPath())\n                .requestURI(request.getRequestURI())\n                .requestURL(request.getRequestURL().toString())\n                .method(request.getMethod())\n                .serverName(request.getServerName())\n                .serverPort(request.getServerPort())\n                .remoteAddr(request.getRemoteAddr())\n                .remoteHost(request.getRemoteHost())\n                .remotePort(request.getRemotePort())\n                .destroyable(isDestroyable)\n                .cookies(hs)\n                .session(session)\n                .principal(request.getUserPrincipal())\n                .authType(request.getAuthType())\n                .isSSecure(request.isSecure());\n\n        if (loadInMemory) {\n            String s = (String) attributeWithoutException(request, FrameworkConfig.THROW_EXCEPTION_ON_CLONED_REQUEST);\n            boolean throwException = Boolean.parseBoolean(s);\n            r = new NoOpsRequest(throwException);\n            if (isWrapped) {\n                load(b.request, b);\n            } else {\n                load(request, b);\n            }\n            b.request(r);\n        }\n\n        return isWrapped ? (AtmosphereRequestImpl) request : b.build();\n    }\n\n    public final static class NoOpsRequest implements HttpServletRequest {\n\n        private final boolean throwExceptionOnCloned;\n        public HttpSession fake;\n        private final static Enumeration<String> EMPTY_ENUM_STRING = Collections.enumeration(Collections.emptyList());\n        private final static Enumeration<Locale> EMPTY_ENUM_LOCALE = Collections.enumeration(Collections.emptyList());\n        private final static List<Part> EMPTY_ENUM_PART = Collections.emptyList();\n        private final static Map<String, String[]> EMPTY_MAP_STRING = Collections.emptyMap();\n        private final static String[] EMPTY_ARRAY = new String[0];\n        private final StringBuffer EMPTY_STRING_BUFFER = new StringBuffer();\n        private final static Cookie[] EMPTY_COOKIE = new Cookie[0];\n        private volatile BufferedReader voidReader;\n        private final ServletInputStream voidStream = new AtmosphereRequestImpl.IS(new ByteArrayInputStream(new byte[0]));\n\n        public NoOpsRequest() {\n            this.throwExceptionOnCloned = false;\n        }\n\n        public NoOpsRequest(boolean throwExceptionOnCloned) {\n            this.throwExceptionOnCloned = throwExceptionOnCloned;\n        }\n\n        private BufferedReader getVoidReader() {\n            if (voidReader == null) {\n                voidReader = new BufferedReader(new StringReader(\"\"));\n            }\n            return voidReader;\n        }\n\n        @Override\n        public boolean authenticate(HttpServletResponse response) {\n            return false;\n        }\n\n        @Override\n        public String getAuthType() {\n            return null;\n        }\n\n        @Override\n        public String getContextPath() {\n            return \"\";\n        }\n\n        @Override\n        public Cookie[] getCookies() {\n            return EMPTY_COOKIE;\n        }\n\n        @Override\n        public long getDateHeader(String name) {\n            return 0;\n        }\n\n        @Override\n        public String getHeader(String name) {\n            return null;\n        }\n\n        @Override\n        public Enumeration<String> getHeaderNames() {\n            return EMPTY_ENUM_STRING;\n        }\n\n        @Override\n        public Enumeration<String> getHeaders(String name) {\n            return EMPTY_ENUM_STRING;\n        }\n\n        @Override\n        public int getIntHeader(String name) {\n            return 0;\n        }\n\n        @Override\n        public String getMethod() {\n            return \"GET\";\n        }\n\n        @Override\n        public Part getPart(String name) throws IOException, ServletException {\n            return null;\n        }\n\n        @Override\n        public Collection<Part> getParts() throws IOException, ServletException {\n            return EMPTY_ENUM_PART;\n        }\n\n        @Override\n        public String getPathInfo() {\n            return \"\";\n        }\n\n        @Override\n        public String getPathTranslated() {\n            return \"\";\n        }\n\n        @Override\n        public String getQueryString() {\n            return \"\";\n        }\n\n        @Override\n        public String getRemoteUser() {\n            return \"\";\n        }\n\n        @Override\n        public String getRequestedSessionId() {\n            return \"\";\n        }\n\n        @Override\n        public String getRequestURI() {\n            return \"/\";\n        }\n\n        @Override\n        public StringBuffer getRequestURL() {\n            return EMPTY_STRING_BUFFER;\n        }\n\n        @Override\n        public String getServletPath() {\n            return \"\";\n        }\n\n        @Override\n        public HttpSession getSession() {\n            return fake;\n        }\n\n        @Override\n        public HttpSession getSession(boolean create) {\n            if (create && fake == null) {\n                fake = new FakeHttpSession(\"\", null, System.currentTimeMillis(), -1) {\n                    @Override\n                    public void invalidate() {\n                        fake = null;\n                        super.invalidate();\n                    }\n                };\n            }\n            return fake;\n        }\n\n        @Override\n        public Principal getUserPrincipal() {\n            return null;\n        }\n\n        @Override\n        public boolean isRequestedSessionIdFromCookie() {\n            return false;\n        }\n\n        @Override\n        public boolean isRequestedSessionIdFromUrl() {\n            return false;\n        }\n\n        @Override\n        public boolean isRequestedSessionIdFromURL() {\n            return false;\n        }\n\n        @Override\n        public boolean isRequestedSessionIdValid() {\n            return false;\n        }\n\n        @Override\n        public boolean isUserInRole(String role) {\n            if (this.throwExceptionOnCloned) {\n                throw new UnsupportedOperationException();\n            }\n            return false;\n        }\n\n        @Override\n        public void login(String username, String password) throws ServletException {\n            if (this.throwExceptionOnCloned) {\n                throw new ServletException();\n            }\n        }\n\n        @Override\n        public void logout() throws ServletException {\n            if (this.throwExceptionOnCloned) {\n                throw new ServletException();\n            }\n        }\n\n        @Override\n        public AsyncContext getAsyncContext() {\n            return null;\n        }\n\n        @Override\n        public Object getAttribute(String name) {\n            return null;\n        }\n\n        @Override\n        public Enumeration<String> getAttributeNames() {\n            return EMPTY_ENUM_STRING;\n        }\n\n        @Override\n        public String getCharacterEncoding() {\n            return null;\n        }\n\n        @Override\n        public int getContentLength() {\n            return 0;\n        }\n\n        @Override\n        public String getContentType() {\n            return \"text/plain\";\n        }\n\n        @Override\n        public DispatcherType getDispatcherType() {\n            return DispatcherType.REQUEST;\n        }\n\n        @Override\n        public ServletInputStream getInputStream() throws IOException {\n            return voidStream;\n        }\n\n        @Override\n        public Locale getLocale() {\n            return null;\n        }\n\n        @Override\n        public Enumeration<Locale> getLocales() {\n            return EMPTY_ENUM_LOCALE;\n        }\n\n        @Override\n        public String getLocalName() {\n            return null;\n        }\n\n        @Override\n        public int getLocalPort() {\n            return 0;\n        }\n\n        @Override\n        public String getLocalAddr() {\n            return \"\";\n        }\n\n        @Override\n        public String getParameter(String name) {\n            return \"\";\n        }\n\n        @Override\n        public Map<String, String[]> getParameterMap() {\n            return EMPTY_MAP_STRING;\n        }\n\n        @Override\n        public Enumeration<String> getParameterNames() {\n            return EMPTY_ENUM_STRING;\n        }\n\n        @Override\n        public String[] getParameterValues(String name) {\n            return EMPTY_ARRAY;\n        }\n\n        @Override\n        public String getProtocol() {\n            return \"HTTP/1.1\";\n        }\n\n        @Override\n        public BufferedReader getReader() throws IOException {\n            return getVoidReader();\n        }\n\n        @Override\n        public String getRealPath(String path) {\n            return path;\n        }\n\n        @Override\n        public String getRemoteAddr() {\n            return \"\";\n        }\n\n        @Override\n        public String getRemoteHost() {\n            return \"\";\n        }\n\n        @Override\n        public int getRemotePort() {\n            return 0;\n        }\n\n        @Override\n        public RequestDispatcher getRequestDispatcher(String path) {\n            return null;\n        }\n\n        @Override\n        public String getScheme() {\n            return \"ws\";\n        }\n\n        @Override\n        public String getServerName() {\n            return \"\";\n        }\n\n        @Override\n        public int getServerPort() {\n            return 0;\n        }\n\n        @Override\n        public ServletContext getServletContext() {\n            return null;\n        }\n\n        @Override\n        public boolean isAsyncStarted() {\n            return false;\n        }\n\n        @Override\n        public boolean isAsyncSupported() {\n            return true;\n        }\n\n        @Override\n        public boolean isSecure() {\n            return false;\n        }\n\n        @Override\n        public void removeAttribute(String name) {\n\n        }\n\n        @Override\n        public void setAttribute(String name, Object o) {\n\n        }\n\n        @Override\n        public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n        }\n\n        @Override\n        public AsyncContext startAsync() {\n            return null;\n        }\n\n        @Override\n        public AsyncContext startAsync(ServletRequest request, ServletResponse response) {\n            return null;\n        }\n    }\n\n    public static final class LazyComputation {\n\n        private final Callable<InetSocketAddress> callable;\n        private InetSocketAddress address;\n\n        public LazyComputation(Callable<InetSocketAddress> callable) {\n            this.callable = callable;\n        }\n\n        public InetSocketAddress address() {\n            if (address == null) {\n                try {\n                    address = callable.call();\n                } catch (Exception e) {\n                    logger.warn(\"\", e);\n                }\n\n                // Falback\n                if (address == null) {\n                    address = new InetSocketAddress(8080);\n                }\n            }\n            return address;\n        }\n\n        public int getPort() {\n            return address().getPort();\n        }\n\n        public String getHostAddress() {\n            return address().getAddress().getHostAddress();\n        }\n\n        public String getHostName() {\n            return address().getHostName();\n        }\n\n    }\n\n    private boolean isCompletionAware() {\n        return Boolean.parseBoolean(resource().getAtmosphereConfig()\n                .getInitParameter(ApplicationConfig.RESPONSE_COMPLETION_AWARE));\n    }\n\n    private class CompletionAwareAsyncContext implements AsyncContext {\n        private AsyncContext context;\n        private CompletionAware callback;\n\n        public CompletionAwareAsyncContext(AsyncContext context, CompletionAware callback) {\n            this.context = context;\n            this.callback = callback;\n        }\n\n        public void addListener(AsyncListener listener) throws IllegalStateException {\n            context.addListener(listener);\n        }\n\n        public void addListener(AsyncListener listener, ServletRequest request, ServletResponse response) throws IllegalStateException {\n            context.addListener(listener, request, response);\n        }\n\n        public void complete() {\n            context.complete();\n            callback.onComplete();\n        }\n\n        public <T extends AsyncListener> T createListener(Class<T> clazz) throws ServletException {\n            return context.createListener(clazz);\n        }\n\n        public void dispatch() throws IllegalStateException {\n            context.dispatch();\n        }\n\n        public void dispatch(ServletContext servletContext, String path) throws IllegalStateException {\n            context.dispatch(servletContext, path);\n        }\n\n        public void dispatch(String path) throws IllegalStateException {\n            context.dispatch(path);\n        }\n\n        public ServletRequest getRequest() {\n            return context.getRequest();\n        }\n\n        public ServletResponse getResponse() {\n            return context.getResponse();\n        }\n\n        public long getTimeout() {\n            return context.getTimeout();\n        }\n\n        public boolean hasOriginalRequestAndResponse() {\n            return context.hasOriginalRequestAndResponse();\n        }\n\n        public void setTimeout(long timeoutMilliseconds) throws IllegalStateException {\n            context.setTimeout(timeoutMilliseconds);\n        }\n\n        public void start(Runnable run) {\n            context.start(run);\n        }\n\n    }\n\n    private class NoOpsAsyncContext implements AsyncContext {\n        private final ServletRequest request;\n        private final ServletResponse response;\n        private long timeout;\n\n        public NoOpsAsyncContext(ServletRequest request, ServletResponse response) {\n            this.request = request;\n            this.response = response;\n            this.timeout = -1;\n        }\n\n        @Override\n        public void addListener(AsyncListener listener) throws IllegalStateException {\n        }\n\n        @Override\n        public void addListener(AsyncListener listener, ServletRequest request, ServletResponse response) throws IllegalStateException {\n        }\n\n        @Override\n        public void complete() {\n        }\n\n        @Override\n        public <T extends AsyncListener> T createListener(Class<T> clazz) throws ServletException {\n            throw new ServletException(\"Not supported\");\n        }\n\n        @Override\n        public void dispatch() throws IllegalStateException {\n        }\n\n        @Override\n        public void dispatch(ServletContext servletContext, String path) throws IllegalStateException {\n        }\n\n        @Override\n        public void dispatch(String path) throws IllegalStateException {\n        }\n\n        @Override\n        public ServletRequest getRequest() {\n            return request;\n        }\n\n        @Override\n        public ServletResponse getResponse() {\n            return response;\n        }\n\n        @Override\n        public long getTimeout() {\n            return timeout;\n        }\n\n        @Override\n        public boolean hasOriginalRequestAndResponse() {\n            return false;\n        }\n\n        @Override\n        public void setTimeout(long timeout) throws IllegalStateException {\n            this.timeout = timeout;\n        }\n\n        @Override\n        public void start(Runnable run) {\n            throw new RuntimeException(\"Not supported\");\n        }\n    }\n\n    private static void load(HttpServletRequest request, Builder b) {\n        Enumeration<String> e = request.getHeaderNames();\n        String s;\n        while (e.hasMoreElements()) {\n            s = e.nextElement();\n            b.headers.put(s, request.getHeader(s));\n        }\n        synchronized (b.request) {\n            e = request.getAttributeNames();\n        }\n        while (e.hasMoreElements()) {\n            s = e.nextElement();\n            b.localAttributes.put(s, attributeWithoutException(request, s));\n        }\n\n        e = request.getParameterNames();\n        while (e.hasMoreElements()) {\n            s = e.nextElement();\n            b.queryStrings.put(s, request.getParameterValues(s));\n        }\n        b.queryString = request.getQueryString();\n\n        Enumeration<Locale> l = request.getLocales();\n        while (l.hasMoreElements()) {\n            b.locale(l.nextElement());\n        }\n    }\n\n    @Override\n    public String toString() {\n        try {\n            return \"AtmosphereRequest{\" +\n                    \" method=\" + getMethod() +\n                    \" contextPath=\" + getContextPath() +\n                    \" servletPath=\" + getServletPath() +\n                    \" pathInfo=\" + getPathInfo() +\n                    \" requestURI=\" + getRequestURI() +\n                    \" requestURL=\" + getRequestURL() +\n                    \" AtmosphereResource UUID=\" + (resource() != null ? resource().uuid() : \"\") +\n                    \" destroyable=\" + b.destroyable +\n                    '}';\n        } catch (Exception e) {\n            // Jetty error\n            return \"AtmosphereRequest{\" +\n                    \" contextPath=\" + getContextPath() +\n                    \" servletPath=\" + getServletPath() +\n                    \" pathInfo=\" + getPathInfo() +\n                    \" requestURI=\" + getRequestURI() +\n                    \" destroyable=\" + b.destroyable +\n                    '}';\n\n        }\n    }\n\n    @Override\n    public String requestURL() {\n        return b.requestURL;\n    }\n}\n",
            "file_name": "AtmosphereRequestImpl.java",
            "human_label": "Wrap an HttpServletRequest with the Builder.",
            "level": "class_runnable",
            "lineno": "1403",
            "name": "wrap",
            "oracle_context": "{ \"apis\" : \"[isAssignableFrom, getClass, getAttributeNames, hasMoreElements, nextElement, put, attributeWithoutException, build, AtmosphereRequestImpl, Builder, localAttributes]\", \"classes\" : \"[Builder, Enumeration<String>, String]\", \"vars\" : \"[localAttributes]\" }",
            "package": "org.atmosphere.cpr",
            "project": "atmosphere-atmosphere-2.7.x"
        },
        {
            "_id": "636766fe1a6d9265ec017834",
            "all_context": "{ \"class_level\" : \"import com.alibaba.fastjson.JSON;\\nimport net.hasor.core.Singleton;\\nimport net.hasor.dataql.UdfSourceAssembly;\\nimport net.hasor.utils.StringUtils;\\nimport net.hasor.web.Invoker;\\nimport net.hasor.web.invoker.HttpParameters;\\nimport javax.servlet.http.Cookie;\\nimport javax.servlet.http.HttpServletResponse;\\nimport javax.servlet.http.HttpSession;\\nimport java.util.*;\\ncookieMap();\\ncookieArrayMap();\\ngetCookie(String cookieName);\\ngetCookieArray(String cookieName);\\ntempCookie(String cookieName,String value);\\ntempCookieAll(Map cookieMap);\\nstoreCookie(String cookieName,String value,int maxAge);\\nstoreCookieAll(Map cookieMap,int maxAge);\\nremoveCookie(String cookieName);\\nheaderMap();\\nheaderArrayMap();\\ngetHeader(String headerName);\\ngetHeaderArray(String headerName);\\nsetHeader(String headerName,String value);\\nsetHeaderAll(Map headerMap);\\naddHeader(String headerName,String value);\\naddHeaderAll(Map headerMap);\\nservletSession();\\nsessionKeys();\\ngetSession(String key);\\nsetSession(String key,Object newValue);\\nremoveSession(String key);\\ncleanSession();\\nsessionInvalidate();\\nsessionId();\\nsessionLastAccessedTime();\\njsonBody();\\n\", \"repo_level\" : \"public interface UdfSourceAssembly {default Supplier<?> getSupplier(Class targetType,Finder finder);\\ndefault Predicate<Method> getPredicate(Class targetType);\\npublic Object[] allParams();\\ndefault Supplier<Map<String,Udf>> getUdfResource(Finder finder);\\npublic Class<? extends Annotation> annotationType();\\npublic String value();\\npublic Object call(Hints readOnly,Object values);\\npublic Object call(Hints readOnly,Object values);\\n }\\npublic interface StringUtils {static boolean isEmpty(String str);\\nstatic boolean isNotEmpty(String str);\\nstatic boolean isBlank(String str);\\nstatic boolean isNotBlank(String str);\\nstatic String trim(String str);\\nstatic String trimToNull(String str);\\nstatic String trimToEmpty(String str);\\nstatic String strip(String str);\\nstatic String stripToNull(String str);\\nstatic String stripToEmpty(String str);\\nstatic String strip(String str,String stripChars);\\nstatic String stripStart(String str,String stripChars);\\nstatic String stripEnd(String str,String stripChars);\\nstatic String[] stripAll(String[] strs);\\nstatic String[] stripAll(String[] strs,String stripChars);\\nstatic boolean equals(String str1,String str2);\\nstatic boolean equalsIgnoreCase(String str1,String str2);\\nstatic int indexOf(String str,char searchChar);\\nstatic int indexOf(String str,char searchChar,int startPos);\\nstatic int indexOf(String str,String searchStr);\\nstatic int ordinalIndexOf(String str,String searchStr,int ordinal);\\nstatic int indexOf(String str,String searchStr,int startPos);\\nstatic int indexOfIgnoreCase(String str,String searchStr);\\nstatic int indexOfIgnoreCase(String str,String searchStr,int startPos);\\nstatic int lastIndexOf(String str,char searchChar);\\nstatic int lastIndexOf(String str,char searchChar,int startPos);\\nstatic int lastIndexOf(String str,String searchStr);\\nstatic int lastOrdinalIndexOf(String str,String searchStr,int ordinal);\\nstatic int lastIndexOf(String str,String searchStr,int startPos);\\nstatic int lastIndexOfIgnoreCase(String str,String searchStr);\\nstatic int lastIndexOfIgnoreCase(String str,String searchStr,int startPos);\\nstatic boolean contains(String str,char searchChar);\\nstatic boolean contains(String str,String searchStr);\\nstatic boolean containsIgnoreCase(String str,String searchStr);\\nstatic int indexOfAny(String str,char[] searchChars);\\nstatic int indexOfAny(String str,String searchChars);\\nstatic boolean containsAny(String str,char[] searchChars);\\nstatic boolean containsAny(String str,String searchChars);\\nstatic int indexOfAnyBut(String str,char[] searchChars);\\nstatic int indexOfAnyBut(String str,String searchChars);\\nstatic boolean containsOnly(String str,char[] valid);\\nstatic boolean containsOnly(String str,String validChars);\\nstatic boolean containsNone(String str,char[] searchChars);\\nstatic boolean containsNone(String str,String invalidChars);\\nstatic int indexOfAny(String str,String[] searchStrs);\\nstatic int lastIndexOfAny(String str,String[] searchStrs);\\nstatic String substring(String str,int start);\\nstatic String substring(String str,int start,int end);\\nstatic String left(String str,int len);\\nstatic String right(String str,int len);\\nstatic String mid(String str,int pos,int len);\\nstatic String substringBefore(String str,String separator);\\nstatic String substringAfter(String str,String separator);\\nstatic String substringBeforeLast(String str,String separator);\\nstatic String substringAfterLast(String str,String separator);\\nstatic String substringBetween(String str,String tag);\\nstatic String substringBetween(String str,String open,String close);\\nstatic String[] substringsBetween(String str,String open,String close);\\nstatic String[] splitKeep(String str,char separatorChar);\\nstatic String[] splitKeep(String str,String separatorStr);\\nstatic String[] split(String str);\\nstatic String[] split(String str,char separatorChar);\\nstatic String[] split(String str,String separatorChars);\\nstatic String[] split(String str,String separatorChars,int max);\\nstatic String[] splitByWholeSeparator(String str,String separator);\\nstatic String[] splitByWholeSeparator(String str,String separator,int max);\\nstatic String[] splitByWholeSeparatorPreserveAllTokens(String str,String separator);\\nstatic String[] splitByWholeSeparatorPreserveAllTokens(String str,String separator,int max);\\nstatic String[] splitPreserveAllTokens(String str);\\nstatic String[] splitPreserveAllTokens(String str,char separatorChar);\\nstatic String[] splitPreserveAllTokens(String str,String separatorChars);\\nstatic String[] splitPreserveAllTokens(String str,String separatorChars,int max);\\nstatic String[] splitByCharacterType(String str);\\nstatic String[] splitByCharacterTypeCamelCase(String str);\\nstatic String join(Object[] array);\\nstatic String join(Object[] array,char separator);\\nstatic String join(Object[] array,char separator,int startIndex,int endIndex);\\nstatic String join(Object[] array,String separator);\\nstatic String join(Object[] array,String separator,int startIndex,int endIndex);\\nstatic String deleteWhitespace(String str);\\nstatic String removeStart(String str,String remove);\\nstatic String removeStartIgnoreCase(String str,String remove);\\nstatic String removeEnd(String str,String remove);\\nstatic String removeEndIgnoreCase(String str,String remove);\\nstatic String remove(String str,String remove);\\nstatic String remove(String str,char remove);\\nstatic String replaceOnce(String text,String searchString,String replacement);\\nstatic String replace(String text,String searchString,String replacement);\\nstatic String replace(String text,String searchString,String replacement,int max);\\nstatic String replaceEach(String text,String[] searchList,String[] replacementList);\\nstatic String replaceEachRepeatedly(String text,String[] searchList,String[] replacementList);\\nstatic String replaceChars(String str,char searchChar,char replaceChar);\\nstatic String replaceChars(String str,String searchChars,String replaceChars);\\nstatic String overlay(String str,String overlay,int start,int end);\\nstatic String chomp(String str);\\nstatic String chomp(String str,String separator);\\nstatic String chop(String str);\\nstatic String repeat(char character,int repeat);\\nstatic String repeat(String str,int repeat);\\nstatic String repeat(String str,String separator,int repeat);\\nstatic String rightPad(String str,int size);\\nstatic String rightPad(String str,int size,char padChar);\\nstatic String rightPad(String str,int size,String padStr);\\nstatic String leftPad(String str,int size);\\nstatic String leftPad(String str,int size,char padChar);\\nstatic String leftPad(String str,int size,String padStr);\\nstatic int length(String str);\\nstatic String center(String str,int size);\\nstatic String center(String str,int size,char padChar);\\nstatic String center(String str,int size,String padStr);\\nstatic String upperCase(String str);\\nstatic String upperCase(String str,Locale locale);\\nstatic String lowerCase(String str);\\nstatic String lowerCase(String str,Locale locale);\\nstatic String capitalize(String str);\\nstatic String uncapitalize(String str);\\nstatic String swapCase(String str);\\nstatic int countMatches(String str,String sub);\\nstatic boolean isAlpha(String str);\\nstatic boolean isAlphaSpace(String str);\\nstatic boolean isAlphanumeric(String str);\\nstatic boolean isAlphanumericSpace(String str);\\nstatic boolean isAsciiPrintable(String str);\\nstatic boolean isNumeric(String str);\\nstatic boolean isNumericSpace(String str);\\nstatic boolean isWhitespace(String str);\\nstatic boolean isAllLowerCase(String str);\\nstatic boolean isAllUpperCase(String str);\\nstatic String defaultString(String str);\\nstatic String defaultString(String str,String defaultStr);\\nstatic String defaultIfBlank(String str,String defaultStr);\\nstatic String defaultIfEmpty(String str,String defaultStr);\\nstatic String reverse(String str);\\nstatic String reverseDelimited(String str,char separatorChar);\\nstatic String abbreviate(String str,int maxWidth);\\nstatic String abbreviate(String str,int offset,int maxWidth);\\nstatic String abbreviateMiddle(String str,String middle,int length);\\nstatic String difference(String str1,String str2);\\nstatic int indexOfDifference(String str1,String str2);\\nstatic int indexOfDifference(String[] strs);\\nstatic String getCommonPrefix(String[] strs);\\nstatic int getLevenshteinDistance(String s,String t);\\nstatic boolean startsWith(String str,String prefix);\\nstatic boolean startsWithIgnoreCase(String str,String prefix);\\nstatic boolean startsWithAny(String string,String[] searchStrings);\\nstatic boolean endsWith(String str,String suffix);\\nstatic boolean endsWithIgnoreCase(String str,String suffix);\\nstatic String normalizeSpace(String str);\\nstatic boolean endsWithAny(String string,String[] searchStrings);\\nstatic String firstCharToUpperCase(String value);\\nstatic String firstCharToLowerCase(String value);\\nstatic boolean equalsBlankIgnoreCase(String str1,String str2);\\nstatic String quote(String input);\\nstatic void quote(Appendable buffer,String input);\\nstatic String toString(Object object);\\n }\\npublic interface Invoker {public AppContext getAppContext();\\npublic HttpServletRequest getHttpRequest();\\npublic HttpServletResponse getHttpResponse();\\npublic Future<T> asyncExecute(EFunction consumer,Executor executor);\\ndefault Future<T> asyncExecute(EFunction consumer);\\npublic String contentType();\\npublic void contentType(String contentType);\\npublic Mapping ownerMapping();\\npublic String getJsonBodyString();\\ndefault Set<String> keySet();\\ndefault T fillForm(Class formType);\\npublic T fillForm(Class formType,T bean);\\ndefault Object get(String key);\\ndefault void remove(String key);\\ndefault void put(String key,Object value);\\npublic boolean isLockKey(String key);\\npublic void lockKey(String key);\\ndefault String getRequestPath();\\ndefault void forEach(BiConsumer action);\\ndefault void putIfAbsent(String key,Object value);\\ndefault Object getOrDefault(String key,Object defaultValue);\\ndefault V getOrMap(String key,Function defaultValue);\\ndefault void computeIfAbsent(String key,Function mappingFunction);\\n }\\npublic interface HttpParameters {static T executeWorker(Invoker invoker,ESupplier worker);\\nstatic Map<String,String> cookieMap();\\nstatic Map<String,List<String>> cookieArrayMap();\\nstatic boolean clearReplaceCookieArrayMap(Map newCookie);\\nstatic boolean mergeReplaceCookieArrayMap(Map newCookie);\\nstatic boolean appendCookieArrayMap(Map newCookie);\\nstatic Invoker localInvoker();\\nstatic Map<String,String> headerMap();\\nstatic Map<String,List<String>> headerArrayMap();\\nstatic boolean clearReplaceHeaderArrayMap(Map newHeader);\\nstatic boolean mergeReplaceHeaderArrayMap(Map newHeader);\\nstatic boolean appendHeaderArrayMap(Map newHeader);\\nstatic Map<String,String> queryMap();\\nstatic Map<String,List<String>> queryArrayMap();\\nstatic boolean clearReplaceQueryArrayMap(Map newQuery);\\nstatic boolean mergeReplaceQueryArrayMap(Map newQuery);\\nstatic boolean appendQueryArrayMap(Map newQuery);\\nstatic Map<String,String> pathMap();\\nstatic Map<String,List<String>> pathArrayMap();\\nstatic boolean clearReplacePathArrayMap(Map newPath);\\nstatic boolean mergeReplacePathArrayMap(Map newPath);\\nstatic boolean appendPathArrayMap(Map newPath);\\nstatic Map<String,String> requestMap();\\nstatic Map<String,List<String>> requestArrayMap();\\nstatic boolean clearReplaceRequestArrayMap(Map newRequestParam);\\nstatic boolean mergeReplaceRequestArrayMap(Map newRequestParam);\\nstatic boolean appendRequestArrayMap(Map newRequestParam);\\n }\\n\" }",
            "class_name": "WebUdfSource",
            "code": "public static String sessionId(){\n  HttpSession httpSession=servletSession();\n  if (httpSession == null) {\n    return null;\n  }\n  return httpSession.getId();\n}\n",
            "docstring": "/** \n * Session ID. \n */\n",
            "end_lineno": "280",
            "file_content": "/*\n * Copyright 2008-2009 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.dataql.fx.web;\nimport com.alibaba.fastjson.JSON;\nimport net.hasor.core.Singleton;\nimport net.hasor.dataql.UdfSourceAssembly;\nimport net.hasor.utils.StringUtils;\nimport net.hasor.web.Invoker;\nimport net.hasor.web.invoker.HttpParameters;\n\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.util.*;\n\n/**\n * Web  <code>import 'net.hasor.dataql.fx.web.WebUdfSource' as webData;</code>\n * @author  (zyc@hasor.net)\n * @version : 2020-03-29\n */\n@Singleton\npublic class WebUdfSource implements UdfSourceAssembly {\n    /** jsonBody */\n    public static Object jsonBody() {\n        Invoker invoker = HttpParameters.localInvoker();\n        if (invoker == null) {\n            return null;\n        }\n        return JSON.parse(invoker.getJsonBodyString());\n    }\n    // --------------------------------------------------------------------------------------------\n\n    /** cookieMap */\n    public static Map<String, String> cookieMap() {\n        return HttpParameters.cookieMap();\n    }\n\n    /** cookieMap,Value */\n    public static Map<String, List<String>> cookieArrayMap() {\n        return HttpParameters.cookieArrayMap();\n    }\n\n    /** Cookie */\n    public static String getCookie(String cookieName) {\n        if (StringUtils.isBlank(cookieName)) {\n            return null;\n        }\n        return cookieMap().get(cookieName);\n    }\n\n    /** Cookie */\n    public static List<String> getCookieArray(String cookieName) {\n        if (StringUtils.isBlank(cookieName)) {\n            return null;\n        }\n        return cookieArrayMap().get(cookieName);\n    }\n\n    /**  Cookie Cookie  MaxAge = -1 */\n    public static boolean tempCookie(String cookieName, String value) {\n        HttpServletResponse httpResponse = HttpParameters.localInvoker().getHttpResponse();\n        Cookie cookie = new Cookie(cookieName, value);\n        cookie.setMaxAge(-1);\n        httpResponse.addCookie(cookie);\n        return true;\n    }\n\n    /**  Cookie Cookie  MaxAge = -1 */\n    public static boolean tempCookieAll(Map<String, String> cookieMap) {\n        if (cookieMap != null) {\n            cookieMap.forEach(WebUdfSource::tempCookie);\n            return true;\n        }\n        return false;\n    }\n\n    /**  Cookie */\n    public static boolean storeCookie(String cookieName, String value, int maxAge) {\n        HttpServletResponse httpResponse = HttpParameters.localInvoker().getHttpResponse();\n        Cookie cookie = new Cookie(cookieName, value);\n        if (maxAge <= 0) {\n            maxAge = -1;\n        }\n        cookie.setMaxAge(maxAge);\n        httpResponse.addCookie(cookie);\n        return true;\n    }\n\n    /**  Cookie */\n    public static boolean storeCookieAll(Map<String, String> cookieMap, int maxAge) {\n        if (cookieMap != null) {\n            cookieMap.forEach((cookieName, value) -> {\n                storeCookie(cookieName, value, maxAge);\n            });\n            return true;\n        }\n        return false;\n    }\n\n    /**  Cookie */\n    public static boolean removeCookie(String cookieName) {\n        HttpServletResponse httpResponse = HttpParameters.localInvoker().getHttpResponse();\n        Cookie cookie = new Cookie(cookieName, \"\");\n        cookie.setMaxAge(0);\n        httpResponse.addCookie(cookie);\n        return true;\n    }\n    // --------------------------------------------------------------------------------------------\n\n    /** headerMap */\n    public static Map<String, String> headerMap() {\n        return HttpParameters.headerMap();\n    }\n\n    /** headerMap,Value */\n    public static Map<String, List<String>> headerArrayMap() {\n        return HttpParameters.headerArrayMap();\n    }\n\n    /**  Header */\n    public static String getHeader(String headerName) {\n        if (StringUtils.isBlank(headerName)) {\n            return null;\n        }\n        return headerMap().get(headerName);\n    }\n\n    /**  Header */\n    public static List<String> getHeaderArray(String headerName) {\n        if (StringUtils.isBlank(headerName)) {\n            return null;\n        }\n        return headerArrayMap().get(headerName);\n    }\n\n    /**  Header */\n    public static boolean setHeader(String headerName, String value) {\n        if (StringUtils.isBlank(headerName)) {\n            return false;\n        }\n        HttpParameters.localInvoker().getHttpResponse().setHeader(headerName, value);\n        return true;\n    }\n\n    /**  HeaderMap */\n    public static boolean setHeaderAll(Map<String, String> headerMap) {\n        if (headerMap != null) {\n            HttpServletResponse httpResponse = HttpParameters.localInvoker().getHttpResponse();\n            headerMap.forEach(httpResponse::setHeader);\n            return true;\n        }\n        return false;\n    }\n\n    /**  Header */\n    public static boolean addHeader(String headerName, String value) {\n        if (StringUtils.isBlank(headerName)) {\n            return false;\n        }\n        HttpParameters.localInvoker().getHttpResponse().addHeader(headerName, value);\n        return true;\n    }\n\n    /**  HeaderMap */\n    public static boolean addHeaderAll(Map<String, String> headerMap) {\n        if (headerMap != null) {\n            HttpServletResponse httpResponse = HttpParameters.localInvoker().getHttpResponse();\n            headerMap.forEach(httpResponse::addHeader);\n            return true;\n        }\n        return false;\n    }\n    // --------------------------------------------------------------------------------------------\n\n    /** session */\n    private static HttpSession servletSession() {\n        Invoker invoker = HttpParameters.localInvoker();\n        if (invoker == null) {\n            return null;\n        }\n        return invoker.getHttpRequest().getSession();\n    }\n\n    /** sessionKeys */\n    public static List<String> sessionKeys() {\n        HttpSession httpSession = servletSession();\n        if (httpSession == null) {\n            return Collections.emptyList();\n        }\n        Enumeration<String> attributeNames = httpSession.getAttributeNames();\n        List<String> names = new ArrayList<>();\n        while (attributeNames.hasMoreElements()) {\n            names.add(attributeNames.nextElement());\n        }\n        return names;\n    }\n\n    /** Session */\n    public static Object getSession(String key) {\n        if (StringUtils.isBlank(key)) {\n            return null;\n        }\n        HttpSession httpSession = servletSession();\n        if (httpSession == null) {\n            return null;\n        }\n        return httpSession.getAttribute(key);\n    }\n\n    /** Session */\n    public static Object setSession(String key, Object newValue) {\n        if (StringUtils.isBlank(key)) {\n            return null;\n        }\n        HttpSession httpSession = servletSession();\n        if (httpSession == null) {\n            httpSession = HttpParameters.localInvoker().getHttpRequest().getSession(true);\n        }\n        Object oldValue = httpSession.getAttribute(key);\n        httpSession.setAttribute(key, newValue);\n        return oldValue;\n    }\n\n    /** Session */\n    public static boolean removeSession(String key) {\n        if (StringUtils.isBlank(key)) {\n            return false;\n        }\n        HttpSession httpSession = servletSession();\n        if (httpSession == null) {\n            return false;\n        }\n        httpSession.removeAttribute(key);\n        return true;\n    }\n\n    /** Key */\n    public static boolean cleanSession() {\n        HttpSession httpSession = servletSession();\n        if (httpSession == null) {\n            return false;\n        }\n        Enumeration<String> attributeNames = httpSession.getAttributeNames();\n        while (attributeNames.hasMoreElements()) {\n            httpSession.removeAttribute(attributeNames.nextElement());\n        }\n        return true;\n    }\n\n    /** Invalidates this session then unbinds any objects bound to it. */\n    public static boolean sessionInvalidate() {\n        HttpSession httpSession = servletSession();\n        if (httpSession == null) {\n            return false;\n        }\n        httpSession.invalidate();\n        return true;\n    }\n\n    /** Session ID. */\n    public static String sessionId() {\n        HttpSession httpSession = servletSession();\n        if (httpSession == null) {\n            return null;\n        }\n        return httpSession.getId();\n    }\n\n    /** . */\n    public static long sessionLastAccessedTime() {\n        HttpSession httpSession = servletSession();\n        if (httpSession == null) {\n            return 0;\n        }\n        return httpSession.getLastAccessedTime();\n    }\n}\n",
            "file_name": "WebUdfSource.java",
            "human_label": "Return the servlet session id",
            "level": "plib_runnable",
            "lineno": "273",
            "name": "sessionId",
            "oracle_context": "{ \"apis\" : \"[servletSession, getId]\", \"classes\" : \"[HttpSession]\", \"vars\" : \"[]\" }",
            "package": "net.hasor.dataql.fx.web",
            "project": "hasor-master"
        },
        {
            "_id": "6367670c1a6d9265ec017a35",
            "all_context": "{ \"class_level\" : \"import java.io.IOException;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Locale;\\nString EMPTY;\\nint INDEX_NOT_FOUND;\\nint PAD_LIMIT;\\nchar[] escapes;\\nStringUtils();\\nisNotEmpty(String str);\\nisBlank(String str);\\nisNotBlank(String str);\\ntrim(String str);\\ntrimToNull(String str);\\ntrimToEmpty(String str);\\nstrip(String str);\\nstripToNull(String str);\\nstripToEmpty(String str);\\nstrip(String str,String stripChars);\\nstripStart(String str,String stripChars);\\nstripEnd(String str,String stripChars);\\nstripAll(String[] strs);\\nstripAll(String[] strs,String stripChars);\\nequals(String str1,String str2);\\nequalsIgnoreCase(String str1,String str2);\\nindexOf(String str,char searchChar);\\nindexOf(String str,char searchChar,int startPos);\\nindexOf(String str,String searchStr);\\nordinalIndexOf(String str,String searchStr,int ordinal);\\nordinalIndexOf(String str,String searchStr,int ordinal,boolean lastIndex);\\nindexOf(String str,String searchStr,int startPos);\\nindexOfIgnoreCase(String str,String searchStr);\\nindexOfIgnoreCase(String str,String searchStr,int startPos);\\nlastIndexOf(String str,char searchChar);\\nlastIndexOf(String str,char searchChar,int startPos);\\nlastIndexOf(String str,String searchStr);\\nlastOrdinalIndexOf(String str,String searchStr,int ordinal);\\nlastIndexOf(String str,String searchStr,int startPos);\\nlastIndexOfIgnoreCase(String str,String searchStr);\\nlastIndexOfIgnoreCase(String str,String searchStr,int startPos);\\ncontains(String str,char searchChar);\\ncontains(String str,String searchStr);\\ncontainsIgnoreCase(String str,String searchStr);\\nindexOfAny(String str,char[] searchChars);\\nindexOfAny(String str,String searchChars);\\ncontainsAny(String str,char[] searchChars);\\ncontainsAny(String str,String searchChars);\\nindexOfAnyBut(String str,char[] searchChars);\\nindexOfAnyBut(String str,String searchChars);\\ncontainsOnly(String str,char[] valid);\\ncontainsOnly(String str,String validChars);\\ncontainsNone(String str,char[] searchChars);\\ncontainsNone(String str,String invalidChars);\\nindexOfAny(String str,String[] searchStrs);\\nlastIndexOfAny(String str,String[] searchStrs);\\nsubstring(String str,int start);\\nsubstring(String str,int start,int end);\\nleft(String str,int len);\\nright(String str,int len);\\nmid(String str,int pos,int len);\\nsubstringBefore(String str,String separator);\\nsubstringAfter(String str,String separator);\\nsubstringBeforeLast(String str,String separator);\\nsubstringAfterLast(String str,String separator);\\nsubstringBetween(String str,String tag);\\nsubstringBetween(String str,String open,String close);\\nsubstringsBetween(String str,String open,String close);\\nsplitKeep(String str,char separatorChar);\\nsplitKeep(String str,String separatorStr);\\nsplit(String str);\\nsplit(String str,char separatorChar);\\nsplit(String str,String separatorChars);\\nsplit(String str,String separatorChars,int max);\\nsplitByWholeSeparator(String str,String separator);\\nsplitByWholeSeparator(String str,String separator,int max);\\nsplitByWholeSeparatorPreserveAllTokens(String str,String separator);\\nsplitByWholeSeparatorPreserveAllTokens(String str,String separator,int max);\\nsplitByWholeSeparatorWorker(String str,String separator,int max,boolean preserveAllTokens);\\nsplitPreserveAllTokens(String str);\\nsplitPreserveAllTokens(String str,char separatorChar);\\nsplitWorker(String str,char separatorChar,boolean preserveAllTokens);\\nsplitPreserveAllTokens(String str,String separatorChars);\\nsplitPreserveAllTokens(String str,String separatorChars,int max);\\nsplitWorker(String str,String separatorChars,int max,boolean preserveAllTokens);\\nsplitByCharacterType(String str);\\nsplitByCharacterTypeCamelCase(String str);\\nsplitByCharacterType(String str,boolean camelCase);\\njoin(Object[] array);\\njoin(Object[] array,char separator);\\njoin(Object[] array,char separator,int startIndex,int endIndex);\\njoin(Object[] array,String separator);\\njoin(Object[] array,String separator,int startIndex,int endIndex);\\ndeleteWhitespace(String str);\\nremoveStart(String str,String remove);\\nremoveStartIgnoreCase(String str,String remove);\\nremoveEnd(String str,String remove);\\nremoveEndIgnoreCase(String str,String remove);\\nremove(String str,String remove);\\nremove(String str,char remove);\\nreplaceOnce(String text,String searchString,String replacement);\\nreplace(String text,String searchString,String replacement);\\nreplace(String text,String searchString,String replacement,int max);\\nreplaceEach(String text,String[] searchList,String[] replacementList);\\nreplaceEachRepeatedly(String text,String[] searchList,String[] replacementList);\\nreplaceEach(String text,String[] searchList,String[] replacementList,boolean repeat,int timeToLive);\\nreplaceChars(String str,char searchChar,char replaceChar);\\nreplaceChars(String str,String searchChars,String replaceChars);\\noverlay(String str,String overlay,int start,int end);\\nchomp(String str);\\nchomp(String str,String separator);\\nchop(String str);\\nrepeat(char character,int repeat);\\nrepeat(String str,int repeat);\\nrepeat(String str,String separator,int repeat);\\npadding(int repeat,char padChar);\\nrightPad(String str,int size);\\nrightPad(String str,int size,char padChar);\\nrightPad(String str,int size,String padStr);\\nleftPad(String str,int size);\\nleftPad(String str,int size,char padChar);\\nleftPad(String str,int size,String padStr);\\nlength(String str);\\ncenter(String str,int size);\\ncenter(String str,int size,char padChar);\\ncenter(String str,int size,String padStr);\\nupperCase(String str);\\nupperCase(String str,Locale locale);\\nlowerCase(String str);\\nlowerCase(String str,Locale locale);\\ncapitalize(String str);\\nuncapitalize(String str);\\nswapCase(String str);\\ncountMatches(String str,String sub);\\nisAlpha(String str);\\nisAlphaSpace(String str);\\nisAlphanumeric(String str);\\nisAlphanumericSpace(String str);\\nisAsciiPrintable(String str);\\nisNumeric(String str);\\nisNumericSpace(String str);\\nisWhitespace(String str);\\nisAllLowerCase(String str);\\nisAllUpperCase(String str);\\ndefaultString(String str);\\ndefaultString(String str,String defaultStr);\\ndefaultIfBlank(String str,String defaultStr);\\ndefaultIfEmpty(String str,String defaultStr);\\nreverse(String str);\\nreverseDelimited(String str,char separatorChar);\\nabbreviate(String str,int maxWidth);\\nabbreviate(String str,int offset,int maxWidth);\\nabbreviateMiddle(String str,String middle,int length);\\ndifference(String str1,String str2);\\nindexOfDifference(String str1,String str2);\\nindexOfDifference(String[] strs);\\ngetCommonPrefix(String[] strs);\\ngetLevenshteinDistance(String s,String t);\\nstartsWith(String str,String prefix);\\nstartsWithIgnoreCase(String str,String prefix);\\nstartsWith(String str,String prefix,boolean ignoreCase);\\nstartsWithAny(String string,String[] searchStrings);\\nendsWith(String str,String suffix);\\nendsWithIgnoreCase(String str,String suffix);\\nendsWith(String str,String suffix,boolean ignoreCase);\\nnormalizeSpace(String str);\\nendsWithAny(String string,String[] searchStrings);\\nfirstCharToUpperCase(String value);\\nfirstCharToLowerCase(String value);\\nequalsBlankIgnoreCase(String str1,String str2);\\nquote(String input);\\nquote(Appendable buffer,String input);\\ntoString(Object object);\\nisEmpty(String str);\\n\", \"repo_level\" : \"\" }",
            "class_name": "StringUtils",
            "code": "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n  if (str == null || suffix == null) {\n    return str == null && suffix == null;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  int strOffset=str.length() - suffix.length();\n  return str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());\n}\n",
            "docstring": "/** \n * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n * @see String#endsWith(String)\n * @param str  the String to check, may be null\n * @param suffix the suffix to find, may be null\n * @param ignoreCase inidicates whether the compare should ignore case(case insensitive) or not.\n * @return <code>true</code> if the String starts with the prefix orboth <code>null</code>\n */\n",
            "end_lineno": "5945",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\n/**\n * <p>Operations on {@link String} that are\n * <code>null</code> safe.</p>\n *\n * <ul>\n *  <li><b>IsEmpty/IsBlank</b>\n *      - checks if a String contains text</li>\n *  <li><b>Trim/Strip</b>\n *      - removes leading and trailing whitespace</li>\n *  <li><b>Equals</b>\n *      - compares two strings null-safe</li>\n *  <li><b>startsWith</b>\n *      - check if a String starts with a prefix null-safe</li>\n *  <li><b>endsWith</b>\n *      - check if a String ends with a suffix null-safe</li>\n *  <li><b>IndexOf/LastIndexOf/Contains</b>\n *      - null-safe index-of checks\n *  <li><b>IndexOfAny/LastIndexOfAny/IndexOfAnyBut/LastIndexOfAnyBut</b>\n *      - index-of any of a set of Strings</li>\n *  <li><b>ContainsOnly/ContainsNone/ContainsAny</b>\n *      - does String contains only/none/any of these characters</li>\n *  <li><b>Substring/Left/Right/Mid</b>\n *      - null-safe substring extractions</li>\n *  <li><b>SubstringBefore/SubstringAfter/SubstringBetween</b>\n *      - substring extraction relative to other strings</li>\n *  <li><b>Split/Join</b>\n *      - splits a String into an array of substrings and vice versa</li>\n *  <li><b>Remove/Delete</b>\n *      - removes part of a String</li>\n *  <li><b>Replace/Overlay</b>\n *      - Searches a String and replaces one String with another</li>\n *  <li><b>Chomp/Chop</b>\n *      - removes the last part of a String</li>\n *  <li><b>LeftPad/RightPad/Center/Repeat</b>\n *      - pads a String</li>\n *  <li><b>UpperCase/LowerCase/SwapCase/Capitalize/Uncapitalize</b>\n *      - changes the case of a String</li>\n *  <li><b>CountMatches</b>\n *      - counts the number of occurrences of one String in another</li>\n *  <li><b>IsAlpha/IsNumeric/IsWhitespace/IsAsciiPrintable</b>\n *      - checks the characters in a String</li>\n *  <li><b>DefaultString</b>\n *      - protects against a null input String</li>\n *  <li><b>Reverse/ReverseDelimited</b>\n *      - reverses a String</li>\n *  <li><b>Abbreviate</b>\n *      - abbreviates a string using ellipsis</li>\n *  <li><b>Difference</b>\n *      - compares Strings and reports on their differences</li>\n *  <li><b>LevensteinDistance</b>\n *      - the number of changes needed to change one String into another</li>\n * </ul>\n *\n * <p>The <code>StringUtils</code> class defines certain words related to\n * String handling.</p>\n *\n * <ul>\n *  <li>null - <code>null</code></li>\n *  <li>empty - a zero-length string (<code>\"\"</code>)</li>\n *  <li>space - the space character (<code>' '</code>, char 32)</li>\n *  <li>whitespace - the characters defined by {@link Character#isWhitespace(char)}</li>\n *  <li>trim - the characters &lt;= 32 as in {@link String#trim()}</li>\n * </ul>\n *\n * <p><code>StringUtils</code> handles <code>null</code> input Strings quietly.\n * That is to say that a <code>null</code> input will return <code>null</code>.\n * Where a <code>boolean</code> or <code>int</code> is being returned\n * details vary by method.</p>\n *\n * <p>A side effect of the <code>null</code> handling is that a\n * <code>NullPointerException</code> should be considered a bug in\n * <code>StringUtils</code> (except for deprecated methods).</p>\n *\n * <p>Methods in this class give sample code to explain their operation.\n * The symbol <code>*</code> is used to indicate any input including <code>null</code>.</p>\n *\n * <p>#ThreadSafe#</p>\n * @see String\n * @author Apache Software Foundation\n * @author <a href=\"http://jakarta.apache.org/turbine/\">Apache Jakarta Turbine</a>\n * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n * @author Daniel L. Rall\n * @author <a href=\"mailto:gcoladonato@yahoo.com\">Greg Coladonato</a>\n * @author <a href=\"mailto:ed@apache.org\">Ed Korthof</a>\n * @author <a href=\"mailto:rand_mcneely@yahoo.com\">Rand McNeely</a>\n * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n * @author Holger Krauth\n * @author <a href=\"mailto:alex@purpletech.com\">Alexander Day Chaffee</a>\n * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n * @author Arun Mammen Thomas\n * @author Gary Gregory\n * @author Phil Steitz\n * @author Al Chou\n * @author Michael Davey\n * @author Reuben Sivan\n * @author Chris Hyzer\n * @author Scott Johnson\n * @since 1.0\n * @version $Id: StringUtils.java 1058365 2011-01-13 00:04:49Z niallp $\n */\n//@Immutable\npublic class StringUtils {\n    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n    // Whitespace:\n    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n    // where WHITESPACE is a string of all whitespace characters\n    //\n    // Character access:\n    // String.charAt(n) versus toCharArray(), then array[n]\n    // String.charAt(n) is about 15% worse for a 10K string\n    // They are about equal for a length 50 string\n    // String.charAt(n) is about 4 times better for a length 3 string\n    // String.charAt(n) is best bet overall\n    //\n    // Append:\n    // String.concat about twice as fast as StringBuffer.append\n    // (not sure who tested this)\n    /**\n     * The empty String <code>\"\"</code>.\n     * @since 2.0\n     */\n    public static final  String EMPTY           = \"\";\n    /**\n     * Represents a failed index search.\n     * @since 2.1\n     */\n    public static final  int    INDEX_NOT_FOUND = -1;\n    /**\n     * <p>The maximum size to which the padding constant(s) can expand.</p>\n     */\n    private static final int    PAD_LIMIT       = 8192;\n\n    /**\n     * <p><code>StringUtils</code> instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * <code>StringUtils.trim(\" foo \");</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean\n     * instance to operate.</p>\n     */\n    public StringUtils() {\n        super();\n    }\n    // Empty checks\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if a String is empty (\"\") or null.</p>\n     *\n     * <pre>\n     * StringUtils.isEmpty(null)      = true\n     * StringUtils.isEmpty(\"\")        = true\n     * StringUtils.isEmpty(\" \")       = false\n     * StringUtils.isEmpty(\"bob\")     = false\n     * StringUtils.isEmpty(\"  bob  \") = false\n     * </pre>\n     *\n     * <p>NOTE: This method changed in Lang version 2.0.\n     * It no longer trims the String.\n     * That functionality is available in isBlank().</p>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if the String is empty or null\n     */\n    public static boolean isEmpty(final String str) {\n        return str == null || str.length() == 0;\n    }\n\n    /**\n     * <p>Checks if a String is not empty (\"\") and not null.</p>\n     *\n     * <pre>\n     * StringUtils.isNotEmpty(null)      = false\n     * StringUtils.isNotEmpty(\"\")        = false\n     * StringUtils.isNotEmpty(\" \")       = true\n     * StringUtils.isNotEmpty(\"bob\")     = true\n     * StringUtils.isNotEmpty(\"  bob  \") = true\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if the String is not empty and not null\n     */\n    public static boolean isNotEmpty(final String str) {\n        return !StringUtils.isEmpty(str);\n    }\n\n    /**\n     * <p>Checks if a String is whitespace, empty (\"\") or null.</p>\n     *\n     * <pre>\n     * StringUtils.isBlank(null)      = true\n     * StringUtils.isBlank(\"\")        = true\n     * StringUtils.isBlank(\" \")       = true\n     * StringUtils.isBlank(\"bob\")     = false\n     * StringUtils.isBlank(\"  bob  \") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if the String is null, empty or whitespace\n     * @since 2.0\n     */\n    public static boolean isBlank(final String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return true;\n        }\n        for (int i = 0; i < strLen; i++) {\n            if (Character.isWhitespace(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if a String is not empty (\"\"), not null and not whitespace only.</p>\n     *\n     * <pre>\n     * StringUtils.isNotBlank(null)      = false\n     * StringUtils.isNotBlank(\"\")        = false\n     * StringUtils.isNotBlank(\" \")       = false\n     * StringUtils.isNotBlank(\"bob\")     = true\n     * StringUtils.isNotBlank(\"  bob  \") = true\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if the String is\n     *  not empty and not null and not whitespace\n     * @since 2.0\n     */\n    public static boolean isNotBlank(final String str) {\n        return !StringUtils.isBlank(str);\n    }\n    // Trim\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Removes control characters (char &lt;= 32) from both\n     * ends of this String, handling <code>null</code> by returning\n     * <code>null</code>.</p>\n     *\n     * <p>The String is trimmed using {@link String#trim()}.\n     * Trim removes start and end characters &lt;= 32.\n     * To strip whitespace use {@link #strip(String)}.</p>\n     *\n     * <p>To trim your choice of characters, use the\n     * {@link #strip(String, String)} methods.</p>\n     *\n     * <pre>\n     * StringUtils.trim(null)          = null\n     * StringUtils.trim(\"\")            = \"\"\n     * StringUtils.trim(\"     \")       = \"\"\n     * StringUtils.trim(\"abc\")         = \"abc\"\n     * StringUtils.trim(\"    abc    \") = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to be trimmed, may be null\n     * @return the trimmed string, <code>null</code> if null String input\n     */\n    public static String trim(final String str) {\n        return str == null ? null : str.trim();\n    }\n\n    /**\n     * <p>Removes control characters (char &lt;= 32) from both\n     * ends of this String returning <code>null</code> if the String is\n     * empty (\"\") after the trim or if it is <code>null</code>.\n     *\n     * <p>The String is trimmed using {@link String#trim()}.\n     * Trim removes start and end characters &lt;= 32.\n     * To strip whitespace use {@link #stripToNull(String)}.</p>\n     *\n     * <pre>\n     * StringUtils.trimToNull(null)          = null\n     * StringUtils.trimToNull(\"\")            = null\n     * StringUtils.trimToNull(\"     \")       = null\n     * StringUtils.trimToNull(\"abc\")         = \"abc\"\n     * StringUtils.trimToNull(\"    abc    \") = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to be trimmed, may be null\n     * @return the trimmed String,\n     *  <code>null</code> if only chars &lt;= 32, empty or null String input\n     * @since 2.0\n     */\n    public static String trimToNull(final String str) {\n        String ts = StringUtils.trim(str);\n        return StringUtils.isEmpty(ts) ? null : ts;\n    }\n\n    /**\n     * <p>Removes control characters (char &lt;= 32) from both\n     * ends of this String returning an empty String (\"\") if the String\n     * is empty (\"\") after the trim or if it is <code>null</code>.\n     *\n     * <p>The String is trimmed using {@link String#trim()}.\n     * Trim removes start and end characters &lt;= 32.\n     * To strip whitespace use {@link #stripToEmpty(String)}.</p>\n     *\n     * <pre>\n     * StringUtils.trimToEmpty(null)          = \"\"\n     * StringUtils.trimToEmpty(\"\")            = \"\"\n     * StringUtils.trimToEmpty(\"     \")       = \"\"\n     * StringUtils.trimToEmpty(\"abc\")         = \"abc\"\n     * StringUtils.trimToEmpty(\"    abc    \") = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to be trimmed, may be null\n     * @return the trimmed String, or an empty String if <code>null</code> input\n     * @since 2.0\n     */\n    public static String trimToEmpty(final String str) {\n        return str == null ? StringUtils.EMPTY : str.trim();\n    }\n    // Stripping\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Strips whitespace from the start and end of a String.</p>\n     *\n     * <p>This is similar to {@link #trim(String)} but removes whitespace.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.strip(null)     = null\n     * StringUtils.strip(\"\")       = \"\"\n     * StringUtils.strip(\"   \")    = \"\"\n     * StringUtils.strip(\"abc\")    = \"abc\"\n     * StringUtils.strip(\"  abc\")  = \"abc\"\n     * StringUtils.strip(\"abc  \")  = \"abc\"\n     * StringUtils.strip(\" abc \")  = \"abc\"\n     * StringUtils.strip(\" ab c \") = \"ab c\"\n     * </pre>\n     *\n     * @param str  the String to remove whitespace from, may be null\n     * @return the stripped String, <code>null</code> if null String input\n     */\n    public static String strip(final String str) {\n        return StringUtils.strip(str, null);\n    }\n\n    /**\n     * <p>Strips whitespace from the start and end of a String  returning\n     * <code>null</code> if the String is empty (\"\") after the strip.</p>\n     *\n     * <p>This is similar to {@link #trimToNull(String)} but removes whitespace.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <pre>\n     * StringUtils.stripToNull(null)     = null\n     * StringUtils.stripToNull(\"\")       = null\n     * StringUtils.stripToNull(\"   \")    = null\n     * StringUtils.stripToNull(\"abc\")    = \"abc\"\n     * StringUtils.stripToNull(\"  abc\")  = \"abc\"\n     * StringUtils.stripToNull(\"abc  \")  = \"abc\"\n     * StringUtils.stripToNull(\" abc \")  = \"abc\"\n     * StringUtils.stripToNull(\" ab c \") = \"ab c\"\n     * </pre>\n     *\n     * @param str  the String to be stripped, may be null\n     * @return the stripped String,\n     *  <code>null</code> if whitespace, empty or null String input\n     * @since 2.0\n     */\n    public static String stripToNull(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = StringUtils.strip(str, null);\n        return str.length() == 0 ? null : str;\n    }\n\n    /**\n     * <p>Strips whitespace from the start and end of a String  returning\n     * an empty String if <code>null</code> input.</p>\n     *\n     * <p>This is similar to {@link #trimToEmpty(String)} but removes whitespace.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <pre>\n     * StringUtils.stripToEmpty(null)     = \"\"\n     * StringUtils.stripToEmpty(\"\")       = \"\"\n     * StringUtils.stripToEmpty(\"   \")    = \"\"\n     * StringUtils.stripToEmpty(\"abc\")    = \"abc\"\n     * StringUtils.stripToEmpty(\"  abc\")  = \"abc\"\n     * StringUtils.stripToEmpty(\"abc  \")  = \"abc\"\n     * StringUtils.stripToEmpty(\" abc \")  = \"abc\"\n     * StringUtils.stripToEmpty(\" ab c \") = \"ab c\"\n     * </pre>\n     *\n     * @param str  the String to be stripped, may be null\n     * @return the trimmed String, or an empty String if <code>null</code> input\n     * @since 2.0\n     */\n    public static String stripToEmpty(final String str) {\n        return str == null ? StringUtils.EMPTY : StringUtils.strip(str, null);\n    }\n\n    /**\n     * <p>Strips any of a set of characters from the start and end of a String.\n     * This is similar to {@link String#trim()} but allows the characters\n     * to be stripped to be controlled.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * An empty string (\"\") input returns the empty string.</p>\n     *\n     * <p>If the stripChars String is <code>null</code>, whitespace is\n     * stripped as defined by {@link Character#isWhitespace(char)}.\n     * Alternatively use {@link #strip(String)}.</p>\n     *\n     * <pre>\n     * StringUtils.strip(null, *)          = null\n     * StringUtils.strip(\"\", *)            = \"\"\n     * StringUtils.strip(\"abc\", null)      = \"abc\"\n     * StringUtils.strip(\"  abc\", null)    = \"abc\"\n     * StringUtils.strip(\"abc  \", null)    = \"abc\"\n     * StringUtils.strip(\" abc \", null)    = \"abc\"\n     * StringUtils.strip(\"  abcyx\", \"xyz\") = \"  abc\"\n     * </pre>\n     *\n     * @param str  the String to remove characters from, may be null\n     * @param stripChars  the characters to remove, null treated as whitespace\n     * @return the stripped String, <code>null</code> if null String input\n     */\n    public static String strip(String str, final String stripChars) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        str = StringUtils.stripStart(str, stripChars);\n        return StringUtils.stripEnd(str, stripChars);\n    }\n\n    /**\n     * <p>Strips any of a set of characters from the start of a String.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * An empty string (\"\") input returns the empty string.</p>\n     *\n     * <p>If the stripChars String is <code>null</code>, whitespace is\n     * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <pre>\n     * StringUtils.stripStart(null, *)          = null\n     * StringUtils.stripStart(\"\", *)            = \"\"\n     * StringUtils.stripStart(\"abc\", \"\")        = \"abc\"\n     * StringUtils.stripStart(\"abc\", null)      = \"abc\"\n     * StringUtils.stripStart(\"  abc\", null)    = \"abc\"\n     * StringUtils.stripStart(\"abc  \", null)    = \"abc  \"\n     * StringUtils.stripStart(\" abc \", null)    = \"abc \"\n     * StringUtils.stripStart(\"yxabc  \", \"xyz\") = \"abc  \"\n     * </pre>\n     *\n     * @param str  the String to remove characters from, may be null\n     * @param stripChars  the characters to remove, null treated as whitespace\n     * @return the stripped String, <code>null</code> if null String input\n     */\n    public static String stripStart(final String str, final String stripChars) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        int start = 0;\n        if (stripChars == null) {\n            while (start != strLen && Character.isWhitespace(str.charAt(start))) {\n                start++;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while (start != strLen && stripChars.indexOf(str.charAt(start)) != StringUtils.INDEX_NOT_FOUND) {\n                start++;\n            }\n        }\n        return str.substring(start);\n    }\n\n    /**\n     * <p>Strips any of a set of characters from the end of a String.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * An empty string (\"\") input returns the empty string.</p>\n     *\n     * <p>If the stripChars String is <code>null</code>, whitespace is\n     * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <pre>\n     * StringUtils.stripEnd(null, *)          = null\n     * StringUtils.stripEnd(\"\", *)            = \"\"\n     * StringUtils.stripEnd(\"abc\", \"\")        = \"abc\"\n     * StringUtils.stripEnd(\"abc\", null)      = \"abc\"\n     * StringUtils.stripEnd(\"  abc\", null)    = \"  abc\"\n     * StringUtils.stripEnd(\"abc  \", null)    = \"abc\"\n     * StringUtils.stripEnd(\" abc \", null)    = \" abc\"\n     * StringUtils.stripEnd(\"  abcyx\", \"xyz\") = \"  abc\"\n     * StringUtils.stripEnd(\"120.00\", \".0\")   = \"12\"\n     * </pre>\n     *\n     * @param str  the String to remove characters from, may be null\n     * @param stripChars  the set of characters to remove, null treated as whitespace\n     * @return the stripped String, <code>null</code> if null String input\n     */\n    public static String stripEnd(final String str, final String stripChars) {\n        int end;\n        if (str == null || (end = str.length()) == 0) {\n            return str;\n        }\n        if (stripChars == null) {\n            while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {\n                end--;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != StringUtils.INDEX_NOT_FOUND) {\n                end--;\n            }\n        }\n        return str.substring(0, end);\n    }\n    // StripAll\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Strips whitespace from the start and end of every String in an array.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <p>A new array is returned each time, except for length zero.\n     * A <code>null</code> array will return <code>null</code>.\n     * An empty array will return itself.\n     * A <code>null</code> array entry will be ignored.</p>\n     *\n     * <pre>\n     * StringUtils.stripAll(null)             = null\n     * StringUtils.stripAll([])               = []\n     * StringUtils.stripAll([\"abc\", \"  abc\"]) = [\"abc\", \"abc\"]\n     * StringUtils.stripAll([\"abc  \", null])  = [\"abc\", null]\n     * </pre>\n     *\n     * @param strs  the array to remove whitespace from, may be null\n     * @return the stripped Strings, <code>null</code> if null array input\n     */\n    public static String[] stripAll(final String[] strs) {\n        return StringUtils.stripAll(strs, null);\n    }\n\n    /**\n     * <p>Strips any of a set of characters from the start and end of every\n     * String in an array.</p>\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <p>A new array is returned each time, except for length zero.\n     * A <code>null</code> array will return <code>null</code>.\n     * An empty array will return itself.\n     * A <code>null</code> array entry will be ignored.\n     * A <code>null</code> stripChars will strip whitespace as defined by\n     * {@link Character#isWhitespace(char)}.</p>\n     *\n     * <pre>\n     * StringUtils.stripAll(null, *)                = null\n     * StringUtils.stripAll([], *)                  = []\n     * StringUtils.stripAll([\"abc\", \"  abc\"], null) = [\"abc\", \"abc\"]\n     * StringUtils.stripAll([\"abc  \", null], null)  = [\"abc\", null]\n     * StringUtils.stripAll([\"abc  \", null], \"yz\")  = [\"abc  \", null]\n     * StringUtils.stripAll([\"yabcz\", null], \"yz\")  = [\"abc\", null]\n     * </pre>\n     *\n     * @param strs  the array to remove characters from, may be null\n     * @param stripChars  the characters to remove, null treated as whitespace\n     * @return the stripped Strings, <code>null</code> if null array input\n     */\n    public static String[] stripAll(final String[] strs, final String stripChars) {\n        int strsLen;\n        if (strs == null || (strsLen = strs.length) == 0) {\n            return strs;\n        }\n        String[] newArr = new String[strsLen];\n        for (int i = 0; i < strsLen; i++) {\n            newArr[i] = StringUtils.strip(strs[i], stripChars);\n        }\n        return newArr;\n    }\n    // Equals\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered to be equal. The comparison is case sensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * @see String#equals(Object)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case sensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equals(final String str1, final String str2) {\n        return str1 == null ? str2 == null : str1.equals(str2);\n    }\n\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(final String str1, final String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n    // IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the first index within a String, handling <code>null</code>.\n     * This method uses {@link String#indexOf(int)}.</p>\n     *\n     * <p>A <code>null</code> or empty (\"\") String will return <code>INDEX_NOT_FOUND (-1)</code>.</p>\n     *\n     * <pre>\n     * StringUtils.indexOf(null, *)         = -1\n     * StringUtils.indexOf(\"\", *)           = -1\n     * StringUtils.indexOf(\"aabaabaa\", 'a') = 0\n     * StringUtils.indexOf(\"aabaabaa\", 'b') = 2\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChar  the character to find\n     * @return the first index of the search character,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.0\n     */\n    public static int indexOf(final String str, final char searchChar) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchChar);\n    }\n\n    /**\n     * <p>Finds the first index within a String from a start position,\n     * handling <code>null</code>.\n     * This method uses {@link String#indexOf(int, int)}.</p>\n     *\n     * <p>A <code>null</code> or empty (\"\") String will return <code>(INDEX_NOT_FOUND) -1</code>.\n     * A negative start position is treated as zero.\n     * A start position greater than the string length returns <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.indexOf(null, *, *)          = -1\n     * StringUtils.indexOf(\"\", *, *)            = -1\n     * StringUtils.indexOf(\"aabaabaa\", 'b', 0)  = 2\n     * StringUtils.indexOf(\"aabaabaa\", 'b', 3)  = 5\n     * StringUtils.indexOf(\"aabaabaa\", 'b', 9)  = -1\n     * StringUtils.indexOf(\"aabaabaa\", 'b', -1) = 2\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChar  the character to find\n     * @param startPos  the start position, negative treated as zero\n     * @return the first index of the search character,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.0\n     */\n    public static int indexOf(final String str, final char searchChar, final int startPos) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchChar, startPos);\n    }\n\n    /**\n     * <p>Finds the first index within a String, handling <code>null</code>.\n     * This method uses {@link String#indexOf(String)}.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.indexOf(null, *)          = -1\n     * StringUtils.indexOf(*, null)          = -1\n     * StringUtils.indexOf(\"\", \"\")           = 0\n     * StringUtils.indexOf(\"\", *)            = -1 (except when * = \"\")\n     * StringUtils.indexOf(\"aabaabaa\", \"a\")  = 0\n     * StringUtils.indexOf(\"aabaabaa\", \"b\")  = 2\n     * StringUtils.indexOf(\"aabaabaa\", \"ab\") = 1\n     * StringUtils.indexOf(\"aabaabaa\", \"\")   = 0\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @return the first index of the search String,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.0\n     */\n    public static int indexOf(final String str, final String searchStr) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchStr);\n    }\n\n    /**\n     * <p>Finds the n-th index within a String, handling <code>null</code>.\n     * This method uses {@link String#indexOf(String)}.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.ordinalIndexOf(null, *, *)          = -1\n     * StringUtils.ordinalIndexOf(*, null, *)          = -1\n     * StringUtils.ordinalIndexOf(\"\", \"\", *)           = 0\n     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 1)  = 0\n     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 2)  = 1\n     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 1)  = 2\n     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 2)  = 5\n     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 1) = 1\n     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 2) = 4\n     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 1)   = 0\n     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 2)   = 0\n     * </pre>\n     *\n     * <p>Note that 'head(String str, int n)' may be implemented as: </p>\n     *\n     * <pre>\n     *   str.substring(0, lastOrdinalIndexOf(str, \"\\n\", n))\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @param ordinal  the n-th <code>searchStr</code> to find\n     * @return the n-th index of the search String,\n     *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input\n     * @since 2.1\n     */\n    public static int ordinalIndexOf(final String str, final String searchStr, final int ordinal) {\n        return StringUtils.ordinalIndexOf(str, searchStr, ordinal, false);\n    }\n\n    /**\n     * <p>Finds the n-th index within a String, handling <code>null</code>.\n     * This method uses {@link String#indexOf(String)}.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @param ordinal  the n-th <code>searchStr</code> to find\n     * @param lastIndex true if lastOrdinalIndexOf() otherwise false if ordinalIndexOf()\n     * @return the n-th index of the search String,\n     *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input\n     */\n    // Shared code between ordinalIndexOf(String,String,int) and lastOrdinalIndexOf(String,String,int)\n    private static int ordinalIndexOf(final String str, final String searchStr, final int ordinal, final boolean lastIndex) {\n        if (str == null || searchStr == null || ordinal <= 0) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return lastIndex ? str.length() : 0;\n        }\n        int found = 0;\n        int index = lastIndex ? str.length() : StringUtils.INDEX_NOT_FOUND;\n        do {\n            if (lastIndex) {\n                index = str.lastIndexOf(searchStr, index - 1);\n            } else {\n                index = str.indexOf(searchStr, index + 1);\n            }\n            if (index < 0) {\n                return index;\n            }\n            found++;\n        } while (found < ordinal);\n        return index;\n    }\n\n    /**\n     * <p>Finds the first index within a String, handling <code>null</code>.\n     * This method uses {@link String#indexOf(String, int)}.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A negative start position is treated as zero.\n     * An empty (\"\") search String always matches.\n     * A start position greater than the string length only matches\n     * an empty search String.</p>\n     *\n     * <pre>\n     * StringUtils.indexOf(null, *, *)          = -1\n     * StringUtils.indexOf(*, null, *)          = -1\n     * StringUtils.indexOf(\"\", \"\", 0)           = 0\n     * StringUtils.indexOf(\"\", *, 0)            = -1 (except when * = \"\")\n     * StringUtils.indexOf(\"aabaabaa\", \"a\", 0)  = 0\n     * StringUtils.indexOf(\"aabaabaa\", \"b\", 0)  = 2\n     * StringUtils.indexOf(\"aabaabaa\", \"ab\", 0) = 1\n     * StringUtils.indexOf(\"aabaabaa\", \"b\", 3)  = 5\n     * StringUtils.indexOf(\"aabaabaa\", \"b\", 9)  = -1\n     * StringUtils.indexOf(\"aabaabaa\", \"b\", -1) = 2\n     * StringUtils.indexOf(\"aabaabaa\", \"\", 2)   = 2\n     * StringUtils.indexOf(\"abc\", \"\", 9)        = 3\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @param startPos  the start position, negative treated as zero\n     * @return the first index of the search String,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.0\n     */\n    public static int indexOf(final String str, final String searchStr, final int startPos) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        // JDK1.2/JDK1.3 have a bug, when startPos > str.length for \"\", hence\n        if (searchStr.length() == 0 && startPos >= str.length()) {\n            return str.length();\n        }\n        return str.indexOf(searchStr, startPos);\n    }\n\n    /**\n     * <p>Case in-sensitive find of the first index within a String.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A negative start position is treated as zero.\n     * An empty (\"\") search String always matches.\n     * A start position greater than the string length only matches\n     * an empty search String.</p>\n     *\n     * <pre>\n     * StringUtils.indexOfIgnoreCase(null, *)          = -1\n     * StringUtils.indexOfIgnoreCase(*, null)          = -1\n     * StringUtils.indexOfIgnoreCase(\"\", \"\")           = 0\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"a\")  = 0\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"b\")  = 2\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"ab\") = 1\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @return the first index of the search String,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.5\n     */\n    public static int indexOfIgnoreCase(final String str, final String searchStr) {\n        return StringUtils.indexOfIgnoreCase(str, searchStr, 0);\n    }\n\n    /**\n     * <p>Case in-sensitive find of the first index within a String\n     * from the specified position.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A negative start position is treated as zero.\n     * An empty (\"\") search String always matches.\n     * A start position greater than the string length only matches\n     * an empty search String.</p>\n     *\n     * <pre>\n     * StringUtils.indexOfIgnoreCase(null, *, *)          = -1\n     * StringUtils.indexOfIgnoreCase(*, null, *)          = -1\n     * StringUtils.indexOfIgnoreCase(\"\", \"\", 0)           = 0\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"A\", 0)  = 0\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", 0)  = 2\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"AB\", 0) = 1\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", 3)  = 5\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", 9)  = -1\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", -1) = 2\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"\", 2)   = 2\n     * StringUtils.indexOfIgnoreCase(\"abc\", \"\", 9)        = 3\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @param startPos  the start position, negative treated as zero\n     * @return the first index of the search String,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.5\n     */\n    public static int indexOfIgnoreCase(final String str, final String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        if (startPos < 0) {\n            startPos = 0;\n        }\n        int endLimit = str.length() - searchStr.length() + 1;\n        if (startPos > endLimit) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return startPos;\n        }\n        for (int i = startPos; i < endLimit; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {\n                return i;\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n    // LastIndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the last index within a String, handling <code>null</code>.\n     * This method uses {@link String#lastIndexOf(int)}.</p>\n     *\n     * <p>A <code>null</code> or empty (\"\") String will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.lastIndexOf(null, *)         = -1\n     * StringUtils.lastIndexOf(\"\", *)           = -1\n     * StringUtils.lastIndexOf(\"aabaabaa\", 'a') = 7\n     * StringUtils.lastIndexOf(\"aabaabaa\", 'b') = 5\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChar  the character to find\n     * @return the last index of the search character,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.0\n     */\n    public static int lastIndexOf(final String str, final char searchChar) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchChar);\n    }\n\n    /**\n     * <p>Finds the last index within a String from a start position,\n     * handling <code>null</code>.\n     * This method uses {@link String#lastIndexOf(int, int)}.</p>\n     *\n     * <p>A <code>null</code> or empty (\"\") String will return <code>-1</code>.\n     * A negative start position returns <code>-1</code>.\n     * A start position greater than the string length searches the whole string.</p>\n     *\n     * <pre>\n     * StringUtils.lastIndexOf(null, *, *)          = -1\n     * StringUtils.lastIndexOf(\"\", *,  *)           = -1\n     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 8)  = 5\n     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 4)  = 2\n     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 0)  = -1\n     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 9)  = 5\n     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', -1) = -1\n     * StringUtils.lastIndexOf(\"aabaabaa\", 'a', 0)  = 0\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChar  the character to find\n     * @param startPos  the start position\n     * @return the last index of the search character,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.0\n     */\n    public static int lastIndexOf(final String str, final char searchChar, final int startPos) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchChar, startPos);\n    }\n\n    /**\n     * <p>Finds the last index within a String, handling <code>null</code>.\n     * This method uses {@link String#lastIndexOf(String)}.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.lastIndexOf(null, *)          = -1\n     * StringUtils.lastIndexOf(*, null)          = -1\n     * StringUtils.lastIndexOf(\"\", \"\")           = 0\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"a\")  = 7\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\")  = 5\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"ab\") = 4\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"\")   = 8\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @return the last index of the search String,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.0\n     */\n    public static int lastIndexOf(final String str, final String searchStr) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchStr);\n    }\n\n    /**\n     * <p>Finds the n-th last index within a String, handling <code>null</code>.\n     * This method uses {@link String#lastIndexOf(String)}.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.lastOrdinalIndexOf(null, *, *)          = -1\n     * StringUtils.lastOrdinalIndexOf(*, null, *)          = -1\n     * StringUtils.lastOrdinalIndexOf(\"\", \"\", *)           = 0\n     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"a\", 1)  = 7\n     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"a\", 2)  = 6\n     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"b\", 1)  = 5\n     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"b\", 2)  = 2\n     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"ab\", 1) = 4\n     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"ab\", 2) = 1\n     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"\", 1)   = 8\n     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"\", 2)   = 8\n     * </pre>\n     *\n     * <p>Note that 'tail(String str, int n)' may be implemented as: </p>\n     *\n     * <pre>\n     *   str.substring(lastOrdinalIndexOf(str, \"\\n\", n) + 1)\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @param ordinal  the n-th last <code>searchStr</code> to find\n     * @return the n-th last index of the search String,\n     *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input\n     * @since 2.5\n     */\n    public static int lastOrdinalIndexOf(final String str, final String searchStr, final int ordinal) {\n        return StringUtils.ordinalIndexOf(str, searchStr, ordinal, true);\n    }\n\n    /**\n     * <p>Finds the first index within a String, handling <code>null</code>.\n     * This method uses {@link String#lastIndexOf(String, int)}.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A negative start position returns <code>-1</code>.\n     * An empty (\"\") search String always matches unless the start position is negative.\n     * A start position greater than the string length searches the whole string.</p>\n     *\n     * <pre>\n     * StringUtils.lastIndexOf(null, *, *)          = -1\n     * StringUtils.lastIndexOf(*, null, *)          = -1\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 8)  = 7\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 8)  = 5\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"ab\", 8) = 4\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 9)  = 5\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", -1) = -1\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 0)  = 0\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 0)  = -1\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @param startPos  the start position, negative treated as zero\n     * @return the first index of the search String,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.0\n     */\n    public static int lastIndexOf(final String str, final String searchStr, final int startPos) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchStr, startPos);\n    }\n\n    /**\n     * <p>Case in-sensitive find of the last index within a String.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A negative start position returns <code>-1</code>.\n     * An empty (\"\") search String always matches unless the start position is negative.\n     * A start position greater than the string length searches the whole string.</p>\n     *\n     * <pre>\n     * StringUtils.lastIndexOfIgnoreCase(null, *)          = -1\n     * StringUtils.lastIndexOfIgnoreCase(*, null)          = -1\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"A\")  = 7\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\")  = 5\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"AB\") = 4\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @return the first index of the search String,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.5\n     */\n    public static int lastIndexOfIgnoreCase(final String str, final String searchStr) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return StringUtils.lastIndexOfIgnoreCase(str, searchStr, str.length());\n    }\n\n    /**\n     * <p>Case in-sensitive find of the last index within a String\n     * from the specified position.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A negative start position returns <code>-1</code>.\n     * An empty (\"\") search String always matches unless the start position is negative.\n     * A start position greater than the string length searches the whole string.</p>\n     *\n     * <pre>\n     * StringUtils.lastIndexOfIgnoreCase(null, *, *)          = -1\n     * StringUtils.lastIndexOfIgnoreCase(*, null, *)          = -1\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"A\", 8)  = 7\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", 8)  = 5\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"AB\", 8) = 4\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", 9)  = 5\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", -1) = -1\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"A\", 0)  = 0\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", 0)  = -1\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @param startPos  the start position\n     * @return the first index of the search String,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.5\n     */\n    public static int lastIndexOfIgnoreCase(final String str, final String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        if (startPos > str.length() - searchStr.length()) {\n            startPos = str.length() - searchStr.length();\n        }\n        if (startPos < 0) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return startPos;\n        }\n        for (int i = startPos; i >= 0; i--) {\n            if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {\n                return i;\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n    // Contains\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if String contains a search character, handling <code>null</code>.\n     * This method uses {@link String#indexOf(int)}.</p>\n     *\n     * <p>A <code>null</code> or empty (\"\") String will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.contains(null, *)    = false\n     * StringUtils.contains(\"\", *)      = false\n     * StringUtils.contains(\"abc\", 'a') = true\n     * StringUtils.contains(\"abc\", 'z') = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChar  the character to find\n     * @return true if the String contains the search character,\n     *  false if not or <code>null</code> string input\n     * @since 2.0\n     */\n    public static boolean contains(final String str, final char searchChar) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        return str.indexOf(searchChar) >= 0;\n    }\n\n    /**\n     * <p>Checks if String contains a search String, handling <code>null</code>.\n     * This method uses {@link String#indexOf(String)}.</p>\n     *\n     * <p>A <code>null</code> String will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.contains(null, *)     = false\n     * StringUtils.contains(*, null)     = false\n     * StringUtils.contains(\"\", \"\")      = true\n     * StringUtils.contains(\"abc\", \"\")   = true\n     * StringUtils.contains(\"abc\", \"a\")  = true\n     * StringUtils.contains(\"abc\", \"z\")  = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @return true if the String contains the search String,\n     *  false if not or <code>null</code> string input\n     * @since 2.0\n     */\n    public static boolean contains(final String str, final String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        return str.contains(searchStr);\n    }\n\n    /**\n     * <p>Checks if String contains a search String irrespective of case,\n     * handling <code>null</code>. Case-insensitivity is defined as by\n     * {@link String#equalsIgnoreCase(String)}.\n     *\n     * <p>A <code>null</code> String will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.contains(null, *) = false\n     * StringUtils.contains(*, null) = false\n     * StringUtils.contains(\"\", \"\") = true\n     * StringUtils.contains(\"abc\", \"\") = true\n     * StringUtils.contains(\"abc\", \"a\") = true\n     * StringUtils.contains(\"abc\", \"z\") = false\n     * StringUtils.contains(\"abc\", \"A\") = true\n     * StringUtils.contains(\"abc\", \"Z\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @return true if the String contains the search String irrespective of\n     * case or false if not or <code>null</code> string input\n     */\n    public static boolean containsIgnoreCase(final String str, final String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        int len = searchStr.length();\n        int max = str.length() - len;\n        for (int i = 0; i <= max; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // IndexOfAny chars\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Search a String to find the first index of any\n     * character in the given set of characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A <code>null</code> or zero length search array will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.indexOfAny(null, *)                = -1\n     * StringUtils.indexOfAny(\"\", *)                  = -1\n     * StringUtils.indexOfAny(*, null)                = -1\n     * StringUtils.indexOfAny(*, [])                  = -1\n     * StringUtils.indexOfAny(\"zzabyycdxx\",['z','a']) = 0\n     * StringUtils.indexOfAny(\"zzabyycdxx\",['b','y']) = 3\n     * StringUtils.indexOfAny(\"aba\", ['z'])           = -1\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChars  the chars to search for, may be null\n     * @return the index of any of the chars, -1 if no match or null input\n     * @since 2.0\n     */\n    public static int indexOfAny(final String str, final char[] searchChars) {\n        if (StringUtils.isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        int csLen = str.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        for (int i = 0; i < csLen; i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && CharUtils.isHighSurrogate(ch)) {\n                        // ch is a supplementary character\n                        if (searchChars[j + 1] == str.charAt(i + 1)) {\n                            return i;\n                        }\n                    } else {\n                        return i;\n                    }\n                }\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Search a String to find the first index of any\n     * character in the given set of characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A <code>null</code> search string will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.indexOfAny(null, *)            = -1\n     * StringUtils.indexOfAny(\"\", *)              = -1\n     * StringUtils.indexOfAny(*, null)            = -1\n     * StringUtils.indexOfAny(*, \"\")              = -1\n     * StringUtils.indexOfAny(\"zzabyycdxx\", \"za\") = 0\n     * StringUtils.indexOfAny(\"zzabyycdxx\", \"by\") = 3\n     * StringUtils.indexOfAny(\"aba\",\"z\")          = -1\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChars  the chars to search for, may be null\n     * @return the index of any of the chars, -1 if no match or null input\n     * @since 2.0\n     */\n    public static int indexOfAny(final String str, final String searchChars) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(searchChars)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return StringUtils.indexOfAny(str, searchChars.toCharArray());\n    }\n    // ContainsAny\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if the String contains any character in the given\n     * set of characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>false</code>.\n     * A <code>null</code> or zero length search array will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.containsAny(null, *)                = false\n     * StringUtils.containsAny(\"\", *)                  = false\n     * StringUtils.containsAny(*, null)                = false\n     * StringUtils.containsAny(*, [])                  = false\n     * StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true\n     * StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true\n     * StringUtils.containsAny(\"aba\", ['z'])           = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChars  the chars to search for, may be null\n     * @return the <code>true</code> if any of the chars are found,\n     * <code>false</code> if no match or null input\n     * @since 2.4\n     */\n    public static boolean containsAny(final String str, final char[] searchChars) {\n        if (StringUtils.isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n            return false;\n        }\n        int csLength = str.length();\n        int searchLength = searchChars.length;\n        int csLast = csLength - 1;\n        int searchLast = searchLength - 1;\n        for (int i = 0; i < csLength; i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchLength; j++) {\n                if (searchChars[j] == ch) {\n                    if (CharUtils.isHighSurrogate(ch)) {\n                        if (j == searchLast) {\n                            // missing low surrogate, fine, like String.indexOf(String)\n                            return true;\n                        }\n                        if (i < csLast && searchChars[j + 1] == str.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        // ch is in the Basic Multilingual Plane\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * <p>\n     * Checks if the String contains any character in the given set of characters.\n     * </p>\n     *\n     * <p>\n     * A <code>null</code> String will return <code>false</code>. A <code>null</code> search string will return\n     * <code>false</code>.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.containsAny(null, *)            = false\n     * StringUtils.containsAny(\"\", *)              = false\n     * StringUtils.containsAny(*, null)            = false\n     * StringUtils.containsAny(*, \"\")              = false\n     * StringUtils.containsAny(\"zzabyycdxx\", \"za\") = true\n     * StringUtils.containsAny(\"zzabyycdxx\", \"by\") = true\n     * StringUtils.containsAny(\"aba\",\"z\")          = false\n     * </pre>\n     *\n     * @param str\n     *            the String to check, may be null\n     * @param searchChars\n     *            the chars to search for, may be null\n     * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n     * @since 2.4\n     */\n    public static boolean containsAny(final String str, final String searchChars) {\n        if (searchChars == null) {\n            return false;\n        }\n        return StringUtils.containsAny(str, searchChars.toCharArray());\n    }\n    // IndexOfAnyBut chars\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Search a String to find the first index of any\n     * character not in the given set of characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A <code>null</code> or zero length search array will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.indexOfAnyBut(null, *)                              = -1\n     * StringUtils.indexOfAnyBut(\"\", *)                                = -1\n     * StringUtils.indexOfAnyBut(*, null)                              = -1\n     * StringUtils.indexOfAnyBut(*, [])                                = -1\n     * StringUtils.indexOfAnyBut(\"zzabyycdxx\", new char[] {'z', 'a'} ) = 3\n     * StringUtils.indexOfAnyBut(\"aba\", new char[] {'z'} )             = 0\n     * StringUtils.indexOfAnyBut(\"aba\", new char[] {'a', 'b'} )        = -1\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChars  the chars to search for, may be null\n     * @return the index of any of the chars, -1 if no match or null input\n     * @since 2.0\n     */\n    public static int indexOfAnyBut(final String str, final char[] searchChars) {\n        if (StringUtils.isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        int csLen = str.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        outer:\n        for (int i = 0; i < csLen; i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && CharUtils.isHighSurrogate(ch)) {\n                        if (searchChars[j + 1] == str.charAt(i + 1)) {\n                            continue outer;\n                        }\n                    } else {\n                        continue outer;\n                    }\n                }\n            }\n            return i;\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Search a String to find the first index of any\n     * character not in the given set of characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A <code>null</code> or empty search string will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.indexOfAnyBut(null, *)            = -1\n     * StringUtils.indexOfAnyBut(\"\", *)              = -1\n     * StringUtils.indexOfAnyBut(*, null)            = -1\n     * StringUtils.indexOfAnyBut(*, \"\")              = -1\n     * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"za\") = 3\n     * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"\")   = -1\n     * StringUtils.indexOfAnyBut(\"aba\",\"ab\")         = -1\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChars  the chars to search for, may be null\n     * @return the index of any of the chars, -1 if no match or null input\n     * @since 2.0\n     */\n    public static int indexOfAnyBut(final String str, final String searchChars) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(searchChars)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            char ch = str.charAt(i);\n            boolean chFound = searchChars.indexOf(ch) >= 0;\n            if (i + 1 < strLen && CharUtils.isHighSurrogate(ch)) {\n                char ch2 = str.charAt(i + 1);\n                if (chFound && searchChars.indexOf(ch2) < 0) {\n                    return i;\n                }\n            } else {\n                if (!chFound) {\n                    return i;\n                }\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n    // ContainsOnly\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if the String contains only certain characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>false</code>.\n     * A <code>null</code> valid character array will return <code>false</code>.\n     * An empty String (length()=0) always returns <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.containsOnly(null, *)       = false\n     * StringUtils.containsOnly(*, null)       = false\n     * StringUtils.containsOnly(\"\", *)         = true\n     * StringUtils.containsOnly(\"ab\", '')      = false\n     * StringUtils.containsOnly(\"abab\", 'abc') = true\n     * StringUtils.containsOnly(\"ab1\", 'abc')  = false\n     * StringUtils.containsOnly(\"abz\", 'abc')  = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param valid  an array of valid chars, may be null\n     * @return true if it only contains valid chars and is non-null\n     */\n    public static boolean containsOnly(final String str, final char[] valid) {\n        // All these pre-checks are to maintain API with an older version\n        if (valid == null || str == null) {\n            return false;\n        }\n        if (str.length() == 0) {\n            return true;\n        }\n        if (valid.length == 0) {\n            return false;\n        }\n        return StringUtils.indexOfAnyBut(str, valid) == StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the String contains only certain characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>false</code>.\n     * A <code>null</code> valid character String will return <code>false</code>.\n     * An empty String (length()=0) always returns <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.containsOnly(null, *)       = false\n     * StringUtils.containsOnly(*, null)       = false\n     * StringUtils.containsOnly(\"\", *)         = true\n     * StringUtils.containsOnly(\"ab\", \"\")      = false\n     * StringUtils.containsOnly(\"abab\", \"abc\") = true\n     * StringUtils.containsOnly(\"ab1\", \"abc\")  = false\n     * StringUtils.containsOnly(\"abz\", \"abc\")  = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param validChars  a String of valid chars, may be null\n     * @return true if it only contains valid chars and is non-null\n     * @since 2.0\n     */\n    public static boolean containsOnly(final String str, final String validChars) {\n        if (str == null || validChars == null) {\n            return false;\n        }\n        return StringUtils.containsOnly(str, validChars.toCharArray());\n    }\n    // ContainsNone\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks that the String does not contain certain characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>true</code>.\n     * A <code>null</code> invalid character array will return <code>true</code>.\n     * An empty String (length()=0) always returns true.</p>\n     *\n     * <pre>\n     * StringUtils.containsNone(null, *)       = true\n     * StringUtils.containsNone(*, null)       = true\n     * StringUtils.containsNone(\"\", *)         = true\n     * StringUtils.containsNone(\"ab\", '')      = true\n     * StringUtils.containsNone(\"abab\", 'xyz') = true\n     * StringUtils.containsNone(\"ab1\", 'xyz')  = true\n     * StringUtils.containsNone(\"abz\", 'xyz')  = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChars  an array of invalid chars, may be null\n     * @return true if it contains none of the invalid chars, or is null\n     * @since 2.0\n     */\n    public static boolean containsNone(final String str, final char[] searchChars) {\n        if (str == null || searchChars == null) {\n            return true;\n        }\n        int csLen = str.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        for (int i = 0; i < csLen; i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (CharUtils.isHighSurrogate(ch)) {\n                        if (j == searchLast) {\n                            // missing low surrogate, fine, like String.indexOf(String)\n                            return false;\n                        }\n                        if (i < csLast && searchChars[j + 1] == str.charAt(i + 1)) {\n                            return false;\n                        }\n                    } else {\n                        // ch is in the Basic Multilingual Plane\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks that the String does not contain certain characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>true</code>.\n     * A <code>null</code> invalid character array will return <code>true</code>.\n     * An empty String (\"\") always returns true.</p>\n     *\n     * <pre>\n     * StringUtils.containsNone(null, *)       = true\n     * StringUtils.containsNone(*, null)       = true\n     * StringUtils.containsNone(\"\", *)         = true\n     * StringUtils.containsNone(\"ab\", \"\")      = true\n     * StringUtils.containsNone(\"abab\", \"xyz\") = true\n     * StringUtils.containsNone(\"ab1\", \"xyz\")  = true\n     * StringUtils.containsNone(\"abz\", \"xyz\")  = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param invalidChars  a String of invalid chars, may be null\n     * @return true if it contains none of the invalid chars, or is null\n     * @since 2.0\n     */\n    public static boolean containsNone(final String str, final String invalidChars) {\n        if (str == null || invalidChars == null) {\n            return true;\n        }\n        return StringUtils.containsNone(str, invalidChars.toCharArray());\n    }\n    // IndexOfAny strings\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Find the first index of any of a set of potential substrings.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A <code>null</code> or zero length search array will return <code>-1</code>.\n     * A <code>null</code> search array entry will be ignored, but a search\n     * array containing \"\" will return <code>0</code> if <code>str</code> is not\n     * null. This method uses {@link String#indexOf(String)}.</p>\n     *\n     * <pre>\n     * StringUtils.indexOfAny(null, *)                     = -1\n     * StringUtils.indexOfAny(*, null)                     = -1\n     * StringUtils.indexOfAny(*, [])                       = -1\n     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"ab\",\"cd\"])   = 2\n     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"cd\",\"ab\"])   = 2\n     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"])   = -1\n     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"zab\",\"aby\"]) = 1\n     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"\"])          = 0\n     * StringUtils.indexOfAny(\"\", [\"\"])                    = 0\n     * StringUtils.indexOfAny(\"\", [\"a\"])                   = -1\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStrs  the Strings to search for, may be null\n     * @return the first index of any of the searchStrs in str, -1 if no match\n     */\n    public static int indexOfAny(final String str, final String[] searchStrs) {\n        if (str == null || searchStrs == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        int sz = searchStrs.length;\n        // String's can't have a MAX_VALUEth index.\n        int ret = Integer.MAX_VALUE;\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            String search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = str.indexOf(search);\n            if (tmp == StringUtils.INDEX_NOT_FOUND) {\n                continue;\n            }\n            if (tmp < ret) {\n                ret = tmp;\n            }\n        }\n        return ret == Integer.MAX_VALUE ? StringUtils.INDEX_NOT_FOUND : ret;\n    }\n\n    /**\n     * <p>Find the latest index of any of a set of potential substrings.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A <code>null</code> search array will return <code>-1</code>.\n     * A <code>null</code> or zero length search array entry will be ignored,\n     * but a search array containing \"\" will return the length of <code>str</code>\n     * if <code>str</code> is not null. This method uses {@link String#indexOf(String)}</p>\n     *\n     * <pre>\n     * StringUtils.lastIndexOfAny(null, *)                   = -1\n     * StringUtils.lastIndexOfAny(*, null)                   = -1\n     * StringUtils.lastIndexOfAny(*, [])                     = -1\n     * StringUtils.lastIndexOfAny(*, [null])                 = -1\n     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"ab\",\"cd\"]) = 6\n     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"cd\",\"ab\"]) = 6\n     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"]) = -1\n     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"]) = -1\n     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"\"])   = 10\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStrs  the Strings to search for, may be null\n     * @return the last index of any of the Strings, -1 if no match\n     */\n    public static int lastIndexOfAny(final String str, final String[] searchStrs) {\n        if (str == null || searchStrs == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        int sz = searchStrs.length;\n        int ret = StringUtils.INDEX_NOT_FOUND;\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            String search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = str.lastIndexOf(search);\n            if (tmp > ret) {\n                ret = tmp;\n            }\n        }\n        return ret;\n    }\n    // Substring\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Gets a substring from the specified String avoiding exceptions.</p>\n     *\n     * <p>A negative start position can be used to start <code>n</code>\n     * characters from the end of the String.</p>\n     *\n     * <p>A <code>null</code> String will return <code>null</code>.\n     * An empty (\"\") String will return \"\".</p>\n     *\n     * <pre>\n     * StringUtils.substring(null, *)   = null\n     * StringUtils.substring(\"\", *)     = \"\"\n     * StringUtils.substring(\"abc\", 0)  = \"abc\"\n     * StringUtils.substring(\"abc\", 2)  = \"c\"\n     * StringUtils.substring(\"abc\", 4)  = \"\"\n     * StringUtils.substring(\"abc\", -2) = \"bc\"\n     * StringUtils.substring(\"abc\", -4) = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to get the substring from, may be null\n     * @param start  the position to start from, negative means\n     *  count back from the end of the String by this many characters\n     * @return substring from start position, <code>null</code> if null String input\n     */\n    public static String substring(final String str, int start) {\n        if (str == null) {\n            return null;\n        }\n        // handle negatives, which means last n characters\n        if (start < 0) {\n            start = str.length() + start; // remember start is negative\n        }\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > str.length()) {\n            return StringUtils.EMPTY;\n        }\n        return str.substring(start);\n    }\n\n    /**\n     * <p>Gets a substring from the specified String avoiding exceptions.</p>\n     *\n     * <p>A negative start position can be used to start/end <code>n</code>\n     * characters from the end of the String.</p>\n     *\n     * <p>The returned substring starts with the character in the <code>start</code>\n     * position and ends before the <code>end</code> position. All position counting is\n     * zero-based -- i.e., to start at the beginning of the string use\n     * <code>start = 0</code>. Negative start and end positions can be used to\n     * specify offsets relative to the end of the String.</p>\n     *\n     * <p>If <code>start</code> is not strictly to the left of <code>end</code>, \"\"\n     * is returned.</p>\n     *\n     * <pre>\n     * StringUtils.substring(null, *, *)    = null\n     * StringUtils.substring(\"\", * ,  *)    = \"\";\n     * StringUtils.substring(\"abc\", 0, 2)   = \"ab\"\n     * StringUtils.substring(\"abc\", 2, 0)   = \"\"\n     * StringUtils.substring(\"abc\", 2, 4)   = \"c\"\n     * StringUtils.substring(\"abc\", 4, 6)   = \"\"\n     * StringUtils.substring(\"abc\", 2, 2)   = \"\"\n     * StringUtils.substring(\"abc\", -2, -1) = \"b\"\n     * StringUtils.substring(\"abc\", -4, 2)  = \"ab\"\n     * </pre>\n     *\n     * @param str  the String to get the substring from, may be null\n     * @param start  the position to start from, negative means\n     *  count back from the end of the String by this many characters\n     * @param end  the position to end at (exclusive), negative means\n     *  count back from the end of the String by this many characters\n     * @return substring from start position to end positon,\n     *  <code>null</code> if null String input\n     */\n    public static String substring(final String str, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n        // handle negatives\n        if (end < 0) {\n            end = str.length() + end; // remember end is negative\n        }\n        if (start < 0) {\n            start = str.length() + start; // remember start is negative\n        }\n        // check length next\n        if (end > str.length()) {\n            end = str.length();\n        }\n        // if start is greater than end, return \"\"\n        if (start > end) {\n            return StringUtils.EMPTY;\n        }\n        if (start < 0) {\n            start = 0;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n        return str.substring(start, end);\n    }\n    // Left/Right/Mid\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Gets the leftmost <code>len</code> characters of a String.</p>\n     *\n     * <p>If <code>len</code> characters are not available, or the\n     * String is <code>null</code>, the String will be returned without\n     * an exception. An empty String is returned if len is negative.</p>\n     *\n     * <pre>\n     * StringUtils.left(null, *)    = null\n     * StringUtils.left(*, -ve)     = \"\"\n     * StringUtils.left(\"\", *)      = \"\"\n     * StringUtils.left(\"abc\", 0)   = \"\"\n     * StringUtils.left(\"abc\", 2)   = \"ab\"\n     * StringUtils.left(\"abc\", 4)   = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to get the leftmost characters from, may be null\n     * @param len  the length of the required String\n     * @return the leftmost characters, <code>null</code> if null String input\n     */\n    public static String left(final String str, final int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return StringUtils.EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n\n    /**\n     * <p>Gets the rightmost <code>len</code> characters of a String.</p>\n     *\n     * <p>If <code>len</code> characters are not available, or the String\n     * is <code>null</code>, the String will be returned without an\n     * an exception. An empty String is returned if len is negative.</p>\n     *\n     * <pre>\n     * StringUtils.right(null, *)    = null\n     * StringUtils.right(*, -ve)     = \"\"\n     * StringUtils.right(\"\", *)      = \"\"\n     * StringUtils.right(\"abc\", 0)   = \"\"\n     * StringUtils.right(\"abc\", 2)   = \"bc\"\n     * StringUtils.right(\"abc\", 4)   = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to get the rightmost characters from, may be null\n     * @param len  the length of the required String\n     * @return the rightmost characters, <code>null</code> if null String input\n     */\n    public static String right(final String str, final int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return StringUtils.EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(str.length() - len);\n    }\n\n    /**\n     * <p>Gets <code>len</code> characters from the middle of a String.</p>\n     *\n     * <p>If <code>len</code> characters are not available, the remainder\n     * of the String will be returned without an exception. If the\n     * String is <code>null</code>, <code>null</code> will be returned.\n     * An empty String is returned if len is negative or exceeds the\n     * length of <code>str</code>.</p>\n     *\n     * <pre>\n     * StringUtils.mid(null, *, *)    = null\n     * StringUtils.mid(*, *, -ve)     = \"\"\n     * StringUtils.mid(\"\", 0, *)      = \"\"\n     * StringUtils.mid(\"abc\", 0, 2)   = \"ab\"\n     * StringUtils.mid(\"abc\", 0, 4)   = \"abc\"\n     * StringUtils.mid(\"abc\", 2, 4)   = \"c\"\n     * StringUtils.mid(\"abc\", 4, 2)   = \"\"\n     * StringUtils.mid(\"abc\", -2, 2)  = \"ab\"\n     * </pre>\n     *\n     * @param str  the String to get the characters from, may be null\n     * @param pos  the position to start from, negative treated as zero\n     * @param len  the length of the required String\n     * @return the middle characters, <code>null</code> if null String input\n     */\n    public static String mid(final String str, int pos, final int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0 || pos > str.length()) {\n            return StringUtils.EMPTY;\n        }\n        if (pos < 0) {\n            pos = 0;\n        }\n        if (str.length() <= pos + len) {\n            return str.substring(pos);\n        }\n        return str.substring(pos, pos + len);\n    }\n    // SubStringAfter/SubStringBefore\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Gets the substring before the first occurrence of a separator.\n     * The separator is not returned.</p>\n     *\n     * <p>A <code>null</code> string input will return <code>null</code>.\n     * An empty (\"\") string input will return the empty string.\n     * A <code>null</code> separator will return the input string.</p>\n     *\n     * <p>If nothing is found, the string input is returned.</p>\n     *\n     * <pre>\n     * StringUtils.substringBefore(null, *)      = null\n     * StringUtils.substringBefore(\"\", *)        = \"\"\n     * StringUtils.substringBefore(\"abc\", \"a\")   = \"\"\n     * StringUtils.substringBefore(\"abcba\", \"b\") = \"a\"\n     * StringUtils.substringBefore(\"abc\", \"c\")   = \"ab\"\n     * StringUtils.substringBefore(\"abc\", \"d\")   = \"abc\"\n     * StringUtils.substringBefore(\"abc\", \"\")    = \"\"\n     * StringUtils.substringBefore(\"abc\", null)  = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to get a substring from, may be null\n     * @param separator  the String to search for, may be null\n     * @return the substring before the first occurrence of the separator,\n     *  <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String substringBefore(final String str, final String separator) {\n        if (StringUtils.isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (separator.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == StringUtils.INDEX_NOT_FOUND) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }\n\n    /**\n     * <p>Gets the substring after the first occurrence of a separator.\n     * The separator is not returned.</p>\n     *\n     * <p>A <code>null</code> string input will return <code>null</code>.\n     * An empty (\"\") string input will return the empty string.\n     * A <code>null</code> separator will return the empty string if the\n     * input string is not <code>null</code>.</p>\n     *\n     * <p>If nothing is found, the empty string is returned.</p>\n     *\n     * <pre>\n     * StringUtils.substringAfter(null, *)      = null\n     * StringUtils.substringAfter(\"\", *)        = \"\"\n     * StringUtils.substringAfter(*, null)      = \"\"\n     * StringUtils.substringAfter(\"abc\", \"a\")   = \"bc\"\n     * StringUtils.substringAfter(\"abcba\", \"b\") = \"cba\"\n     * StringUtils.substringAfter(\"abc\", \"c\")   = \"\"\n     * StringUtils.substringAfter(\"abc\", \"d\")   = \"\"\n     * StringUtils.substringAfter(\"abc\", \"\")    = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to get a substring from, may be null\n     * @param separator  the String to search for, may be null\n     * @return the substring after the first occurrence of the separator,\n     *  <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String substringAfter(final String str, final String separator) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        if (separator == null) {\n            return StringUtils.EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == StringUtils.INDEX_NOT_FOUND) {\n            return StringUtils.EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }\n\n    /**\n     * <p>Gets the substring before the last occurrence of a separator.\n     * The separator is not returned.</p>\n     *\n     * <p>A <code>null</code> string input will return <code>null</code>.\n     * An empty (\"\") string input will return the empty string.\n     * An empty or <code>null</code> separator will return the input string.</p>\n     *\n     * <p>If nothing is found, the string input is returned.</p>\n     *\n     * <pre>\n     * StringUtils.substringBeforeLast(null, *)      = null\n     * StringUtils.substringBeforeLast(\"\", *)        = \"\"\n     * StringUtils.substringBeforeLast(\"abcba\", \"b\") = \"abc\"\n     * StringUtils.substringBeforeLast(\"abc\", \"c\")   = \"ab\"\n     * StringUtils.substringBeforeLast(\"a\", \"a\")     = \"\"\n     * StringUtils.substringBeforeLast(\"a\", \"z\")     = \"a\"\n     * StringUtils.substringBeforeLast(\"a\", null)    = \"a\"\n     * StringUtils.substringBeforeLast(\"a\", \"\")      = \"a\"\n     * </pre>\n     *\n     * @param str  the String to get a substring from, may be null\n     * @param separator  the String to search for, may be null\n     * @return the substring before the last occurrence of the separator,\n     *  <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String substringBeforeLast(final String str, final String separator) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(separator)) {\n            return str;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == StringUtils.INDEX_NOT_FOUND) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }\n\n    /**\n     * <p>Gets the substring after the last occurrence of a separator.\n     * The separator is not returned.</p>\n     *\n     * <p>A <code>null</code> string input will return <code>null</code>.\n     * An empty (\"\") string input will return the empty string.\n     * An empty or <code>null</code> separator will return the empty string if\n     * the input string is not <code>null</code>.</p>\n     *\n     * <p>If nothing is found, the empty string is returned.</p>\n     *\n     * <pre>\n     * StringUtils.substringAfterLast(null, *)      = null\n     * StringUtils.substringAfterLast(\"\", *)        = \"\"\n     * StringUtils.substringAfterLast(*, \"\")        = \"\"\n     * StringUtils.substringAfterLast(*, null)      = \"\"\n     * StringUtils.substringAfterLast(\"abc\", \"a\")   = \"bc\"\n     * StringUtils.substringAfterLast(\"abcba\", \"b\") = \"a\"\n     * StringUtils.substringAfterLast(\"abc\", \"c\")   = \"\"\n     * StringUtils.substringAfterLast(\"a\", \"a\")     = \"\"\n     * StringUtils.substringAfterLast(\"a\", \"z\")     = \"\"\n     * </pre>\n     *\n     * @param str  the String to get a substring from, may be null\n     * @param separator  the String to search for, may be null\n     * @return the substring after the last occurrence of the separator,\n     *  <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String substringAfterLast(final String str, final String separator) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        if (StringUtils.isEmpty(separator)) {\n            return StringUtils.EMPTY;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == StringUtils.INDEX_NOT_FOUND || pos == str.length() - separator.length()) {\n            return StringUtils.EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }\n    // Substring between\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Gets the String that is nested in between two instances of the\n     * same String.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> tag returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.substringBetween(null, *)            = null\n     * StringUtils.substringBetween(\"\", \"\")             = \"\"\n     * StringUtils.substringBetween(\"\", \"tag\")          = null\n     * StringUtils.substringBetween(\"tagabctag\", null)  = null\n     * StringUtils.substringBetween(\"tagabctag\", \"\")    = \"\"\n     * StringUtils.substringBetween(\"tagabctag\", \"tag\") = \"abc\"\n     * </pre>\n     *\n     * @param str  the String containing the substring, may be null\n     * @param tag  the String before and after the substring, may be null\n     * @return the substring, <code>null</code> if no match\n     * @since 2.0\n     */\n    public static String substringBetween(final String str, final String tag) {\n        return StringUtils.substringBetween(str, tag, tag);\n    }\n\n    /**\n     * <p>Gets the String that is nested in between two Strings.\n     * Only the first match is returned.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> open/close returns <code>null</code> (no match).\n     * An empty (\"\") open and close returns an empty string.</p>\n     *\n     * <pre>\n     * StringUtils.substringBetween(\"wx[b]yz\", \"[\", \"]\") = \"b\"\n     * StringUtils.substringBetween(null, *, *)          = null\n     * StringUtils.substringBetween(*, null, *)          = null\n     * StringUtils.substringBetween(*, *, null)          = null\n     * StringUtils.substringBetween(\"\", \"\", \"\")          = \"\"\n     * StringUtils.substringBetween(\"\", \"\", \"]\")         = null\n     * StringUtils.substringBetween(\"\", \"[\", \"]\")        = null\n     * StringUtils.substringBetween(\"yabcz\", \"\", \"\")     = \"\"\n     * StringUtils.substringBetween(\"yabcz\", \"y\", \"z\")   = \"abc\"\n     * StringUtils.substringBetween(\"yabczyabcz\", \"y\", \"z\")   = \"abc\"\n     * </pre>\n     *\n     * @param str  the String containing the substring, may be null\n     * @param open  the String before the substring, may be null\n     * @param close  the String after the substring, may be null\n     * @return the substring, <code>null</code> if no match\n     * @since 2.0\n     */\n    public static String substringBetween(final String str, final String open, final String close) {\n        if (str == null || open == null || close == null) {\n            return null;\n        }\n        int start = str.indexOf(open);\n        if (start != StringUtils.INDEX_NOT_FOUND) {\n            int end = str.indexOf(close, start + open.length());\n            if (end != StringUtils.INDEX_NOT_FOUND) {\n                return str.substring(start + open.length(), end);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * <p>Searches a String for substrings delimited by a start and end tag,\n     * returning all matching substrings in an array.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> open/close returns <code>null</code> (no match).\n     * An empty (\"\") open/close returns <code>null</code> (no match).</p>\n     *\n     * <pre>\n     * StringUtils.substringsBetween(\"[a][b][c]\", \"[\", \"]\") = [\"a\",\"b\",\"c\"]\n     * StringUtils.substringsBetween(null, *, *)            = null\n     * StringUtils.substringsBetween(*, null, *)            = null\n     * StringUtils.substringsBetween(*, *, null)            = null\n     * StringUtils.substringsBetween(\"\", \"[\", \"]\")          = []\n     * </pre>\n     *\n     * @param str  the String containing the substrings, null returns null, empty returns empty\n     * @param open  the String identifying the start of the substring, empty returns null\n     * @param close  the String identifying the end of the substring, empty returns null\n     * @return a String Array of substrings, or <code>null</code> if no match\n     * @since 2.3\n     */\n    public static String[] substringsBetween(final String str, final String open, final String close) {\n        if (str == null || StringUtils.isEmpty(open) || StringUtils.isEmpty(close)) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        int closeLen = close.length();\n        int openLen = open.length();\n        List<String> list = new ArrayList<String>();\n        int pos = 0;\n        while (pos < strLen - closeLen) {\n            int start = str.indexOf(open, pos);\n            if (start < 0) {\n                break;\n            }\n            start += openLen;\n            int end = str.indexOf(close, start);\n            if (end < 0) {\n                break;\n            }\n            list.add(str.substring(start, end));\n            pos = end + closeLen;\n        }\n        if (list.isEmpty()) {\n            return null;\n        }\n        return list.toArray(new String[list.size()]);\n    }\n    // Splitting\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Splits the provided text into an array, using whitespace as the separator. but keep separator.</p>\n     *\n     * <pre>\n     * StringUtils.splitKeep(null)          = null\n     * StringUtils.splitKeep(\"\")            = []\n     * StringUtils.splitKeep(\"a b c\", \" \")  = [\"a\", \" \", \"b\", \" \", \"c\"]\n     * StringUtils.splitKeep(\"abc def\", \" \")= [\"abc\", \" \", \"def\"]\n     * StringUtils.splitKeep(\" abc \", \" \")  = [\" \", \"abc\", \" \"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    public static String[] splitKeep(String str, char separatorChar) {\n        return splitKeep(str, String.valueOf(separatorChar));\n    }\n\n    /**\n     * <p>Splits the provided text into an array, using whitespace as the separator. but keep separator.</p>\n     *\n     * <pre>\n     * StringUtils.splitKeep(null)          = null\n     * StringUtils.splitKeep(\"\")            = []\n     * StringUtils.splitKeep(\"a b c\", \" \")  = [\"a\", \" \", \"b\", \" \", \"c\"]\n     * StringUtils.splitKeep(\"abc def\", \" \")= [\"abc\", \" \", \"def\"]\n     * StringUtils.splitKeep(\" abc \", \" \")  = [\" \", \"abc\", \" \"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    public static String[] splitKeep(String str, String separatorStr) {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        int CHARS = separatorStr.length();\n        if (CHARS == 0) {\n            throw new IllegalArgumentException(\"chars must be > 0\");\n        }\n        int lastIndex = 0;\n        ArrayList<String> dat = new ArrayList<>();\n        while (true) {\n            int lookIndex = str.indexOf(separatorStr, lastIndex);\n            if (lookIndex == -1) {\n                String substring = str.substring(lastIndex);\n                if (substring.length() > 0) {\n                    dat.add(substring);\n                }\n                break;\n            } else {\n                if (lastIndex != lookIndex) {\n                    String term = str.substring(lastIndex, lookIndex);\n                    dat.add(term);\n                }\n                dat.add(separatorStr);\n                lastIndex = lookIndex + CHARS;\n            }\n        }\n        return dat.toArray(new String[0]);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, using whitespace as the\n     * separator.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as one separator.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.split(null)       = null\n     * StringUtils.split(\"\")         = []\n     * StringUtils.split(\"abc def\")  = [\"abc\", \"def\"]\n     * StringUtils.split(\"abc  def\") = [\"abc\", \"def\"]\n     * StringUtils.split(\" abc \")    = [\"abc\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    public static String[] split(final String str) {\n        return StringUtils.split(str, null, -1);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, separator specified.\n     * This is an alternative to using StringTokenizer.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as one separator.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.split(null, *)         = null\n     * StringUtils.split(\"\", *)           = []\n     * StringUtils.split(\"a.b.c\", '.')    = [\"a\", \"b\", \"c\"]\n     * StringUtils.split(\"a..b.c\", '.')   = [\"a\", \"b\", \"c\"]\n     * StringUtils.split(\"a:b:c\", '.')    = [\"a:b:c\"]\n     * StringUtils.split(\"a b c\", ' ')    = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separatorChar  the character used as the delimiter\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String[] split(final String str, final char separatorChar) {\n        return StringUtils.splitWorker(str, separatorChar, false);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, separators specified.\n     * This is an alternative to using StringTokenizer.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as one separator.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separatorChars splits on whitespace.</p>\n     *\n     * <pre>\n     * StringUtils.split(null, *)         = null\n     * StringUtils.split(\"\", *)           = []\n     * StringUtils.split(\"abc def\", null) = [\"abc\", \"def\"]\n     * StringUtils.split(\"abc def\", \" \")  = [\"abc\", \"def\"]\n     * StringUtils.split(\"abc  def\", \" \") = [\"abc\", \"def\"]\n     * StringUtils.split(\"ab:cd:ef\", \":\") = [\"ab\", \"cd\", \"ef\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separatorChars  the characters used as the delimiters,\n     *  <code>null</code> splits on whitespace\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    public static String[] split(final String str, final String separatorChars) {\n        return StringUtils.splitWorker(str, separatorChars, -1, false);\n    }\n\n    /**\n     * <p>Splits the provided text into an array with a maximum length,\n     * separators specified.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as one separator.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separatorChars splits on whitespace.</p>\n     *\n     * <p>If more than <code>max</code> delimited substrings are found, the last\n     * returned string includes all characters after the first <code>max - 1</code>\n     * returned strings (including separator characters).</p>\n     *\n     * <pre>\n     * StringUtils.split(null, *, *)            = null\n     * StringUtils.split(\"\", *, *)              = []\n     * StringUtils.split(\"ab de fg\", null, 0)   = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.split(\"ab   de fg\", null, 0) = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.split(\"ab:cd:ef\", \":\", 0)    = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.split(\"ab:cd:ef\", \":\", 2)    = [\"ab\", \"cd:ef\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separatorChars  the characters used as the delimiters,\n     *  <code>null</code> splits on whitespace\n     * @param max  the maximum number of elements to include in the\n     *  array. A zero or negative value implies no limit\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    public static String[] split(final String str, final String separatorChars, final int max) {\n        return StringUtils.splitWorker(str, separatorChars, max, false);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, separator string specified.</p>\n     *\n     * <p>The separator(s) will not be included in the returned String array.\n     * Adjacent separators are treated as one separator.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separator splits on whitespace.</p>\n     *\n     * <pre>\n     * StringUtils.splitByWholeSeparator(null, *)               = null\n     * StringUtils.splitByWholeSeparator(\"\", *)                 = []\n     * StringUtils.splitByWholeSeparator(\"ab de fg\", null)      = [\"ab\", \"de\", \"fg\"]\n     * StringUtils.splitByWholeSeparator(\"ab   de fg\", null)    = [\"ab\", \"de\", \"fg\"]\n     * StringUtils.splitByWholeSeparator(\"ab:cd:ef\", \":\")       = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\") = [\"ab\", \"cd\", \"ef\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separator  String containing the String to be used as a delimiter,\n     *  <code>null</code> splits on whitespace\n     * @return an array of parsed Strings, <code>null</code> if null String was input\n     */\n    public static String[] splitByWholeSeparator(final String str, final String separator) {\n        return StringUtils.splitByWholeSeparatorWorker(str, separator, -1, false);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, separator string specified.\n     * Returns a maximum of <code>max</code> substrings.</p>\n     *\n     * <p>The separator(s) will not be included in the returned String array.\n     * Adjacent separators are treated as one separator.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separator splits on whitespace.</p>\n     *\n     * <pre>\n     * StringUtils.splitByWholeSeparator(null, *, *)               = null\n     * StringUtils.splitByWholeSeparator(\"\", *, *)                 = []\n     * StringUtils.splitByWholeSeparator(\"ab de fg\", null, 0)      = [\"ab\", \"de\", \"fg\"]\n     * StringUtils.splitByWholeSeparator(\"ab   de fg\", null, 0)    = [\"ab\", \"de\", \"fg\"]\n     * StringUtils.splitByWholeSeparator(\"ab:cd:ef\", \":\", 2)       = [\"ab\", \"cd:ef\"]\n     * StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\", 5) = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\", 2) = [\"ab\", \"cd-!-ef\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separator  String containing the String to be used as a delimiter,\n     *  <code>null</code> splits on whitespace\n     * @param max  the maximum number of elements to include in the returned\n     *  array. A zero or negative value implies no limit.\n     * @return an array of parsed Strings, <code>null</code> if null String was input\n     */\n    public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {\n        return StringUtils.splitByWholeSeparatorWorker(str, separator, max, false);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, separator string specified. </p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as separators for empty tokens.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separator splits on whitespace.</p>\n     *\n     * <pre>\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *)               = null\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"\", *)                 = []\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab de fg\", null)      = [\"ab\", \"de\", \"fg\"]\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab   de fg\", null)    = [\"ab\", \"\", \"\", \"de\", \"fg\"]\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab:cd:ef\", \":\")       = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\") = [\"ab\", \"cd\", \"ef\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separator  String containing the String to be used as a delimiter,\n     *  <code>null</code> splits on whitespace\n     * @return an array of parsed Strings, <code>null</code> if null String was input\n     * @since 2.4\n     */\n    public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator) {\n        return StringUtils.splitByWholeSeparatorWorker(str, separator, -1, true);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, separator string specified.\n     * Returns a maximum of <code>max</code> substrings.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as separators for empty tokens.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separator splits on whitespace.</p>\n     *\n     * <pre>\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *, *)               = null\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"\", *, *)                 = []\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab de fg\", null, 0)      = [\"ab\", \"de\", \"fg\"]\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab   de fg\", null, 0)    = [\"ab\", \"\", \"\", \"de\", \"fg\"]\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab:cd:ef\", \":\", 2)       = [\"ab\", \"cd:ef\"]\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\", 5) = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\", 2) = [\"ab\", \"cd-!-ef\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separator  String containing the String to be used as a delimiter,\n     *  <code>null</code> splits on whitespace\n     * @param max  the maximum number of elements to include in the returned\n     *  array. A zero or negative value implies no limit.\n     * @return an array of parsed Strings, <code>null</code> if null String was input\n     * @since 2.4\n     */\n    public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {\n        return StringUtils.splitByWholeSeparatorWorker(str, separator, max, true);\n    }\n\n    /**\n     * Performs the logic for the <code>splitByWholeSeparatorPreserveAllTokens</code> methods.\n     *\n     * @param str  the String to parse, may be <code>null</code>\n     * @param separator  String containing the String to be used as a delimiter,\n     *  <code>null</code> splits on whitespace\n     * @param max  the maximum number of elements to include in the returned\n     *  array. A zero or negative value implies no limit.\n     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n     * treated as empty token separators; if <code>false</code>, adjacent\n     * separators are treated as one separator.\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.4\n     */\n    private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        if (separator == null || StringUtils.EMPTY.equals(separator)) {\n            // Split on whitespace.\n            return StringUtils.splitWorker(str, null, max, preserveAllTokens);\n        }\n        int separatorLength = separator.length();\n        ArrayList<String> substrings = new ArrayList<>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(StringUtils.EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n        return substrings.toArray(new String[0]);\n    }\n    // -----------------------------------------------------------------------\n\n    /**\n     * <p>Splits the provided text into an array, using whitespace as the\n     * separator, preserving all tokens, including empty tokens created by\n     * adjacent separators. This is an alternative to using StringTokenizer.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as separators for empty tokens.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.splitPreserveAllTokens(null)       = null\n     * StringUtils.splitPreserveAllTokens(\"\")         = []\n     * StringUtils.splitPreserveAllTokens(\"abc def\")  = [\"abc\", \"def\"]\n     * StringUtils.splitPreserveAllTokens(\"abc  def\") = [\"abc\", \"\", \"def\"]\n     * StringUtils.splitPreserveAllTokens(\" abc \")    = [\"\", \"abc\", \"\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be <code>null</code>\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String[] splitPreserveAllTokens(final String str) {\n        return StringUtils.splitWorker(str, null, -1, true);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, separator specified,\n     * preserving all tokens, including empty tokens created by adjacent\n     * separators. This is an alternative to using StringTokenizer.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as separators for empty tokens.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.splitPreserveAllTokens(null, *)         = null\n     * StringUtils.splitPreserveAllTokens(\"\", *)           = []\n     * StringUtils.splitPreserveAllTokens(\"a.b.c\", '.')    = [\"a\", \"b\", \"c\"]\n     * StringUtils.splitPreserveAllTokens(\"a..b.c\", '.')   = [\"a\", \"\", \"b\", \"c\"]\n     * StringUtils.splitPreserveAllTokens(\"a:b:c\", '.')    = [\"a:b:c\"]\n     * StringUtils.splitPreserveAllTokens(\"a\\tb\\nc\", null) = [\"a\", \"b\", \"c\"]\n     * StringUtils.splitPreserveAllTokens(\"a b c\", ' ')    = [\"a\", \"b\", \"c\"]\n     * StringUtils.splitPreserveAllTokens(\"a b c \", ' ')   = [\"a\", \"b\", \"c\", \"\"]\n     * StringUtils.splitPreserveAllTokens(\"a b c  \", ' ')   = [\"a\", \"b\", \"c\", \"\", \"\"]\n     * StringUtils.splitPreserveAllTokens(\" a b c\", ' ')   = [\"\", a\", \"b\", \"c\"]\n     * StringUtils.splitPreserveAllTokens(\"  a b c\", ' ')  = [\"\", \"\", a\", \"b\", \"c\"]\n     * StringUtils.splitPreserveAllTokens(\" a b c \", ' ')  = [\"\", a\", \"b\", \"c\", \"\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be <code>null</code>\n     * @param separatorChar  the character used as the delimiter,\n     *  <code>null</code> splits on whitespace\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String[] splitPreserveAllTokens(final String str, final char separatorChar) {\n        return StringUtils.splitWorker(str, separatorChar, true);\n    }\n\n    /**\n     * Performs the logic for the <code>split</code> and\n     * <code>splitPreserveAllTokens</code> methods that do not return a\n     * maximum array length.\n     *\n     * @param str  the String to parse, may be <code>null</code>\n     * @param separatorChar the separate character\n     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n     * treated as empty token separators; if <code>false</code>, adjacent\n     * separators are treated as one separator.\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<>();\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        while (i < len) {\n            if (str.charAt(i) == separatorChar) {\n                if (match || preserveAllTokens) {\n                    list.add(str.substring(start, i));\n                    match = false;\n                    lastMatch = true;\n                }\n                start = ++i;\n                continue;\n            }\n            lastMatch = false;\n            match = true;\n            i++;\n        }\n        if (match || preserveAllTokens && lastMatch) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[0]);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, separators specified,\n     * preserving all tokens, including empty tokens created by adjacent\n     * separators. This is an alternative to using StringTokenizer.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as separators for empty tokens.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separatorChars splits on whitespace.</p>\n     *\n     * <pre>\n     * StringUtils.splitPreserveAllTokens(null, *)           = null\n     * StringUtils.splitPreserveAllTokens(\"\", *)             = []\n     * StringUtils.splitPreserveAllTokens(\"abc def\", null)   = [\"abc\", \"def\"]\n     * StringUtils.splitPreserveAllTokens(\"abc def\", \" \")    = [\"abc\", \"def\"]\n     * StringUtils.splitPreserveAllTokens(\"abc  def\", \" \")   = [\"abc\", \"\", def\"]\n     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\")   = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef:\", \":\")  = [\"ab\", \"cd\", \"ef\", \"\"]\n     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef::\", \":\") = [\"ab\", \"cd\", \"ef\", \"\", \"\"]\n     * StringUtils.splitPreserveAllTokens(\"ab::cd:ef\", \":\")  = [\"ab\", \"\", cd\", \"ef\"]\n     * StringUtils.splitPreserveAllTokens(\":cd:ef\", \":\")     = [\"\", cd\", \"ef\"]\n     * StringUtils.splitPreserveAllTokens(\"::cd:ef\", \":\")    = [\"\", \"\", cd\", \"ef\"]\n     * StringUtils.splitPreserveAllTokens(\":cd:ef:\", \":\")    = [\"\", cd\", \"ef\", \"\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be <code>null</code>\n     * @param separatorChars  the characters used as the delimiters,\n     *  <code>null</code> splits on whitespace\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String[] splitPreserveAllTokens(final String str, final String separatorChars) {\n        return StringUtils.splitWorker(str, separatorChars, -1, true);\n    }\n\n    /**\n     * <p>Splits the provided text into an array with a maximum length,\n     * separators specified, preserving all tokens, including empty tokens\n     * created by adjacent separators.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as separators for empty tokens.\n     * Adjacent separators are treated as one separator.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separatorChars splits on whitespace.</p>\n     *\n     * <p>If more than <code>max</code> delimited substrings are found, the last\n     * returned string includes all characters after the first <code>max - 1</code>\n     * returned strings (including separator characters).</p>\n     *\n     * <pre>\n     * StringUtils.splitPreserveAllTokens(null, *, *)            = null\n     * StringUtils.splitPreserveAllTokens(\"\", *, *)              = []\n     * StringUtils.splitPreserveAllTokens(\"ab de fg\", null, 0)   = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 0) = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 0)    = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 2)    = [\"ab\", \"cd:ef\"]\n     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 2) = [\"ab\", \"  de fg\"]\n     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 3) = [\"ab\", \"\", \" de fg\"]\n     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 4) = [\"ab\", \"\", \"\", \"de fg\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be <code>null</code>\n     * @param separatorChars  the characters used as the delimiters,\n     *  <code>null</code> splits on whitespace\n     * @param max  the maximum number of elements to include in the\n     *  array. A zero or negative value implies no limit\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {\n        return StringUtils.splitWorker(str, separatorChars, max, true);\n    }\n\n    /**\n     * Performs the logic for the <code>split</code> and\n     * <code>splitPreserveAllTokens</code> methods that return a maximum array\n     * length.\n     *\n     * @param str  the String to parse, may be <code>null</code>\n     * @param separatorChars the separate character\n     * @param max  the maximum number of elements to include in the\n     *  array. A zero or negative value implies no limit.\n     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n     * treated as empty token separators; if <code>false</code>, adjacent\n     * separators are treated as one separator.\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n        // Direct code is quicker than StringTokenizer.\n        // Also, StringTokenizer uses isSpace() not isWhitespace()\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<>();\n        int sizePlus1 = 1;\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        if (separatorChars == null) {\n            // Null separator means use whitespace\n            while (i < len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else if (separatorChars.length() == 1) {\n            // Optimise 1 character case\n            char sep = separatorChars.charAt(0);\n            while (i < len) {\n                if (str.charAt(i) == sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            // standard case\n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || preserveAllTokens && lastMatch) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[0]);\n    }\n\n    /**\n     * <p>Splits a String by Character type as returned by\n     * <code>java.lang.Character.getType(char)</code>. Groups of contiguous\n     * characters of the same type are returned as complete tokens.\n     * <pre>\n     * StringUtils.splitByCharacterType(null)         = null\n     * StringUtils.splitByCharacterType(\"\")           = []\n     * StringUtils.splitByCharacterType(\"ab de fg\")   = [\"ab\", \" \", \"de\", \" \", \"fg\"]\n     * StringUtils.splitByCharacterType(\"ab   de fg\") = [\"ab\", \"   \", \"de\", \" \", \"fg\"]\n     * StringUtils.splitByCharacterType(\"ab:cd:ef\")   = [\"ab\", \":\", \"cd\", \":\", \"ef\"]\n     * StringUtils.splitByCharacterType(\"number5\")    = [\"number\", \"5\"]\n     * StringUtils.splitByCharacterType(\"fooBar\")     = [\"foo\", \"B\", \"ar\"]\n     * StringUtils.splitByCharacterType(\"foo200Bar\")  = [\"foo\", \"200\", \"B\", \"ar\"]\n     * StringUtils.splitByCharacterType(\"ASFRules\")   = [\"ASFR\", \"ules\"]\n     * </pre>\n     * @param str the String to split, may be <code>null</code>\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.4\n     */\n    public static String[] splitByCharacterType(final String str) {\n        return StringUtils.splitByCharacterType(str, false);\n    }\n\n    /**\n     * <p>Splits a String by Character type as returned by\n     * <code>java.lang.Character.getType(char)</code>. Groups of contiguous\n     * characters of the same type are returned as complete tokens, with the\n     * following exception: the character of type\n     * <code>Character.UPPERCASE_LETTER</code>, if any, immediately\n     * preceding a token of type <code>Character.LOWERCASE_LETTER</code>\n     * will belong to the following token rather than to the preceding, if any,\n     * <code>Character.UPPERCASE_LETTER</code> token.\n     * <pre>\n     * StringUtils.splitByCharacterTypeCamelCase(null)         = null\n     * StringUtils.splitByCharacterTypeCamelCase(\"\")           = []\n     * StringUtils.splitByCharacterTypeCamelCase(\"ab de fg\")   = [\"ab\", \" \", \"de\", \" \", \"fg\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"ab   de fg\") = [\"ab\", \"   \", \"de\", \" \", \"fg\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"ab:cd:ef\")   = [\"ab\", \":\", \"cd\", \":\", \"ef\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"number5\")    = [\"number\", \"5\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"fooBar\")     = [\"foo\", \"Bar\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"foo200Bar\")  = [\"foo\", \"200\", \"Bar\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"ASFRules\")   = [\"ASF\", \"Rules\"]\n     * </pre>\n     * @param str the String to split, may be <code>null</code>\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.4\n     */\n    public static String[] splitByCharacterTypeCamelCase(final String str) {\n        return StringUtils.splitByCharacterType(str, true);\n    }\n\n    /**\n     * <p>Splits a String by Character type as returned by\n     * <code>java.lang.Character.getType(char)</code>. Groups of contiguous\n     * characters of the same type are returned as complete tokens, with the\n     * following exception: if <code>camelCase</code> is <code>true</code>,\n     * the character of type <code>Character.UPPERCASE_LETTER</code>, if any,\n     * immediately preceding a token of type <code>Character.LOWERCASE_LETTER</code>\n     * will belong to the following token rather than to the preceding, if any,\n     * <code>Character.UPPERCASE_LETTER</code> token.\n     * @param str the String to split, may be <code>null</code>\n     * @param camelCase whether to use so-called \"camel-case\" for letter types\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.4\n     */\n    private static String[] splitByCharacterType(final String str, final boolean camelCase) {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        char[] c = str.toCharArray();\n        List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(c[tokenStart]);\n        for (int pos = tokenStart + 1; pos < c.length; pos++) {\n            int type = Character.getType(c[pos]);\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(c, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(new String(c, tokenStart, c.length - tokenStart));\n        return list.toArray(new String[0]);\n    }\n    // Joining\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Joins the elements of the provided array into a single String\n     * containing the provided list of elements.</p>\n     *\n     * <p>No separator is added to the joined String.\n     * Null objects or empty strings within the array are represented by\n     * empty strings.</p>\n     *\n     * <pre>\n     * StringUtils.join(null)            = null\n     * StringUtils.join([])              = \"\"\n     * StringUtils.join([null])          = \"\"\n     * StringUtils.join([\"a\", \"b\", \"c\"]) = \"abc\"\n     * StringUtils.join([null, \"\", \"a\"]) = \"a\"\n     * </pre>\n     *\n     * @param array  the array of values to join together, may be null\n     * @return the joined String, <code>null</code> if null array input\n     * @since 2.0\n     */\n    public static String join(final Object[] array) {\n        return StringUtils.join(array, null);\n    }\n\n    /**\n     * <p>Joins the elements of the provided array into a single String\n     * containing the provided list of elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * Null objects or empty strings within the array are represented by\n     * empty strings.</p>\n     *\n     * <pre>\n     * StringUtils.join(null, *)               = null\n     * StringUtils.join([], *)                 = \"\"\n     * StringUtils.join([null], *)             = \"\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], ';')  = \"a;b;c\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"\n     * StringUtils.join([null, \"\", \"a\"], ';')  = \";;a\"\n     * </pre>\n     *\n     * @param array  the array of values to join together, may be null\n     * @param separator  the separator character to use\n     * @return the joined String, <code>null</code> if null array input\n     * @since 2.0\n     */\n    public static String join(final Object[] array, final char separator) {\n        if (array == null) {\n            return null;\n        }\n        return StringUtils.join(array, separator, 0, array.length);\n    }\n\n    /**\n     * <p>Joins the elements of the provided array into a single String\n     * containing the provided list of elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * Null objects or empty strings within the array are represented by\n     * empty strings.</p>\n     *\n     * <pre>\n     * StringUtils.join(null, *)               = null\n     * StringUtils.join([], *)                 = \"\"\n     * StringUtils.join([null], *)             = \"\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], ';')  = \"a;b;c\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"\n     * StringUtils.join([null, \"\", \"a\"], ';')  = \";;a\"\n     * </pre>\n     *\n     * @param array  the array of values to join together, may be null\n     * @param separator  the separator character to use\n     * @param startIndex the first index to start joining from.  It is\n     * an error to pass in an end index past the end of the array\n     * @param endIndex the index to stop joining from (exclusive). It is\n     * an error to pass in an end index past the end of the array\n     * @return the joined String, <code>null</code> if null array input\n     * @since 2.0\n     */\n    public static String join(final Object[] array, final char separator, final int startIndex, final int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        int bufSize = endIndex - startIndex;\n        if (bufSize <= 0) {\n            return StringUtils.EMPTY;\n        }\n        bufSize *= (array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1;\n        StringBuilder buf = new StringBuilder(bufSize);\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * <p>Joins the elements of the provided array into a single String\n     * containing the provided list of elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * A <code>null</code> separator is the same as an empty String (\"\").\n     * Null objects or empty strings within the array are represented by\n     * empty strings.</p>\n     *\n     * <pre>\n     * StringUtils.join(null, *)                = null\n     * StringUtils.join([], *)                  = \"\"\n     * StringUtils.join([null], *)              = \"\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], \"--\")  = \"a--b--c\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], null)  = \"abc\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], \"\")    = \"abc\"\n     * StringUtils.join([null, \"\", \"a\"], ',')   = \",,a\"\n     * </pre>\n     *\n     * @param array  the array of values to join together, may be null\n     * @param separator  the separator character to use, null treated as \"\"\n     * @return the joined String, <code>null</code> if null array input\n     */\n    public static String join(final Object[] array, final String separator) {\n        if (array == null) {\n            return null;\n        }\n        return StringUtils.join(array, separator, 0, array.length);\n    }\n\n    /**\n     * <p>Joins the elements of the provided array into a single String\n     * containing the provided list of elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * A <code>null</code> separator is the same as an empty String (\"\").\n     * Null objects or empty strings within the array are represented by\n     * empty strings.</p>\n     *\n     * <pre>\n     * StringUtils.join(null, *)                = null\n     * StringUtils.join([], *)                  = \"\"\n     * StringUtils.join([null], *)              = \"\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], \"--\")  = \"a--b--c\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], null)  = \"abc\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], \"\")    = \"abc\"\n     * StringUtils.join([null, \"\", \"a\"], ',')   = \",,a\"\n     * </pre>\n     *\n     * @param array  the array of values to join together, may be null\n     * @param separator  the separator character to use, null treated as \"\"\n     * @param startIndex the first index to start joining from.  It is\n     * an error to pass in an end index past the end of the array\n     * @param endIndex the index to stop joining from (exclusive). It is\n     * an error to pass in an end index past the end of the array\n     * @return the joined String, <code>null</code> if null array input\n     */\n    public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        if (separator == null) {\n            separator = StringUtils.EMPTY;\n        }\n        // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))\n        //           (Assuming that all Strings are roughly equally long)\n        int bufSize = endIndex - startIndex;\n        if (bufSize <= 0) {\n            return StringUtils.EMPTY;\n        }\n        bufSize *= (array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length();\n        StringBuilder buf = new StringBuilder(bufSize);\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n    // Delete\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Deletes all whitespaces from a String as defined by\n     * {@link Character#isWhitespace(char)}.</p>\n     *\n     * <pre>\n     * StringUtils.deleteWhitespace(null)         = null\n     * StringUtils.deleteWhitespace(\"\")           = \"\"\n     * StringUtils.deleteWhitespace(\"abc\")        = \"abc\"\n     * StringUtils.deleteWhitespace(\"   ab  c  \") = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to delete whitespace from, may be null\n     * @return the String without whitespaces, <code>null</code> if null String input\n     */\n    public static String deleteWhitespace(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        int sz = str.length();\n        char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }\n    // Remove\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Removes a substring only if it is at the begining of a source string,\n     * otherwise returns the source string.</p>\n     *\n     * <p>A <code>null</code> source string will return <code>null</code>.\n     * An empty (\"\") source string will return the empty string.\n     * A <code>null</code> search string will return the source string.</p>\n     *\n     * <pre>\n     * StringUtils.removeStart(null, *)      = null\n     * StringUtils.removeStart(\"\", *)        = \"\"\n     * StringUtils.removeStart(*, null)      = *\n     * StringUtils.removeStart(\"www.domain.com\", \"www.\")   = \"domain.com\"\n     * StringUtils.removeStart(\"domain.com\", \"www.\")       = \"domain.com\"\n     * StringUtils.removeStart(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n     * StringUtils.removeStart(\"abc\", \"\")    = \"abc\"\n     * </pre>\n     *\n     * @param str  the source String to search, may be null\n     * @param remove  the String to search for and remove, may be null\n     * @return the substring with the string removed if found,\n     *  <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String removeStart(final String str, final String remove) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(remove)) {\n            return str;\n        }\n        if (str.startsWith(remove)) {\n            return str.substring(remove.length());\n        }\n        return str;\n    }\n\n    /**\n     * <p>Case insensitive removal of a substring if it is at the begining of a source string,\n     * otherwise returns the source string.</p>\n     *\n     * <p>A <code>null</code> source string will return <code>null</code>.\n     * An empty (\"\") source string will return the empty string.\n     * A <code>null</code> search string will return the source string.</p>\n     *\n     * <pre>\n     * StringUtils.removeStartIgnoreCase(null, *)      = null\n     * StringUtils.removeStartIgnoreCase(\"\", *)        = \"\"\n     * StringUtils.removeStartIgnoreCase(*, null)      = *\n     * StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"www.\")   = \"domain.com\"\n     * StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"WWW.\")   = \"domain.com\"\n     * StringUtils.removeStartIgnoreCase(\"domain.com\", \"www.\")       = \"domain.com\"\n     * StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n     * StringUtils.removeStartIgnoreCase(\"abc\", \"\")    = \"abc\"\n     * </pre>\n     *\n     * @param str  the source String to search, may be null\n     * @param remove  the String to search for (case insensitive) and remove, may be null\n     * @return the substring with the string removed if found,\n     *  <code>null</code> if null String input\n     * @since 2.4\n     */\n    public static String removeStartIgnoreCase(final String str, final String remove) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(remove)) {\n            return str;\n        }\n        if (StringUtils.startsWithIgnoreCase(str, remove)) {\n            return str.substring(remove.length());\n        }\n        return str;\n    }\n\n    /**\n     * <p>Removes a substring only if it is at the end of a source string,\n     * otherwise returns the source string.</p>\n     *\n     * <p>A <code>null</code> source string will return <code>null</code>.\n     * An empty (\"\") source string will return the empty string.\n     * A <code>null</code> search string will return the source string.</p>\n     *\n     * <pre>\n     * StringUtils.removeEnd(null, *)      = null\n     * StringUtils.removeEnd(\"\", *)        = \"\"\n     * StringUtils.removeEnd(*, null)      = *\n     * StringUtils.removeEnd(\"www.domain.com\", \".com.\")  = \"www.domain.com\"\n     * StringUtils.removeEnd(\"www.domain.com\", \".com\")   = \"www.domain\"\n     * StringUtils.removeEnd(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n     * StringUtils.removeEnd(\"abc\", \"\")    = \"abc\"\n     * </pre>\n     *\n     * @param str  the source String to search, may be null\n     * @param remove  the String to search for and remove, may be null\n     * @return the substring with the string removed if found,\n     *  <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String removeEnd(final String str, final String remove) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(remove)) {\n            return str;\n        }\n        if (str.endsWith(remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    /**\n     * <p>Case insensitive removal of a substring if it is at the end of a source string,\n     * otherwise returns the source string.</p>\n     *\n     * <p>A <code>null</code> source string will return <code>null</code>.\n     * An empty (\"\") source string will return the empty string.\n     * A <code>null</code> search string will return the source string.</p>\n     *\n     * <pre>\n     * StringUtils.removeEndIgnoreCase(null, *)      = null\n     * StringUtils.removeEndIgnoreCase(\"\", *)        = \"\"\n     * StringUtils.removeEndIgnoreCase(*, null)      = *\n     * StringUtils.removeEndIgnoreCase(\"www.domain.com\", \".com.\")  = \"www.domain.com\"\n     * StringUtils.removeEndIgnoreCase(\"www.domain.com\", \".com\")   = \"www.domain\"\n     * StringUtils.removeEndIgnoreCase(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n     * StringUtils.removeEndIgnoreCase(\"abc\", \"\")    = \"abc\"\n     * StringUtils.removeEndIgnoreCase(\"www.domain.com\", \".COM\") = \"www.domain\")\n     * StringUtils.removeEndIgnoreCase(\"www.domain.COM\", \".com\") = \"www.domain\")\n     * </pre>\n     *\n     * @param str  the source String to search, may be null\n     * @param remove  the String to search for (case insensitive) and remove, may be null\n     * @return the substring with the string removed if found,\n     *  <code>null</code> if null String input\n     * @since 2.4\n     */\n    public static String removeEndIgnoreCase(final String str, final String remove) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(remove)) {\n            return str;\n        }\n        if (StringUtils.endsWithIgnoreCase(str, remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    /**\n     * <p>Removes all occurrences of a substring from within the source string.</p>\n     *\n     * <p>A <code>null</code> source string will return <code>null</code>.\n     * An empty (\"\") source string will return the empty string.\n     * A <code>null</code> remove string will return the source string.\n     * An empty (\"\") remove string will return the source string.</p>\n     *\n     * <pre>\n     * StringUtils.remove(null, *)        = null\n     * StringUtils.remove(\"\", *)          = \"\"\n     * StringUtils.remove(*, null)        = *\n     * StringUtils.remove(*, \"\")          = *\n     * StringUtils.remove(\"queued\", \"ue\") = \"qd\"\n     * StringUtils.remove(\"queued\", \"zz\") = \"queued\"\n     * </pre>\n     *\n     * @param str  the source String to search, may be null\n     * @param remove  the String to search for and remove, may be null\n     * @return the substring with the string removed if found,\n     *  <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String remove(final String str, final String remove) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(remove)) {\n            return str;\n        }\n        return StringUtils.replace(str, remove, StringUtils.EMPTY, -1);\n    }\n\n    /**\n     * <p>Removes all occurrences of a character from within the source string.</p>\n     *\n     * <p>A <code>null</code> source string will return <code>null</code>.\n     * An empty (\"\") source string will return the empty string.</p>\n     *\n     * <pre>\n     * StringUtils.remove(null, *)       = null\n     * StringUtils.remove(\"\", *)         = \"\"\n     * StringUtils.remove(\"queued\", 'u') = \"qeed\"\n     * StringUtils.remove(\"queued\", 'z') = \"queued\"\n     * </pre>\n     *\n     * @param str  the source String to search, may be null\n     * @param remove  the char to search for and remove, may be null\n     * @return the substring with the char removed if found,\n     *  <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String remove(final String str, final char remove) {\n        if (StringUtils.isEmpty(str) || str.indexOf(remove) == StringUtils.INDEX_NOT_FOUND) {\n            return str;\n        }\n        char[] chars = str.toCharArray();\n        int pos = 0;\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] != remove) {\n                chars[pos++] = chars[i];\n            }\n        }\n        return new String(chars, 0, pos);\n    }\n    // Replacing\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Replaces a String with another String inside a larger String, once.</p>\n     *\n     * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n     *\n     * <pre>\n     * StringUtils.replaceOnce(null, *, *)        = null\n     * StringUtils.replaceOnce(\"\", *, *)          = \"\"\n     * StringUtils.replaceOnce(\"any\", null, *)    = \"any\"\n     * StringUtils.replaceOnce(\"any\", *, null)    = \"any\"\n     * StringUtils.replaceOnce(\"any\", \"\", *)      = \"any\"\n     * StringUtils.replaceOnce(\"aba\", \"a\", null)  = \"aba\"\n     * StringUtils.replaceOnce(\"aba\", \"a\", \"\")    = \"ba\"\n     * StringUtils.replaceOnce(\"aba\", \"a\", \"z\")   = \"zba\"\n     * </pre>\n     *\n     * @see #replace(String text, String searchString, String replacement, int max)\n     * @param text  text to search and replace in, may be null\n     * @param searchString  the String to search for, may be null\n     * @param replacement  the String to replace with, may be null\n     * @return the text with any replacements processed,\n     *  <code>null</code> if null String input\n     */\n    public static String replaceOnce(final String text, final String searchString, final String replacement) {\n        return StringUtils.replace(text, searchString, replacement, 1);\n    }\n\n    /**\n     * <p>Replaces all occurrences of a String within another String.</p>\n     *\n     * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n     *\n     * <pre>\n     * StringUtils.replace(null, *, *)        = null\n     * StringUtils.replace(\"\", *, *)          = \"\"\n     * StringUtils.replace(\"any\", null, *)    = \"any\"\n     * StringUtils.replace(\"any\", *, null)    = \"any\"\n     * StringUtils.replace(\"any\", \"\", *)      = \"any\"\n     * StringUtils.replace(\"aba\", \"a\", null)  = \"aba\"\n     * StringUtils.replace(\"aba\", \"a\", \"\")    = \"b\"\n     * StringUtils.replace(\"aba\", \"a\", \"z\")   = \"zbz\"\n     * </pre>\n     *\n     * @see #replace(String text, String searchString, String replacement, int max)\n     * @param text  text to search and replace in, may be null\n     * @param searchString  the String to search for, may be null\n     * @param replacement  the String to replace it with, may be null\n     * @return the text with any replacements processed,\n     *  <code>null</code> if null String input\n     */\n    public static String replace(final String text, final String searchString, final String replacement) {\n        return StringUtils.replace(text, searchString, replacement, -1);\n    }\n\n    /**\n     * <p>Replaces a String with another String inside a larger String,\n     * for the first <code>max</code> values of the search String.</p>\n     *\n     * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n     *\n     * <pre>\n     * StringUtils.replace(null, *, *, *)         = null\n     * StringUtils.replace(\"\", *, *, *)           = \"\"\n     * StringUtils.replace(\"any\", null, *, *)     = \"any\"\n     * StringUtils.replace(\"any\", *, null, *)     = \"any\"\n     * StringUtils.replace(\"any\", \"\", *, *)       = \"any\"\n     * StringUtils.replace(\"any\", *, *, 0)        = \"any\"\n     * StringUtils.replace(\"abaa\", \"a\", null, -1) = \"abaa\"\n     * StringUtils.replace(\"abaa\", \"a\", \"\", -1)   = \"b\"\n     * StringUtils.replace(\"abaa\", \"a\", \"z\", 0)   = \"abaa\"\n     * StringUtils.replace(\"abaa\", \"a\", \"z\", 1)   = \"zbaa\"\n     * StringUtils.replace(\"abaa\", \"a\", \"z\", 2)   = \"zbza\"\n     * StringUtils.replace(\"abaa\", \"a\", \"z\", -1)  = \"zbzz\"\n     * </pre>\n     *\n     * @param text  text to search and replace in, may be null\n     * @param searchString  the String to search for, may be null\n     * @param replacement  the String to replace it with, may be null\n     * @param max  maximum number of values to replace, or <code>-1</code> if no maximum\n     * @return the text with any replacements processed,\n     *  <code>null</code> if null String input\n     */\n    public static String replace(final String text, final String searchString, final String replacement, int max) {\n        if (StringUtils.isEmpty(text) || StringUtils.isEmpty(searchString) || replacement == null || max == 0) {\n            return text;\n        }\n        int start = 0;\n        int end = text.indexOf(searchString, start);\n        if (end == StringUtils.INDEX_NOT_FOUND) {\n            return text;\n        }\n        int replLength = searchString.length();\n        int increase = replacement.length() - replLength;\n        increase = Math.max(increase, 0);\n        increase *= max < 0 ? 16 : Math.min(max, 64);\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n        while (end != StringUtils.INDEX_NOT_FOUND) {\n            buf.append(text.substring(start, end)).append(replacement);\n            start = end + replLength;\n            if (--max == 0) {\n                break;\n            }\n            end = text.indexOf(searchString, start);\n        }\n        buf.append(text.substring(start));\n        return buf.toString();\n    }\n\n    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     *\n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. This will not repeat. For repeating replaces, call the\n     * overloaded method.\n     * </p>\n     *\n     * <pre>\n     *  StringUtils.replaceEach(null, *, *)        = null\n     *  StringUtils.replaceEach(\"\", *, *)          = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0]) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null)  = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"})  = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"})  = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"})  = \"wcte\"\n     *  (example of how it does not repeat)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"})  = \"dcte\"\n     * </pre>\n     *\n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) {\n        return StringUtils.replaceEach(text, searchList, replacementList, false, 0);\n    }\n\n    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     *\n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. This will not repeat. For repeating replaces, call the\n     * overloaded method.\n     * </p>\n     *\n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n     *  (example of how it repeats)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, true) = IllegalArgumentException\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, false) = \"dcabe\"\n     * </pre>\n     *\n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IllegalArgumentException\n     *             if the search is repeating and there is an endless loop due\n     *             to outputs of one being inputs to another\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {\n        // timeToLive should be 0 if not used or nothing to replace, else it's\n        // the length of the replace array\n        int timeToLive = searchList == null ? 0 : searchList.length;\n        return StringUtils.replaceEach(text, searchList, replacementList, true, timeToLive);\n    }\n\n    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     *\n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored.\n     * </p>\n     *\n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n     *  (example of how it repeats)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n     * </pre>\n     *\n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @param repeat if true, then replace repeatedly\n     *       until there are no more possible replacements or timeToLive < 0\n     * @param timeToLive\n     *            if less than 0 then there is a circular reference and endless\n     *            loop\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IllegalArgumentException\n     *             if the search is repeating and there is an endless loop due\n     *             to outputs of one being inputs to another\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n        if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n            return text;\n        }\n        // if recursing, this shouldnt be less than 0\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n        // make sure lengths are ok, these need to be equal\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n        }\n        // keep track of which still have matches\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n        // index on index that the match was found\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n        // index of replace array that will replace the search string found\n        // NOTE: logic duplicated below START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic mostly below END\n        // no search strings found, we are done\n        if (textIndex == -1) {\n            return text;\n        }\n        int start = 0;\n        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n        int increase = 0;\n        // count the replacement text elements that are larger than their corresponding text being replaced\n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; // assume 3 matches\n            }\n        }\n        // have upper-bound at 20% increase, then let Java take over\n        increase = Math.min(increase, text.length() / 5);\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n        while (textIndex != -1) {\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n            start = textIndex + searchList[replaceIndex].length();\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            // find the next earliest match\n            // NOTE: logic mostly duplicated above START\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n                // see if we need to keep searching for this\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            // NOTE: logic duplicated above END\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n        return StringUtils.replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n    // Replace, character based\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Replaces all occurrences of a character in a String with another.\n     * This is a null-safe version of {@link String#replace(char, char)}.</p>\n     *\n     * <p>A <code>null</code> string input returns <code>null</code>.\n     * An empty (\"\") string input returns an empty string.</p>\n     *\n     * <pre>\n     * StringUtils.replaceChars(null, *, *)        = null\n     * StringUtils.replaceChars(\"\", *, *)          = \"\"\n     * StringUtils.replaceChars(\"abcba\", 'b', 'y') = \"aycya\"\n     * StringUtils.replaceChars(\"abcba\", 'z', 'y') = \"abcba\"\n     * </pre>\n     *\n     * @param str  String to replace characters in, may be null\n     * @param searchChar  the character to search for, may be null\n     * @param replaceChar  the character to replace, may be null\n     * @return modified String, <code>null</code> if null string input\n     * @since 2.0\n     */\n    public static String replaceChars(final String str, final char searchChar, final char replaceChar) {\n        if (str == null) {\n            return null;\n        }\n        return str.replace(searchChar, replaceChar);\n    }\n\n    /**\n     * <p>Replaces multiple characters in a String in one go.\n     * This method can also be used to delete characters.</p>\n     *\n     * <p>For example:<br />\n     * <code>replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly</code>.</p>\n     *\n     * <p>A <code>null</code> string input returns <code>null</code>.\n     * An empty (\"\") string input returns an empty string.\n     * A null or empty set of search characters returns the input string.</p>\n     *\n     * <p>The length of the search characters should normally equal the length\n     * of the replace characters.\n     * If the search characters is longer, then the extra search characters\n     * are deleted.\n     * If the search characters is shorter, then the extra replace characters\n     * are ignored.</p>\n     *\n     * <pre>\n     * StringUtils.replaceChars(null, *, *)           = null\n     * StringUtils.replaceChars(\"\", *, *)             = \"\"\n     * StringUtils.replaceChars(\"abc\", null, *)       = \"abc\"\n     * StringUtils.replaceChars(\"abc\", \"\", *)         = \"abc\"\n     * StringUtils.replaceChars(\"abc\", \"b\", null)     = \"ac\"\n     * StringUtils.replaceChars(\"abc\", \"b\", \"\")       = \"ac\"\n     * StringUtils.replaceChars(\"abcba\", \"bc\", \"yz\")  = \"ayzya\"\n     * StringUtils.replaceChars(\"abcba\", \"bc\", \"y\")   = \"ayya\"\n     * StringUtils.replaceChars(\"abcba\", \"bc\", \"yzx\") = \"ayzya\"\n     * </pre>\n     *\n     * @param str  String to replace characters in, may be null\n     * @param searchChars  a set of characters to search for, may be null\n     * @param replaceChars  a set of characters to replace, may be null\n     * @return modified String, <code>null</code> if null string input\n     * @since 2.0\n     */\n    public static String replaceChars(final String str, final String searchChars, String replaceChars) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(searchChars)) {\n            return str;\n        }\n        if (replaceChars == null) {\n            replaceChars = StringUtils.EMPTY;\n        }\n        boolean modified = false;\n        int replaceCharsLength = replaceChars.length();\n        int strLength = str.length();\n        StringBuilder buf = new StringBuilder(strLength);\n        for (int i = 0; i < strLength; i++) {\n            char ch = str.charAt(i);\n            int index = searchChars.indexOf(ch);\n            if (index >= 0) {\n                modified = true;\n                if (index < replaceCharsLength) {\n                    buf.append(replaceChars.charAt(index));\n                }\n            } else {\n                buf.append(ch);\n            }\n        }\n        if (modified) {\n            return buf.toString();\n        }\n        return str;\n    }\n    // Overlay\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Overlays part of a String with another String.</p>\n     *\n     * <p>A <code>null</code> string input returns <code>null</code>.\n     * A negative index is treated as zero.\n     * An index greater than the string length is treated as the string length.\n     * The start index is always the smaller of the two indices.</p>\n     *\n     * <pre>\n     * StringUtils.overlay(null, *, *, *)            = null\n     * StringUtils.overlay(\"\", \"abc\", 0, 0)          = \"abc\"\n     * StringUtils.overlay(\"abcdef\", null, 2, 4)     = \"abef\"\n     * StringUtils.overlay(\"abcdef\", \"\", 2, 4)       = \"abef\"\n     * StringUtils.overlay(\"abcdef\", \"\", 4, 2)       = \"abef\"\n     * StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 4)   = \"abzzzzef\"\n     * StringUtils.overlay(\"abcdef\", \"zzzz\", 4, 2)   = \"abzzzzef\"\n     * StringUtils.overlay(\"abcdef\", \"zzzz\", -1, 4)  = \"zzzzef\"\n     * StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 8)   = \"abzzzz\"\n     * StringUtils.overlay(\"abcdef\", \"zzzz\", -2, -3) = \"zzzzabcdef\"\n     * StringUtils.overlay(\"abcdef\", \"zzzz\", 8, 10)  = \"abcdefzzzz\"\n     * </pre>\n     *\n     * @param str  the String to do overlaying in, may be null\n     * @param overlay  the String to overlay, may be null\n     * @param start  the position to start overlaying at\n     * @param end  the position to stop overlaying before\n     * @return overlayed String, <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String overlay(final String str, String overlay, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n        if (overlay == null) {\n            overlay = StringUtils.EMPTY;\n        }\n        int len = str.length();\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > len) {\n            start = len;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n        if (end > len) {\n            end = len;\n        }\n        if (start > end) {\n            int temp = start;\n            start = end;\n            end = temp;\n        }\n        return str.substring(0, start) + overlay + str.substring(end);\n    }\n    // Chomping\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Removes one newline from end of a String if it's there,\n     * otherwise leave it alone.  A newline is &quot;<code>\\n</code>&quot;,\n     * &quot;<code>\\r</code>&quot;, or &quot;<code>\\r\\n</code>&quot;.</p>\n     *\n     * <p>NOTE: This method changed in 2.0.\n     * It now more closely matches Perl chomp.</p>\n     *\n     * <pre>\n     * StringUtils.chomp(null)          = null\n     * StringUtils.chomp(\"\")            = \"\"\n     * StringUtils.chomp(\"abc \\r\")      = \"abc \"\n     * StringUtils.chomp(\"abc\\n\")       = \"abc\"\n     * StringUtils.chomp(\"abc\\r\\n\")     = \"abc\"\n     * StringUtils.chomp(\"abc\\r\\n\\r\\n\") = \"abc\\r\\n\"\n     * StringUtils.chomp(\"abc\\n\\r\")     = \"abc\\n\"\n     * StringUtils.chomp(\"abc\\n\\rabc\")  = \"abc\\n\\rabc\"\n     * StringUtils.chomp(\"\\r\")          = \"\"\n     * StringUtils.chomp(\"\\n\")          = \"\"\n     * StringUtils.chomp(\"\\r\\n\")        = \"\"\n     * </pre>\n     *\n     * @param str  the String to chomp a newline from, may be null\n     * @return String without newline, <code>null</code> if null String input\n     */\n    public static String chomp(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        if (str.length() == 1) {\n            char ch = str.charAt(0);\n            if (ch == CharUtils.CR || ch == CharUtils.LF) {\n                return StringUtils.EMPTY;\n            }\n            return str;\n        }\n        int lastIdx = str.length() - 1;\n        char last = str.charAt(lastIdx);\n        if (last == CharUtils.LF) {\n            if (str.charAt(lastIdx - 1) == CharUtils.CR) {\n                lastIdx--;\n            }\n        } else if (last != CharUtils.CR) {\n            lastIdx++;\n        }\n        return str.substring(0, lastIdx);\n    }\n\n    /**\n     * <p>Removes <code>separator</code> from the end of\n     * <code>str</code> if it's there, otherwise leave it alone.</p>\n     *\n     * <p>NOTE: This method changed in version 2.0.\n     * It now more closely matches Perl chomp.\n     * For the previous behavior, use {@link #substringBeforeLast(String, String)}.\n     * This method uses {@link String#endsWith(String)}.</p>\n     *\n     * <pre>\n     * StringUtils.chomp(null, *)         = null\n     * StringUtils.chomp(\"\", *)           = \"\"\n     * StringUtils.chomp(\"foobar\", \"bar\") = \"foo\"\n     * StringUtils.chomp(\"foobar\", \"baz\") = \"foobar\"\n     * StringUtils.chomp(\"foo\", \"foo\")    = \"\"\n     * StringUtils.chomp(\"foo \", \"foo\")   = \"foo \"\n     * StringUtils.chomp(\" foo\", \"foo\")   = \" \"\n     * StringUtils.chomp(\"foo\", \"foooo\")  = \"foo\"\n     * StringUtils.chomp(\"foo\", \"\")       = \"foo\"\n     * StringUtils.chomp(\"foo\", null)     = \"foo\"\n     * </pre>\n     *\n     * @param str  the String to chomp from, may be null\n     * @param separator  separator String, may be null\n     * @return String without trailing separator, <code>null</code> if null String input\n     */\n    public static String chomp(final String str, final String separator) {\n        if (StringUtils.isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (str.endsWith(separator)) {\n            return str.substring(0, str.length() - separator.length());\n        }\n        return str;\n    }\n    // Chopping\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Remove the last character from a String.</p>\n     *\n     * <p>If the String ends in <code>\\r\\n</code>, then remove both\n     * of them.</p>\n     *\n     * <pre>\n     * StringUtils.chop(null)          = null\n     * StringUtils.chop(\"\")            = \"\"\n     * StringUtils.chop(\"abc \\r\")      = \"abc \"\n     * StringUtils.chop(\"abc\\n\")       = \"abc\"\n     * StringUtils.chop(\"abc\\r\\n\")     = \"abc\"\n     * StringUtils.chop(\"abc\")         = \"ab\"\n     * StringUtils.chop(\"abc\\nabc\")    = \"abc\\nab\"\n     * StringUtils.chop(\"a\")           = \"\"\n     * StringUtils.chop(\"\\r\")          = \"\"\n     * StringUtils.chop(\"\\n\")          = \"\"\n     * StringUtils.chop(\"\\r\\n\")        = \"\"\n     * </pre>\n     *\n     * @param str  the String to chop last character from, may be null\n     * @return String without last character, <code>null</code> if null String input\n     */\n    public static String chop(final String str) {\n        if (str == null) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen < 2) {\n            return StringUtils.EMPTY;\n        }\n        int lastIdx = strLen - 1;\n        String ret = str.substring(0, lastIdx);\n        char last = str.charAt(lastIdx);\n        if (last == CharUtils.LF) {\n            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {\n                return ret.substring(0, lastIdx - 1);\n            }\n        }\n        return ret;\n    }\n    // Padding\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Repeat a String <code>repeat</code> times to form a\n     * new String.</p>\n     *\n     * <pre>\n     * StringUtils.repeat(null, 2) = null\n     * StringUtils.repeat(\"\", 0)   = \"\"\n     * StringUtils.repeat(\"\", 2)   = \"\"\n     * StringUtils.repeat(\"a\", 3)  = \"aaa\"\n     * StringUtils.repeat(\"ab\", 2) = \"abab\"\n     * StringUtils.repeat(\"a\", -2) = \"\"\n     * </pre>\n     *\n     * @param character  the Character to to repeat, may be null\n     * @param repeat  number of times to repeat str, negative treated as zero\n     * @return a new String consisting of the original String repeated,\n     *  <code>null</code> if null String input\n     */\n    public static String repeat(final char character, final int repeat) {\n        return repeat(character + \"\", repeat);\n    }\n\n    /**\n     * <p>Repeat a String <code>repeat</code> times to form a\n     * new String.</p>\n     *\n     * <pre>\n     * StringUtils.repeat(null, 2) = null\n     * StringUtils.repeat(\"\", 0)   = \"\"\n     * StringUtils.repeat(\"\", 2)   = \"\"\n     * StringUtils.repeat(\"a\", 3)  = \"aaa\"\n     * StringUtils.repeat(\"ab\", 2) = \"abab\"\n     * StringUtils.repeat(\"a\", -2) = \"\"\n     * </pre>\n     *\n     * @param str  the String to repeat, may be null\n     * @param repeat  number of times to repeat str, negative treated as zero\n     * @return a new String consisting of the original String repeated,\n     *  <code>null</code> if null String input\n     */\n    public static String repeat(final String str, final int repeat) {\n        // Performance tuned for 2.0 (JDK1.4)\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return StringUtils.EMPTY;\n        }\n        int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= StringUtils.PAD_LIMIT) {\n            return StringUtils.padding(repeat, str.charAt(0));\n        }\n        int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1:\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i >= 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2:\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default:\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n\n    /**\n     * <p>Repeat a String <code>repeat</code> times to form a\n     * new String, with a String separator injected each time. </p>\n     *\n     * <pre>\n     * StringUtils.repeat(null, null, 2) = null\n     * StringUtils.repeat(null, \"x\", 2)  = null\n     * StringUtils.repeat(\"\", null, 0)   = \"\"\n     * StringUtils.repeat(\"\", \"\", 2)     = \"\"\n     * StringUtils.repeat(\"\", \"x\", 3)    = \"xxx\"\n     * StringUtils.repeat(\"?\", \", \", 3)  = \"?, ?, ?\"\n     * </pre>\n     *\n     * @param str        the String to repeat, may be null\n     * @param separator  the String to inject, may be null\n     * @param repeat     number of times to repeat str, negative treated as zero\n     * @return a new String consisting of the original String repeated,\n     *  <code>null</code> if null String input\n     * @since 2.5\n     */\n    public static String repeat(final String str, final String separator, final int repeat) {\n        if (str == null || separator == null) {\n            return StringUtils.repeat(str, repeat);\n        } else {\n            // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it\n            String result = StringUtils.repeat(str + separator, repeat);\n            return StringUtils.removeEnd(result, separator);\n        }\n    }\n\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead.\n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(final int repeat, final char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final char[] buf = new char[repeat];\n        Arrays.fill(buf, padChar);\n        return new String(buf);\n    }\n\n    /**\n     * <p>Right pad a String with spaces (' ').</p>\n     *\n     * <p>The String is padded to the size of <code>size</code>.</p>\n     *\n     * <pre>\n     * StringUtils.rightPad(null, *)   = null\n     * StringUtils.rightPad(\"\", 3)     = \"   \"\n     * StringUtils.rightPad(\"bat\", 3)  = \"bat\"\n     * StringUtils.rightPad(\"bat\", 5)  = \"bat  \"\n     * StringUtils.rightPad(\"bat\", 1)  = \"bat\"\n     * StringUtils.rightPad(\"bat\", -1) = \"bat\"\n     * </pre>\n     *\n     * @param str  the String to pad out, may be null\n     * @param size  the size to pad to\n     * @return right padded String or original String if no padding is necessary,\n     *  <code>null</code> if null String input\n     */\n    public static String rightPad(final String str, final int size) {\n        return StringUtils.rightPad(str, size, ' ');\n    }\n\n    /**\n     * <p>Right pad a String with a specified character.</p>\n     *\n     * <p>The String is padded to the size of <code>size</code>.</p>\n     *\n     * <pre>\n     * StringUtils.rightPad(null, *, *)     = null\n     * StringUtils.rightPad(\"\", 3, 'z')     = \"zzz\"\n     * StringUtils.rightPad(\"bat\", 3, 'z')  = \"bat\"\n     * StringUtils.rightPad(\"bat\", 5, 'z')  = \"batzz\"\n     * StringUtils.rightPad(\"bat\", 1, 'z')  = \"bat\"\n     * StringUtils.rightPad(\"bat\", -1, 'z') = \"bat\"\n     * </pre>\n     *\n     * @param str  the String to pad out, may be null\n     * @param size  the size to pad to\n     * @param padChar  the character to pad with\n     * @return right padded String or original String if no padding is necessary,\n     *  <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String rightPad(final String str, final int size, final char padChar) {\n        if (str == null) {\n            return null;\n        }\n        int pads = size - str.length();\n        if (pads <= 0) {\n            return str; // returns original String when possible\n        }\n        if (pads > StringUtils.PAD_LIMIT) {\n            return StringUtils.rightPad(str, size, String.valueOf(padChar));\n        }\n        return str.concat(StringUtils.padding(pads, padChar));\n    }\n\n    /**\n     * <p>Right pad a String with a specified String.</p>\n     *\n     * <p>The String is padded to the size of <code>size</code>.</p>\n     *\n     * <pre>\n     * StringUtils.rightPad(null, *, *)      = null\n     * StringUtils.rightPad(\"\", 3, \"z\")      = \"zzz\"\n     * StringUtils.rightPad(\"bat\", 3, \"yz\")  = \"bat\"\n     * StringUtils.rightPad(\"bat\", 5, \"yz\")  = \"batyz\"\n     * StringUtils.rightPad(\"bat\", 8, \"yz\")  = \"batyzyzy\"\n     * StringUtils.rightPad(\"bat\", 1, \"yz\")  = \"bat\"\n     * StringUtils.rightPad(\"bat\", -1, \"yz\") = \"bat\"\n     * StringUtils.rightPad(\"bat\", 5, null)  = \"bat  \"\n     * StringUtils.rightPad(\"bat\", 5, \"\")    = \"bat  \"\n     * </pre>\n     *\n     * @param str  the String to pad out, may be null\n     * @param size  the size to pad to\n     * @param padStr  the String to pad with, null or empty treated as single space\n     * @return right padded String or original String if no padding is necessary,\n     *  <code>null</code> if null String input\n     */\n    public static String rightPad(final String str, final int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int padLen = padStr.length();\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str; // returns original String when possible\n        }\n        if (padLen == 1 && pads <= StringUtils.PAD_LIMIT) {\n            return StringUtils.rightPad(str, size, padStr.charAt(0));\n        }\n        if (pads == padLen) {\n            return str.concat(padStr);\n        } else if (pads < padLen) {\n            return str.concat(padStr.substring(0, pads));\n        } else {\n            char[] padding = new char[pads];\n            char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return str.concat(new String(padding));\n        }\n    }\n\n    /**\n     * <p>Left pad a String with spaces (' ').</p>\n     *\n     * <p>The String is padded to the size of <code>size</code>.</p>\n     *\n     * <pre>\n     * StringUtils.leftPad(null, *)   = null\n     * StringUtils.leftPad(\"\", 3)     = \"   \"\n     * StringUtils.leftPad(\"bat\", 3)  = \"bat\"\n     * StringUtils.leftPad(\"bat\", 5)  = \"  bat\"\n     * StringUtils.leftPad(\"bat\", 1)  = \"bat\"\n     * StringUtils.leftPad(\"bat\", -1) = \"bat\"\n     * </pre>\n     *\n     * @param str  the String to pad out, may be null\n     * @param size  the size to pad to\n     * @return left padded String or original String if no padding is necessary,\n     *  <code>null</code> if null String input\n     */\n    public static String leftPad(final String str, final int size) {\n        return StringUtils.leftPad(str, size, ' ');\n    }\n\n    /**\n     * <p>Left pad a String with a specified character.</p>\n     *\n     * <p>Pad to a size of <code>size</code>.</p>\n     *\n     * <pre>\n     * StringUtils.leftPad(null, *, *)     = null\n     * StringUtils.leftPad(\"\", 3, 'z')     = \"zzz\"\n     * StringUtils.leftPad(\"bat\", 3, 'z')  = \"bat\"\n     * StringUtils.leftPad(\"bat\", 5, 'z')  = \"zzbat\"\n     * StringUtils.leftPad(\"bat\", 1, 'z')  = \"bat\"\n     * StringUtils.leftPad(\"bat\", -1, 'z') = \"bat\"\n     * </pre>\n     *\n     * @param str  the String to pad out, may be null\n     * @param size  the size to pad to\n     * @param padChar  the character to pad with\n     * @return left padded String or original String if no padding is necessary,\n     *  <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String leftPad(final String str, final int size, final char padChar) {\n        if (str == null) {\n            return null;\n        }\n        int pads = size - str.length();\n        if (pads <= 0) {\n            return str; // returns original String when possible\n        }\n        if (pads > StringUtils.PAD_LIMIT) {\n            return StringUtils.leftPad(str, size, String.valueOf(padChar));\n        }\n        return StringUtils.padding(pads, padChar).concat(str);\n    }\n\n    /**\n     * <p>Left pad a String with a specified String.</p>\n     *\n     * <p>Pad to a size of <code>size</code>.</p>\n     *\n     * <pre>\n     * StringUtils.leftPad(null, *, *)      = null\n     * StringUtils.leftPad(\"\", 3, \"z\")      = \"zzz\"\n     * StringUtils.leftPad(\"bat\", 3, \"yz\")  = \"bat\"\n     * StringUtils.leftPad(\"bat\", 5, \"yz\")  = \"yzbat\"\n     * StringUtils.leftPad(\"bat\", 8, \"yz\")  = \"yzyzybat\"\n     * StringUtils.leftPad(\"bat\", 1, \"yz\")  = \"bat\"\n     * StringUtils.leftPad(\"bat\", -1, \"yz\") = \"bat\"\n     * StringUtils.leftPad(\"bat\", 5, null)  = \"  bat\"\n     * StringUtils.leftPad(\"bat\", 5, \"\")    = \"  bat\"\n     * </pre>\n     *\n     * @param str  the String to pad out, may be null\n     * @param size  the size to pad to\n     * @param padStr  the String to pad with, null or empty treated as single space\n     * @return left padded String or original String if no padding is necessary,\n     *  <code>null</code> if null String input\n     */\n    public static String leftPad(final String str, final int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int padLen = padStr.length();\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str; // returns original String when possible\n        }\n        if (padLen == 1 && pads <= StringUtils.PAD_LIMIT) {\n            return StringUtils.leftPad(str, size, padStr.charAt(0));\n        }\n        if (pads == padLen) {\n            return padStr.concat(str);\n        } else if (pads < padLen) {\n            return padStr.substring(0, pads).concat(str);\n        } else {\n            char[] padding = new char[pads];\n            char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return new String(padding).concat(str);\n        }\n    }\n\n    /**\n     * Gets a String's length or <code>0</code> if the String is <code>null</code>.\n     *\n     * @param str\n     *            a String or <code>null</code>\n     * @return String length or <code>0</code> if the String is <code>null</code>.\n     * @since 2.4\n     */\n    public static int length(final String str) {\n        return str == null ? 0 : str.length();\n    }\n    // Centering\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Centers a String in a larger String of size <code>size</code>\n     * using the space character (' ').<p>\n     *\n     * <p>If the size is less than the String length, the String is returned.\n     * A <code>null</code> String returns <code>null</code>.\n     * A negative size is treated as zero.</p>\n     *\n     * <p>Equivalent to <code>center(str, size, \" \")</code>.</p>\n     *\n     * <pre>\n     * StringUtils.center(null, *)   = null\n     * StringUtils.center(\"\", 4)     = \"    \"\n     * StringUtils.center(\"ab\", -1)  = \"ab\"\n     * StringUtils.center(\"ab\", 4)   = \" ab \"\n     * StringUtils.center(\"abcd\", 2) = \"abcd\"\n     * StringUtils.center(\"a\", 4)    = \" a  \"\n     * </pre>\n     *\n     * @param str  the String to center, may be null\n     * @param size  the int size of new String, negative treated as zero\n     * @return centered String, <code>null</code> if null String input\n     */\n    public static String center(final String str, final int size) {\n        return StringUtils.center(str, size, ' ');\n    }\n\n    /**\n     * <p>Centers a String in a larger String of size <code>size</code>.\n     * Uses a supplied character as the value to pad the String with.</p>\n     *\n     * <p>If the size is less than the String length, the String is returned.\n     * A <code>null</code> String returns <code>null</code>.\n     * A negative size is treated as zero.</p>\n     *\n     * <pre>\n     * StringUtils.center(null, *, *)     = null\n     * StringUtils.center(\"\", 4, ' ')     = \"    \"\n     * StringUtils.center(\"ab\", -1, ' ')  = \"ab\"\n     * StringUtils.center(\"ab\", 4, ' ')   = \" ab\"\n     * StringUtils.center(\"abcd\", 2, ' ') = \"abcd\"\n     * StringUtils.center(\"a\", 4, ' ')    = \" a  \"\n     * StringUtils.center(\"a\", 4, 'y')    = \"yayy\"\n     * </pre>\n     *\n     * @param str  the String to center, may be null\n     * @param size  the int size of new String, negative treated as zero\n     * @param padChar  the character to pad the new String with\n     * @return centered String, <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String center(String str, final int size, final char padChar) {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = StringUtils.leftPad(str, strLen + pads / 2, padChar);\n        str = StringUtils.rightPad(str, size, padChar);\n        return str;\n    }\n\n    /**\n     * <p>Centers a String in a larger String of size <code>size</code>.\n     * Uses a supplied String as the value to pad the String with.</p>\n     *\n     * <p>If the size is less than the String length, the String is returned.\n     * A <code>null</code> String returns <code>null</code>.\n     * A negative size is treated as zero.</p>\n     *\n     * <pre>\n     * StringUtils.center(null, *, *)     = null\n     * StringUtils.center(\"\", 4, \" \")     = \"    \"\n     * StringUtils.center(\"ab\", -1, \" \")  = \"ab\"\n     * StringUtils.center(\"ab\", 4, \" \")   = \" ab\"\n     * StringUtils.center(\"abcd\", 2, \" \") = \"abcd\"\n     * StringUtils.center(\"a\", 4, \" \")    = \" a  \"\n     * StringUtils.center(\"a\", 4, \"yz\")   = \"yayz\"\n     * StringUtils.center(\"abc\", 7, null) = \"  abc  \"\n     * StringUtils.center(\"abc\", 7, \"\")   = \"  abc  \"\n     * </pre>\n     *\n     * @param str  the String to center, may be null\n     * @param size  the int size of new String, negative treated as zero\n     * @param padStr  the String to pad the new String with, must not be null or empty\n     * @return centered String, <code>null</code> if null String input\n     * @throws IllegalArgumentException if padStr is <code>null</code> or empty\n     */\n    public static String center(String str, final int size, String padStr) {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        if (StringUtils.isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = StringUtils.leftPad(str, strLen + pads / 2, padStr);\n        str = StringUtils.rightPad(str, size, padStr);\n        return str;\n    }\n    // Case conversion\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts a String to upper case as per {@link String#toUpperCase()}.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.upperCase(null)  = null\n     * StringUtils.upperCase(\"\")    = \"\"\n     * StringUtils.upperCase(\"aBc\") = \"ABC\"\n     * </pre>\n     *\n     * <p><strong>Note:</strong> As described in the documentation for {@link String#toUpperCase()},\n     * the result of this method is affected by the current locale.\n     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}\n     * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>\n     *\n     * @param str  the String to upper case, may be null\n     * @return the upper cased String, <code>null</code> if null String input\n     */\n    public static String upperCase(final String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase();\n    }\n\n    /**\n     * <p>Converts a String to upper case as per {@link String#toUpperCase(Locale)}.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.upperCase(null, Locale.ENGLISH)  = null\n     * StringUtils.upperCase(\"\", Locale.ENGLISH)    = \"\"\n     * StringUtils.upperCase(\"aBc\", Locale.ENGLISH) = \"ABC\"\n     * </pre>\n     *\n     * @param str  the String to upper case, may be null\n     * @param locale  the locale that defines the case transformation rules, must not be null\n     * @return the upper cased String, <code>null</code> if null String input\n     * @since 2.5\n     */\n    public static String upperCase(final String str, final Locale locale) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase(locale);\n    }\n\n    /**\n     * <p>Converts a String to lower case as per {@link String#toLowerCase()}.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.lowerCase(null)  = null\n     * StringUtils.lowerCase(\"\")    = \"\"\n     * StringUtils.lowerCase(\"aBc\") = \"abc\"\n     * </pre>\n     *\n     * <p><strong>Note:</strong> As described in the documentation for {@link String#toLowerCase()},\n     * the result of this method is affected by the current locale.\n     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}\n     * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>\n     *\n     * @param str  the String to lower case, may be null\n     * @return the lower cased String, <code>null</code> if null String input\n     */\n    public static String lowerCase(final String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase();\n    }\n\n    /**\n     * <p>Converts a String to lower case as per {@link String#toLowerCase(Locale)}.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.lowerCase(null, Locale.ENGLISH)  = null\n     * StringUtils.lowerCase(\"\", Locale.ENGLISH)    = \"\"\n     * StringUtils.lowerCase(\"aBc\", Locale.ENGLISH) = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to lower case, may be null\n     * @param locale  the locale that defines the case transformation rules, must not be null\n     * @return the lower cased String, <code>null</code> if null String input\n     * @since 2.5\n     */\n    public static String lowerCase(final String str, final Locale locale) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase(locale);\n    }\n\n    /**\n     * <p>Capitalizes a String changing the first letter to title case as\n     * per {@link Character#toTitleCase(char)}. No other letters are changed.</p>\n     *\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.capitalize(null)  = null\n     * StringUtils.capitalize(\"\")    = \"\"\n     * StringUtils.capitalize(\"cat\") = \"Cat\"\n     * StringUtils.capitalize(\"cAt\") = \"CAt\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @return the capitalized String, <code>null</code> if null String input\n     * @see #uncapitalize(String)\n     * @since 2.0\n     */\n    public static String capitalize(final String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        return Character.toTitleCase(str.charAt(0)) + str.substring(1);\n    }\n\n    /**\n     * <p>Uncapitalizes a String changing the first letter to title case as\n     * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>\n     *\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.uncapitalize(null)  = null\n     * StringUtils.uncapitalize(\"\")    = \"\"\n     * StringUtils.uncapitalize(\"Cat\") = \"cat\"\n     * StringUtils.uncapitalize(\"CAT\") = \"cAT\"\n     * </pre>\n     *\n     * @param str  the String to uncapitalize, may be null\n     * @return the uncapitalized String, <code>null</code> if null String input\n     * @see #capitalize(String)\n     * @since 2.0\n     */\n    public static String uncapitalize(final String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        return Character.toLowerCase(str.charAt(0)) + str.substring(1);\n    }\n\n    /**\n     * <p>Swaps the case of a String changing upper and title case to\n     * lower case, and lower case to upper case.</p>\n     *\n     * <ul>\n     *  <li>Upper case character converts to Lower case</li>\n     *  <li>Title case character converts to Lower case</li>\n     *  <li>Lower case character converts to Upper case</li>\n     * </ul>\n     *\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.swapCase(null)                 = null\n     * StringUtils.swapCase(\"\")                   = \"\"\n     * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n     * </pre>\n     *\n     * <p>NOTE: This method changed in Lang version 2.0.\n     * It no longer performs a word based algorithm.\n     * If you only use ASCII, you will notice no change.\n     * That functionality is available in WordUtils.</p>\n     *\n     * @param str  the String to swap case, may be null\n     * @return the changed String, <code>null</code> if null String input\n     */\n    public static String swapCase(final String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        StringBuilder buffer = new StringBuilder(strLen);\n        char ch = 0;\n        for (int i = 0; i < strLen; i++) {\n            ch = str.charAt(i);\n            if (Character.isUpperCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isTitleCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isLowerCase(ch)) {\n                ch = Character.toUpperCase(ch);\n            }\n            buffer.append(ch);\n        }\n        return buffer.toString();\n    }\n    // Count matches\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Counts how many times the substring appears in the larger String.</p>\n     *\n     * <p>A <code>null</code> or empty (\"\") String input returns <code>0</code>.</p>\n     *\n     * <pre>\n     * StringUtils.countMatches(null, *)       = 0\n     * StringUtils.countMatches(\"\", *)         = 0\n     * StringUtils.countMatches(\"abba\", null)  = 0\n     * StringUtils.countMatches(\"abba\", \"\")    = 0\n     * StringUtils.countMatches(\"abba\", \"a\")   = 2\n     * StringUtils.countMatches(\"abba\", \"ab\")  = 1\n     * StringUtils.countMatches(\"abba\", \"xxx\") = 0\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param sub  the substring to count, may be null\n     * @return the number of occurrences, 0 if either String is <code>null</code>\n     */\n    public static int countMatches(final String str, final String sub) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(sub)) {\n            return 0;\n        }\n        int count = 0;\n        int idx = 0;\n        while ((idx = str.indexOf(sub, idx)) != StringUtils.INDEX_NOT_FOUND) {\n            count++;\n            idx += sub.length();\n        }\n        return count;\n    }\n    // Character Tests\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if the String contains only unicode letters.</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isAlpha(null)   = false\n     * StringUtils.isAlpha(\"\")     = true\n     * StringUtils.isAlpha(\"  \")   = false\n     * StringUtils.isAlpha(\"abc\")  = true\n     * StringUtils.isAlpha(\"ab2c\") = false\n     * StringUtils.isAlpha(\"ab-c\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains letters, and is non-null\n     */\n    public static boolean isAlpha(final String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isLetter(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the String contains only unicode letters and\n     * space (' ').</p>\n     *\n     * <p><code>null</code> will return <code>false</code>\n     * An empty String (length()=0) will return <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isAlphaSpace(null)   = false\n     * StringUtils.isAlphaSpace(\"\")     = true\n     * StringUtils.isAlphaSpace(\"  \")   = true\n     * StringUtils.isAlphaSpace(\"abc\")  = true\n     * StringUtils.isAlphaSpace(\"ab c\") = true\n     * StringUtils.isAlphaSpace(\"ab2c\") = false\n     * StringUtils.isAlphaSpace(\"ab-c\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains letters and space,\n     *  and is non-null\n     */\n    public static boolean isAlphaSpace(final String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isLetter(str.charAt(i)) && str.charAt(i) != ' ') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the String contains only unicode letters or digits.</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isAlphanumeric(null)   = false\n     * StringUtils.isAlphanumeric(\"\")     = true\n     * StringUtils.isAlphanumeric(\"  \")   = false\n     * StringUtils.isAlphanumeric(\"abc\")  = true\n     * StringUtils.isAlphanumeric(\"ab c\") = false\n     * StringUtils.isAlphanumeric(\"ab2c\") = true\n     * StringUtils.isAlphanumeric(\"ab-c\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains letters or digits,\n     *  and is non-null\n     */\n    public static boolean isAlphanumeric(final String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isLetterOrDigit(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the String contains only unicode letters, digits\n     * or space (<code>' '</code>).</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isAlphanumeric(null)   = false\n     * StringUtils.isAlphanumeric(\"\")     = true\n     * StringUtils.isAlphanumeric(\"  \")   = true\n     * StringUtils.isAlphanumeric(\"abc\")  = true\n     * StringUtils.isAlphanumeric(\"ab c\") = true\n     * StringUtils.isAlphanumeric(\"ab2c\") = true\n     * StringUtils.isAlphanumeric(\"ab-c\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains letters, digits or space,\n     *  and is non-null\n     */\n    public static boolean isAlphanumericSpace(final String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isLetterOrDigit(str.charAt(i)) && str.charAt(i) != ' ') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the string contains only ASCII printable characters.</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isAsciiPrintable(null)     = false\n     * StringUtils.isAsciiPrintable(\"\")       = true\n     * StringUtils.isAsciiPrintable(\" \")      = true\n     * StringUtils.isAsciiPrintable(\"Ceki\")   = true\n     * StringUtils.isAsciiPrintable(\"ab2c\")   = true\n     * StringUtils.isAsciiPrintable(\"!ab-c~\") = true\n     * StringUtils.isAsciiPrintable(\"\\u0020\") = true\n     * StringUtils.isAsciiPrintable(\"\\u0021\") = true\n     * StringUtils.isAsciiPrintable(\"\\u007e\") = true\n     * StringUtils.isAsciiPrintable(\"\\u007f\") = false\n     * StringUtils.isAsciiPrintable(\"Ceki G\\u00fclc\\u00fc\") = false\n     * </pre>\n     *\n     * @param str the string to check, may be null\n     * @return <code>true</code> if every character is in the range\n     *  32 thru 126\n     * @since 2.1\n     */\n    public static boolean isAsciiPrintable(final String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!CharUtils.isAsciiPrintable(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the String contains only unicode digits.\n     * A decimal point is not a unicode digit and returns false.</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isNumeric(null)   = false\n     * StringUtils.isNumeric(\"\")     = true\n     * StringUtils.isNumeric(\"  \")   = false\n     * StringUtils.isNumeric(\"123\")  = true\n     * StringUtils.isNumeric(\"12 3\") = false\n     * StringUtils.isNumeric(\"ab2c\") = false\n     * StringUtils.isNumeric(\"12-3\") = false\n     * StringUtils.isNumeric(\"12.3\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains digits, and is non-null\n     */\n    public static boolean isNumeric(final String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isDigit(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the String contains only unicode digits or space\n     * (<code>' '</code>).\n     * A decimal point is not a unicode digit and returns false.</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isNumeric(null)   = false\n     * StringUtils.isNumeric(\"\")     = true\n     * StringUtils.isNumeric(\"  \")   = true\n     * StringUtils.isNumeric(\"123\")  = true\n     * StringUtils.isNumeric(\"12 3\") = true\n     * StringUtils.isNumeric(\"ab2c\") = false\n     * StringUtils.isNumeric(\"12-3\") = false\n     * StringUtils.isNumeric(\"12.3\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains digits or space,\n     *  and is non-null\n     */\n    public static boolean isNumericSpace(final String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isDigit(str.charAt(i)) && str.charAt(i) != ' ') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the String contains only whitespace.</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isWhitespace(null)   = false\n     * StringUtils.isWhitespace(\"\")     = true\n     * StringUtils.isWhitespace(\"  \")   = true\n     * StringUtils.isWhitespace(\"abc\")  = false\n     * StringUtils.isWhitespace(\"ab2c\") = false\n     * StringUtils.isWhitespace(\"ab-c\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains whitespace, and is non-null\n     * @since 2.0\n     */\n    public static boolean isWhitespace(final String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the String contains only lowercase characters.</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isAllLowerCase(null)   = false\n     * StringUtils.isAllLowerCase(\"\")     = false\n     * StringUtils.isAllLowerCase(\"  \")   = false\n     * StringUtils.isAllLowerCase(\"abc\")  = true\n     * StringUtils.isAllLowerCase(\"abC\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains lowercase characters, and is non-null\n     * @since 2.5\n     */\n    public static boolean isAllLowerCase(final String str) {\n        if (str == null || StringUtils.isEmpty(str)) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isLowerCase(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the String contains only uppercase characters.</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isAllUpperCase(null)   = false\n     * StringUtils.isAllUpperCase(\"\")     = false\n     * StringUtils.isAllUpperCase(\"  \")   = false\n     * StringUtils.isAllUpperCase(\"ABC\")  = true\n     * StringUtils.isAllUpperCase(\"aBC\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains uppercase characters, and is non-null\n     * @since 2.5\n     */\n    public static boolean isAllUpperCase(final String str) {\n        if (str == null || StringUtils.isEmpty(str)) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isUpperCase(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Defaults\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Returns either the passed in String,\n     * or if the String is <code>null</code>, an empty String (\"\").</p>\n     *\n     * <pre>\n     * StringUtils.defaultString(null)  = \"\"\n     * StringUtils.defaultString(\"\")    = \"\"\n     * StringUtils.defaultString(\"bat\") = \"bat\"\n     * </pre>\n     *\n     * @see ObjectUtils#toString(Object)\n     * @see String#valueOf(Object)\n     * @param str  the String to check, may be null\n     * @return the passed in String, or the empty String if it\n     *  was <code>null</code>\n     */\n    public static String defaultString(final String str) {\n        return str == null ? StringUtils.EMPTY : str;\n    }\n\n    /**\n     * <p>Returns either the passed in String, or if the String is\n     * <code>null</code>, the value of <code>defaultStr</code>.</p>\n     *\n     * <pre>\n     * StringUtils.defaultString(null, \"NULL\")  = \"NULL\"\n     * StringUtils.defaultString(\"\", \"NULL\")    = \"\"\n     * StringUtils.defaultString(\"bat\", \"NULL\") = \"bat\"\n     * </pre>\n     *\n     * @see ObjectUtils#toString(Object, String)\n     * @see String#valueOf(Object)\n     * @param str  the String to check, may be null\n     * @param defaultStr  the default String to return\n     *  if the input is <code>null</code>, may be null\n     * @return the passed in String, or the default if it was <code>null</code>\n     */\n    public static String defaultString(final String str, final String defaultStr) {\n        return str == null ? defaultStr : str;\n    }\n\n    /**\n     * <p>Returns either the passed in String, or if the String is\n     * whitespace, empty (\"\") or <code>null</code>, the value of <code>defaultStr</code>.</p>\n     *\n     * <pre>\n     * StringUtils.defaultIfBlank(null, \"NULL\")  = \"NULL\"\n     * StringUtils.defaultIfBlank(\"\", \"NULL\")    = \"NULL\"\n     * StringUtils.defaultIfBlank(\" \", \"NULL\")   = \"NULL\"\n     * StringUtils.defaultIfBlank(\"bat\", \"NULL\") = \"bat\"\n     * StringUtils.defaultIfBlank(\"\", null)      = null\n     * </pre>\n     * @param str the String to check, may be null\n     * @param defaultStr  the default String to return\n     *  if the input is whitespace, empty (\"\") or <code>null</code>, may be null\n     * @return the passed in String, or the default\n     * @see StringUtils#defaultString(String, String)\n     * @since 2.6\n     */\n    public static String defaultIfBlank(final String str, final String defaultStr) {\n        return StringUtils.isBlank(str) ? defaultStr : str;\n    }\n\n    /**\n     * <p>Returns either the passed in String, or if the String is\n     * empty or <code>null</code>, the value of <code>defaultStr</code>.</p>\n     *\n     * <pre>\n     * StringUtils.defaultIfEmpty(null, \"NULL\")  = \"NULL\"\n     * StringUtils.defaultIfEmpty(\"\", \"NULL\")    = \"NULL\"\n     * StringUtils.defaultIfEmpty(\"bat\", \"NULL\") = \"bat\"\n     * StringUtils.defaultIfEmpty(\"\", null)      = null\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param defaultStr  the default String to return\n     *  if the input is empty (\"\") or <code>null</code>, may be null\n     * @return the passed in String, or the default\n     * @see StringUtils#defaultString(String, String)\n     */\n    public static String defaultIfEmpty(final String str, final String defaultStr) {\n        return StringUtils.isEmpty(str) ? defaultStr : str;\n    }\n    // Reversing\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Reverses a String as per {@link StringBuilder#reverse()}.</p>\n     *\n     * <p>A <code>null</code> String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.reverse(null)  = null\n     * StringUtils.reverse(\"\")    = \"\"\n     * StringUtils.reverse(\"bat\") = \"tab\"\n     * </pre>\n     *\n     * @param str  the String to reverse, may be null\n     * @return the reversed String, <code>null</code> if null String input\n     */\n    public static String reverse(final String str) {\n        if (str == null) {\n            return null;\n        }\n        return new StringBuilder(str).reverse().toString();\n    }\n\n    /**\n     * <p>Reverses a String that is delimited by a specific character.</p>\n     *\n     * <p>The Strings between the delimiters are not reversed.\n     * Thus java.lang.String becomes String.lang.java (if the delimiter\n     * is <code>'.'</code>).</p>\n     *\n     * <pre>\n     * StringUtils.reverseDelimited(null, *)      = null\n     * StringUtils.reverseDelimited(\"\", *)        = \"\"\n     * StringUtils.reverseDelimited(\"a.b.c\", 'x') = \"a.b.c\"\n     * StringUtils.reverseDelimited(\"a.b.c\", \".\") = \"c.b.a\"\n     * </pre>\n     *\n     * @param str  the String to reverse, may be null\n     * @param separatorChar  the separator character to use\n     * @return the reversed String, <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String reverseDelimited(final String str, final char separatorChar) {\n        if (str == null) {\n            return null;\n        }\n        // could implement manually, but simple way is to reuse other,\n        // probably slower, methods.\n        String[] strs = StringUtils.split(str, separatorChar);\n        ArrayUtils.reverse(strs);\n        return StringUtils.join(strs, separatorChar);\n    }\n    // Abbreviating\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Abbreviates a String using ellipses. This will turn\n     * \"Now is the time for all good men\" into \"Now is the time for...\"</p>\n     *\n     * <p>Specifically:\n     * <ul>\n     *   <li>If <code>str</code> is less than <code>maxWidth</code> characters\n     *       long, return it.</li>\n     *   <li>Else abbreviate it to <code>(substring(str, 0, max-3) + \"...\")</code>.</li>\n     *   <li>If <code>maxWidth</code> is less than <code>4</code>, throw an\n     *       <code>IllegalArgumentException</code>.</li>\n     *   <li>In no case will it return a String of length greater than\n     *       <code>maxWidth</code>.</li>\n     * </ul>\n     * </p>\n     *\n     * <pre>\n     * StringUtils.abbreviate(null, *)      = null\n     * StringUtils.abbreviate(\"\", 4)        = \"\"\n     * StringUtils.abbreviate(\"abcdefg\", 6) = \"abc...\"\n     * StringUtils.abbreviate(\"abcdefg\", 7) = \"abcdefg\"\n     * StringUtils.abbreviate(\"abcdefg\", 8) = \"abcdefg\"\n     * StringUtils.abbreviate(\"abcdefg\", 4) = \"a...\"\n     * StringUtils.abbreviate(\"abcdefg\", 3) = IllegalArgumentException\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param maxWidth  maximum length of result String, must be at least 4\n     * @return abbreviated String, <code>null</code> if null String input\n     * @throws IllegalArgumentException if the width is too small\n     * @since 2.0\n     */\n    public static String abbreviate(final String str, final int maxWidth) {\n        return StringUtils.abbreviate(str, 0, maxWidth);\n    }\n\n    /**\n     * <p>Abbreviates a String using ellipses. This will turn\n     * \"Now is the time for all good men\" into \"...is the time for...\"</p>\n     *\n     * <p>Works like <code>abbreviate(String, int)</code>, but allows you to specify\n     * a \"left edge\" offset.  Note that this left edge is not necessarily going to\n     * be the leftmost character in the result, or the first character following the\n     * ellipses, but it will appear somewhere in the result.\n     *\n     * <p>In no case will it return a String of length greater than\n     * <code>maxWidth</code>.</p>\n     *\n     * <pre>\n     * StringUtils.abbreviate(null, *, *)                = null\n     * StringUtils.abbreviate(\"\", 0, 4)                  = \"\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", -1, 10) = \"abcdefg...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 0, 10)  = \"abcdefg...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 1, 10)  = \"abcdefg...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 4, 10)  = \"abcdefg...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 5, 10)  = \"...fghi...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 6, 10)  = \"...ghij...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 8, 10)  = \"...ijklmno\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 10, 10) = \"...ijklmno\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 12, 10) = \"...ijklmno\"\n     * StringUtils.abbreviate(\"abcdefghij\", 0, 3)        = IllegalArgumentException\n     * StringUtils.abbreviate(\"abcdefghij\", 5, 6)        = IllegalArgumentException\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param offset  left edge of source String\n     * @param maxWidth  maximum length of result String, must be at least 4\n     * @return abbreviated String, <code>null</code> if null String input\n     * @throws IllegalArgumentException if the width is too small\n     * @since 2.0\n     */\n    public static String abbreviate(final String str, int offset, final int maxWidth) {\n        if (str == null) {\n            return null;\n        }\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n        if (str.length() - offset < maxWidth - 3) {\n            offset = str.length() - (maxWidth - 3);\n        }\n        if (offset <= 4) {\n            return str.substring(0, maxWidth - 3) + \"...\";\n        }\n        if (maxWidth < 7) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n        }\n        if (offset + maxWidth - 3 < str.length()) {\n            return \"...\" + StringUtils.abbreviate(str.substring(offset), maxWidth - 3);\n        }\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n\n    /**\n     * <p>Abbreviates a String to the length passed, replacing the middle characters with the supplied\n     * replacement String.</p>\n     *\n     * <p>This abbreviation only occurs if the following criteria is met:\n     * <ul>\n     * <li>Neither the String for abbreviation nor the replacement String are null or empty </li>\n     * <li>The length to truncate to is less than the length of the supplied String</li>\n     * <li>The length to truncate to is greater than 0</li>\n     * <li>The abbreviated String will have enough room for the length supplied replacement String\n     * and the first and last characters of the supplied String for abbreviation</li>\n     * </ul>\n     * Otherwise, the returned String will be the same as the supplied String for abbreviation.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.abbreviateMiddle(null, null, 0)      = null\n     * StringUtils.abbreviateMiddle(\"abc\", null, 0)      = \"abc\"\n     * StringUtils.abbreviateMiddle(\"abc\", \".\", 0)      = \"abc\"\n     * StringUtils.abbreviateMiddle(\"abc\", \".\", 3)      = \"abc\"\n     * StringUtils.abbreviateMiddle(\"abcdef\", \".\", 4)     = \"ab.f\"\n     * </pre>\n     *\n     * @param str  the String to abbreviate, may be null\n     * @param middle the String to replace the middle characters with, may be null\n     * @param length the length to abbreviate <code>str</code> to.\n     * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.\n     * @since 2.5\n     */\n    public static String abbreviateMiddle(final String str, final String middle, final int length) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(middle)) {\n            return str;\n        }\n        if (length >= str.length() || length < middle.length() + 2) {\n            return str;\n        }\n        int targetSting = length - middle.length();\n        int startOffset = targetSting / 2 + targetSting % 2;\n        int endOffset = str.length() - targetSting / 2;\n        return str.substring(0, startOffset) + middle + str.substring(endOffset);\n    }\n    // Difference\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Compares two Strings, and returns the portion where they differ.\n     * (More precisely, return the remainder of the second String,\n     * starting from where it's different from the first.)</p>\n     *\n     * <p>For example,\n     * <code>difference(\"i am a machine\", \"i am a robot\") -> \"robot\"</code>.</p>\n     *\n     * <pre>\n     * StringUtils.difference(null, null) = null\n     * StringUtils.difference(\"\", \"\") = \"\"\n     * StringUtils.difference(\"\", \"abc\") = \"abc\"\n     * StringUtils.difference(\"abc\", \"\") = \"\"\n     * StringUtils.difference(\"abc\", \"abc\") = \"\"\n     * StringUtils.difference(\"ab\", \"abxyz\") = \"xyz\"\n     * StringUtils.difference(\"abcde\", \"abxyz\") = \"xyz\"\n     * StringUtils.difference(\"abcde\", \"xyz\") = \"xyz\"\n     * </pre>\n     *\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return the portion of str2 where it differs from str1; returns the\n     * empty String if they are equal\n     * @since 2.0\n     */\n    public static String difference(final String str1, final String str2) {\n        if (str1 == null) {\n            return str2;\n        }\n        if (str2 == null) {\n            return str1;\n        }\n        int at = StringUtils.indexOfDifference(str1, str2);\n        if (at == StringUtils.INDEX_NOT_FOUND) {\n            return StringUtils.EMPTY;\n        }\n        return str2.substring(at);\n    }\n\n    /**\n     * <p>Compares two Strings, and returns the index at which the\n     * Strings begin to differ.</p>\n     *\n     * <p>For example,\n     * <code>indexOfDifference(\"i am a machine\", \"i am a robot\") -> 7</code></p>\n     *\n     * <pre>\n     * StringUtils.indexOfDifference(null, null) = -1\n     * StringUtils.indexOfDifference(\"\", \"\") = -1\n     * StringUtils.indexOfDifference(\"\", \"abc\") = 0\n     * StringUtils.indexOfDifference(\"abc\", \"\") = 0\n     * StringUtils.indexOfDifference(\"abc\", \"abc\") = -1\n     * StringUtils.indexOfDifference(\"ab\", \"abxyz\") = 2\n     * StringUtils.indexOfDifference(\"abcde\", \"abxyz\") = 2\n     * StringUtils.indexOfDifference(\"abcde\", \"xyz\") = 0\n     * </pre>\n     *\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return the index where str2 and str1 begin to differ; -1 if they are equal\n     * @since 2.0\n     */\n    public static int indexOfDifference(final String str1, final String str2) {\n        if (str1 != null && str1.equals(str2)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        if (str1 == null || str2 == null) {\n            return 0;\n        }\n        int i;\n        for (i = 0; i < str1.length() && i < str2.length(); ++i) {\n            if (str1.charAt(i) != str2.charAt(i)) {\n                break;\n            }\n        }\n        if (i < str2.length() || i < str1.length()) {\n            return i;\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Compares all Strings in an array and returns the index at which the\n     * Strings begin to differ.</p>\n     *\n     * <p>For example,\n     * <code>indexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}) -> 7</code></p>\n     *\n     * <pre>\n     * StringUtils.indexOfDifference(null) = -1\n     * StringUtils.indexOfDifference(new String[] {}) = -1\n     * StringUtils.indexOfDifference(new String[] {\"abc\"}) = -1\n     * StringUtils.indexOfDifference(new String[] {null, null}) = -1\n     * StringUtils.indexOfDifference(new String[] {\"\", \"\"}) = -1\n     * StringUtils.indexOfDifference(new String[] {\"\", null}) = 0\n     * StringUtils.indexOfDifference(new String[] {\"abc\", null, null}) = 0\n     * StringUtils.indexOfDifference(new String[] {null, null, \"abc\"}) = 0\n     * StringUtils.indexOfDifference(new String[] {\"\", \"abc\"}) = 0\n     * StringUtils.indexOfDifference(new String[] {\"abc\", \"\"}) = 0\n     * StringUtils.indexOfDifference(new String[] {\"abc\", \"abc\"}) = -1\n     * StringUtils.indexOfDifference(new String[] {\"abc\", \"a\"}) = 1\n     * StringUtils.indexOfDifference(new String[] {\"ab\", \"abxyz\"}) = 2\n     * StringUtils.indexOfDifference(new String[] {\"abcde\", \"abxyz\"}) = 2\n     * StringUtils.indexOfDifference(new String[] {\"abcde\", \"xyz\"}) = 0\n     * StringUtils.indexOfDifference(new String[] {\"xyz\", \"abcde\"}) = 0\n     * StringUtils.indexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}) = 7\n     * </pre>\n     *\n     * @param strs  array of strings, entries may be null\n     * @return the index where the strings begin to differ; -1 if they are all equal\n     * @since 2.4\n     */\n    public static int indexOfDifference(final String[] strs) {\n        if (strs == null || strs.length <= 1) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        boolean anyStringNull = false;\n        boolean allStringsNull = true;\n        int arrayLen = strs.length;\n        int shortestStrLen = Integer.MAX_VALUE;\n        int longestStrLen = 0;\n        // find the min and max string lengths; this avoids checking to make\n        // sure we are not exceeding the length of the string each time through\n        // the bottom loop.\n        for (int i = 0; i < arrayLen; i++) {\n            if (strs[i] == null) {\n                anyStringNull = true;\n                shortestStrLen = 0;\n            } else {\n                allStringsNull = false;\n                shortestStrLen = Math.min(strs[i].length(), shortestStrLen);\n                longestStrLen = Math.max(strs[i].length(), longestStrLen);\n            }\n        }\n        // handle lists containing all nulls or all empty strings\n        if (allStringsNull || longestStrLen == 0 && !anyStringNull) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        // handle lists containing some nulls or some empty strings\n        if (shortestStrLen == 0) {\n            return 0;\n        }\n        // find the position with the first difference across all strings\n        int firstDiff = -1;\n        for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {\n            char comparisonChar = strs[0].charAt(stringPos);\n            for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {\n                if (strs[arrayPos].charAt(stringPos) != comparisonChar) {\n                    firstDiff = stringPos;\n                    break;\n                }\n            }\n            if (firstDiff != -1) {\n                break;\n            }\n        }\n        if (firstDiff == -1 && shortestStrLen != longestStrLen) {\n            // we compared all of the characters up to the length of the\n            // shortest string and didn't find a match, but the string lengths\n            // vary, so return the length of the shortest string.\n            return shortestStrLen;\n        }\n        return firstDiff;\n    }\n\n    /**\n     * <p>Compares all Strings in an array and returns the initial sequence of\n     * characters that is common to all of them.</p>\n     *\n     * <p>For example,\n     * <code>getCommonPrefix(new String[] {\"i am a machine\", \"i am a robot\"}) -> \"i am a \"</code></p>\n     *\n     * <pre>\n     * StringUtils.getCommonPrefix(null) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"abc\"}) = \"abc\"\n     * StringUtils.getCommonPrefix(new String[] {null, null}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"\", \"\"}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"\", null}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"abc\", null, null}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {null, null, \"abc\"}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"\", \"abc\"}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"abc\", \"\"}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"abc\", \"abc\"}) = \"abc\"\n     * StringUtils.getCommonPrefix(new String[] {\"abc\", \"a\"}) = \"a\"\n     * StringUtils.getCommonPrefix(new String[] {\"ab\", \"abxyz\"}) = \"ab\"\n     * StringUtils.getCommonPrefix(new String[] {\"abcde\", \"abxyz\"}) = \"ab\"\n     * StringUtils.getCommonPrefix(new String[] {\"abcde\", \"xyz\"}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"xyz\", \"abcde\"}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"i am a machine\", \"i am a robot\"}) = \"i am a \"\n     * </pre>\n     *\n     * @param strs  array of String objects, entries may be null\n     * @return the initial sequence of characters that are common to all Strings\n     * in the array; empty String if the array is null, the elements are all null\n     * or if there is no common prefix.\n     * @since 2.4\n     */\n    public static String getCommonPrefix(final String[] strs) {\n        if (strs == null || strs.length == 0) {\n            return StringUtils.EMPTY;\n        }\n        int smallestIndexOfDiff = StringUtils.indexOfDifference(strs);\n        if (smallestIndexOfDiff == StringUtils.INDEX_NOT_FOUND) {\n            // all strings were identical\n            if (strs[0] == null) {\n                return StringUtils.EMPTY;\n            }\n            return strs[0];\n        } else if (smallestIndexOfDiff == 0) {\n            // there were no common initial characters\n            return StringUtils.EMPTY;\n        } else {\n            // we found a common initial character sequence\n            return strs[0].substring(0, smallestIndexOfDiff);\n        }\n    }\n    // Misc\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Find the Levenshtein distance between two Strings.</p>\n     *\n     * <p>This is the number of changes needed to change one String into\n     * another, where each change is a single character modification (deletion,\n     * insertion or substitution).</p>\n     *\n     * <p>The previous implementation of the Levenshtein distance algorithm\n     * was from <a href=\"http://www.merriampark.com/ld.htm\">http://www.merriampark.com/ld.htm</a></p>\n     *\n     * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError\n     * which can occur when my Java implementation is used with very large strings.<br>\n     * This implementation of the Levenshtein distance algorithm\n     * is from <a href=\"http://www.merriampark.com/ldjava.htm\">http://www.merriampark.com/ldjava.htm</a></p>\n     *\n     * <pre>\n     * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException\n     * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException\n     * StringUtils.getLevenshteinDistance(\"\",\"\")               = 0\n     * StringUtils.getLevenshteinDistance(\"\",\"a\")              = 1\n     * StringUtils.getLevenshteinDistance(\"aaapppp\", \"\")       = 7\n     * StringUtils.getLevenshteinDistance(\"frog\", \"fog\")       = 1\n     * StringUtils.getLevenshteinDistance(\"fly\", \"ant\")        = 3\n     * StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\") = 7\n     * StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\") = 7\n     * StringUtils.getLevenshteinDistance(\"hippo\", \"zzzzzzzz\") = 8\n     * StringUtils.getLevenshteinDistance(\"hello\", \"hallo\")    = 1\n     * </pre>\n     *\n     * @param s  the first String, must not be null\n     * @param t  the second String, must not be null\n     * @return result distance\n     * @throws IllegalArgumentException if either String input <code>null</code>\n     */\n    public static int getLevenshteinDistance(String s, String t) {\n        if (s == null || t == null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        }\n        /*\n           The difference between this impl. and the previous is that, rather\n           than creating and retaining a matrix of size s.length()+1 by t.length()+1,\n           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,\n           is the 'current working' distance array that maintains the newest distance cost\n           counts as we iterate through the characters of String s.  Each time we increment\n           the index of String t we are comparing, d is copied to p, the second int[].  Doing so\n           allows us to retain the previous cost counts as required by the algorithm (taking\n           the minimum of the cost count to the left, up one, and diagonally up and to the left\n           of the current cost count being calculated).  (Note that the arrays aren't really\n           copied anymore, just switched...this is clearly much better than cloning an array\n           or doing a System.arraycopy() each time  through the outer loop.)\n\n           Effectively, the difference between the two implementations is this one does not\n           cause an out of memory condition when calculating the LD over two very large strings.\n         */\n        int n = s.length(); // length of s\n        int m = t.length(); // length of t\n        if (n == 0) {\n            return m;\n        } else if (m == 0) {\n            return n;\n        }\n        if (n > m) {\n            // swap the input strings to consume less memory\n            String tmp = s;\n            s = t;\n            t = tmp;\n            n = m;\n            m = t.length();\n        }\n        int[] p = new int[n + 1]; //'previous' cost array, horizontally\n        int[] d = new int[n + 1]; // cost array, horizontally\n        int[] _d; //placeholder to assist in swapping p and d\n        // indexes into strings s and t\n        int i; // iterates through s\n        int j; // iterates through t\n        char t_j; // jth character of t\n        int cost; // cost\n        for (i = 0; i <= n; i++) {\n            p[i] = i;\n        }\n        for (j = 1; j <= m; j++) {\n            t_j = t.charAt(j - 1);\n            d[0] = j;\n            for (i = 1; i <= n; i++) {\n                cost = s.charAt(i - 1) == t_j ? 0 : 1;\n                // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n                d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);\n            }\n            // copy current distance counts to 'previous row' distance counts\n            _d = p;\n            p = d;\n            d = _d;\n        }\n        // our last action in the above loop was to switch d and p, so p now\n        // actually has the most recent cost counts\n        return p[n];\n    }\n    // startsWith\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Check if a String starts with a specified prefix.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered to be equal. The comparison is case sensitive.</p>\n     *\n     * <pre>\n     * StringUtils.startsWith(null, null)      = true\n     * StringUtils.startsWith(null, \"abc\")     = false\n     * StringUtils.startsWith(\"abcdef\", null)  = false\n     * StringUtils.startsWith(\"abcdef\", \"abc\") = true\n     * StringUtils.startsWith(\"ABCDEF\", \"abc\") = false\n     * </pre>\n     *\n     * @see String#startsWith(String)\n     * @param str  the String to check, may be null\n     * @param prefix the prefix to find, may be null\n     * @return <code>true</code> if the String starts with the prefix, case sensitive, or\n     *  both <code>null</code>\n     * @since 2.4\n     */\n    public static boolean startsWith(final String str, final String prefix) {\n        return StringUtils.startsWith(str, prefix, false);\n    }\n\n    /**\n     * <p>Case insensitive check if a String starts with a specified prefix.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered to be equal. The comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.startsWithIgnoreCase(null, null)      = true\n     * StringUtils.startsWithIgnoreCase(null, \"abc\")     = false\n     * StringUtils.startsWithIgnoreCase(\"abcdef\", null)  = false\n     * StringUtils.startsWithIgnoreCase(\"abcdef\", \"abc\") = true\n     * StringUtils.startsWithIgnoreCase(\"ABCDEF\", \"abc\") = true\n     * </pre>\n     *\n     * @see String#startsWith(String)\n     * @param str  the String to check, may be null\n     * @param prefix the prefix to find, may be null\n     * @return <code>true</code> if the String starts with the prefix, case insensitive, or\n     *  both <code>null</code>\n     * @since 2.4\n     */\n    public static boolean startsWithIgnoreCase(final String str, final String prefix) {\n        return StringUtils.startsWith(str, prefix, true);\n    }\n\n    /**\n     * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n     *\n     * @see String#startsWith(String)\n     * @param str  the String to check, may be null\n     * @param prefix the prefix to find, may be null\n     * @param ignoreCase inidicates whether the compare should ignore case\n     *  (case insensitive) or not.\n     * @return <code>true</code> if the String starts with the prefix or\n     *  both <code>null</code>\n     */\n    private static boolean startsWith(final String str, final String prefix, final boolean ignoreCase) {\n        if (str == null || prefix == null) {\n            return str == null && prefix == null;\n        }\n        if (prefix.length() > str.length()) {\n            return false;\n        }\n        return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n    }\n\n    /**\n     * <p>Check if a String starts with any of an array of specified strings.</p>\n     *\n     * <pre>\n     * StringUtils.startsWithAny(null, null)      = false\n     * StringUtils.startsWithAny(null, new String[] {\"abc\"})  = false\n     * StringUtils.startsWithAny(\"abcxyz\", null)     = false\n     * StringUtils.startsWithAny(\"abcxyz\", new String[] {\"\"}) = false\n     * StringUtils.startsWithAny(\"abcxyz\", new String[] {\"abc\"}) = true\n     * StringUtils.startsWithAny(\"abcxyz\", new String[] {null, \"xyz\", \"abc\"}) = true\n     * </pre>\n     *\n     * @see #startsWith(String, String)\n     * @param string  the String to check, may be null\n     * @param searchStrings the Strings to find, may be null or empty\n     * @return <code>true</code> if the String starts with any of the the prefixes, case insensitive, or\n     *  both <code>null</code>\n     * @since 2.5\n     */\n    public static boolean startsWithAny(final String string, final String[] searchStrings) {\n        if (StringUtils.isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n            return false;\n        }\n        for (String searchString : searchStrings) {\n            if (StringUtils.startsWith(string, searchString)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // endsWith\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Check if a String ends with a specified suffix.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered to be equal. The comparison is case sensitive.</p>\n     *\n     * <pre>\n     * StringUtils.endsWith(null, null)      = true\n     * StringUtils.endsWith(null, \"def\")     = false\n     * StringUtils.endsWith(\"abcdef\", null)  = false\n     * StringUtils.endsWith(\"abcdef\", \"def\") = true\n     * StringUtils.endsWith(\"ABCDEF\", \"def\") = false\n     * StringUtils.endsWith(\"ABCDEF\", \"cde\") = false\n     * </pre>\n     *\n     * @see String#endsWith(String)\n     * @param str  the String to check, may be null\n     * @param suffix the suffix to find, may be null\n     * @return <code>true</code> if the String ends with the suffix, case sensitive, or\n     *  both <code>null</code>\n     * @since 2.4\n     */\n    public static boolean endsWith(final String str, final String suffix) {\n        return StringUtils.endsWith(str, suffix, false);\n    }\n\n    /**\n     * <p>Case insensitive check if a String ends with a specified suffix.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered to be equal. The comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.endsWithIgnoreCase(null, null)      = true\n     * StringUtils.endsWithIgnoreCase(null, \"def\")     = false\n     * StringUtils.endsWithIgnoreCase(\"abcdef\", null)  = false\n     * StringUtils.endsWithIgnoreCase(\"abcdef\", \"def\") = true\n     * StringUtils.endsWithIgnoreCase(\"ABCDEF\", \"def\") = true\n     * StringUtils.endsWithIgnoreCase(\"ABCDEF\", \"cde\") = false\n     * </pre>\n     *\n     * @see String#endsWith(String)\n     * @param str  the String to check, may be null\n     * @param suffix the suffix to find, may be null\n     * @return <code>true</code> if the String ends with the suffix, case insensitive, or\n     *  both <code>null</code>\n     * @since 2.4\n     */\n    public static boolean endsWithIgnoreCase(final String str, final String suffix) {\n        return StringUtils.endsWith(str, suffix, true);\n    }\n\n    /**\n     * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n     *\n     * @see String#endsWith(String)\n     * @param str  the String to check, may be null\n     * @param suffix the suffix to find, may be null\n     * @param ignoreCase inidicates whether the compare should ignore case\n     *  (case insensitive) or not.\n     * @return <code>true</code> if the String starts with the prefix or\n     *  both <code>null</code>\n     */\n    private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n        if (str == null || suffix == null) {\n            return str == null && suffix == null;\n        }\n        if (suffix.length() > str.length()) {\n            return false;\n        }\n        int strOffset = str.length() - suffix.length();\n        return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n    }\n\n    /**\n     * <p>\n     * Similar to <a\n     * href=\"http://www.w3.org/TR/xpath/#function-normalize-space\">http://www.w3.org/TR/xpath/#function-normalize\n     * -space</a>\n     * </p>\n     * <p>\n     * The function returns the argument string with whitespace normalized by using\n     * <code>{@link #trim(String)}</code> to remove leading and trailing whitespace\n     * and then replacing sequences of whitespace characters by a single space.\n     * </p>\n     * In XML Whitespace characters are the same as those allowed by the <a\n     * href=\"http://www.w3.org/TR/REC-xml/#NT-S\">S</a> production, which is S ::= (#x20 | #x9 | #xD | #xA)+\n     * <p>\n     * See Java's {@link Character#isWhitespace(char)} for which characters are considered whitespace.\n     * <p>\n     * The difference is that Java's whitespace includes vertical tab and form feed, which this functional will also\n     * normalize. Additonally <code>{@link #trim(String)}</code> removes control characters (char &lt;= 32) from both\n     * ends of this String.\n     * </p>\n     *\n     * @see Character#isWhitespace(char)\n     * @see #trim(String)\n     * @see <ahref=\"http://www.w3.org/TR/xpath/#function-normalize-space\">\n     *              http://www.w3.org/TR/xpath/#function-normalize-space</a>\n     * @param str the source String to normalize whitespaces from, may be null\n     * @return the modified string with whitespace normalized, <code>null</code> if null String input\n     *\n     * @since 2.6\n     */\n    public static String normalizeSpace(String str) {\n        str = StringUtils.strip(str);\n        if (str == null || str.length() <= 2) {\n            return str;\n        }\n        StringBuilder b = new StringBuilder(str.length());\n        for (int i = 0; i < str.length(); i++) {\n            char c = str.charAt(i);\n            if (Character.isWhitespace(c)) {\n                if (i > 0 && !Character.isWhitespace(str.charAt(i - 1))) {\n                    b.append(' ');\n                }\n            } else {\n                b.append(c);\n            }\n        }\n        return b.toString();\n    }\n\n    /**\n     * <p>Check if a String ends with any of an array of specified strings.</p>\n     *\n     * <pre>\n     * StringUtils.endsWithAny(null, null)      = false\n     * StringUtils.endsWithAny(null, new String[] {\"abc\"})  = false\n     * StringUtils.endsWithAny(\"abcxyz\", null)     = false\n     * StringUtils.endsWithAny(\"abcxyz\", new String[] {\"\"}) = true\n     * StringUtils.endsWithAny(\"abcxyz\", new String[] {\"xyz\"}) = true\n     * StringUtils.endsWithAny(\"abcxyz\", new String[] {null, \"xyz\", \"abc\"}) = true\n     * </pre>\n     *\n     * @param string  the String to check, may be null\n     * @param searchStrings the Strings to find, may be null or empty\n     * @return <code>true</code> if the String ends with any of the the prefixes, case insensitive, or\n     *  both <code>null</code>\n     * @since 2.6\n     */\n    public static boolean endsWithAny(final String string, final String[] searchStrings) {\n        if (StringUtils.isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n            return false;\n        }\n        for (String searchString : searchStrings) {\n            if (StringUtils.endsWith(string, searchString)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * \n     * <pre>\n     * StringUtils.firstCharToUpperCase(null)      = null\n     * StringUtils.firstCharToUpperCase(\"\")        = \"\"\n     * StringUtils.firstCharToUpperCase(\"abc\")     = \"Abc\"\n     * StringUtils.firstCharToUpperCase(\"Abc\")     = \"Abc\"\n     * StringUtils.firstCharToUpperCase(\"ABC\")     = \"ABC\"\n     * </pre>\n     */\n    public static String firstCharToUpperCase(final String value) {\n        if (StringUtils.isBlank(value)) {\n            return value;\n        }\n        StringBuilder sb = new StringBuilder(value);\n        char firstChar = sb.charAt(0);\n        sb.delete(0, 1);\n        sb.insert(0, (char) (firstChar >= 97 ? firstChar - 32 : firstChar));\n        return sb.toString();\n    }\n\n    /**\n     * \n     * <pre>\n     * StringUtils.firstCharToLowerCase(null)      = null\n     * StringUtils.firstCharToLowerCase(\"\")        = \"\"\n     * StringUtils.firstCharToLowerCase(\"abc\")     = \"abc\"\n     * StringUtils.firstCharToLowerCase(\"Abc\")     = \"abc\"\n     * StringUtils.firstCharToLowerCase(\"ABC\")     = \"aBC\"\n     * </pre>\n     */\n    public static String firstCharToLowerCase(final String value) {\n        if (StringUtils.isBlank(value)) {\n            return value;\n        }\n        StringBuilder sb = new StringBuilder(value);\n        char firstChar = sb.charAt(0);\n        sb.delete(0, 1);\n        sb.insert(0, (char) (firstChar <= 90 ? firstChar + 32 : firstChar));\n        return sb.toString();\n    }\n\n    /**\n     * \n     * <pre>\n     * StringUtils.equalsBlankIgnoreCase(null,\"\")         = true\n     * StringUtils.equalsBlankIgnoreCase(\"\",\"\")           = true\n     * StringUtils.equalsBlankIgnoreCase(\" \",\"\")          = true\n     * StringUtils.equalsBlankIgnoreCase(\" \",null)        = true\n     * StringUtils.equalsBlankIgnoreCase(\"bob\",\"\")        = false\n     * StringUtils.equalsBlankIgnoreCase(\"  bob  \",\"bob\") = true\n     * </pre>\n     */\n    public static boolean equalsBlankIgnoreCase(final String str1, final String str2) {\n        return StringUtils.equalsIgnoreCase(StringUtils.trimToEmpty(str1), StringUtils.trimToEmpty(str2));\n    }\n\n    /* ------------------------------------------------------------ */\n    private static final char[] escapes = new char[32];\n\n    static {\n        Arrays.fill(escapes, (char) 0xFFFF);\n        escapes['\\b'] = 'b';\n        escapes['\\t'] = 't';\n        escapes['\\n'] = 'n';\n        escapes['\\f'] = 'f';\n        escapes['\\r'] = 'r';\n    }\n\n    /** Quote a string into an Appendable.\n     * The characters \", \\, \\n, \\r, \\t, \\f and \\b are escaped\n     * @param input The String to quote.\n     */\n    public static String quote(String input) {\n        StringBuilder buffer = new StringBuilder();\n        quote(buffer, input);\n        return buffer.toString();\n    }\n\n    public static void quote(Appendable buffer, String input) {\n        try {\n            buffer.append('\"');\n            for (int i = 0; i < input.length(); ++i) {\n                char c = input.charAt(i);\n                if (c >= 32) {\n                    if (c == '\"' || c == '\\\\')\n                        buffer.append('\\\\');\n                    buffer.append(c);\n                } else {\n                    char escape = escapes[c];\n                    if (escape == 0xFFFF) {\n                        // Unicode escape\n                        buffer.append('\\\\').append('u').append('0').append('0');\n                        if (c < 0x10)\n                            buffer.append('0');\n                        buffer.append(Integer.toString(c, 16));\n                    } else {\n                        buffer.append('\\\\').append(escape);\n                    }\n                }\n            }\n            buffer.append('\"');\n        } catch (IOException x) {\n            throw new RuntimeException(x);\n        }\n    }\n\n    /** Object to String ,when null object then null else return toString(); */\n    public static String toString(Object object) {\n        return (object == null) ? null : object.toString();\n    }\n}",
            "file_name": "StringUtils.java",
            "human_label": "Determines whether a character string ends with a specified suffix.",
            "level": "self_contained",
            "lineno": "5925",
            "name": "endsWith",
            "oracle_context": "{ \"apis\" : \"[length, regionMatches]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
            "package": "net.hasor.utils",
            "project": "hasor-master"
        },
        {
            "_id": "6367667f1a6d9265ec01745d",
            "all_context": "{ \"class_level\" : \"import java.io.UnsupportedEncodingException;\\nimport java.net.URI;\\nimport java.net.URLDecoder;\\nimport java.nio.Buffer;\\nimport java.nio.ByteBuffer;\\nimport java.nio.CharBuffer;\\nimport java.nio.charset.Charset;\\nimport java.nio.charset.StandardCharsets;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collections;\\nimport java.util.HashMap;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Map;\\nchar[] HEX_DIGITS;\\nString[] SCHEME;\\nString[] UNRESERVED;\\nString[] SUB_DELIMS;\\nboolean[][] ENCODING_TABLES;\\nCharset UTF_8_CHARSET;\\nPathSegmentImpl EMPTY_PATH_SEGMENT;\\nString path;\\nMap<String,String> matrixParameters;\\nint[] HEX_TABLE;\\nUriComponent();\\nvalidate(String s,Type t,boolean template);\\nvalid(String s,Type t);\\nvalid(String s,Type t,boolean template);\\n_valid(String s,Type t,boolean template);\\ncontextualEncode(String s,Type t);\\ncontextualEncode(String s,Type t,boolean template);\\nencode(String s,Type t);\\nencode(String s,Type t,boolean template);\\nencodeTemplateNames(String s);\\n_encode(String s,Type t,boolean template,boolean contextualEncode);\\nappendPercentEncodedOctet(StringBuilder sb,int b);\\nappendUTF8EncodedCharacter(StringBuilder sb,char c);\\ncreatingEncodingTables();\\ncreatingEncodingTable(List allowed);\\ndecode(String s,Type t);\\ndecodeQuery(URI u,boolean decode);\\ndecodeQuery(String q,boolean decode);\\ndecodeQueryParam(Map params,String param,boolean decode);\\nPathSegmentImpl(String path,boolean decode);\\nPathSegmentImpl(String path,boolean decode,Map matrixParameters);\\ngetPath();\\ngetMatrixParameters();\\ndecodePath(URI u,boolean decode);\\ndecodePath(String path,boolean decode);\\ndecodePathSegment(List segments,String segment,boolean decode);\\ndecodeMatrix(String pathSegment,boolean decode);\\ndecodeMatrixParam(Map params,String param,boolean decode);\\ndecode(String s,int n);\\ndecodeQueryParam(String s,int n);\\ndecodeHost(String s,int n);\\ndecodePercentEncodedOctets(String s,int i,ByteBuffer bb);\\ndecodeOctets(int i,ByteBuffer bb,StringBuilder sb);\\ndecodeHex(String s,int i);\\ncreateHexTable();\\ndecodeHex(char c);\\nisHexCharacter(char c);\\nvalidate(String s,Type t);\\n\", \"repo_level\" : \"\" }",
            "class_name": "UriComponent",
            "code": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n  String rawPath=u.getRawPath();\n  if (rawPath != null && rawPath.length() > 0 && rawPath.charAt(0) == '/') {\n    rawPath=rawPath.substring(1);\n  }\n  return decodePath(rawPath,decode);\n}\n",
            "docstring": "/** \n * Decode the path component of a URI as path segments.\n * @param u the URI. If the path component is an absolute path componentthen the leading '/' is ignored and is not considered a delimiator of a path segment.\n * @param decode true if the path segments of the path componentshould be in decoded form.\n * @return the list of path segments.\n */\n",
            "end_lineno": "591",
            "file_content": "/*\n * Copyright 2008-2022 Async-IO.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n *\n * Copyright (c) 2010-2018 Oracle and/or its affiliates. All rights reserved.\n *\n * The contents of this file are subject to the terms of either the GNU\n * General Public License Version 2 only (\"GPL\") or the Common Development\n * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n * may not use this file except in compliance with the License.  You can\n * obtain a copy of the License at\n * http://glassfish.java.net/public/CDDL+GPL_1_1.html\n * or packager/legal/LICENSE.txt.  See the License for the specific\n * language governing permissions and limitations under the License.\n *\n * When distributing the software, include this License Header Notice in each\n * file and include the License file at packager/legal/LICENSE.txt.\n *\n * GPL Classpath Exception:\n * Oracle designates this particular file as subject to the \"Classpath\"\n * exception as provided by Oracle in the GPL Version 2 section of the License\n * file that accompanied this code.\n *\n * Modifications:\n * If applicable, add the following below the License Header, with the fields\n * enclosed by brackets [] replaced by your own identifying information:\n * \"Portions Copyright [year] [name of copyright owner]\"\n *\n * Contributor(s):\n * If you wish your version of this file to be governed by only the CDDL or\n * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n * elects to include this software in this distribution under the [CDDL or GPL\n * Version 2] license.\"  If you don't indicate a single choice of license, a\n * recipient has the option to distribute your version of this file under\n * either the CDDL, the GPL Version 2 or to extend the choice of license to\n * its licensees as provided above.  However, if you add GPL Version 2 code\n * and therefore, elected the GPL Version 2 license, then the option applies\n * only if the new code is made subject to such option by the copyright\n * holder.\n */\npackage org.atmosphere.util.uri;\n\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLDecoder;\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Utility class for validating, encoding and decoding components\n * of a URI.\n *\n * @author Paul.Sandoz@Sun.Com\n */\npublic class UriComponent {\n\n    // TODO rewrite to use masks and not lookup tables\n    /**\n     * The URI component type.\n     */\n    public enum Type {\n\n        /**\n         * ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\" characters\n         */\n        UNRESERVED,\n        /**\n         * The URI scheme component type.\n         */\n        SCHEME,\n        /**\n         * The URI authority component type.\n         */\n        AUTHORITY,\n        /**\n         * The URI user info component type.\n         */\n        USER_INFO,\n        /**\n         * The URI host component type.\n         */\n        HOST,\n        /**\n         * The URI port component type.\n         */\n        PORT,\n        /**\n         * The URI path component type.\n         */\n        PATH,\n        /**\n         * The URI path component type that is a path segment.\n         */\n        PATH_SEGMENT,\n        /**\n         * The URI path component type that is a matrix parameter.\n         */\n        MATRIX_PARAM,\n        /**\n         * The URI query component type.\n         */\n        QUERY,\n        /**\n         * The URI query component type that is a query parameter.\n         */\n        QUERY_PARAM,\n        /**\n         * The URI fragment component type.\n         */\n        FRAGMENT,\n    }\n\n    private UriComponent() {\n    }\n\n    /**\n     * Validates the legal characters of a percent-encoded string that \n     * represents a URI component type.\n     *\n     * @param s the encoded string.\n     * @param t the URI compontent type identifying the legal characters.\n     * @throws IllegalArgumentException if the encoded string contains illegal\n     *         characters.\n     */\n    public static void validate(String s, Type t) {\n        validate(s, t, false);\n    }\n\n    /**\n     * Validates the legal characters of a percent-encoded string that \n     * represents a URI component type.\n     *\n     * @param s the encoded string.\n     * @param t the URI compontent type identifying the legal characters.\n     * @param template true if the encoded string contains URI template variables\n     * @throws IllegalArgumentException if the encoded string contains illegal\n     *         characters.\n     */\n    public static void validate(String s, Type t, boolean template) {\n        int i = _valid(s, t, template);\n        if (i > -1) // TODO localize\n        {\n            throw new IllegalArgumentException(\"The string '\" + s +\n                    \"' for the URI component \" + t +\n                    \" contains an invalid character, '\" + s.charAt(i) + \"', at index \" + i);\n        }\n    }\n\n    /**\n     * Validates the legal characters of a percent-encoded string that \n     * represents a URI component type.\n     *\n     * @param s the encoded string.\n     * @param t the URI compontent type identifying the legal characters.\n     * @return true if the encoded string is valid, otherwise false.\n     */\n    public static boolean valid(String s, Type t) {\n        return valid(s, t, false);\n    }\n\n    /**\n     * Validates the legal characters of a percent-encoded string that \n     * represents a URI component type.\n     *\n     * @param s the encoded string.\n     * @param t the URI compontent type identifying the legal characters.\n     * @param template true if the encoded string contains URI template variables\n     * @return true if the encoded string is valid, otherwise false.\n     */\n    public static boolean valid(String s, Type t, boolean template) {\n        return _valid(s, t, template) == -1;\n    }\n\n    private static int _valid(String s, Type t, boolean template) {\n        boolean[] table = ENCODING_TABLES[t.ordinal()];\n\n        for (int i = 0; i < s.length(); i++) {\n            final char c = s.charAt(i);\n            if (c >= 0x80 || (c != '%' && !table[c])) {\n                if (!template || (c != '{' && c != '}')) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Contextually encodes the characters of string that are either non-ASCII\n     * characters or are ASCII characters that must be percent-encoded using the\n     * UTF-8 encoding. Percent-encoded characters will be recognized and not\n     * double encoded.\n     *\n     * @param s the string to be encoded.\n     * @param t the URI compontent type identifying the ASCII characters that \n     *          must be percent-encoded.\n     * @return the encoded string.\n     */\n    public static String contextualEncode(String s, Type t) {\n        return _encode(s, t, false, true);\n    }\n\n    /**\n     * Contextually encodes the characters of string that are either non-ASCII\n     * characters or are ASCII characters that must be percent-encoded using the\n     * UTF-8 encoding. Percent-encoded characters will be recognized and not\n     * double encoded.\n     *\n     * @param s the string to be encoded.\n     * @param t the URI compontent type identifying the ASCII characters that \n     *          must be percent-encoded.\n     * @param template true if the encoded string contains URI template variables\n     * @return the encoded string.\n     */\n    public static String contextualEncode(String s, Type t, boolean template) {\n        return _encode(s, t, template, true);\n    }\n\n    /**\n     * Encodes the characters of string that are either non-ASCII characters \n     * or are ASCII characters that must be percent-encoded using the \n     * UTF-8 encoding.\n     *\n     * @param s the string to be encoded.\n     * @param t the URI compontent type identifying the ASCII characters that \n     *          must be percent-encoded.\n     * @return the encoded string.\n     */\n    public static String encode(String s, Type t) {\n        return _encode(s, t, false, false);\n    }\n\n    /**\n     * Encodes the characters of string that are either non-ASCII characters \n     * or are ASCII characters that must be percent-encoded using the \n     * UTF-8 encoding.\n     *\n     * @param s the string to be encoded.\n     * @param t the URI compontent type identifying the ASCII characters that \n     *          must be percent-encoded.\n     * @param template true if the encoded string contains URI template variables\n     * @return the encoded string.\n     */\n    public static String encode(String s, Type t, boolean template) {\n        return _encode(s, t, template, false);\n    }\n\n    /**\n     * Encodes a string with template parameters names present, specifically the\n     * characters '{' and '}' will be percent-encoded.\n     * \n     * @param s the string with zero or more template parameters names\n     * @return the string with encoded template parameters names.\n     */\n    public static String encodeTemplateNames(String s) {\n        int i = s.indexOf('{');\n        if (i != -1)\n            s = s.replace(\"{\", \"%7B\");\n        i = s.indexOf('}');\n        if (i != -1)\n            s = s.replace(\"}\", \"%7D\");\n\n        return s;\n    }\n\n    private static String _encode(String s, Type t, boolean template, boolean contextualEncode) {\n        final boolean[] table = ENCODING_TABLES[t.ordinal()];\n\n        StringBuilder sb = null;\n        for (int i = 0; i < s.length(); i++) {\n            final char c = s.charAt(i);\n            if (c < 0x80 && table[c]) {\n                if (sb != null) sb.append(c);\n            } else {\n                if (template && (c == '{' || c == '}')) {\n                    if (sb != null) sb.append(c);\n                    continue;\n                } else if (contextualEncode) {\n                    if (c == '%' && i + 2 < s.length()) {\n                        if (isHexCharacter(s.charAt(i + 1)) &&\n                                isHexCharacter(s.charAt(i + 2))) {\n                            if (sb != null)\n                                sb.append('%').append(s.charAt(i + 1)).append(s.charAt(i + 2));\n                            i += 2;\n                            continue;\n                        }\n                    }\n                }\n\n                if (sb == null) {\n                    sb = new StringBuilder();\n                    sb.append(s, 0, i);\n                }\n\n                if (c < 0x80) {\n                    if (c == ' ' && (t == Type.QUERY_PARAM)) {\n                        sb.append('+');\n                    } else {\n                        appendPercentEncodedOctet(sb, c);\n                    }\n                } else {\n                    appendUTF8EncodedCharacter(sb, c);\n                }\n            }\n        }\n\n        return (sb == null) ? s : sb.toString();\n    }\n    private final static char[] HEX_DIGITS = {\n        '0', '1', '2', '3', '4', '5', '6', '7',\n        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n    };\n\n    private static void appendPercentEncodedOctet(StringBuilder sb, int b) {\n        sb.append('%');\n        sb.append(HEX_DIGITS[b >> 4]);\n        sb.append(HEX_DIGITS[b & 0x0F]);\n    }\n\n    private static void appendUTF8EncodedCharacter(StringBuilder sb, char c) {\n        final ByteBuffer bb = UTF_8_CHARSET.encode(\"\" + c);\n\n        while (bb.hasRemaining()) {\n            appendPercentEncodedOctet(sb, bb.get() & 0xFF);\n        }\n    }\n    private static final String[] SCHEME = {\"0-9\", \"A-Z\", \"a-z\", \"+\", \"-\", \".\"};\n    private static final String[] UNRESERVED = {\"0-9\", \"A-Z\", \"a-z\", \"-\", \".\", \"_\", \"~\"};\n    private static final String[] SUB_DELIMS = {\"!\", \"$\", \"&\", \"'\", \"(\", \")\", \"*\", \"+\", \",\", \";\", \"=\"};\n    private static final boolean[][] ENCODING_TABLES = creatingEncodingTables();\n\n    private static boolean[][] creatingEncodingTables() {\n        boolean[][] tables = new boolean[Type.values().length][];\n\n        List<String> l = new ArrayList<>(Arrays.asList(SCHEME));\n        tables[Type.SCHEME.ordinal()] = creatingEncodingTable(l);\n\n        l.clear();\n\n        l.addAll(Arrays.asList(UNRESERVED));\n        tables[Type.UNRESERVED.ordinal()] = creatingEncodingTable(l);\n\n        l.addAll(Arrays.asList(SUB_DELIMS));\n\n        tables[Type.HOST.ordinal()] = creatingEncodingTable(l);\n\n        tables[Type.PORT.ordinal()] = creatingEncodingTable(Collections.singletonList(\"0-9\"));\n\n        l.add(\":\");\n\n        tables[Type.USER_INFO.ordinal()] = creatingEncodingTable(l);\n\n        l.add(\"@\");\n\n        tables[Type.AUTHORITY.ordinal()] = creatingEncodingTable(l);\n\n        tables[Type.PATH_SEGMENT.ordinal()] = creatingEncodingTable(l);\n        tables[Type.PATH_SEGMENT.ordinal()][';'] = false;\n\n        tables[Type.MATRIX_PARAM.ordinal()] = tables[Type.PATH_SEGMENT.ordinal()].clone();\n        tables[Type.MATRIX_PARAM.ordinal()]['='] = false;\n\n        l.add(\"/\");\n\n        tables[Type.PATH.ordinal()] = creatingEncodingTable(l);\n\n        l.add(\"?\");\n\n        tables[Type.QUERY.ordinal()] = creatingEncodingTable(l);\n\n        tables[Type.FRAGMENT.ordinal()] = tables[Type.QUERY.ordinal()];\n\n        tables[Type.QUERY_PARAM.ordinal()] = creatingEncodingTable(l);\n        tables[Type.QUERY_PARAM.ordinal()]['='] = false;\n        tables[Type.QUERY_PARAM.ordinal()]['+'] = false;\n        tables[Type.QUERY_PARAM.ordinal()]['&'] = false;\n\n        return tables;\n    }\n\n    private static boolean[] creatingEncodingTable(List<String> allowed) {\n        boolean[] table = new boolean[0x80];\n        for (String range : allowed) {\n            if (range.length() == 1) {\n                table[range.charAt(0)] = true;\n            } else if (range.length() == 3 && range.charAt(1) == '-') {\n                for (int i = range.charAt(0); i <= range.charAt(2); i++) {\n                    table[i] = true;\n                }\n            }\n        }\n\n        return table;\n    }\n    private static final Charset UTF_8_CHARSET = StandardCharsets.UTF_8;\n\n    /**\n     * Decodes characters of a string that are percent-encoded octets using \n     * UTF-8 decoding (if needed).\n     * <p>\n     * It is assumed that the string is valid according to an (unspecified) URI \n     * component type. If a sequence of contiguous percent-encoded octets is \n     * not a valid UTF-8 character then the octets are replaced with '\\uFFFD'.\n     * <p>\n     * If the URI component is of type HOST then any \"%\" found between \"[]\" is \n     * left alone. It is an IPv6 literal with a scope_id.\n     * <p>\n     * If the URI component is of type QUERY_PARAM then any \"+\" is decoded as\n     * as ' '.\n     * <p>\n     * @param s the string to be decoded.\n     * @param t the URI component type, may be null.\n     * @return the decoded string.\n     * @throws IllegalArgumentException if a malformed percent-encoded octet is\n     *         detected\n     */\n    public static String decode(String s, Type t) {\n        if (s == null) {\n            throw new IllegalArgumentException();\n        }\n\n        final int n = s.length();\n        if (n == 0) {\n            return s;\n        }\n\n        // If there are no percent-escaped octets\n        if (s.indexOf('%') < 0) {\n            // If there are no '+' characters for query param\n            if (t == Type.QUERY_PARAM) {\n                if (s.indexOf('+') < 0) {\n                    return s;\n                }\n            } else {\n                return s;\n            }\n        } else {\n            // Malformed percent-escaped octet at the end\n            if (n < 2) // TODO localize\n            {\n                throw new IllegalArgumentException(\"Malformed percent-encoded octet at index 1\");\n            }\n\n            // Malformed percent-escaped octet at the end\n            if (s.charAt(n - 2) == '%') // TODO localize\n            {\n                throw new IllegalArgumentException(\"Malformed percent-encoded octet at index \" + (n - 2));\n            }\n        }\n\n        if (t == null)\n            return decode(s, n);\n        \n        switch (t) {\n            case HOST :\n                return decodeHost(s, n);\n            case QUERY_PARAM :\n                return decodeQueryParam(s, n);\n            default :\n                return decode(s, n);\n        }\n    }\n\n    /**\n     * Decode the query component of a URI.\n     * \n     * @param u the URI.\n     * @param decode true if the query parameters of the query component\n     *        should be in decoded form.\n     * @return the multivalued map of query parameters.\n     */\n    public static Map<String, String> decodeQuery(URI u, boolean decode) {\n        return decodeQuery(u.getRawQuery(), decode);\n    }\n\n    /**\n     * Decode the query component of a URI.\n     * \n     * @param q the query component in encoded form.\n     * @param decode true of the query parameters of the query component\n     *        should be in decoded form.\n     * @return the multivalued map of query parameters.\n     */\n    public static Map<String, String> decodeQuery(String q, boolean decode) {\n        Map<String, String> queryParameters = new HashMap<>();\n\n        if (q == null || q.length() == 0) {\n            return queryParameters;\n        }\n\n        int s = 0, e;\n        do {\n            e = q.indexOf('&', s);\n\n            if (e == -1) {\n                decodeQueryParam(queryParameters, q.substring(s), decode);\n            } else if (e > s) {\n                decodeQueryParam(queryParameters, q.substring(s, e), decode);\n            }\n            s = e + 1;\n        } while (s > 0 && s < q.length());\n\n        return queryParameters;\n    }\n\n    private static void decodeQueryParam(Map<String, String> params,\n            String param, boolean decode) {\n        try {\n            int equals = param.indexOf('=');\n            if (equals > 0) {\n                params.put(\n                        URLDecoder.decode(param.substring(0, equals), \"UTF-8\"),\n                        (decode) ? URLDecoder.decode(param.substring(equals + 1), \"UTF-8\") : param.substring(equals + 1));\n            } else if (equals == 0) {\n                // no key declared, ignore\n            } else if (param.length() > 0) {\n                params.put(\n                        URLDecoder.decode(param, \"UTF-8\"),\n                        \"\");\n            }\n        } catch (UnsupportedEncodingException ex) {\n            // This should never occur\n            throw new IllegalArgumentException(ex);\n        }\n    }\n\n    private static final class PathSegmentImpl  {\n\n        private static final PathSegmentImpl EMPTY_PATH_SEGMENT = new PathSegmentImpl(\"\", false);\n        private final String path;\n        private final Map<String, String> matrixParameters;\n\n        PathSegmentImpl(String path, boolean decode) {\n            this(path, decode, new HashMap<String, String> ());\n        }\n\n        PathSegmentImpl(String path, boolean decode, Map<String, String> matrixParameters) {\n            this.path = (decode) ? UriComponent.decode(path, UriComponent.Type.PATH_SEGMENT) : path;\n            this.matrixParameters = matrixParameters;\n        }\n\n        public String getPath() {\n            return path;\n        }\n\n        public Map<String, String> getMatrixParameters() {\n            return matrixParameters;\n        }\n    }\n\n    /**\n     * Decode the path component of a URI as path segments.\n     *\n     * @param u the URI. If the path component is an absolute path component\n     *        then the leading '/' is ignored and is not considered a delimiator\n     *        of a path segment.\n     * @param decode true if the path segments of the path component\n     *        should be in decoded form.\n     * @return the list of path segments.\n     */\n    public static List<PathSegmentImpl> decodePath(URI u, boolean decode) {\n        String rawPath = u.getRawPath();\n        if (rawPath != null && rawPath.length() > 0 && rawPath.charAt(0) == '/') {\n            rawPath = rawPath.substring(1);\n        }\n        return decodePath(rawPath, decode);\n    }\n\n    /**\n     * Decode the path component of a URI as path segments.\n     * <p>\n     * Any '/' character in the path is considered to be a deliminator\n     * between two path segments. Thus if the path is '/' then the path segment\n     * list will contain two empty path segments. If the path is \"//\" then\n     * the path segment list will contain three empty path segments. If the path\n     * is \"/a/\" the path segment list will consist of the following path\n     * segments in order: \"\", \"a\" and \"\".\n     *\n     * @param path the path component in encoded form.\n     * @param decode true if the path segments of the path component\n     *        should be in decoded form.\n     * @return the list of path segments.\n     */\n    public static List<PathSegmentImpl> decodePath(String path, boolean decode) {\n        List<PathSegmentImpl> segments = new LinkedList<>();\n\n        if (path == null) {\n            return segments;\n        }\n\n        int s;\n        int e = -1;\n        do {\n            s = e + 1;\n            e = path.indexOf('/', s);\n\n            if (e > s) {\n                decodePathSegment(segments, path.substring(s, e), decode);\n            } else if (e == s) {\n                segments.add(PathSegmentImpl.EMPTY_PATH_SEGMENT);\n            }\n        } while (e != -1);\n        if (s < path.length()) {\n            decodePathSegment(segments, path.substring(s), decode);\n        } else {\n            segments.add(PathSegmentImpl.EMPTY_PATH_SEGMENT);\n        }\n        return segments;\n    }\n\n    public static void decodePathSegment(List<PathSegmentImpl> segments, String segment, boolean decode) {\n        int colon = segment.indexOf(';');\n        if (colon != -1) {\n            segments.add(new PathSegmentImpl(\n                    (colon == 0) ? \"\" : segment.substring(0, colon),\n                    decode,\n                    decodeMatrix(segment, decode)));\n        } else {\n            segments.add(new PathSegmentImpl(\n                    segment,\n                    decode));\n        }\n    }\n\n    /**\n     * Decode the matrix component of a URI path segment.\n     *\n     * @param pathSegment the path segment component in encoded form.\n     * @param decode true if the matrix parameters of the path segment component\n     *        should be in decoded form.\n     * @return the multivalued map of matrix parameters.\n     */\n    public static Map<String, String> decodeMatrix(String pathSegment, boolean decode) {\n        Map<String, String> matrixMap = new HashMap<>();\n\n        // Skip over path segment\n        int s = pathSegment.indexOf(';') + 1;\n        if (s == 0 || s == pathSegment.length()) {\n            return matrixMap;\n        }\n\n        int e;\n        do {\n            e = pathSegment.indexOf(';', s);\n\n            if (e == -1) {\n                decodeMatrixParam(matrixMap, pathSegment.substring(s), decode);\n            } else if (e > s) {\n                decodeMatrixParam(matrixMap, pathSegment.substring(s, e), decode);\n            }\n            s = e + 1;\n        } while (s > 0 && s < pathSegment.length());\n\n        return matrixMap;\n    }\n\n    private static void decodeMatrixParam(Map<String, String> params,\n            String param, boolean decode) {\n        int equals = param.indexOf('=');\n        if (equals > 0) {\n            params.put(\n                    UriComponent.decode(param.substring(0, equals), UriComponent.Type.MATRIX_PARAM),\n                    (decode) ? UriComponent.decode(param.substring(equals + 1), UriComponent.Type.MATRIX_PARAM) : param.substring(equals + 1));\n        } else if (equals == 0) {\n            // no key declared, ignore\n        } else if (param.length() > 0) {\n            params.put(\n                    UriComponent.decode(param, UriComponent.Type.MATRIX_PARAM),\n                    \"\");\n        }\n    }\n\n    private static String decode(String s, int n) {\n        final StringBuilder sb = new StringBuilder(n);\n        ByteBuffer bb = null;\n\n        for (int i = 0; i < n;) {\n            final char c = s.charAt(i++);\n            if (c != '%') {\n                sb.append(c);\n            } else {\n                bb = decodePercentEncodedOctets(s, i, bb);\n                i = decodeOctets(i, bb, sb);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    private static String decodeQueryParam(String s, int n) {\n        final StringBuilder sb = new StringBuilder(n);\n        ByteBuffer bb = null;\n\n        for (int i = 0; i < n;) {\n            final char c = s.charAt(i++);\n            if (c != '%') {\n                if (c != '+')\n                    sb.append(c);\n                else\n                    sb.append(' ');\n            } else {\n                bb = decodePercentEncodedOctets(s, i, bb);\n                i = decodeOctets(i, bb, sb);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    private static String decodeHost(String s, int n) {\n        final StringBuilder sb = new StringBuilder(n);\n        ByteBuffer bb = null;\n\n        boolean betweenBrackets = false;\n        for (int i = 0; i < n;) {\n            final char c = s.charAt(i++);\n            if (c == '[') {\n                betweenBrackets = true;\n            } else if (betweenBrackets && c == ']') {\n                betweenBrackets = false;\n            }\n\n            if (c != '%' || betweenBrackets) {\n                sb.append(c);\n            } else {\n                bb = decodePercentEncodedOctets(s, i, bb);\n                i = decodeOctets(i, bb, sb);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * Decode a contigious sequence of percent encoded octets.\n     * <p>\n     * Assumes the index, i, starts that the first hex digit of the first\n     * percent-encoded octet.\n     */\n    private static ByteBuffer decodePercentEncodedOctets(String s, int i, ByteBuffer bb) {\n        if (bb == null)\n            bb = ByteBuffer.allocate(1);\n        else\n            ((Buffer)bb).clear();\n\n        while (true) {\n            // Decode the hex digits\n            bb.put((byte) (decodeHex(s, i++) << 4 | decodeHex(s, i++)));\n\n            // Finish if at the end of the string\n            if (i == s.length()) {\n                break;\n            }\n\n            // Finish if no more percent-encoded octets follow\n            if (s.charAt(i++) != '%') {\n                break;\n            }\n\n            // Check if the byte buffer needs to be increased in size\n            if (bb.position() == bb.capacity()) {\n                ((Buffer)bb).flip();\n                // Create a new byte buffer with the maximum number of possible\n                // octets, hence resize should only occur once\n                ByteBuffer bb_new = ByteBuffer.allocate(s.length() / 3);\n                bb_new.put(bb);\n                bb = bb_new;\n            }\n        }\n\n        ((Buffer)bb).flip();\n        return bb;\n    }\n\n    /**\n     * Decodes octets to characters using the UTF-8 decoding and appends\n     * the characters to a StringBuffer.\n     * @return the index to the next unchecked character in the string to decode\n     */\n    private static int decodeOctets(int i, ByteBuffer bb, StringBuilder sb) {\n        // If there is only one octet and is an ASCII character\n        if (bb.limit() == 1 && (bb.get(0) & 0xFF) < 0x80) {\n            // Octet can be appended directly\n            sb.append((char) bb.get(0));\n            return i + 2;\n        } else {\n            // \n            CharBuffer cb = UTF_8_CHARSET.decode(bb);\n            sb.append(cb);\n            return i + bb.limit() * 3 - 1;\n        }\n    }\n\n    private static int decodeHex(String s, int i) {\n        final int v = decodeHex(s.charAt(i));\n        if (v == -1) // TODO localize\n        {\n            throw new IllegalArgumentException(\"Malformed percent-encoded octet at index \" + i +\n                    \", invalid hexadecimal digit '\" + s.charAt(i) + \"'\");\n        }\n        return v;\n    }\n    private static final int[] HEX_TABLE = createHexTable();\n\n    private static int[] createHexTable() {\n        int[] table = new int[0x80];\n        Arrays.fill(table, -1);\n\n        for (char c = '0'; c <= '9'; c++) {\n            table[c] = c - '0';\n        }\n        for (char c = 'A'; c <= 'F'; c++) {\n            table[c] = c - 'A' + 10;\n        }\n        for (char c = 'a'; c <= 'f'; c++) {\n            table[c] = c - 'a' + 10;\n        }\n        return table;\n    }\n\n    private static int decodeHex(char c) {\n        return (c < 128) ? HEX_TABLE[c] : -1;\n    }\n\n    private static boolean isHexCharacter(char c) {\n        return c < 128 && HEX_TABLE[c] != -1;\n    }\n}",
            "file_name": "UriComponent.java",
            "human_label": "Decode the raw path.",
            "level": "slib_runnable",
            "lineno": "575",
            "name": "decodePath",
            "oracle_context": "{ \"apis\" : \"[getRawPath, length, charAt, substring, PathSegmentImpl]\", \"classes\" : \"[String]\", \"vars\" : \"[]\" }",
            "package": "org.atmosphere.util.uri",
            "project": "atmosphere-atmosphere-2.7.x"
        },
        {
            "_id": "636767821a6d9265ec0183ab",
            "all_context": "{ \"class_level\" : \"import java.io.IOException;\\nimport java.io.PrintWriter;\\nimport java.io.StringWriter;\\nlong _seqCount;\\nLogLevel _level;\\nString _message;\\nlong _sequenceNumber;\\nlong _millis;\\nString _category;\\nString _thread;\\nString _thrownStackTrace;\\nThrowable _thrown;\\nString _ndc;\\nString _location;\\nLogRecord();\\ngetLevel();\\nsetLevel(LogLevel level);\\nhasThrown();\\nisFatal();\\ngetCategory();\\nsetCategory(String category);\\ngetMessage();\\nsetMessage(String message);\\ngetSequenceNumber();\\nsetSequenceNumber(long number);\\ngetMillis();\\nsetMillis(long millis);\\ngetThreadDescription();\\nsetThreadDescription(String threadDescription);\\ngetThrownStackTrace();\\nsetThrownStackTrace(String trace);\\ngetThrown();\\nsetThrown(Throwable thrown);\\ntoString();\\ngetNDC();\\nsetNDC(String ndc);\\ngetLocation();\\nsetLocation(String location);\\nresetSequenceNumber();\\ngetNextId();\\nisSevereLevel();\\n\", \"repo_level\" : \"\" }",
            "class_name": "LogRecord",
            "code": "public boolean hasThrown(){\n  Throwable thrown=getThrown();\n  if (thrown == null) {\n    return false;\n  }\n  String thrownString=thrown.toString();\n  return thrownString != null && thrownString.trim().length() != 0;\n}\n",
            "docstring": "/** \n * @return true if getThrown().toString() is a non-empty string.\n */\n",
            "end_lineno": "117",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.log4j.lf5;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\n\n/**\n * LogRecord.  A LogRecord encapsulates the details of your desired log\n * request.\n *\n * @author Michael J. Sikorsky\n * @author Robert Shaw\n */\n\n// Contributed by ThoughtWorks Inc.\n\npublic abstract class LogRecord implements java.io.Serializable {\n  //--------------------------------------------------------------------------\n  //   Constants:\n  //--------------------------------------------------------------------------\n\n  //--------------------------------------------------------------------------\n  //   Protected Variables:\n  //--------------------------------------------------------------------------\n  protected static long _seqCount = 0;\n\n  protected LogLevel _level;\n  protected String _message;\n  protected long _sequenceNumber;\n  protected long _millis;\n  protected String _category;\n  protected String _thread;\n  protected String _thrownStackTrace;\n  protected Throwable _thrown;\n  protected String _ndc;\n  protected String _location;\n\n  //--------------------------------------------------------------------------\n  //   Private Variables:\n  //--------------------------------------------------------------------------\n\n  //--------------------------------------------------------------------------\n  //   Constructors:\n  //--------------------------------------------------------------------------\n\n  public LogRecord() {\n    super();\n\n    _millis = System.currentTimeMillis();\n    _category = \"Debug\";\n    _message = \"\";\n    _level = LogLevel.INFO;\n    _sequenceNumber = getNextId();\n    _thread = Thread.currentThread().toString();\n    _ndc = \"\";\n    _location = \"\";\n  }\n\n  //--------------------------------------------------------------------------\n  //   Public Methods:\n  //--------------------------------------------------------------------------\n\n  /**\n   * Get the level of this LogRecord.\n   *\n   * @return The LogLevel of this record.\n   * @see #setLevel(LogLevel)\n   * @see LogLevel\n   */\n  public LogLevel getLevel() {\n    return (_level);\n  }\n\n  /**\n   * Set the level of this LogRecord.\n   *\n   * @param level The LogLevel for this record.\n   * @see #getLevel()\n   * @see LogLevel\n   */\n  public void setLevel(LogLevel level) {\n    _level = level;\n  }\n\n  /**\n   * Abstract method. Must be overridden to indicate what log level\n   * to show in red.\n   */\n  public abstract boolean isSevereLevel();\n\n  /**\n   * @return true if getThrown().toString() is a non-empty string.\n   */\n  public boolean hasThrown() {\n    Throwable thrown = getThrown();\n    if (thrown == null) {\n      return false;\n    }\n    String thrownString = thrown.toString();\n    return thrownString != null && thrownString.trim().length() != 0;\n  }\n\n  /**\n   * @return true if isSevereLevel() or hasThrown() returns true.\n   */\n  public boolean isFatal() {\n    return isSevereLevel() || hasThrown();\n  }\n\n  /**\n   * Get the category asscociated with this LogRecord.  For a more detailed\n   * description of what a category is see setCategory().\n   *\n   * @return The category of this record.\n   * @see #setCategory(String)\n   */\n  public String getCategory() {\n    return (_category);\n  }\n\n  /**\n   * Set the category associated with this LogRecord. A category represents\n   * a hierarchical dot (\".\") separated namespace for messages.\n   * The definition of a category is application specific, but a common convention\n   * is as follows:\n   *\n   * <p>\n   * When logging messages\n   * for a particluar class you can use its class name:\n   * com.thoughtworks.framework.servlet.ServletServiceBroker.<br><br>\n   * Futhermore, to log a message for a particular method in a class\n   * add the method name:\n   * com.thoughtworks.framework.servlet.ServletServiceBroker.init().\n   * </p>\n   *\n   * @param category The category for this record.\n   * @see #getCategory()\n   */\n  public void setCategory(String category) {\n    _category = category;\n  }\n\n  /**\n   * Get the message asscociated with this LogRecord.\n   *\n   * @return The message of this record.\n   * @see #setMessage(String)\n   */\n  public String getMessage() {\n    return (_message);\n  }\n\n  /**\n   * Set the message associated with this LogRecord.\n   *\n   * @param message The message for this record.\n   * @see #getMessage()\n   */\n  public void setMessage(String message) {\n    _message = message;\n  }\n\n  /**\n   * Get the sequence number associated with this LogRecord.  Sequence numbers\n   * are generally assigned when a LogRecord is constructed.  Sequence numbers\n   * start at 0 and increase with each newly constructed LogRocord.\n   *\n   * @return The sequence number of this record.\n   * @see #setSequenceNumber(long)\n   */\n  public long getSequenceNumber() {\n    return (_sequenceNumber);\n  }\n\n  /**\n   * Set the sequence number assocsiated with this LogRecord.  A sequence number\n   * will automatically be assigned to evey newly constructed LogRecord, however,\n   * this method can override the value.\n   *\n   * @param number The sequence number.\n   * @see #getSequenceNumber()\n   */\n  public void setSequenceNumber(long number) {\n    _sequenceNumber = number;\n  }\n\n  /**\n   * Get the event time of this record in milliseconds from 1970.\n   * When a LogRecord is constructed the event time is set but may be\n   * overridden by calling setMillis();\n   *\n   * @return The event time of this record in milliseconds from 1970.\n   * @see #setMillis(long)\n   */\n  public long getMillis() {\n    return _millis;\n  }\n\n  /**\n   * Set the event time of this record.  When a LogRecord is constructed\n   * the event time is set but may be overridden by calling this method.\n   *\n   * @param millis The time in milliseconds from 1970.\n   * @see #getMillis()\n   */\n  public void setMillis(long millis) {\n    _millis = millis;\n  }\n\n  /**\n   * Get the thread description asscociated with this LogRecord.  When a\n   * LogRecord is constructed, the thread description is set by calling:\n   * Thread.currentThread().toString().  You may supply a thread description\n   * of your own by calling the setThreadDescription(String) method.\n   *\n   * @return The thread description of this record.\n   * @see #setThreadDescription(String)\n   */\n  public String getThreadDescription() {\n    return (_thread);\n  }\n\n  /**\n   * Set the thread description associated with this LogRecord.  When a\n   * LogRecord is constructed, the thread description is set by calling:\n   * Thread.currentThread().toString().  You may supply a thread description\n   * of your own by calling this method.\n   *\n   * @param threadDescription The description of the thread for this record.\n   * @see #getThreadDescription()\n   */\n  public void setThreadDescription(String threadDescription) {\n    _thread = threadDescription;\n  }\n\n  /**\n   * Get the stack trace in a String-based format for the associated Throwable\n   * of this LogRecord.  The stack trace in a String-based format is set\n   * when the setThrown(Throwable) method is called.\n   *\n   * <p>\n   * Why do we need this method considering that we\n   * have the getThrown() and setThrown() methods?\n   * A Throwable object may not be serializable, however, a String representation\n   * of it is.  Users of LogRecords should generally call this method over\n   * getThrown() for the reasons of serialization.\n   * </p>\n   *\n   * @return The Stack Trace for the asscoiated Throwable of this LogRecord.\n   * @see #setThrown(Throwable)\n   * @see #getThrown()\n   */\n  public String getThrownStackTrace() {\n    return (_thrownStackTrace);\n  }\n\n  /**\n   * Set the ThrownStackTrace for the log record.\n   *\n   * @param trace A String to associate with this LogRecord\n   * @see #getThrownStackTrace()\n   */\n  public void setThrownStackTrace(String trace) {\n    _thrownStackTrace = trace;\n  }\n\n  /**\n   * Get the Throwable associated with this LogRecord.\n   *\n   * @return The LogLevel of this record.\n   * @see #setThrown(Throwable)\n   * @see #getThrownStackTrace()\n   */\n  public Throwable getThrown() {\n    return (_thrown);\n  }\n\n  /**\n   * Set the Throwable associated with this LogRecord.  When this method\n   * is called, the stack trace in a String-based format is made\n   * available via the getThrownStackTrace() method.\n   *\n   * @param thrown A Throwable to associate with this LogRecord.\n   * @see #getThrown()\n   * @see #getThrownStackTrace()\n   */\n  public void setThrown(Throwable thrown) {\n    if (thrown == null) {\n      return;\n    }\n    _thrown = thrown;\n    StringWriter sw = new StringWriter();\n    PrintWriter out = new PrintWriter(sw);\n    thrown.printStackTrace(out);\n    out.flush();\n    _thrownStackTrace = sw.toString();\n    try {\n      out.close();\n      sw.close();\n    } catch (IOException e) {\n      // Do nothing, this should not happen as it is StringWriter.\n    }\n    out = null;\n    sw = null;\n  }\n\n  /**\n   * Return a String representation of this LogRecord.\n   */\n  public String toString() {\n    StringBuffer buf = new StringBuffer();\n    buf.append(\"LogRecord: [\" + _level + \", \" + _message + \"]\");\n    return (buf.toString());\n  }\n\n  /**\n   * Get the NDC (nested diagnostic context) for this record.\n   *\n   * @return The string representing the NDC.\n   */\n  public String getNDC() {\n    return _ndc;\n  }\n\n  /**\n   * Set the NDC (nested diagnostic context) for this record.\n   *\n   * @param ndc A string representing the NDC.\n   */\n  public void setNDC(String ndc) {\n    _ndc = ndc;\n  }\n\n  /**\n   * Get the location in code where this LogRecord originated.\n   *\n   * @return The string containing the location information.\n   */\n  public String getLocation() {\n    return _location;\n  }\n\n  /**\n   * Set the location in code where this LogRecord originated.\n   *\n   * @param location A string containing location information.\n   */\n  public void setLocation(String location) {\n    _location = location;\n  }\n\n  /**\n   * Resets that sequence number to 0.\n   *\n   */\n  public static synchronized void resetSequenceNumber() {\n    _seqCount = 0;\n  }\n\n  //--------------------------------------------------------------------------\n  //   Protected Methods:\n  //--------------------------------------------------------------------------\n\n  protected static synchronized long getNextId() {\n    _seqCount++;\n    return _seqCount;\n  }\n  //--------------------------------------------------------------------------\n  //   Private Methods:\n  //--------------------------------------------------------------------------\n\n  //--------------------------------------------------------------------------\n  //   Nested Top-Level Classes or Interfaces:\n  //--------------------------------------------------------------------------\n\n}\n\n\n\n",
            "file_name": "LogRecord.java",
            "human_label": "Check whether there is a thrown",
            "level": "class_runnable",
            "lineno": "107",
            "name": "hasThrown",
            "oracle_context": "{ \"apis\" : \"[getThrown, toString, length, trim]\", \"classes\" : \"[Throwable, String]\", \"vars\" : \"[]\" }",
            "package": "org.apache.log4j.lf5",
            "project": "logging-log4j1-main"
        },
        {
            "_id": "636767831a6d9265ec0183c9",
            "all_context": "{ \"class_level\" : \"import java.util.Hashtable;\\nimport java.util.Stack;\\nimport java.util.Enumeration;\\nimport java.util.Vector;\\nimport org.apache.log4j.helpers.LogLog;\\nHashtable ht;\\nint pushCounter;\\nint REAP_THRESHOLD;\\nString fullMessage;\\nString message;\\nNDC();\\ngetCurrentStack();\\ncloneStack();\\ninherit(Stack stack);\\nget();\\ngetDepth();\\nlazyRemove();\\npop();\\npeek();\\npush(String message);\\nremove();\\nsetMaxDepth(int maxDepth);\\nDiagnosticContext(String message,DiagnosticContext parent);\\nclear();\\n\", \"repo_level\" : \"public interface LogLog {public void setInternalDebugging(boolean enabled);\\nstatic void debug(String msg);\\nstatic void debug(String msg,Throwable t);\\nstatic void error(String msg);\\nstatic void error(String msg,Throwable t);\\nstatic void setQuietMode(boolean quietMode);\\nstatic void warn(String msg);\\nstatic void warn(String msg,Throwable t);\\n }\\n\" }",
            "class_name": "NDC",
            "code": "public static String peek(){\n  Stack stack=getCurrentStack();\n  if (stack != null && !stack.isEmpty())   return ((DiagnosticContext)stack.peek()).message;\n else   return \"\";\n}\n",
            "docstring": "/** \n * Looks at the last diagnostic context at the top of this NDC without removing it. <p>The returned value is the value that was pushed last. If no context is available, then the empty string \"\" is returned.\n * @return String The innermost diagnostic context.\n */\n",
            "end_lineno": "326",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//      Contributors:      Dan Milstein \n//                         Ray Millard\n\npackage org.apache.log4j;\n\nimport java.util.Hashtable;\nimport java.util.Stack;\nimport java.util.Enumeration;\nimport java.util.Vector;\n\nimport org.apache.log4j.helpers.LogLog;\n\n/**\n   The NDC class implements <i>nested diagnostic contexts</i> as\n   defined by Neil Harrison in the article \"Patterns for Logging\n   Diagnostic Messages\" part of the book \"<i>Pattern Languages of\n   Program Design 3</i>\" edited by Martin et al.\n\n   <p>A Nested Diagnostic Context, or NDC in short, is an instrument\n   to distinguish interleaved log output from different sources. Log\n   output is typically interleaved when a server handles multiple\n   clients near-simultaneously.\n\n   <p>Interleaved log output can still be meaningful if each log entry\n   from different contexts had a distinctive stamp. This is where NDCs\n   come into play.\n\n   <p><em><b>Note that NDCs are managed on a per thread\n   basis</b></em>. NDC operations such as {@link #push push}, {@link\n   #pop}, {@link #clear}, {@link #getDepth} and {@link #setMaxDepth}\n   affect the NDC of the <em>current</em> thread only. NDCs of other\n   threads remain unaffected.\n\n   <p>For example, a servlet can build a per client request NDC\n   consisting the clients host name and other information contained in\n   the the request. <em>Cookies</em> are another source of distinctive\n   information. To build an NDC one uses the {@link #push push}\n   operation. Simply put,\n\n   <p><ul>\n     <li>Contexts can be nested.\n\n     <p><li>When entering a context, call <code>NDC.push</code>. As a\n     side effect, if there is no nested diagnostic context for the\n     current thread, this method will create it.\n\n     <p><li>When leaving a context, call <code>NDC.pop</code>.\n\n     <p><li><b>When exiting a thread make sure to call {@link #remove\n     NDC.remove()}</b>.  \n   </ul>\n   \n   <p>There is no penalty for forgetting to match each\n   <code>push</code> operation with a corresponding <code>pop</code>,\n   except the obvious mismatch between the real application context\n   and the context set in the NDC.\n\n   <p>If configured to do so, {@link PatternLayout} and {@link\n   TTCCLayout} instances automatically retrieve the nested diagnostic\n   context for the current thread without any user intervention.\n   Hence, even if a servlet is serving multiple clients\n   simultaneously, the logs emanating from the same code (belonging to\n   the same category) can still be distinguished because each client\n   request will have a different NDC tag.\n\n   <p>Heavy duty systems should call the {@link #remove} method when\n   leaving the run method of a thread. This ensures that the memory\n   used by the thread can be freed by the Java garbage\n   collector. There is a mechanism to lazily remove references to dead\n   threads. In practice, this means that you can be a little sloppy\n   and sometimes forget to call {@link #remove} before exiting a\n   thread.\n   \n   <p>A thread may inherit the nested diagnostic context of another\n   (possibly parent) thread using the {@link #inherit inherit}\n   method. A thread may obtain a copy of its NDC with the {@link\n   #cloneStack cloneStack} method and pass the reference to any other\n   thread, in particular to a child.\n   \n   @author Ceki G&uuml;lc&uuml;\n   @since 0.7.0\n  \n*/\n \npublic class NDC {\n\n  // The synchronized keyword is not used in this class. This may seem\n  // dangerous, especially since the class will be used by\n  // multiple-threads. In particular, all threads share the same\n  // hashtable (the \"ht\" variable). This is OK since java hashtables\n  // are thread safe. Same goes for Stacks.\n\n  // More importantly, when inheriting diagnostic contexts the child\n  // thread is handed a clone of the parent's NDC.  It follows that\n  // each thread has its own NDC (i.e. stack).\n\n  static Hashtable ht = new Hashtable();\n\n  static int pushCounter = 0; // the number of times push has been called\n                              // after the latest call to lazyRemove\n\n  // The number of times we allow push to be called before we call lazyRemove\n  // 5 is a relatively small number. As such, lazyRemove is not called too\n  // frequently. We thus avoid the cost of creating an Enumeration too often.\n  // The higher this number, the longer is the avarage period for which all\n  // logging calls in all threads are blocked.\n  static final int REAP_THRESHOLD = 5;\n  \n  // No instances allowed.\n  private NDC() {}\n  \n  /**\n   *   Get NDC stack for current thread.\n   *   @return NDC stack for current thread.\n   */\n  private static Stack getCurrentStack() {\n      if (ht != null) {\n          return (Stack) ht.get(Thread.currentThread());\n      }\n      return null;\n  }\n\n\n  /**\n     Clear any nested diagnostic information if any. This method is\n     useful in cases where the same thread can be potentially used\n     over and over in different unrelated contexts.\n\n     <p>This method is equivalent to calling the {@link #setMaxDepth}\n     method with a zero <code>maxDepth</code> argument.\n     \n     @since 0.8.4c */\n  public\n  static\n  void clear() {\n    Stack stack = getCurrentStack();    \n    if(stack != null) \n      stack.setSize(0);    \n  }\n\n  \n  /**\n     Clone the diagnostic context for the current thread.\n\n     <p>Internally a diagnostic context is represented as a stack.  A\n     given thread can supply the stack (i.e. diagnostic context) to a\n     child thread so that the child can inherit the parent thread's\n     diagnostic context.\n\n     <p>The child thread uses the {@link #inherit inherit} method to\n     inherit the parent's diagnostic context.\n     \n     @return Stack A clone of the current thread's  diagnostic context.\n\n  */\n  public\n  static\n  Stack cloneStack() {\n    Stack stack = getCurrentStack();\n    if(stack == null)\n      return null;\n    else {\n      return (Stack) stack.clone();\n    }\n  }\n\n  \n  /**\n     Inherit the diagnostic context of another thread.\n\n     <p>The parent thread can obtain a reference to its diagnostic\n     context using the {@link #cloneStack} method.  It should\n     communicate this information to its child so that it may inherit\n     the parent's diagnostic context.\n\n     <p>The parent's diagnostic context is cloned before being\n     inherited. In other words, once inherited, the two diagnostic\n     contexts can be managed independently.\n     \n     <p>In java, a child thread cannot obtain a reference to its\n     parent, unless it is directly handed the reference. Consequently,\n     there is no client-transparent way of inheriting diagnostic\n     contexts. Do you know any solution to this problem?\n\n     @param stack The diagnostic context of the parent thread.\n\n  */\n  public\n  static\n  void inherit(Stack stack) {\n    if(stack != null)\n      ht.put(Thread.currentThread(), stack);\n  }\n\n\n  /**\n     <font color=\"#FF4040\"><b>Never use this method directly, use the {@link\n     org.apache.log4j.spi.LoggingEvent#getNDC} method instead</b></font>.\n  */\n  static\n  public\n  String get() {\n    Stack s = getCurrentStack();\n    if(s != null && !s.isEmpty()) \n      return ((DiagnosticContext) s.peek()).fullMessage;\n    else\n      return null;\n  }\n  \n  /**\n   * Get the current nesting depth of this diagnostic context.\n   *\n   * @see #setMaxDepth\n   * @since 0.7.5\n   */\n  public\n  static\n  int getDepth() {\n    Stack stack = getCurrentStack();          \n    if(stack == null)\n      return 0;\n    else\n      return stack.size();      \n  }\n\n  private\n  static\n  void lazyRemove() {\n    if (ht == null) return;\n     \n    // The synchronization on ht is necessary to prevent JDK 1.2.x from\n    // throwing ConcurrentModificationExceptions at us. This sucks BIG-TIME.\n    // One solution is to write our own hashtable implementation.\n    Vector v;\n    \n    synchronized(ht) {\n      // Avoid calling clean-up too often.\n      if(++pushCounter <= REAP_THRESHOLD) {\n\treturn; // We release the lock ASAP.\n      } else {\n\tpushCounter = 0; // OK let's do some work.\n      }\n\n      int misses = 0;\n      v = new Vector(); \n      Enumeration enumeration = ht.keys();\n      // We give up after 4 straigt missses. That is 4 consecutive\n      // inspected threads in 'ht' that turn out to be alive.\n      // The higher the proportion on dead threads in ht, the higher the\n      // chances of removal.\n      while(enumeration.hasMoreElements() && (misses <= 4)) {\n\tThread t = (Thread) enumeration.nextElement();\n\tif(t.isAlive()) {\n\t  misses++;\n\t} else {\n\t  misses = 0;\n\t  v.addElement(t);\n\t}\n      }\n    } // synchronized\n\n    int size = v.size();\n    for(int i = 0; i < size; i++) {\n      Thread t = (Thread) v.elementAt(i);\n      LogLog.debug(\"Lazy NDC removal for thread [\" + t.getName() + \"] (\"+ \n\t\t   ht.size() + \").\");\n      ht.remove(t);\n    }\n  }\n\n  /**\n     Clients should call this method before leaving a diagnostic\n     context.\n\n     <p>The returned value is the value that was pushed last. If no\n     context is available, then the empty string \"\" is returned.\n     \n     @return String The innermost diagnostic context.\n     \n     */\n  public\n  static\n  String pop() {\n    Stack stack = getCurrentStack();\n    if(stack != null && !stack.isEmpty()) \n      return ((DiagnosticContext) stack.pop()).message;\n    else\n      return \"\";\n  }\n\n  /**\n     Looks at the last diagnostic context at the top of this NDC\n     without removing it.\n\n     <p>The returned value is the value that was pushed last. If no\n     context is available, then the empty string \"\" is returned.\n     \n     @return String The innermost diagnostic context.\n     \n     */\n  public\n  static\n  String peek() {\n    Stack stack = getCurrentStack();\n    if(stack != null && !stack.isEmpty())\n      return ((DiagnosticContext) stack.peek()).message;\n    else\n      return \"\";\n  }\n  \n  /**\n     Push new diagnostic context information for the current thread.\n\n     <p>The contents of the <code>message</code> parameter is\n     determined solely by the client.  \n     \n     @param message The new diagnostic context information.  */\n  public\n  static\n  void push(String message) {\n    Stack stack = getCurrentStack();\n      \n    if(stack == null) {\n      DiagnosticContext dc = new DiagnosticContext(message, null);      \n      stack = new Stack();\n      Thread key = Thread.currentThread();\n      ht.put(key, stack);\n      stack.push(dc);\n    } else if (stack.isEmpty()) {\n      DiagnosticContext dc = new DiagnosticContext(message, null);            \n      stack.push(dc);\n    } else {\n      DiagnosticContext parent = (DiagnosticContext) stack.peek();\n      stack.push(new DiagnosticContext(message, parent));\n    }    \n  }\n\n  /**\n     Remove the diagnostic context for this thread.\n\n     <p>Each thread that created a diagnostic context by calling\n     {@link #push} should call this method before exiting. Otherwise,\n     the memory used by the <b>thread</b> cannot be reclaimed by the\n     VM.\n\n     <p>As this is such an important problem in heavy duty systems and\n     because it is difficult to always guarantee that the remove\n     method is called before exiting a thread, this method has been\n     augmented to lazily remove references to dead threads. In\n     practice, this means that you can be a little sloppy and\n     occasionally forget to call {@link #remove} before exiting a\n     thread. However, you must call <code>remove</code> sometime. If\n     you never call it, then your application is sure to run out of\n     memory.\n     \n  */\n  static\n  public\n  void remove() {\n    if (ht != null) {\n        ht.remove(Thread.currentThread());\n    \n        // Lazily remove dead-thread references in ht.\n        lazyRemove();\n    }\n  }\n\n  /**\n     Set maximum depth of this diagnostic context. If the current\n     depth is smaller or equal to <code>maxDepth</code>, then no\n     action is taken.\n\n     <p>This method is a convenient alternative to multiple {@link\n     #pop} calls. Moreover, it is often the case that at the end of\n     complex call sequences, the depth of the NDC is\n     unpredictable. The <code>setMaxDepth</code> method circumvents\n     this problem.\n\n     <p>For example, the combination\n     <pre>\n       void foo() {\n       &nbsp;  int depth = NDC.getDepth();\n\n       &nbsp;  ... complex sequence of calls\n\n       &nbsp;  NDC.setMaxDepth(depth);\n       }\n     </pre>\n\n     ensures that between the entry and exit of foo the depth of the\n     diagnostic stack is conserved.\n     \n     @see #getDepth\n     @since 0.7.5 */\n  static\n  public\n  void setMaxDepth(int maxDepth) {\n    Stack stack = getCurrentStack();    \n    if(stack != null && maxDepth < stack.size()) \n      stack.setSize(maxDepth);\n  }\n  \n  // =====================================================================\n   private static class DiagnosticContext {\n\n    String fullMessage;\n    String message;\n    \n    DiagnosticContext(String message, DiagnosticContext parent) {\n      this.message = message;\n      if(parent != null) {\n\tfullMessage = parent.fullMessage + ' ' + message;\n      } else {\n\tfullMessage = message;\n      }\n    }\n  }\n}\n\n",
            "file_name": "NDC.java",
            "human_label": "Return the value at the top of the stack",
            "level": "class_runnable",
            "lineno": "308",
            "name": "peek",
            "oracle_context": "{ \"apis\" : \"[getCurrentStack, isEmpty, DiagnosticContext]\", \"classes\" : \"[Stack]\", \"vars\" : \"[message]\" }",
            "package": "org.apache.log4j",
            "project": "logging-log4j1-main"
        },
        {
            "_id": "6367670a1a6d9265ec0179e7",
            "all_context": "{ \"class_level\" : \"import net.hasor.utils.convert.convert.*;\\nimport net.hasor.utils.supplier.ContextClassLoaderLocal;\\nimport java.io.File;\\nimport java.lang.reflect.Array;\\nimport java.math.BigDecimal;\\nimport java.math.BigInteger;\\nimport java.net.URI;\\nimport java.net.URL;\\nimport java.sql.Timestamp;\\nimport java.util.Calendar;\\nimport java.util.Collection;\\nInteger ZERO;\\nCharacter SPACE;\\nConverterBeanContextClassLoaderLocal BEANS_BY_CLASSLOADER;\\nWeakFastHashMap converters;\\ninitialValue();\\ngetInstance();\\nConverterBean();\\nconvert(String value,Class clazz);\\nconvert(String[] values,Class clazz);\\nconvert(T value,Class targetType);\\nderegister();\\nregister(boolean throwException,boolean defaultNull,int defaultArraySize);\\nregisterPrimitives(boolean throwException);\\nregisterStandard(boolean throwException,boolean defaultNull);\\nregisterOther(boolean throwException);\\nregisterArrays(boolean throwException,int defaultArraySize);\\nregisterArrayConverter(Class componentType,Converter componentConverter,boolean throwException,int defaultArraySize);\\nregister(Class clazz,Converter converter);\\nderegister(Class clazz);\\nlookup(Class clazz);\\nlookup(Class sourceType,Class targetType);\\nregister(Converter converter,Class clazz);\\nconvert(Object value);\\n\", \"repo_level\" : \"public interface ContextClassLoaderLocal {protected T initialValue();\\nsynchronized T get();\\nsynchronized void set(T value);\\nsynchronized void unset();\\nsynchronized void unset(ClassLoader classLoader);\\n }\\n\" }",
            "class_name": "ConverterBean",
            "code": "public Converter lookup(final Class<?> clazz){\n  Converter conv=(Converter)this.converters.get(clazz);\n  if (conv != null) {\n    return conv;\n  }\n  for (  Object regType : this.converters.keySet()) {\n    if (((Class<?>)regType).isAssignableFrom(clazz)) {\n      return (Converter)this.converters.get(regType);\n    }\n  }\n  return null;\n}\n",
            "docstring": "/** \n * Look up and return any registered  {@link Converter} for the specifieddestination class; if there is no registered Converter, return <code>null</code>.\n * @param clazz Class for which to return a registered Converter\n * @return The registered {@link Converter} or <code>null</code> if not found\n */\n",
            "end_lineno": "491",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.convert;\nimport net.hasor.utils.convert.convert.*;\nimport net.hasor.utils.supplier.ContextClassLoaderLocal;\n\nimport java.io.File;\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.Calendar;\nimport java.util.Collection;\n\n/**\n * <p>Utility methods for converting String scalar values to objects of the\n * specified Class, String arrays to arrays of the specified Class.  The\n * actual {@link Converter} instance to be used can be registered for each\n * possible destination Class.  Unless you override them, standard\n * {@link Converter} instances are provided for all of the following\n * destination Classes:</p>\n * <ul>\n * <li>java.lang.BigDecimal (no default value)</li>\n * <li>java.lang.BigInteger (no default value)</li>\n * <li>boolean and java.lang.Boolean (default to false)</li>\n * <li>byte and java.lang.Byte (default to zero)</li>\n * <li>char and java.lang.Character (default to a space)</li>\n * <li>java.lang.Class (no default value)</li>\n * <li>double and java.lang.Double (default to zero)</li>\n * <li>float and java.lang.Float (default to zero)</li>\n * <li>int and java.lang.Integer (default to zero)</li>\n * <li>long and java.lang.Long (default to zero)</li>\n * <li>short and java.lang.Short (default to zero)</li>\n * <li>java.lang.String (default to null)</li>\n * <li>java.io.File (no default value)</li>\n * <li>java.net.URL (no default value)</li>\n * <li>java.sql.Date (no default value)</li>\n * <li>java.sql.Time (no default value)</li>\n * <li>java.sql.Timestamp (no default value)</li>\n * </ul>\n *\n * <p>For backwards compatibility, the standard Converters for primitive\n * types (and the corresponding wrapper classes) return a defined\n * default value when a conversion error occurs.  If you prefer to have a\n * {@link ConversionException} thrown instead, replace the standard Converter\n * instances with instances created with the zero-arguments constructor.  For\n * example, to cause the Converters for integers to throw an exception on\n * conversion errors, you could do this:</p>\n * <pre>\n *   // No-args constructor gets the version that throws exceptions\n *   Converter myConverter = new net.hasor.utils.convert.convert.IntegerConverter();\n *   ConverterUtils.register(myConverter, Integer.TYPE);    // Native type\n *   ConverterUtils.register(myConverter, Integer.class);   // Wrapper class\n * </pre>\n *\n * <p>\n * Converters generally treat null input as if it were invalid\n * input, ie they return their default value if one was specified when the\n * converter was constructed, and throw an exception otherwise. If you prefer\n * nulls to be preserved for converters that are converting to objects (not\n * primitives) then register a converter as above, passing a default value of\n * null to the converter constructor (and of course registering that converter\n * only for the .class target).\n * </p>\n *\n * <p>\n * When a converter is listed above as having no default value, then that\n * converter will throw an exception when passed null or an invalid value\n * as its input. In particular, by default the BigInteger and BigDecimal\n * converters have no default (and are therefore somewhat inconsistent\n * with the other numerical converters which all have zero as their default).\n * </p>\n *\n * <p>\n * Converters that generate <i>arrays</i> of each of the primitive types are\n * also automatically configured (including String[]). When passed null\n * or invalid input, these return an empty array (not null). See class\n * AbstractArrayConverter for the supported input formats for these converters.\n * </p>\n *\n * @author Craig R. McClanahan\n * @author Ralph Schaer\n * @author Chris Audley\n * @author James Strachan\n * @version $Revision: 745079 $ $Date: 2009-02-17 14:04:10 +0000 (Tue, 17 Feb 2009) $\n * @since 1.7\n */\npublic class ConverterBean {\n    private static final Integer                              ZERO                 = 0;\n    private static final Character                            SPACE                = ' ';\n    /** Contains <code>ConverterBean</code> instances indexed by context classloader. */\n    private static final ConverterBeanContextClassLoaderLocal BEANS_BY_CLASSLOADER = new ConverterBeanContextClassLoaderLocal();\n\n    private static class ConverterBeanContextClassLoaderLocal extends ContextClassLoaderLocal<ConverterBean> {\n        @Override\n        protected ConverterBean initialValue() {\n            return new ConverterBean();\n        }\n    }\n    // ------------------------------------------------------- Class Methods\n\n    /**\n     * Get singleton instance\n     * @return The singleton instance\n     */\n    protected static ConverterBean getInstance() {\n        return ConverterBean.BEANS_BY_CLASSLOADER.get();\n    }\n    // ------------------------------------------------------- Variables\n    /**\n     * The set of {@link Converter}s that can be used to convert Strings\n     * into objects of a specified Class, keyed by the destination Class.\n     */\n    private WeakFastHashMap converters = new WeakFastHashMap();\n    // ------------------------------------------------------- Constructors\n\n    /** Construct a bean with standard converters registered */\n    public ConverterBean() {\n        this.converters.setFast(false);\n        this.deregister();\n        this.converters.setFast(true);\n    }\n    // --------------------------------------------------------- Public Methods\n\n    /**\n     * Convert the specified value into a String.  If the specified value\n     * is an array, the first element (converted to a String) will be\n     * returned.  The registered {@link Converter} for the\n     * <code>java.lang.String</code> class will be used, which allows\n     * applications to customize Object->String conversions (the default\n     * implementation simply uses toString()).\n     *\n     * @param value Value to be converted (may be null)\n     * @return The converted String value\n     */\n    public String convert(Object value) {\n        if (value == null) {\n            return null;\n        } else if (value.getClass().isArray()) {\n            if (Array.getLength(value) < 1) {\n                return null;\n            }\n            value = Array.get(value, 0);\n            if (value == null) {\n                return null;\n            } else {\n                Converter converter = this.lookup(String.class);\n                return (String) converter.convert(String.class, value);\n            }\n        } else {\n            Converter converter = this.lookup(String.class);\n            return (String) converter.convert(String.class, value);\n        }\n    }\n\n    /**\n     * Convert the specified value to an object of the specified class (if\n     * possible).  Otherwise, return a String representation of the value.\n     *\n     * @param value Value to be converted (may be null)\n     * @param clazz Java class to be converted to\n     * @return The converted value\n     *\n     * @exception ConversionException if thrown by an underlying Converter\n     */\n    public Object convert(final String value, final Class<?> clazz) {\n        Converter converter = this.lookup(clazz);\n        if (converter == null) {\n            converter = this.lookup(String.class);\n        }\n        return converter.convert(clazz, value);\n    }\n\n    /**\n     * Convert an array of specified values to an array of objects of the\n     * specified class (if possible).  If the specified Java class is itself\n     * an array class, this class will be the type of the returned value.\n     * Otherwise, an array will be constructed whose component type is the\n     * specified class.\n     *\n     * @param values Array of values to be converted\n     * @param clazz Java array or element class to be converted to\n     * @return The converted value\n     *\n     * @exception ConversionException if thrown by an underlying Converter\n     */\n    public Object convert(final String[] values, final Class<?> clazz) {\n        Class<?> type = clazz;\n        if (clazz.isArray()) {\n            type = clazz.getComponentType();\n        }\n        Converter converter = this.lookup(type);\n        if (converter == null) {\n            converter = this.lookup(String.class);\n        }\n        Object array = Array.newInstance(type, values.length);\n        for (int i = 0; i < values.length; i++) {\n            Array.set(array, i, converter.convert(type, values[i]));\n        }\n        return array;\n    }\n\n    /**\n     * <p>Convert the value to an object of the specified class (if\n     * possible).</p>\n     *\n     * @param value Value to be converted (may be null)\n     * @param targetType Class of the value to be converted to\n     * @return The converted value\n     *\n     * @exception ConversionException if thrown by an underlying Converter\n     */\n    public <T> T convert(final T value, final Class<? extends T> targetType) {\n        Class<?> sourceType = value == null ? null : value.getClass();\n        Object converted = value;\n        Converter converter = this.lookup(sourceType, targetType);\n        if (converter != null) {\n            converted = converter.convert(targetType, value);\n        }\n        if (targetType == String.class && converted != null && !(converted instanceof String)) {\n            // NOTE: For backwards compatibility, if the Converter\n            //       doesn't handle  conversion-->String then\n            //       use the registered String Converter\n            converter = this.lookup(String.class);\n            if (converter != null) {\n                converted = converter.convert(String.class, converted);\n            }\n            // If the object still isn't a String, use toString() method\n            if (converted != null && !(converted instanceof String)) {\n                converted = converted.toString();\n            }\n        }\n        return (T) converted;\n    }\n\n    /**\n     * Remove all registered {@link Converter}s, and re-establish the\n     * standard Converters.\n     */\n    public void deregister() {\n        this.converters.clear();\n        this.registerPrimitives(false);\n        this.registerStandard(false, false);\n        this.registerOther(true);\n        this.registerArrays(false, 0);\n    }\n\n    /**\n     * Register the provided converters with the specified defaults.\n     *\n     * @param throwException <code>true</code> if the converters should\n     * throw an exception when a conversion error occurs, otherwise <code>\n     * <code>false</code> if a default value should be used.\n     * @param defaultNull <code>true</code>if the <i>standard</i> converters\n     * (see {@link ConverterBean#registerStandard(boolean, boolean)})\n     * should use a default value of <code>null</code>, otherwise <code>false</code>.\n     * N.B. This values is ignored if <code>throwException</code> is <code>true</code>\n     * @param defaultArraySize The size of the default array value for array converters\n     * (N.B. This values is ignored if <code>throwException</code> is <code>true</code>).\n     * Specifying a value less than zero causes a <code>null<code> value to be used for\n     * the default.\n     */\n    public void register(final boolean throwException, final boolean defaultNull, final int defaultArraySize) {\n        this.registerPrimitives(throwException);\n        this.registerStandard(throwException, defaultNull);\n        this.registerOther(throwException);\n        this.registerArrays(throwException, defaultArraySize);\n    }\n\n    /**\n     * Register the converters for primitive types.\n     * </p>\n     * This method registers the following converters:\n     * <ul>\n     *     <li><code>Boolean.TYPE</code> - {@link BooleanConverter}</li>\n     *     <li><code>Byte.TYPE</code> - {@link ByteConverter}</li>\n     *     <li><code>Character.TYPE</code> - {@link CharacterConverter}</li>\n     *     <li><code>Double.TYPE</code> - {@link DoubleConverter}</li>\n     *     <li><code>Float.TYPE</code> - {@link FloatConverter}</li>\n     *     <li><code>Integer.TYPE</code> - {@link IntegerConverter}</li>\n     *     <li><code>Long.TYPE</code> - {@link LongConverter}</li>\n     *     <li><code>Short.TYPE</code> - {@link ShortConverter}</li>\n     * </ul>\n     * @param throwException <code>true</code> if the converters should\n     * throw an exception when a conversion error occurs, otherwise <code>\n     * <code>false</code> if a default value should be used.\n     */\n    private void registerPrimitives(final boolean throwException) {\n        this.register(Boolean.TYPE, throwException ? new BooleanConverter() : new BooleanConverter(Boolean.FALSE));\n        this.register(Byte.TYPE, throwException ? new ByteConverter() : new ByteConverter(ConverterBean.ZERO));\n        this.register(Character.TYPE, throwException ? new CharacterConverter() : new CharacterConverter(ConverterBean.SPACE));\n        this.register(Double.TYPE, throwException ? new DoubleConverter() : new DoubleConverter(ConverterBean.ZERO));\n        this.register(Float.TYPE, throwException ? new FloatConverter() : new FloatConverter(ConverterBean.ZERO));\n        this.register(Integer.TYPE, throwException ? new IntegerConverter() : new IntegerConverter(ConverterBean.ZERO));\n        this.register(Long.TYPE, throwException ? new LongConverter() : new LongConverter(ConverterBean.ZERO));\n        this.register(Short.TYPE, throwException ? new ShortConverter() : new ShortConverter(ConverterBean.ZERO));\n    }\n\n    /**\n     * Register the converters for standard types.\n     * </p>\n     * This method registers the following converters:\n     * <ul>\n     *     <li><code>BigDecimal.class</code> - {@link BigDecimalConverter}</li>\n     *     <li><code>BigInteger.class</code> - {@link BigIntegerConverter}</li>\n     *     <li><code>Boolean.class</code> - {@link BooleanConverter}</li>\n     *     <li><code>Byte.class</code> - {@link ByteConverter}</li>\n     *     <li><code>Character.class</code> - {@link CharacterConverter}</li>\n     *     <li><code>Double.class</code> - {@link DoubleConverter}</li>\n     *     <li><code>Float.class</code> - {@link FloatConverter}</li>\n     *     <li><code>Integer.class</code> - {@link IntegerConverter}</li>\n     *     <li><code>Long.class</code> - {@link LongConverter}</li>\n     *     <li><code>Short.class</code> - {@link ShortConverter}</li>\n     *     <li><code>String.class</code> - {@link StringConverter}</li>\n     * </ul>\n     * @param throwException <code>true</code> if the converters should\n     * throw an exception when a conversion error occurs, otherwise <code>\n     * <code>false</code> if a default value should be used.\n     * @param defaultNull <code>true</code>if the <i>standard</i> converters\n     * (see {@link ConverterBean#registerStandard(boolean, boolean)})\n     * should use a default value of <code>null</code>, otherwise <code>false</code>.\n     * N.B. This values is ignored if <code>throwException</code> is <code>true</code>\n     */\n    private void registerStandard(final boolean throwException, final boolean defaultNull) {\n        Number defaultNumber = defaultNull ? null : ConverterBean.ZERO;\n        BigDecimal bigDecDeflt = defaultNull ? null : new BigDecimal(\"0.0\");\n        BigInteger bigIntDeflt = defaultNull ? null : new BigInteger(\"0\");\n        Boolean booleanDefault = defaultNull ? null : Boolean.FALSE;\n        Character charDefault = defaultNull ? null : ConverterBean.SPACE;\n        String stringDefault = defaultNull ? null : \"\";\n        //\n        this.register(BigDecimal.class, throwException ? new BigDecimalConverter() : new BigDecimalConverter(bigDecDeflt));\n        this.register(BigInteger.class, throwException ? new BigIntegerConverter() : new BigIntegerConverter(bigIntDeflt));\n        this.register(Boolean.class, throwException ? new BooleanConverter() : new BooleanConverter(booleanDefault));\n        this.register(Byte.class, throwException ? new ByteConverter() : new ByteConverter(defaultNumber));\n        this.register(Character.class, throwException ? new CharacterConverter() : new CharacterConverter(charDefault));\n        this.register(Double.class, throwException ? new DoubleConverter() : new DoubleConverter(defaultNumber));\n        this.register(Float.class, throwException ? new FloatConverter() : new FloatConverter(defaultNumber));\n        this.register(Integer.class, throwException ? new IntegerConverter() : new IntegerConverter(defaultNumber));\n        this.register(Long.class, throwException ? new LongConverter() : new LongConverter(defaultNumber));\n        this.register(Short.class, throwException ? new ShortConverter() : new ShortConverter(defaultNumber));\n        this.register(String.class, throwException ? new StringConverter() : new StringConverter(stringDefault));\n    }\n\n    /**\n     * Register the converters for other types.\n     * </p>\n     * This method registers the following converters:\n     * <ul>\n     *     <li><code>Class.class</code> - {@link ClassConverter}</li>\n     *     <li><code>java.util.Date.class</code> - {@link DateConverter}</li>\n     *     <li><code>java.util.Calendar.class</code> - {@link CalendarConverter}</li>\n     *     <li><code>File.class</code> - {@link FileConverter}</li>\n     *     <li><code>java.sql.Date.class</code> - {@link SqlDateConverter}</li>\n     *     <li><code>java.sql.Time.class</code> - {@link SqlTimeConverter}</li>\n     *     <li><code>java.sql.Timestamp.class</code> - {@link SqlTimestampConverter}</li>\n     *     <li><code>URL.class</code> - {@link URLConverter}</li>\n     * </ul>\n     * @param throwException <code>true</code> if the converters should\n     * throw an exception when a conversion error occurs, otherwise <code>\n     * <code>false</code> if a default value should be used.\n     */\n    private void registerOther(final boolean throwException) {\n        this.register(Class.class, throwException ? new ClassConverter() : new ClassConverter(null));\n        this.register(java.util.Date.class, throwException ? new DateConverter() : new DateConverter(null));\n        this.register(Calendar.class, throwException ? new CalendarConverter() : new CalendarConverter(null));\n        this.register(File.class, throwException ? new FileConverter() : new FileConverter(null));\n        this.register(java.sql.Date.class, throwException ? new SqlDateConverter() : new SqlDateConverter(null));\n        this.register(java.sql.Time.class, throwException ? new SqlTimeConverter() : new SqlTimeConverter(null));\n        this.register(Timestamp.class, throwException ? new SqlTimestampConverter() : new SqlTimestampConverter(null));\n        this.register(URL.class, throwException ? new URLConverter() : new URLConverter(null));\n        this.register(URI.class, throwException ? new URIConverter() : new URIConverter(null));\n        this.register(Enum.class, throwException ? new EnumConverter() : new EnumConverter(null));\n    }\n\n    /**\n     * Register array converters.\n     *\n     * @param throwException <code>true</code> if the converters should\n     * throw an exception when a conversion error occurs, otherwise <code>\n     * <code>false</code> if a default value should be used.\n     * @param defaultArraySize The size of the default array value for array converters\n     * (N.B. This values is ignored if <code>throwException</code> is <code>true</code>).\n     * Specifying a value less than zero causes a <code>null<code> value to be used for\n     * the default.\n     */\n    private void registerArrays(final boolean throwException, final int defaultArraySize) {\n        // Primitives\n        this.registerArrayConverter(Boolean.TYPE, new BooleanConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Byte.TYPE, new ByteConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Character.TYPE, new CharacterConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Double.TYPE, new DoubleConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Float.TYPE, new FloatConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Integer.TYPE, new IntegerConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Long.TYPE, new LongConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Short.TYPE, new ShortConverter(), throwException, defaultArraySize);\n        // Standard\n        this.registerArrayConverter(BigDecimal.class, new BigDecimalConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(BigInteger.class, new BigIntegerConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Boolean.class, new BooleanConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Byte.class, new ByteConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Character.class, new CharacterConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Double.class, new DoubleConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Float.class, new FloatConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Integer.class, new IntegerConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Long.class, new LongConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Short.class, new ShortConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(String.class, new StringConverter(), throwException, defaultArraySize);\n        // Other\n        this.registerArrayConverter(Class.class, new ClassConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(java.util.Date.class, new DateConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Calendar.class, new DateConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(File.class, new FileConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(java.sql.Date.class, new SqlDateConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(java.sql.Time.class, new SqlTimeConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(Timestamp.class, new SqlTimestampConverter(), throwException, defaultArraySize);\n        this.registerArrayConverter(URL.class, new URLConverter(), throwException, defaultArraySize);\n    }\n\n    /**\n     * Register a new ArrayConverter with the specified element delegate converter\n     * that returns a default array of the specified size in the event of conversion errors.\n     *\n     * @param componentType The component type of the array\n     * @param componentConverter The converter to delegate to for the array elements\n     * @param throwException Whether a conversion exception should be thrown or a default\n     * value used in the event of a conversion error\n     * @param defaultArraySize The size of the default array\n     */\n    private void registerArrayConverter(final Class<?> componentType, final Converter componentConverter, final boolean throwException, final int defaultArraySize) {\n        Class<?> arrayType = Array.newInstance(componentType, 0).getClass();\n        Converter arrayConverter = null;\n        if (throwException) {\n            arrayConverter = new ArrayConverter(arrayType, componentConverter);\n        } else {\n            arrayConverter = new ArrayConverter(arrayType, componentConverter, defaultArraySize);\n        }\n        this.register(arrayType, arrayConverter);\n    }\n\n    /** strictly for convenience since it has same parameter order as Map.put */\n    private void register(final Class<?> clazz, final Converter converter) {\n        this.register(new ConverterFacade(converter), clazz);\n    }\n\n    /**\n     * Remove any registered {@link Converter} for the specified destination\n     * <code>Class</code>.\n     *\n     * @param clazz Class for which to remove a registered Converter\n     */\n    public void deregister(final Class<?> clazz) {\n        this.converters.remove(clazz);\n    }\n\n    /**\n     * Look up and return any registered {@link Converter} for the specified\n     * destination class; if there is no registered Converter, return\n     * <code>null</code>.\n     *\n     * @param clazz Class for which to return a registered Converter\n     * @return The registered {@link Converter} or <code>null</code> if not found\n     */\n    public Converter lookup(final Class<?> clazz) {\n        Converter conv = (Converter) this.converters.get(clazz);\n        if (conv != null) {\n            return conv;\n        }\n        for (Object regType : this.converters.keySet()) {\n            if (((Class<?>) regType).isAssignableFrom(clazz)) {\n                return (Converter) this.converters.get(regType);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Look up and return any registered {@link Converter} for the specified\n     * source and destination class; if there is no registered Converter,\n     * return <code>null</code>.\n     *\n     * @param sourceType Class of the value being converted\n     * @param targetType Class of the value to be converted to\n     * @return The registered {@link Converter} or <code>null</code> if not found\n     */\n    public Converter lookup(final Class<?> sourceType, final Class<?> targetType) {\n        if (targetType == null) {\n            throw new IllegalArgumentException(\"Target type is missing\");\n        }\n        if (sourceType == null) {\n            return this.lookup(targetType);\n        }\n        Converter converter = null;\n        // Convert --> String\n        if (targetType == String.class) {\n            converter = this.lookup(sourceType);\n            if (converter == null && (sourceType.isArray() || Collection.class.isAssignableFrom(sourceType))) {\n                converter = this.lookup(String[].class);\n            }\n            if (converter == null) {\n                converter = this.lookup(String.class);\n            }\n            return converter;\n        }\n        // Convert --> String array\n        if (targetType == String[].class) {\n            if (sourceType.isArray() || Collection.class.isAssignableFrom(sourceType)) {\n                converter = this.lookup(sourceType);\n            }\n            if (converter == null) {\n                converter = this.lookup(String[].class);\n            }\n            return converter;\n        }\n        return this.lookup(targetType);\n    }\n\n    /**\n     * Register a custom {@link Converter} for the specified destination\n     * <code>Class</code>, replacing any previously registered Converter.\n     *\n     * @param converter Converter to be registered\n     * @param clazz Destination class for conversions performed by this\n     *  Converter\n     */\n    public void register(final Converter converter, final Class<?> clazz) {\n        this.converters.put(clazz, converter);\n    }\n}\n",
            "file_name": "ConverterBean.java",
            "human_label": "Check whether the specified converter exists in converters. If yes, converter is returned. If no, null is returned.",
            "level": "class_runnable",
            "lineno": "472",
            "name": "lookup",
            "oracle_context": "{ \"apis\" : \"[get, keySet, isAssignableFrom]\", \"classes\" : \"[Converter]\", \"vars\" : \"[converters]\" }",
            "package": "net.hasor.utils.convert",
            "project": "hasor-master"
        },
        {
            "_id": "636767a41a6d9265ec018572",
            "all_context": "{ \"class_level\" : \"import java.io.DataInput;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.nio.ByteBuffer;\\nimport java.util.ArrayList;\\nimport java.util.List;\\nimport io.protostuff.StringSerializer.STRING;\\nimport static io.protostuff.WireFormat.TAG_TYPE_BITS;\\nimport static io.protostuff.WireFormat.TAG_TYPE_MASK;\\nimport static io.protostuff.WireFormat.WIRETYPE_END_GROUP;\\nimport static io.protostuff.WireFormat.WIRETYPE_LENGTH_DELIMITED;\\nimport static io.protostuff.WireFormat.WIRETYPE_TAIL_DELIMITER;\\nbyte[] buffer;\\nint bufferSize;\\nint bufferSizeAfterLimit;\\nint bufferPos;\\nInputStream input;\\nint lastTag;\\nint packedLimit;\\nint totalBytesRetired;\\nint currentLimit;\\nboolean decodeNestedMessageAsGroup;\\nint sizeLimit;\\nint DEFAULT_SIZE_LIMIT;\\nint DEFAULT_BUFFER_SIZE;\\nnewInstance(byte[] buf);\\nnewInstance(byte[] buf,int off,int len);\\nreadTag();\\ncheckLastTagWas(int value);\\nskipField(int tag);\\nskipMessage();\\nreadDouble();\\nreadFloat();\\nreadUInt64();\\nreadInt64();\\nreadInt32();\\nreadFixed64();\\nreadFixed32();\\nreadBool();\\nreadString();\\nreadBytes(ByteBuffer bb);\\nmergeObject(T value,Schema schema);\\nmergeObjectEncodedAsGroup(T value,Schema schema);\\nreadBytes();\\nreadUInt32();\\nreadEnum();\\nreadSFixed32();\\nreadSFixed64();\\nreadSInt32();\\nreadSInt64();\\nreadRawVarint32();\\nreadRawVarint32(InputStream input);\\nreadRawVarint32(InputStream input,int firstByte);\\nreadRawVarint32(DataInput input,byte firstByte);\\nreadRawVarint64();\\nreadRawLittleEndian32();\\nreadRawLittleEndian64();\\ndecodeZigZag32(int n);\\ndecodeZigZag64(long n);\\nCodedInput(byte[] buffer,int off,int len,boolean decodeNestedMessageAsGroup);\\nCodedInput(InputStream input,boolean decodeNestedMessageAsGroup);\\nCodedInput(InputStream input,byte[] buffer,boolean decodeNestedMessageAsGroup);\\nCodedInput(InputStream input,byte[] buffer,int offset,int limit,boolean decodeNestedMessageAsGroup);\\nsetSizeLimit(int limit);\\nresetSizeCounter();\\nreset();\\npushLimit(int byteLimit);\\nrecomputeBufferSizeAfterLimit();\\npopLimit(int oldLimit);\\ngetBytesUntilLimit();\\nisCurrentFieldPacked();\\nisAtEnd();\\ngetTotalBytesRead();\\nrefillBuffer(boolean mustSucceed);\\nreadRawByte();\\nreadRawBytes(int size);\\nskipRawBytes(int size);\\nreadFieldNumber(Schema schema);\\ncheckIfPackedField();\\nreadByteArray();\\nhandleUnknownField(int fieldNumber,Schema schema);\\ntransferByteRangeTo(Output output,boolean utf8String,int fieldNumber,boolean repeated);\\ngetLastTag();\\nreadByteBuffer();\\nnewInstance(InputStream input);\\n\", \"repo_level\" : \"\" }",
            "class_name": "CodedInput",
            "code": "public long readRawVarint64() throws IOException {\n  int shift=0;\n  long result=0;\n  while (shift < 64) {\n    final byte b=readRawByte();\n    result|=(long)(b & 0x7F) << shift;\n    if ((b & 0x80) == 0) {\n      return result;\n    }\n    shift+=7;\n  }\n  throw ProtobufException.malformedVarint();\n}\n",
            "docstring": "/** \n * Read a raw Varint from the stream.\n */\n",
            "end_lineno": "629",
            "file_content": "//========================================================================\n//Copyright 2007-2009 David Yu dyuproject@gmail.com\n//------------------------------------------------------------------------\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at \n//http://www.apache.org/licenses/LICENSE-2.0\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//========================================================================\n\n// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// http://code.google.com/p/protobuf/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npackage io.protostuff;\n\nimport java.io.DataInput;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport io.protostuff.StringSerializer.STRING;\n\nimport static io.protostuff.WireFormat.TAG_TYPE_BITS;\nimport static io.protostuff.WireFormat.TAG_TYPE_MASK;\nimport static io.protostuff.WireFormat.WIRETYPE_END_GROUP;\nimport static io.protostuff.WireFormat.WIRETYPE_LENGTH_DELIMITED;\nimport static io.protostuff.WireFormat.WIRETYPE_TAIL_DELIMITER;\n\n/**\n * Reads and decodes protocol message fields.\n * <p>\n * This class contains two kinds of methods: methods that read specific protocol message constructs and field types\n * (e.g. {@link #readTag()} and {@link #readInt32()}) and methods that read low-level values (e.g.\n * {@link #readRawVarint32()} and {@link #readRawBytes}). If you are reading encoded protocol messages, you should use\n * the former methods, but if you are reading some other format of your own design, use the latter.\n *\n * @author kenton@google.com Kenton Varda\n * @author David Yu\n */\npublic final class CodedInput implements Input\n{\n    /**\n     * Create a new CodedInput wrapping the given InputStream.\n     */\n    public static CodedInput newInstance(final InputStream input)\n    {\n        return new CodedInput(input, false);\n    }\n\n    /**\n     * Create a new CodedInput wrapping the given byte array.\n     */\n    public static CodedInput newInstance(final byte[] buf)\n    {\n        return newInstance(buf, 0, buf.length);\n    }\n\n    /**\n     * Create a new CodedInput wrapping the given byte array slice.\n     */\n    public static CodedInput newInstance(final byte[] buf, final int off,\n            final int len)\n    {\n        return new CodedInput(buf, off, len, false);\n    }\n\n    // -----------------------------------------------------------------\n\n    /**\n     * Attempt to read a field tag, returning zero if we have reached EOF. Protocol message parsers use this to read\n     * tags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.\n     */\n    public int readTag() throws IOException\n    {\n        if (isAtEnd())\n        {\n            lastTag = 0;\n            return 0;\n        }\n\n        final int tag = readRawVarint32();\n        if (tag >>> TAG_TYPE_BITS == 0)\n        {\n            // If we actually read zero, that's not a valid tag.\n            throw ProtobufException.invalidTag();\n        }\n        lastTag = tag;\n        return tag;\n    }\n\n    /**\n     * Verifies that the last call to readTag() returned the given tag value. This is used to verify that a nested group\n     * ended with the correct end tag.\n     *\n     * @throws ProtobufException\n     *             {@code value} does not match the last tag.\n     */\n    public void checkLastTagWas(final int value)\n            throws ProtobufException\n    {\n        if (lastTag != value)\n        {\n            throw ProtobufException.invalidEndTag();\n        }\n    }\n\n    /**\n     * Reads and discards a single field, given its tag value.\n     *\n     * @return {@code false} if the tag is an endgroup tag, in which case nothing is skipped. Otherwise, returns\n     *         {@code true}.\n     */\n    public boolean skipField(final int tag) throws IOException\n    {\n        switch (WireFormat.getTagWireType(tag))\n        {\n            case WireFormat.WIRETYPE_VARINT:\n                readInt32();\n                return true;\n            case WireFormat.WIRETYPE_FIXED64:\n                readRawLittleEndian64();\n                return true;\n            case WireFormat.WIRETYPE_LENGTH_DELIMITED:\n                skipRawBytes(readRawVarint32());\n                return true;\n            case WireFormat.WIRETYPE_START_GROUP:\n                skipMessage();\n                checkLastTagWas(WireFormat.makeTag(WireFormat.getTagFieldNumber(tag),\n                        WireFormat.WIRETYPE_END_GROUP));\n                return true;\n            case WireFormat.WIRETYPE_END_GROUP:\n                return false;\n            case WireFormat.WIRETYPE_FIXED32:\n                readRawLittleEndian32();\n                return true;\n            default:\n                throw ProtobufException.invalidWireType();\n        }\n    }\n\n    /**\n     * Reads and discards an entire message. This will read either until EOF or until an endgroup tag, whichever comes\n     * first.\n     */\n    public void skipMessage() throws IOException\n    {\n        while (true)\n        {\n            final int tag = readTag();\n            if (tag == 0 || !skipField(tag))\n            {\n                return;\n            }\n        }\n    }\n\n    // -----------------------------------------------------------------\n\n    /**\n     * Read a {@code double} field value from the stream.\n     */\n    @Override\n    public double readDouble() throws IOException\n    {\n        checkIfPackedField();\n        return Double.longBitsToDouble(readRawLittleEndian64());\n    }\n\n    /**\n     * Read a {@code float} field value from the stream.\n     */\n    @Override\n    public float readFloat() throws IOException\n    {\n        checkIfPackedField();\n        return Float.intBitsToFloat(readRawLittleEndian32());\n    }\n\n    /**\n     * Read a {@code uint64} field value from the stream.\n     */\n    @Override\n    public long readUInt64() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint64();\n    }\n\n    /**\n     * Read an {@code int64} field value from the stream.\n     */\n    @Override\n    public long readInt64() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint64();\n    }\n\n    /**\n     * Read an {@code int32} field value from the stream.\n     */\n    @Override\n    public int readInt32() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint32();\n    }\n\n    /**\n     * Read a {@code fixed64} field value from the stream.\n     */\n    @Override\n    public long readFixed64() throws IOException\n    {\n        checkIfPackedField();\n        return readRawLittleEndian64();\n    }\n\n    /**\n     * Read a {@code fixed32} field value from the stream.\n     */\n    @Override\n    public int readFixed32() throws IOException\n    {\n        checkIfPackedField();\n        return readRawLittleEndian32();\n    }\n\n    /**\n     * Read a {@code bool} field value from the stream.\n     */\n    @Override\n    public boolean readBool() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint32() != 0;\n    }\n\n    /**\n     * Read a {@code string} field value from the stream.\n     */\n    @Override\n    public String readString() throws IOException\n    {\n        final int size = readRawVarint32();\n        if (size <= (bufferSize - bufferPos) && size > 0)\n        {\n            // Fast path: We already have the bytes in a contiguous buffer, so\n            // just copy directly from it.\n            final String result = STRING.deser(buffer, bufferPos, size);\n            bufferPos += size;\n            return result;\n        }\n        else\n        {\n            // Slow path: Build a byte array first then copy it.\n            return STRING.deser(readRawBytes(size));\n        }\n    }\n\n    /**\n     * Read a {@code string} field value from the stream into a ByteBuffer.\n     */\n    @Override\n    public void readBytes(final ByteBuffer bb) throws IOException\n    {\n        final int size = readRawVarint32();\n\n        if (size <= (bufferSize - bufferPos) && size > 0)\n        {\n            // Fast path: We already have the bytes in a contiguous buffer, so\n            // just copy directly from it.\n            bb.limit(size);\n            bb.put(buffer, bufferPos, size);\n            bufferPos += size;\n        }\n        else\n        {\n            // Slow path: Build a byte array first then copy it.\n            bb.put(readRawBytes(size));\n        }\n    }\n\n    @Override\n    public <T> T mergeObject(T value, final Schema<T> schema) throws IOException\n    {\n        if (decodeNestedMessageAsGroup)\n            return mergeObjectEncodedAsGroup(value, schema);\n\n        final int length = readRawVarint32();\n        // if (recursionDepth >= recursionLimit) {\n        // throw ProtobufException.recursionLimitExceeded();\n        // }\n        final int oldLimit = pushLimit(length);\n        // ++recursionDepth;\n\n        if (value == null)\n        {\n            value = schema.newMessage();\n        }\n        schema.mergeFrom(this, value);\n        if (!schema.isInitialized(value))\n        {\n            throw new UninitializedMessageException(value, schema);\n        }\n        checkLastTagWas(0);\n        // --recursionDepth;\n        popLimit(oldLimit);\n        return value;\n    }\n\n    /**\n     * Reads a message field value from the stream (using the {@code group} encoding).\n     */\n    private <T> T mergeObjectEncodedAsGroup(T value, final Schema<T> schema) throws IOException\n    {\n        // if (recursionDepth >= recursionLimit) {\n        // throw ProtobufException.recursionLimitExceeded();\n        // }\n        // ++recursionDepth;\n\n        if (value == null)\n        {\n            value = schema.newMessage();\n        }\n        schema.mergeFrom(this, value);\n        if (!schema.isInitialized(value))\n        {\n            throw new UninitializedMessageException(value, schema);\n        }\n        // handling is in #readFieldNumber\n        checkLastTagWas(0);\n        // --recursionDepth;\n        return value;\n    }\n\n    /*\n     * @ Reads a {@code group} field value from the stream and merges it into the given {@link UnknownFieldSet}.\n     * \n     * @deprecated UnknownFieldSet.Builder now implements MessageLite.Builder, so you can just call {@link #readGroup}.\n     */\n    /*\n     * @Deprecated public void readUnknownGroup(final int fieldNumber, final MessageLite.Builder builder) throws\n     * IOException { // We know that UnknownFieldSet will ignore any ExtensionRegistry so it // is safe to pass null\n     * here. (We can't call // ExtensionRegistry.getEmptyRegistry() because that would make this // class depend on\n     * ExtensionRegistry, which is not part of the lite // library.) readGroup(fieldNumber, builder, null); }\n     */\n\n    /**\n     * Read a {@code bytes} field value from the stream.\n     */\n    @Override\n    public ByteString readBytes() throws IOException\n    {\n        final int size = readRawVarint32();\n        if (size == 0)\n        {\n            return ByteString.EMPTY;\n        }\n\n        if (size <= (bufferSize - bufferPos) && size > 0)\n        {\n            // Fast path: We already have the bytes in a contiguous buffer, so\n            // just copy directly from it.\n            final ByteString result = ByteString.copyFrom(buffer, bufferPos, size);\n            bufferPos += size;\n            return result;\n        }\n        else\n        {\n            // Slow path: Build a byte array first then copy it.\n            // return ByteString.copyFrom(readRawBytes(size));\n            return ByteString.wrap(readRawBytes(size));\n        }\n    }\n\n    /**\n     * Read a {@code uint32} field value from the stream.\n     */\n    @Override\n    public int readUInt32() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint32();\n    }\n\n    /**\n     * Read an enum field value from the stream. Caller is responsible for converting the numeric value to an actual\n     * enum.\n     */\n    @Override\n    public int readEnum() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint32();\n    }\n\n    /**\n     * Read an {@code sfixed32} field value from the stream.\n     */\n    @Override\n    public int readSFixed32() throws IOException\n    {\n        checkIfPackedField();\n        return readRawLittleEndian32();\n    }\n\n    /**\n     * Read an {@code sfixed64} field value from the stream.\n     */\n    @Override\n    public long readSFixed64() throws IOException\n    {\n        checkIfPackedField();\n        return readRawLittleEndian64();\n    }\n\n    /**\n     * Read an {@code sint32} field value from the stream.\n     */\n    @Override\n    public int readSInt32() throws IOException\n    {\n        checkIfPackedField();\n        return decodeZigZag32(readRawVarint32());\n    }\n\n    /**\n     * Read an {@code sint64} field value from the stream.\n     */\n    @Override\n    public long readSInt64() throws IOException\n    {\n        checkIfPackedField();\n        return decodeZigZag64(readRawVarint64());\n    }\n\n    // =================================================================\n\n    /**\n     * Read a raw Varint from the stream. If larger than 32 bits, discard the upper bits.\n     */\n    public int readRawVarint32() throws IOException\n    {\n        byte tmp = readRawByte();\n        if (tmp >= 0)\n        {\n            return tmp;\n        }\n        int result = tmp & 0x7f;\n        if ((tmp = readRawByte()) >= 0)\n        {\n            result |= tmp << 7;\n        }\n        else\n        {\n            result |= (tmp & 0x7f) << 7;\n            if ((tmp = readRawByte()) >= 0)\n            {\n                result |= tmp << 14;\n            }\n            else\n            {\n                result |= (tmp & 0x7f) << 14;\n                if ((tmp = readRawByte()) >= 0)\n                {\n                    result |= tmp << 21;\n                }\n                else\n                {\n                    result |= (tmp & 0x7f) << 21;\n                    result |= (tmp = readRawByte()) << 28;\n                    if (tmp < 0)\n                    {\n                        // Discard upper 32 bits.\n                        for (int i = 0; i < 5; i++)\n                        {\n                            if (readRawByte() >= 0)\n                            {\n                                return result;\n                            }\n                        }\n                        throw ProtobufException.malformedVarint();\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Reads a varint from the input one byte at a time, so that it does not read any bytes after the end of the varint.\n     * If you simply wrapped the stream in a CodedInput and used {@link #readRawVarint32(InputStream)} then you would\n     * probably end up reading past the end of the varint since CodedInput buffers its input.\n     */\n    static int readRawVarint32(final InputStream input) throws IOException\n    {\n        final int firstByte = input.read();\n        if (firstByte == -1)\n        {\n            throw ProtobufException.truncatedMessage();\n        }\n\n        if ((firstByte & 0x80) == 0)\n        {\n            return firstByte;\n        }\n        return readRawVarint32(input, firstByte);\n    }\n\n    /**\n     * Reads a varint from the input one byte at a time, so that it does not read any bytes after the end of the varint.\n     * If you simply wrapped the stream in a CodedInput and used {@link #readRawVarint32(InputStream)} then you would\n     * probably end up reading past the end of the varint since CodedInput buffers its input.\n     */\n    static int readRawVarint32(final InputStream input, final int firstByte) throws IOException\n    {\n        int result = firstByte & 0x7f;\n        int offset = 7;\n        for (; offset < 32; offset += 7)\n        {\n            final int b = input.read();\n            if (b == -1)\n            {\n                throw ProtobufException.truncatedMessage();\n            }\n            result |= (b & 0x7f) << offset;\n            if ((b & 0x80) == 0)\n            {\n                return result;\n            }\n        }\n        // Keep reading up to 64 bits.\n        for (; offset < 64; offset += 7)\n        {\n            final int b = input.read();\n            if (b == -1)\n            {\n                throw ProtobufException.truncatedMessage();\n            }\n            if ((b & 0x80) == 0)\n            {\n                return result;\n            }\n        }\n        throw ProtobufException.malformedVarint();\n    }\n\n    /**\n     * Reads a varint from the input one byte at a time from a {@link DataInput}, so that it does not read any bytes\n     * after the end of the varint.\n     */\n    static int readRawVarint32(final DataInput input, final byte firstByte) throws IOException\n    {\n        int result = firstByte & 0x7f;\n        int offset = 7;\n        for (; offset < 32; offset += 7)\n        {\n            final byte b = input.readByte();\n            result |= (b & 0x7f) << offset;\n            if ((b & 0x80) == 0)\n            {\n                return result;\n            }\n        }\n        // Keep reading up to 64 bits.\n        for (; offset < 64; offset += 7)\n        {\n            final byte b = input.readByte();\n            if ((b & 0x80) == 0)\n            {\n                return result;\n            }\n        }\n        throw ProtobufException.malformedVarint();\n    }\n\n    /**\n     * Read a raw Varint from the stream.\n     */\n    public long readRawVarint64() throws IOException\n    {\n        int shift = 0;\n        long result = 0;\n        while (shift < 64)\n        {\n            final byte b = readRawByte();\n            result |= (long) (b & 0x7F) << shift;\n            if ((b & 0x80) == 0)\n            {\n                return result;\n            }\n            shift += 7;\n        }\n        throw ProtobufException.malformedVarint();\n    }\n\n    /**\n     * Read a 32-bit little-endian integer from the stream.\n     */\n    public int readRawLittleEndian32() throws IOException\n    {\n        final byte b1 = readRawByte();\n        final byte b2 = readRawByte();\n        final byte b3 = readRawByte();\n        final byte b4 = readRawByte();\n        return (((int) b1 & 0xff)) |\n                (((int) b2 & 0xff) << 8) |\n                (((int) b3 & 0xff) << 16) |\n                (((int) b4 & 0xff) << 24);\n    }\n\n    /**\n     * Read a 64-bit little-endian integer from the stream.\n     */\n    public long readRawLittleEndian64() throws IOException\n    {\n        final byte b1 = readRawByte();\n        final byte b2 = readRawByte();\n        final byte b3 = readRawByte();\n        final byte b4 = readRawByte();\n        final byte b5 = readRawByte();\n        final byte b6 = readRawByte();\n        final byte b7 = readRawByte();\n        final byte b8 = readRawByte();\n        return (((long) b1 & 0xff)) |\n                (((long) b2 & 0xff) << 8) |\n                (((long) b3 & 0xff) << 16) |\n                (((long) b4 & 0xff) << 24) |\n                (((long) b5 & 0xff) << 32) |\n                (((long) b6 & 0xff) << 40) |\n                (((long) b7 & 0xff) << 48) |\n                (((long) b8 & 0xff) << 56);\n    }\n\n    /**\n     * Decode a ZigZag-encoded 32-bit value. ZigZag encodes signed integers into values that can be efficiently encoded\n     * with varint. (Otherwise, negative values must be sign-extended to 64 bits to be varint encoded, thus always\n     * taking 10 bytes on the wire.)\n     *\n     * @param n\n     *            An unsigned 32-bit integer, stored in a signed int because Java has no explicit unsigned support.\n     * @return A signed 32-bit integer.\n     */\n    public static int decodeZigZag32(final int n)\n    {\n        return (n >>> 1) ^ -(n & 1);\n    }\n\n    /**\n     * Decode a ZigZag-encoded 64-bit value. ZigZag encodes signed integers into values that can be efficiently encoded\n     * with varint. (Otherwise, negative values must be sign-extended to 64 bits to be varint encoded, thus always\n     * taking 10 bytes on the wire.)\n     *\n     * @param n\n     *            An unsigned 64-bit integer, stored in a signed int because Java has no explicit unsigned support.\n     * @return A signed 64-bit integer.\n     */\n    public static long decodeZigZag64(final long n)\n    {\n        return (n >>> 1) ^ -(n & 1);\n    }\n\n    // -----------------------------------------------------------------\n\n    private final byte[] buffer;\n    private int bufferSize;\n    private int bufferSizeAfterLimit;\n    private int bufferPos;\n    private final InputStream input;\n    private int lastTag;\n    private int packedLimit = 0;\n\n    /**\n     * The total number of bytes read before the current buffer. The total bytes read up to the current position can be\n     * computed as {@code totalBytesRetired + bufferPos}. This value may be negative if reading started in the middle of\n     * the current buffer (e.g. if the constructor that takes a byte array and an offset was used).\n     */\n    private int totalBytesRetired;\n\n    /**\n     * The absolute position of the end of the current message.\n     */\n    private int currentLimit = Integer.MAX_VALUE;\n\n    // ** See setRecursionLimit() */\n    // private int recursionDepth;\n    // private int recursionLimit = DEFAULT_RECURSION_LIMIT;\n\n    /**\n     * If true, the nested messages are group-encoded\n     */\n    public final boolean decodeNestedMessageAsGroup;\n\n    /**\n     * See setSizeLimit()\n     */\n    private int sizeLimit = DEFAULT_SIZE_LIMIT;\n\n    // static final int DEFAULT_RECURSION_LIMIT = 64;\n    static final int DEFAULT_SIZE_LIMIT = 64 << 20; // 64MB\n    static final int DEFAULT_BUFFER_SIZE = 4096;\n\n    public CodedInput(final byte[] buffer, final int off, final int len,\n            boolean decodeNestedMessageAsGroup)\n    {\n        this.buffer = buffer;\n        bufferSize = off + len;\n        bufferPos = off;\n        totalBytesRetired = -off;\n        input = null;\n        this.decodeNestedMessageAsGroup = decodeNestedMessageAsGroup;\n    }\n\n    public CodedInput(final InputStream input, boolean decodeNestedMessageAsGroup)\n    {\n        this(input, new byte[DEFAULT_BUFFER_SIZE], 0, 0, decodeNestedMessageAsGroup);\n    }\n\n    public CodedInput(final InputStream input, byte[] buffer,\n            boolean decodeNestedMessageAsGroup)\n    {\n        this(input, buffer, 0, 0, decodeNestedMessageAsGroup);\n    }\n\n    public CodedInput(final InputStream input, byte[] buffer, int offset, int limit,\n            boolean decodeNestedMessageAsGroup)\n    {\n        this.buffer = buffer;\n        bufferSize = limit;\n        bufferPos = offset;\n        totalBytesRetired = -offset;\n        this.input = input;\n        this.decodeNestedMessageAsGroup = decodeNestedMessageAsGroup;\n    }\n\n    /*\n     * Set the maximum message recursion depth. In order to prevent malicious messages from causing stack overflows,\n     * {@code CodedInput} limits how deeply messages may be nested. The default limit is 64.\n     * \n     * @return the old limit.\n     * \n     * public int setRecursionLimit(final int limit) { if (limit < 0) { throw new IllegalArgumentException(\n     * \"Recursion limit cannot be negative: \" + limit); } final int oldLimit = recursionLimit; recursionLimit = limit;\n     * return oldLimit; }\n     */\n\n    /**\n     * Set the maximum message size. In order to prevent malicious messages from exhausting memory or causing integer\n     * overflows, {@code CodedInput} limits how large a message may be. The default limit is 64MB. You should set this\n     * limit as small as you can without harming your app's functionality. Note that size limits only apply when reading\n     * from an {@code InputStream}, not when constructed around a raw byte array.\n     * <p>\n     * If you want to read several messages from a single CodedInput, you could call {@link #resetSizeCounter()} after\n     * each one to avoid hitting the size limit.\n     *\n     * @return the old limit.\n     */\n    public int setSizeLimit(final int limit)\n    {\n        if (limit < 0)\n        {\n            throw new IllegalArgumentException(\n                    \"Size limit cannot be negative: \" + limit);\n        }\n        final int oldLimit = sizeLimit;\n        sizeLimit = limit;\n        return oldLimit;\n    }\n\n    /**\n     * Resets the current size counter to zero (see {@link #setSizeLimit(int)}). The field {@code totalBytesRetired}\n     * will be negative if the initial position was not zero.\n     */\n    public void resetSizeCounter()\n    {\n        totalBytesRetired = -bufferPos;\n    }\n\n    /**\n     * Resets the buffer position and limit to re-use this CodedInput object.\n     */\n    public void reset()\n    {\n        this.bufferSize = 0;\n        this.bufferPos = 0;\n        this.bufferSizeAfterLimit = 0;\n        this.currentLimit = Integer.MAX_VALUE;\n        this.lastTag = 0;\n        this.packedLimit = 0;\n        this.sizeLimit = DEFAULT_SIZE_LIMIT;\n        resetSizeCounter();\n    }\n\n    /**\n     * Note that {@code pushLimit()} does NOT affect how many bytes the {@code CodedInputStream} reads from an\n     * underlying {@code InputStream} when refreshing its buffer. If you need to prevent reading past a certain point in\n     * the underlying {@code InputStream} (e.g. because you expect it to contain more data after the end of the message\n     * which you need to handle differently) then you must place a wrapper around your {@code InputStream} which limits\n     * the amount of data that can be read from it.\n     *\n     * @return the old limit.\n     */\n    public int pushLimit(int byteLimit) throws ProtobufException\n    {\n        if (byteLimit < 0)\n        {\n            throw ProtobufException.negativeSize();\n        }\n        byteLimit += totalBytesRetired + bufferPos;\n        final int oldLimit = currentLimit;\n        if (byteLimit > oldLimit)\n        {\n            throw ProtobufException.truncatedMessage();\n        }\n        currentLimit = byteLimit;\n\n        recomputeBufferSizeAfterLimit();\n\n        return oldLimit;\n    }\n\n    private void recomputeBufferSizeAfterLimit()\n    {\n        bufferSize += bufferSizeAfterLimit;\n        final int bufferEnd = totalBytesRetired + bufferSize;\n        if (bufferEnd > currentLimit)\n        {\n            // Limit is in current buffer.\n            bufferSizeAfterLimit = bufferEnd - currentLimit;\n            bufferSize -= bufferSizeAfterLimit;\n        }\n        else\n        {\n            bufferSizeAfterLimit = 0;\n        }\n    }\n\n    /**\n     * Discards the current limit, returning to the previous limit.\n     *\n     * @param oldLimit\n     *            The old limit, as returned by {@code pushLimit}.\n     */\n    public void popLimit(final int oldLimit)\n    {\n        currentLimit = oldLimit;\n        recomputeBufferSizeAfterLimit();\n    }\n\n    /**\n     * Returns the number of bytes to be read before the current limit. If no limit is set, returns -1.\n     */\n    public int getBytesUntilLimit()\n    {\n        if (currentLimit == Integer.MAX_VALUE)\n        {\n            return -1;\n        }\n\n        final int currentAbsolutePosition = totalBytesRetired + bufferPos;\n        return currentLimit - currentAbsolutePosition;\n    }\n\n    /**\n     * Return true if currently reading packed field\n     */\n    public boolean isCurrentFieldPacked()\n    {\n        return packedLimit != 0 && packedLimit != getTotalBytesRead();\n    }\n\n    /**\n     * Returns true if the stream has reached the end of the input. This is the case if either the end of the underlying\n     * input source has been reached or if the stream has reached a limit created using {@link #pushLimit(int)}.\n     */\n    public boolean isAtEnd() throws IOException\n    {\n        return bufferPos == bufferSize && !refillBuffer(false);\n    }\n\n    /**\n     * The total bytes read up to the current position. Calling {@link #resetSizeCounter()} resets this value to zero.\n     */\n    public int getTotalBytesRead()\n    {\n        return totalBytesRetired + bufferPos;\n    }\n\n    /**\n     * Called with {@code this.buffer} is empty to read more bytes from the input. If {@code mustSucceed} is true,\n     * refillBuffer() guarantees that either there will be at least one byte in the buffer when it returns or it will\n     * throw an exception. If {@code mustSucceed} is false, refillBuffer() returns false if no more bytes were\n     * available.\n     */\n    private boolean refillBuffer(final boolean mustSucceed) throws IOException\n    {\n        if (bufferPos < bufferSize)\n        {\n            throw new IllegalStateException(\n                    \"refillBuffer() called when buffer wasn't empty.\");\n        }\n\n        if (totalBytesRetired + bufferSize == currentLimit)\n        {\n            // Oops, we hit a limit.\n            if (mustSucceed)\n            {\n                throw ProtobufException.truncatedMessage();\n            }\n            else\n            {\n                return false;\n            }\n        }\n\n        totalBytesRetired += bufferSize;\n\n        bufferPos = 0;\n        bufferSize = (input == null) ? -1 : input.read(buffer);\n        if (bufferSize == 0 || bufferSize < -1)\n        {\n            throw new IllegalStateException(\n                    \"InputStream#read(byte[]) returned invalid result: \" + bufferSize +\n                            \"\\nThe InputStream implementation is buggy.\");\n        }\n        if (bufferSize == -1)\n        {\n            bufferSize = 0;\n            if (mustSucceed)\n            {\n                throw ProtobufException.truncatedMessage();\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else\n        {\n            recomputeBufferSizeAfterLimit();\n            final int totalBytesRead =\n                    totalBytesRetired + bufferSize + bufferSizeAfterLimit;\n            if (totalBytesRead > sizeLimit || totalBytesRead < 0)\n            {\n                throw ProtobufException.sizeLimitExceeded();\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Read one byte from the input.\n     *\n     * @throws ProtobufException\n     *             The end of the stream or the current limit was reached.\n     */\n    public byte readRawByte() throws IOException\n    {\n        if (bufferPos == bufferSize)\n        {\n            refillBuffer(true);\n        }\n        return buffer[bufferPos++];\n    }\n\n    /**\n     * Read a fixed size of bytes from the input.\n     *\n     * @throws ProtobufException\n     *             The end of the stream or the current limit was reached.\n     */\n    public byte[] readRawBytes(final int size) throws IOException\n    {\n        if (size < 0)\n        {\n            throw ProtobufException.negativeSize();\n        }\n\n        if (totalBytesRetired + bufferPos + size > currentLimit)\n        {\n            // Read to the end of the stream anyway.\n            skipRawBytes(currentLimit - totalBytesRetired - bufferPos);\n            // Then fail.\n            throw ProtobufException.truncatedMessage();\n        }\n\n        if (size <= bufferSize - bufferPos)\n        {\n            // We have all the bytes we need already.\n            final byte[] bytes = new byte[size];\n            System.arraycopy(buffer, bufferPos, bytes, 0, size);\n            bufferPos += size;\n            return bytes;\n        }\n        else if (size < buffer.length)\n        {\n            // Reading more bytes than are in the buffer, but not an excessive number\n            // of bytes. We can safely allocate the resulting array ahead of time.\n\n            // First copy what we have.\n            final byte[] bytes = new byte[size];\n            int pos = bufferSize - bufferPos;\n            System.arraycopy(buffer, bufferPos, bytes, 0, pos);\n            bufferPos = bufferSize;\n\n            // We want to use refillBuffer() and then copy from the buffer into our\n            // byte array rather than reading directly into our byte array because\n            // the input may be unbuffered.\n            refillBuffer(true);\n\n            while (size - pos > bufferSize)\n            {\n                System.arraycopy(buffer, 0, bytes, pos, bufferSize);\n                pos += bufferSize;\n                bufferPos = bufferSize;\n                refillBuffer(true);\n            }\n\n            System.arraycopy(buffer, 0, bytes, pos, size - pos);\n            bufferPos = size - pos;\n\n            return bytes;\n        }\n        else\n        {\n            // The size is very large. For security reasons, we can't allocate the\n            // entire byte array yet. The size comes directly from the input, so a\n            // maliciously-crafted message could provide a bogus very large size in\n            // order to trick the app into allocating a lot of memory. We avoid this\n            // by allocating and reading only a small chunk at a time, so that the\n            // malicious message must actually *be* extremely large to cause\n            // problems. Meanwhile, we limit the allowed size of a message elsewhere.\n\n            // Remember the buffer markers since we'll have to copy the bytes out of\n            // it later.\n            final int originalBufferPos = bufferPos;\n            final int originalBufferSize = bufferSize;\n\n            // Mark the current buffer consumed.\n            totalBytesRetired += bufferSize;\n            bufferPos = 0;\n            bufferSize = 0;\n\n            // Read all the rest of the bytes we need.\n            int sizeLeft = size - (originalBufferSize - originalBufferPos);\n            final List<byte[]> chunks = new ArrayList<byte[]>();\n\n            while (sizeLeft > 0)\n            {\n                final byte[] chunk = new byte[Math.min(sizeLeft, buffer.length)];\n                int pos = 0;\n                while (pos < chunk.length)\n                {\n                    final int n = (input == null) ? -1 :\n                            input.read(chunk, pos, chunk.length - pos);\n                    if (n == -1)\n                    {\n                        throw ProtobufException.truncatedMessage();\n                    }\n                    totalBytesRetired += n;\n                    pos += n;\n                }\n                sizeLeft -= chunk.length;\n                chunks.add(chunk);\n            }\n\n            // OK, got everything. Now concatenate it all into one buffer.\n            final byte[] bytes = new byte[size];\n\n            // Start by copying the leftover bytes from this.buffer.\n            int pos = originalBufferSize - originalBufferPos;\n            System.arraycopy(buffer, originalBufferPos, bytes, 0, pos);\n\n            // And now all the chunks.\n            for (final byte[] chunk : chunks)\n            {\n                System.arraycopy(chunk, 0, bytes, pos, chunk.length);\n                pos += chunk.length;\n            }\n\n            // Done.\n            return bytes;\n        }\n    }\n\n    /**\n     * Reads and discards {@code size} bytes.\n     *\n     * @throws ProtobufException\n     *             The end of the stream or the current limit was reached.\n     */\n    public void skipRawBytes(final int size) throws IOException\n    {\n        if (size < 0)\n        {\n            throw ProtobufException.negativeSize();\n        }\n\n        if (totalBytesRetired + bufferPos + size > currentLimit)\n        {\n            // Read to the end of the stream anyway.\n            skipRawBytes(currentLimit - totalBytesRetired - bufferPos);\n            // Then fail.\n            throw ProtobufException.truncatedMessage();\n        }\n\n        if (size <= bufferSize - bufferPos)\n        {\n            // We have all the bytes we need already.\n            bufferPos += size;\n        }\n        else\n        {\n            // Skipping more bytes than are in the buffer. First skip what we have.\n            int pos = bufferSize - bufferPos;\n            bufferPos = bufferSize;\n\n            // Keep refilling the buffer until we get to the point we wanted to skip\n            // to. This has the side effect of ensuring the limits are updated\n            // correctly.\n            refillBuffer(true);\n            while (size - pos > bufferSize)\n            {\n                pos += bufferSize;\n                bufferPos = bufferSize;\n                refillBuffer(true);\n            }\n\n            bufferPos = size - pos;\n        }\n    }\n\n    // START EXTRA\n    @Override\n    public <T> int readFieldNumber(Schema<T> schema) throws IOException\n    {\n        if (isAtEnd())\n        {\n            lastTag = 0;\n            return 0;\n        }\n\n        // are we reading packed field?\n        if (isCurrentFieldPacked())\n        {\n            if (packedLimit < getTotalBytesRead())\n                throw ProtobufException.misreportedSize();\n\n            // Return field number while reading packed field\n            return lastTag >>> TAG_TYPE_BITS;\n        }\n\n        packedLimit = 0;\n        final int tag = readRawVarint32();\n        final int fieldNumber = tag >>> TAG_TYPE_BITS;\n        if (fieldNumber == 0)\n        {\n            if (decodeNestedMessageAsGroup && WIRETYPE_TAIL_DELIMITER == (tag & TAG_TYPE_MASK))\n            {\n                // protostuff's tail delimiter for streaming\n                // 2 options: length-delimited or tail-delimited.\n                lastTag = 0;\n                return 0;\n            }\n            // If we actually read zero, that's not a valid tag.\n            throw ProtobufException.invalidTag();\n        }\n        if (decodeNestedMessageAsGroup && WIRETYPE_END_GROUP == (tag & TAG_TYPE_MASK))\n        {\n            lastTag = 0;\n            return 0;\n        }\n\n        lastTag = tag;\n        return fieldNumber;\n    }\n\n    /**\n     * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that\n     * packed fields are being read.\n     *\n     * @throws IOException\n     */\n    private void checkIfPackedField() throws IOException\n    {\n        // Do we have the start of a packed field?\n        if (packedLimit == 0 && WireFormat.getTagWireType(lastTag) == WIRETYPE_LENGTH_DELIMITED)\n        {\n            final int length = readRawVarint32();\n            if (length < 0)\n                throw ProtobufException.negativeSize();\n\n            this.packedLimit = getTotalBytesRead() + length;\n        }\n    }\n\n    @Override\n    public byte[] readByteArray() throws IOException\n    {\n        final int size = readRawVarint32();\n        if (size <= (bufferSize - bufferPos) && size > 0)\n        {\n            // Fast path: We already have the bytes in a contiguous buffer, so\n            // just copy directly from it.\n            final byte[] copy = new byte[size];\n            System.arraycopy(buffer, bufferPos, copy, 0, size);\n            bufferPos += size;\n            return copy;\n        }\n        else\n        {\n            // Slow path: Build a byte array first then copy it.\n            return readRawBytes(size);\n        }\n    }\n\n    @Override\n    public <T> void handleUnknownField(int fieldNumber, Schema<T> schema) throws IOException\n    {\n        skipField(lastTag);\n    }\n\n    @Override\n    public void transferByteRangeTo(Output output, boolean utf8String, int fieldNumber,\n            boolean repeated) throws IOException\n    {\n        final int size = readRawVarint32();\n        if (size <= (bufferSize - bufferPos) && size > 0)\n        {\n            // Fast path: We already have the bytes in a contiguous buffer\n            output.writeByteRange(utf8String, fieldNumber, buffer, bufferPos, size, repeated);\n            bufferPos += size;\n        }\n        else\n        {\n            // Slow path: Build a byte array first then copy it.\n            output.writeByteRange(utf8String, fieldNumber, readRawBytes(size), 0, size, repeated);\n        }\n    }\n\n    /**\n     * Returns the last tag.\n     */\n    public int getLastTag()\n    {\n        return lastTag;\n    }\n\n    /**\n     * Reads a byte array/ByteBuffer value.\n     */\n    @Override\n    public ByteBuffer readByteBuffer() throws IOException\n    {\n        return ByteBuffer.wrap(readByteArray());\n    }\n\n    // END EXTRA\n}\n",
            "file_name": "CodedInput.java",
            "human_label": "Read raw varint",
            "level": "class_runnable",
            "lineno": "611",
            "name": "readRawVarint64",
            "oracle_context": "{ \"apis\" : \"[readRawByte, malformedVarint]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
            "package": "io.protostuff",
            "project": "protostuff-master"
        },
        {
            "_id": "636766ae1a6d9265ec0175dc",
            "all_context": "{ \"class_level\" : \"import java.util.List;\\nimport java.util.Map;\\nimport java.util.concurrent.ConcurrentHashMap;\\nimport java.util.logging.Logger;\\nimport javax.enterprise.context.RequestScoped;\\nimport javax.inject.Inject;\\nimport javax.ws.rs.container.ContainerResponseContext;\\nimport javax.ws.rs.container.ResourceInfo;\\nimport javax.ws.rs.core.HttpHeaders;\\nimport javax.ws.rs.core.UriInfo;\\nimport org.demoiselle.jee.crud.AbstractDAO;\\nimport org.demoiselle.jee.crud.CrudUtilHelper;\\nimport org.demoiselle.jee.crud.DemoiselleRequestContext;\\nimport org.demoiselle.jee.crud.ReservedHTTPHeaders;\\nimport org.demoiselle.jee.crud.ReservedKeyWords;\\nimport org.demoiselle.jee.crud.Search;\\nUriInfo uriInfo;\\nResourceInfo resourceInfo;\\nDemoiselleRequestContext drc;\\nPaginationHelperMessage message;\\nPaginationHelperConfig paginationConfig;\\nLogger logger;\\nPaginationHelper();\\nPaginationHelper(ResourceInfo resourceInfo,UriInfo uriInfo,PaginationHelperConfig paginationConfig,DemoiselleRequestContext drc,PaginationHelperMessage message);\\nfillObjects(ResourceInfo resourceInfo,UriInfo uriInfo);\\nisPaginationEnabled();\\nisRequestPagination();\\ncheckAndFillRangeValues();\\ngetDefaultNumberPagination();\\nhasSearchAnnotation();\\nisPartialContentResponse();\\nlogInvalidRangeParameters(String range);\\nbuildContentRange();\\nbuildAcceptRange();\\nbuildHeaders(ResourceInfo resourceInfo,UriInfo uriInfo);\\nbuildLinkHeader();\\nisFirstPage();\\nbuildAcceptRangeWithResponse(ContainerResponseContext response);\\nexecute(ResourceInfo resourceInfo,UriInfo uriInfo);\\n\", \"repo_level\" : \"public interface AbstractDAO {abstract EntityManager getEntityManager();\\npublic T persist(T entity);\\npublic T mergeHalf(I id,T entity);\\npublic T mergeFull(T entity);\\npublic void remove(I id);\\npublic T find(I id);\\npublic Result find();\\nprotected void configureCriteriaQuery(CriteriaBuilder criteriaBuilder,CriteriaQuery criteriaQuery);\\nprotected void configureOrder(CriteriaBuilder criteriaBuilder,CriteriaQuery criteriaQuery,Root root);\\nprotected Predicate[] buildPredicates(CriteriaBuilder criteriaBuilder,CriteriaQuery criteriaQuery,Root root);\\nprotected Boolean isEnumFilter(String key,String value,TreeNodeField tnf);\\nprotected Boolean isUUIDFilter(String key,String value,TreeNodeField tnf);\\nprotected Integer convertEnumToInt(String key,String value,TreeNodeField tnf);\\nprotected Boolean isLikeFilter(String value);\\nprotected Predicate buildLikePredicate(CriteriaBuilder criteriaBuilder,CriteriaQuery criteriaQuery,From root,String key,String value);\\nprotected Integer getMaxResult();\\npublic Long count();\\nprotected Predicate[] extractPredicates(MultivaluedMap queryParameters,CriteriaBuilder criteriaBuilder,Root root);\\npublic PaginationHelperConfig getPaginationConfig();\\npublic DemoiselleRequestContext getDrc();\\npublic Class<T> getEntityClass();\\n }\\npublic interface CrudUtilHelper {static Class<?> getTargetClass(Class targetClass);\\nstatic void checkIfExistField(Class targetClass,String field);\\nstatic List<Field> getAllFields(List fields,Class type);\\nstatic Field getField(Class targetClass,String name);\\nstatic List<String> extractFields(String fields);\\nstatic TreeNodeField<String,Set<String>> extractFieldsFromSearchAnnotation(ResourceInfo resourceInfo);\\nstatic void fillLeafTreeNodeField(TreeNodeField tnf,String field,Set value);\\nstatic void validateFields(TreeNodeField tnf,ResourceInfo resourceInfo,CrudMessage crudMessage);\\nstatic String getMethodAnnotatedWithID(Class targetClass);\\n }\\npublic interface DemoiselleRequestContext { Integer getLimit();\\n void setLimit(Integer limit);\\n Integer getOffset();\\n void setOffset(Integer offset);\\n Long getCount();\\n void setCount(Long count);\\n Class<?> getEntityClass();\\n void setEntityClass(Class entityClass);\\n TreeNodeField<String,Set<String>> getFilters();\\n void setFilters(TreeNodeField filters);\\n List<SortModel> getSorts();\\n void setSorts(List sorts);\\n TreeNodeField<String,Set<String>> getFields();\\n void setFields(TreeNodeField fields);\\n Boolean isPaginationEnabled();\\n void setPaginationEnabled(Boolean isPaginationEnabled);\\n }\\n\" }",
            "class_name": "PaginationHelper",
            "code": "public Boolean isPartialContentResponse(){\n  Integer limit=drc.getLimit() == null ? 0 : drc.getLimit();\n  Long count=drc.getCount() == null ? 0 : drc.getCount();\n  return !((limit + 1) >= count);\n}\n",
            "docstring": "/** \n * Check if the actual response is a Partial Content (HTTP 206 code)\n * @return is partial content or not\n */\n",
            "end_lineno": "219",
            "file_content": "/*\n * Demoiselle Framework\n *\n * License: GNU Lesser General Public License (LGPL), version 3 or later.\n * See the lgpl.txt file in the root directory or <https://www.gnu.org/licenses/lgpl.html>.\n */\npackage org.demoiselle.jee.crud.pagination;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Logger;\n\nimport javax.enterprise.context.RequestScoped;\nimport javax.inject.Inject;\nimport javax.ws.rs.container.ContainerResponseContext;\nimport javax.ws.rs.container.ResourceInfo;\nimport javax.ws.rs.core.HttpHeaders;\nimport javax.ws.rs.core.UriInfo;\n\nimport org.demoiselle.jee.crud.AbstractDAO;\nimport org.demoiselle.jee.crud.CrudUtilHelper;\nimport org.demoiselle.jee.crud.DemoiselleRequestContext;\nimport org.demoiselle.jee.crud.ReservedHTTPHeaders;\nimport org.demoiselle.jee.crud.ReservedKeyWords;\nimport org.demoiselle.jee.crud.Search;\n\n/**\n * Class responsible for managing the 'range' parameter comes from Url Query\n * String.\n *\n * Ex:\n *\n * Given a request\n * <pre>\n * GET @{literal http://localhost:8080/api/users?range=0-10}\n * </pre>\n *\n * This class will processing the request above and parse the range parameters\n * to {@link DemoiselleRequestContext} object.\n *\n * This object will be use on {@link AbstractDAO} class to execute the\n * pagination on database.\n *\n */\n@RequestScoped\npublic class PaginationHelper {\n\n    private UriInfo uriInfo;\n\n    private ResourceInfo resourceInfo;\n\n    @Inject\n    private DemoiselleRequestContext drc;\n\n    @Inject\n    private PaginationHelperMessage message;\n\n    @Inject\n    private PaginationHelperConfig paginationConfig;\n\n    private static final Logger logger = Logger.getLogger(PaginationHelper.class.getName());\n\n    public PaginationHelper() {\n    }\n\n    public PaginationHelper(ResourceInfo resourceInfo, UriInfo uriInfo, PaginationHelperConfig paginationConfig, DemoiselleRequestContext drc, PaginationHelperMessage message) {\n        this.resourceInfo = resourceInfo;\n        this.uriInfo = uriInfo;\n        this.paginationConfig = paginationConfig;\n        this.drc = drc;\n        this.message = message;\n    }\n\n    /**\n     * Open the request query string to extract values from 'range' parameter\n     * and fill the {@link DemoiselleRequestContext#setOffset(Integer)} and\n     * {@link DemoiselleRequestContext#setLimit(Integer)}\n     *\n     * @param resourceInfo ResourceInfo\n     * @param uriInfo UriInfo\n     */\n    public void execute(ResourceInfo resourceInfo, UriInfo uriInfo) {\n        fillObjects(resourceInfo, uriInfo);\n\n        drc.setPaginationEnabled(isPaginationEnabled());\n\n        if (drc.isPaginationEnabled()) {\n\n            if (isRequestPagination()) {\n                checkAndFillRangeValues();\n            }\n\n            if (hasSearchAnnotation() && !isRequestPagination()) {\n                drc.setLimit(getDefaultNumberPagination() - 1);\n                drc.setOffset(new Integer(0));\n            }\n        }\n\n        if (hasSearchAnnotation() && isRequestPagination()) {\n            Search searchAnnotation = resourceInfo.getResourceMethod().getAnnotation(Search.class);\n            // Pagination @Search.withPagination is disabled but the request parameter has 'range' parameter\n            if (searchAnnotation.withPagination() == Boolean.FALSE) {\n                throw new IllegalArgumentException(message.paginationIsNotEnabled());\n            }\n        }\n    }\n\n    private void fillObjects(ResourceInfo resourceInfo, UriInfo uriInfo) {\n        this.resourceInfo = resourceInfo == null ? this.resourceInfo : resourceInfo;\n        this.uriInfo = uriInfo == null ? this.uriInfo : uriInfo;\n    }\n\n    /**\n     * Check the pagination is enabled\n     *\n     * @return pagination enabled/disabled\n     */\n    private Boolean isPaginationEnabled() {\n        if (paginationConfig.getIsGlobalEnabled() == Boolean.FALSE) {\n            return Boolean.FALSE;\n        }\n\n        if (hasSearchAnnotation()) {\n            Search searchAnnotation = resourceInfo.getResourceMethod().getAnnotation(Search.class);\n            return searchAnnotation.withPagination();\n        }\n\n        return paginationConfig.getIsGlobalEnabled();\n    }\n\n    /**\n     * Check if the actual request has the 'range' parameter on query string\n     *\n     * @return is request pagination or not\n     */\n    private Boolean isRequestPagination() {\n        // Verify if contains 'range' in url\n        if (uriInfo.getQueryParameters().containsKey(ReservedKeyWords.DEFAULT_RANGE_KEY.getKey())) {\n            return Boolean.TRUE;\n        }\n        return Boolean.FALSE;\n    }\n\n    /**\n     * Check if the value of 'range' parameter is valid using the rules:\n     *\n     * - Value formatted like offset-limit (range=0-10); - The 'offset' and\n     * 'limit' should be a integer; - The 'offset' should be less than or equals\n     * 'limit';\n     *\n     *\n     * @throws IllegalArgumentException The format is invalid\n     */\n    private void checkAndFillRangeValues() throws IllegalArgumentException {\n        List<String> rangeList = uriInfo.getQueryParameters().get(ReservedKeyWords.DEFAULT_RANGE_KEY.getKey());\n        if (!rangeList.isEmpty()) {\n            String range[] = rangeList.get(0).split(\"-\");\n            if (range.length == 2) {\n                String offset = range[0];\n                String limit = range[1];\n\n                try {\n                    drc.setOffset(new Integer(offset));\n                    drc.setLimit(new Integer(limit));\n\n                    if (drc.getOffset() > drc.getLimit()) {\n                        logInvalidRangeParameters(rangeList.get(0));\n                        throw new IllegalArgumentException(this.message.invalidRangeParameters());\n                    }\n\n                    if (((drc.getLimit() - drc.getOffset()) + 1) > getDefaultNumberPagination()) {\n                        logger.warning(message.defaultPaginationNumberExceed(getDefaultNumberPagination()) + \", [\" + drc.toString() + \"]\");\n                        throw new IllegalArgumentException(message.defaultPaginationNumberExceed(getDefaultNumberPagination()));\n                    }\n\n                } catch (NumberFormatException nfe) {\n                    logInvalidRangeParameters(rangeList.get(0));\n                    throw new IllegalArgumentException(message.invalidRangeParameters());\n                }\n            } else {\n                logInvalidRangeParameters(rangeList.get(0));\n                throw new IllegalArgumentException(message.invalidRangeParameters());\n            }\n        }\n\n    }\n\n    /**\n     * Get default pagination number, if the target method is annotated with\n     * Search annotation the default annotation will be\n     * {@link Search#quantityPerPage()} otherwise the default pagination will be\n     * {@link PaginationHelperConfig#getDefaultPagination()} value;\n     *\n     * @return Number per page\n     */\n    private Integer getDefaultNumberPagination() {\n        if (hasSearchAnnotation()) {\n            Search searchAnnotation = resourceInfo.getResourceMethod().getAnnotation(Search.class);\n            return searchAnnotation.quantityPerPage();\n        }\n\n        return paginationConfig.getDefaultPagination();\n    }\n\n    private Boolean hasSearchAnnotation() {\n        return resourceInfo.getResourceMethod().isAnnotationPresent(Search.class);\n    }\n\n    /**\n     * Check if the actual response is a Partial Content (HTTP 206 code)\n     *\n     * @return is partial content or not\n     */\n    public Boolean isPartialContentResponse() {\n        Integer limit = drc.getLimit() == null ? 0 : drc.getLimit();\n        Long count = drc.getCount() == null ? 0 : drc.getCount();\n        return !((limit + 1) >= count);\n    }\n\n    private void logInvalidRangeParameters(String range) {\n        logger.warning(message.invalidRangeParameters() + \", [params: \" + range + \"]\");\n    }\n\n    /**\n     * Build the 'Content-Range' HTTP Header value.\n     *\n     * @return 'Content-Range' value\n     */\n    private String buildContentRange() {\n        Integer limit = drc.getLimit() == null ? getDefaultNumberPagination() - 1 : drc.getLimit();\n        Integer offset = drc.getOffset() == null ? 0 : drc.getOffset();\n        Long count = drc.getCount() == null ? 0 : drc.getCount();\n        return offset + \"-\" + (limit.equals(0) ? count - 1 : limit) + \"/\" + count;\n    }\n\n    /**\n     * Build the 'Accept-Range' HTTP Header value.\n     *\n     * @return 'Accept-Range' value\n     */\n    public String buildAcceptRange() {\n        String resource = \"\";\n\n        if (drc.getEntityClass() != null) {\n            resource = drc.getEntityClass().getSimpleName().toLowerCase();\n        } else {\n            if (resourceInfo != null && resourceInfo.getResourceClass() != null) {\n                Class<?> targetClass = CrudUtilHelper.getTargetClass(resourceInfo.getResourceClass());\n                if (targetClass != null) {\n                    resource = targetClass.getSimpleName().toLowerCase();\n                }\n            }\n        }\n\n        if (!resource.isEmpty()) {\n            return resource + \" \" + getDefaultNumberPagination();\n        }\n\n        return null;\n    }\n\n    /**\n     * Set the 'Content-Range', 'Accept-Range', 'Link' and\n     * 'Access-Control-Expose-Headers' HTTP headers;\n     *\n     * @param resourceInfo ResourceInfo\n     * @param uriInfo UriInfo\n     *\n     * @return A map with HTTP headers\n     */\n    public Map<String, String> buildHeaders(ResourceInfo resourceInfo, UriInfo uriInfo) {\n        fillObjects(resourceInfo, uriInfo);\n        Map<String, String> headers = new ConcurrentHashMap<>();\n\n        if (drc.isPaginationEnabled()) {\n            headers.putIfAbsent(ReservedHTTPHeaders.HTTP_HEADER_CONTENT_RANGE.getKey(), buildContentRange());\n            headers.putIfAbsent(ReservedHTTPHeaders.HTTP_HEADER_ACCEPT_RANGE.getKey(), buildAcceptRange());\n            String linkHeader = buildLinkHeader();\n\n            if (!linkHeader.isEmpty()) {\n                headers.putIfAbsent(HttpHeaders.LINK, linkHeader);\n            }\n        }\n\n        return headers;\n    }\n\n    /**\n     * Build the 'Link' HTTP header value\n     *\n     * @return 'Link' value\n     */\n    private String buildLinkHeader() {\n        StringBuffer sb = new StringBuffer();\n        String url = uriInfo.getRequestUri().toString();\n        url = url.replaceFirst(\".range=([^&]*)\", \"\");\n\n        if (drc.getOffset() == null) {\n            drc.setOffset(new Integer(0));\n        }\n\n        if (drc.getLimit() == null) {\n            drc.setLimit(getDefaultNumberPagination() - 1);\n        }\n\n        Integer offset = drc.getOffset() + 1;\n        Integer limit = drc.getLimit() + 1;\n        Integer quantityPerPage = (limit - offset) + 1;\n\n        if (uriInfo.getQueryParameters().isEmpty()\n                || (uriInfo.getQueryParameters().size() == 1 && uriInfo.getQueryParameters().containsKey(ReservedKeyWords.DEFAULT_RANGE_KEY.getKey()))) {\n            url += \"?\" + ReservedKeyWords.DEFAULT_RANGE_KEY.getKey() + \"=\";\n        } else {\n            url += \"&\" + ReservedKeyWords.DEFAULT_RANGE_KEY.getKey() + \"=\";\n        }\n\n        if (!isFirstPage()) {\n            Integer prevPageRangeInit = (drc.getOffset() - quantityPerPage) < 0 ? 0 : (drc.getOffset() - quantityPerPage);\n            Integer firstRange2 = quantityPerPage - 1 < drc.getOffset() - 1 ? quantityPerPage - 1 : drc.getOffset() - 1;\n\n            String firstPage = url + 0 + \"-\" + firstRange2;\n            String prevPage = url + prevPageRangeInit + \"-\" + (drc.getOffset() - 1);\n\n            sb.append(\"<\").append(firstPage).append(\">; rel=\\\"first\\\",\");\n            sb.append(\"<\").append(prevPage).append(\">; rel=\\\"prev\\\",\");\n        }\n\n        if (isPartialContentResponse()) {\n            String nextPage = url + (drc.getOffset() + quantityPerPage) + \"-\" + (2 * quantityPerPage + drc.getOffset() - 1);\n            String lastPage = url + (drc.getCount() - quantityPerPage) + \"-\" + (drc.getCount() - 1);\n\n            if (offset + quantityPerPage >= drc.getCount() - 1) {\n                nextPage = lastPage;\n            }\n\n            sb.append(\"<\").append(nextPage).append(\">; rel=\\\"next\\\",\");\n            sb.append(\"<\").append(lastPage).append(\">; rel=\\\"last\\\"\");\n        }\n\n        return sb.toString();\n    }\n\n    private Boolean isFirstPage() {\n        return drc.getOffset().equals(0);\n    }\n\n    public void buildAcceptRangeWithResponse(ContainerResponseContext response) {\n        if (response != null) {\n            String acceptRangeHeader = buildAcceptRange();\n            if (acceptRangeHeader != null) {\n                response.getHeaders().putSingle(ReservedHTTPHeaders.HTTP_HEADER_ACCEPT_RANGE.getKey(), acceptRangeHeader);\n            }\n        }\n\n    }\n\n}\n",
            "file_name": "PaginationHelper.java",
            "human_label": "Determine whether the actual response is a Partial Content",
            "level": "plib_runnable",
            "lineno": "210",
            "name": "isPartialContentResponse",
            "oracle_context": "{ \"apis\" : \"[getLimit, getCount]\", \"classes\" : \"[Integer, Long]\", \"vars\" : \"[drc]\" }",
            "package": "org.demoiselle.jee.crud.pagination",
            "project": "framework-master"
        },
        {
            "_id": "636767601a6d9265ec0180fd",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.*;\\nimport org.jgrapht.alg.util.*;\\nimport org.jgrapht.graph.*;\\nimport java.util.*;\\nimport java.util.function.*;\\nlong serialVersionUID;\\nMap<Pair<V,V>,Set<E>> touchingVerticesToEdgeMap;\\nFastLookupDirectedSpecifics(Graph graph,Map vertexMap,Map touchingVerticesToEdgeMap,EdgeSetFactory edgeSetFactory);\\ngetAllEdges(V sourceVertex,V targetVertex);\\ngetEdge(V sourceVertex,V targetVertex);\\naddEdgeToTouchingVertices(V sourceVertex,V targetVertex,E e);\\naddEdgeToTouchingVerticesIfAbsent(V sourceVertex,V targetVertex,E e);\\ncreateEdgeToTouchingVerticesIfAbsent(V sourceVertex,V targetVertex,Supplier edgeSupplier);\\nremoveEdgeFromTouchingVertices(V sourceVertex,V targetVertex,E e);\\nremoveFromIndex(V sourceVertex,V targetVertex,E e);\\n\", \"repo_level\" : \"\" }",
            "class_name": "FastLookupDirectedSpecifics",
            "code": "protected void addToIndex(V sourceVertex,V targetVertex,E e){\n  Pair<V,V> vertexPair=new Pair<>(sourceVertex,targetVertex);\n  Set<E> edgeSet=touchingVerticesToEdgeMap.get(vertexPair);\n  if (edgeSet != null)   edgeSet.add(e);\n else {\n    edgeSet=edgeSetFactory.createEdgeSet(sourceVertex);\n    edgeSet.add(e);\n    touchingVerticesToEdgeMap.put(vertexPair,edgeSet);\n  }\n}\n",
            "docstring": "/** \n * Add an edge to the index.\n * @param sourceVertex the source vertex\n * @param targetVertex the target vertex\n * @param e the edge\n */\n",
            "end_lineno": "159",
            "file_content": "/*\n * (C) Copyright 2015-2021, by Joris Kinable and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.graph.specifics;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.util.*;\nimport org.jgrapht.graph.*;\n\nimport java.util.*;\nimport java.util.function.*;\n\n/**\n * Fast implementation of DirectedSpecifics. This class uses additional data structures to improve\n * the performance of methods which depend on edge retrievals, e.g. getEdge(V u, V v),\n * containsEdge(V u, V v),addEdge(V u, V v). A disadvantage is an increase in memory consumption. If\n * memory utilization is an issue, use a {@link DirectedSpecifics} instead.\n *\n * @param <V> the graph vertex type\n * @param <E> the graph edge type\n *\n * @author Joris Kinable\n */\npublic class FastLookupDirectedSpecifics<V, E>\n    extends\n    DirectedSpecifics<V, E>\n{\n    private static final long serialVersionUID = 4089085208843722263L;\n\n    /**\n     * Maps a pair of vertices &lt;u,v&gt; to a set of edges {(u,v)}. In case of a multigraph, all\n     * edges which touch both u and v are included in the set.\n     */\n    protected Map<Pair<V, V>, Set<E>> touchingVerticesToEdgeMap;\n\n    /**\n     * Construct a new fast lookup directed specifics.\n     * \n     * @param graph the graph for which these specifics are for\n     * @param vertexMap map for the storage of vertex edge sets. Needs to have a predictable\n     *        iteration order.\n     * @param touchingVerticesToEdgeMap Additional map for caching. No need for a predictable\n     *        iteration order.\n     * @param edgeSetFactory factory for the creation of vertex edge sets\n     */\n    public FastLookupDirectedSpecifics(\n        Graph<V, E> graph, Map<V, DirectedEdgeContainer<V, E>> vertexMap,\n        Map<Pair<V, V>, Set<E>> touchingVerticesToEdgeMap, EdgeSetFactory<V, E> edgeSetFactory)\n    {\n        super(graph, vertexMap, edgeSetFactory);\n        this.touchingVerticesToEdgeMap = Objects.requireNonNull(touchingVerticesToEdgeMap);\n    }\n\n    @Override\n    public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n    {\n        if (graph.containsVertex(sourceVertex) && graph.containsVertex(targetVertex)) {\n            Set<E> edges = touchingVerticesToEdgeMap.get(new Pair<>(sourceVertex, targetVertex));\n            if (edges == null) {\n                return Collections.emptySet();\n            } else {\n                Set<E> edgeSet = edgeSetFactory.createEdgeSet(sourceVertex);\n                edgeSet.addAll(edges);\n                return edgeSet;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public E getEdge(V sourceVertex, V targetVertex)\n    {\n        Set<E> edges = touchingVerticesToEdgeMap.get(new Pair<>(sourceVertex, targetVertex));\n        if (edges == null || edges.isEmpty())\n            return null;\n        else {\n            return edges.iterator().next();\n        }\n    }\n\n    @Override\n    public boolean addEdgeToTouchingVertices(V sourceVertex, V targetVertex, E e)\n    {\n        if (!super.addEdgeToTouchingVertices(sourceVertex, targetVertex, e)) {\n            return false;\n        }\n        addToIndex(sourceVertex, targetVertex, e);\n        return true;\n    }\n\n    @Override\n    public boolean addEdgeToTouchingVerticesIfAbsent(V sourceVertex, V targetVertex, E e)\n    {\n        // first lookup using our own index\n        E edge = getEdge(sourceVertex, targetVertex);\n        if (edge != null) {\n            return false;\n        }\n\n        return addEdgeToTouchingVertices(sourceVertex, targetVertex, e);\n    }\n\n    @Override\n    public E createEdgeToTouchingVerticesIfAbsent(\n        V sourceVertex, V targetVertex, Supplier<E> edgeSupplier)\n    {\n        // first lookup using our own index\n        E edge = getEdge(sourceVertex, targetVertex);\n        if (edge != null) {\n            return null;\n        }\n\n        E e = edgeSupplier.get();\n        addEdgeToTouchingVertices(sourceVertex, targetVertex, e);\n        return e;\n    }\n\n    @Override\n    public void removeEdgeFromTouchingVertices(V sourceVertex, V targetVertex, E e)\n    {\n        super.removeEdgeFromTouchingVertices(sourceVertex, targetVertex, e);\n\n        removeFromIndex(sourceVertex, targetVertex, e);\n    }\n\n    /**\n     * Add an edge to the index.\n     * \n     * @param sourceVertex the source vertex\n     * @param targetVertex the target vertex\n     * @param e the edge\n     */\n    protected void addToIndex(V sourceVertex, V targetVertex, E e)\n    {\n        Pair<V, V> vertexPair = new Pair<>(sourceVertex, targetVertex);\n        Set<E> edgeSet = touchingVerticesToEdgeMap.get(vertexPair);\n        if (edgeSet != null)\n            edgeSet.add(e);\n        else {\n            edgeSet = edgeSetFactory.createEdgeSet(sourceVertex);\n            edgeSet.add(e);\n            touchingVerticesToEdgeMap.put(vertexPair, edgeSet);\n        }\n    }\n\n    /**\n     * Remove an edge from the index.\n     * \n     * @param sourceVertex the source vertex\n     * @param targetVertex the target vertex\n     * @param e the edge\n     */\n    protected void removeFromIndex(V sourceVertex, V targetVertex, E e)\n    {\n        Pair<V, V> vertexPair = new Pair<>(sourceVertex, targetVertex);\n        Set<E> edgeSet = touchingVerticesToEdgeMap.get(vertexPair);\n        if (edgeSet != null) {\n            edgeSet.remove(e);\n            if (edgeSet.isEmpty()) {\n                touchingVerticesToEdgeMap.remove(vertexPair);\n            }\n        }\n    }\n\n}\n",
            "file_name": "FastLookupDirectedSpecifics.java",
            "human_label": "Add an edge whose start point is sourceVertex and end point is targetVertex to touchingVerticesToEdgeMap.",
            "level": "class_runnable",
            "lineno": "141",
            "name": "addToIndex",
            "oracle_context": "{ \"apis\" : \"[get, add, createEdgeSet, put]\", \"classes\" : \"[Pair<V,V>, Set<E>]\", \"vars\" : \"[touchingVerticesToEdgeMap]\" }",
            "package": "org.jgrapht.graph.specifics",
            "project": "jgrapht-master"
        },
        {
            "_id": "636767521a6d9265ec017ecc",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.alg.util.*;\\nimport java.util.*;\\nsplitAlongXAxis(Box2D box);\\nsplitAlongYAxis(Box2D box);\\ncontainsPoint(Box2D box,Point2D p,Comparator comparator);\\ncontainsPoint(Box2D box,Point2D p);\\n\", \"repo_level\" : \"\" }",
            "class_name": "Boxes",
            "code": "public static Pair<Box2D,Box2D> splitAlongXAxis(Box2D box){\n  double newWidth=box.getWidth() / 2d;\n  double height=box.getHeight();\n  return Pair.of(Box2D.of(box.getMinX(),box.getMinY(),newWidth,height),Box2D.of(box.getMinX() + newWidth,box.getMinY(),newWidth,height));\n}\n",
            "docstring": "/** \n * Split a box along the x axis into two equal boxes.\n * @param box the box to split\n * @return a pair with the two resulting boxes\n */\n",
            "end_lineno": "71",
            "file_content": "/*\n * (C) Copyright 2018-2021, by Dimitrios Michail and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.alg.drawing.model;\n\nimport org.jgrapht.alg.util.*;\n\nimport java.util.*;\n\n/**\n * A collection of utilities to assist with boxes manipulation.\n * \n * @author Dimitrios Michail\n */\npublic abstract class Boxes\n{\n    /**\n     * Test whether a box contains a point.\n     * \n     * @param box the box\n     * @param p the point\n     * @return true if the point is contained inside the box, false otherwise\n     */\n    public static boolean containsPoint(Box2D box, Point2D p)\n    {\n        double maxX = box.getMinX() + box.getWidth();\n        if (p.getX() > maxX) {\n            return false;\n        }\n        if (p.getX() < box.getMinX()) {\n            return false;\n        }\n        double maxY = box.getMinY() + box.getHeight();\n        if (p.getY() > maxY) {\n            return false;\n        }\n        if (p.getY() < box.getMinY()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Split a box along the x axis into two equal boxes.\n     * \n     * @param box the box to split\n     * @return a pair with the two resulting boxes\n     */\n    public static Pair<Box2D, Box2D> splitAlongXAxis(Box2D box)\n    {\n        double newWidth = box.getWidth() / 2d;\n        double height = box.getHeight();\n        return Pair\n            .of(\n                Box2D.of(box.getMinX(), box.getMinY(), newWidth, height),\n                Box2D.of(box.getMinX() + newWidth, box.getMinY(), newWidth, height));\n    }\n\n    /**\n     * Split a box along the y axis into two equal boxes.\n     * \n     * @param box the box to split\n     * @return a pair with the two resulting boxes\n     */\n    public static Pair<Box2D, Box2D> splitAlongYAxis(Box2D box)\n    {\n        double width = box.getWidth();\n        double newHeight = box.getHeight() / 2d;\n        return Pair\n            .of(\n                Box2D.of(box.getMinX(), box.getMinY(), width, newHeight),\n                Box2D.of(box.getMinX(), box.getMinY() + newHeight, width, newHeight));\n    }\n\n    /**\n     * Test whether a box contains a point.\n     * \n     * @param box the box\n     * @param p the point\n     * @param comparator the comparator to use\n     * @return true if the point is contained inside the box, false otherwise\n     */\n    public static boolean containsPoint(Box2D box, Point2D p, Comparator<Double> comparator)\n    {\n        double maxX = box.getMinX() + box.getWidth();\n        if (comparator.compare(p.getX(), maxX) > 0) {\n            return false;\n        }\n        if (comparator.compare(p.getX(), box.getMinX()) < 0) {\n            return false;\n        }\n        double maxY = box.getMinY() + box.getHeight();\n        if (comparator.compare(p.getY(), maxY) > 0) {\n            return false;\n        }\n        if (comparator.compare(p.getY(), box.getMinY()) < 0) {\n            return false;\n        }\n        return true;\n    }\n\n}\n",
            "file_name": "Boxes.java",
            "human_label": "Divide a box into two equal boxes on the x axis.",
            "level": "project_runnable",
            "lineno": "57",
            "name": "splitAlongXAxis",
            "oracle_context": "{ \"apis\" : \"[getWidth, getHeight, of, getMinX, getMinY]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
            "package": "org.jgrapht.alg.drawing.model",
            "project": "jgrapht-master"
        },
        {
            "_id": "636766f21a6d9265ec017677",
            "all_context": "{ \"class_level\" : \"BooleanUtils();\\nisTrue(Boolean bool);\\nisNotTrue(Boolean bool);\\nisFalse(Boolean bool);\\nisNotFalse(Boolean bool);\\ntoBooleanObject(boolean bool);\\ntoBoolean(Boolean bool);\\ntoBooleanDefaultIfNull(Boolean bool,boolean valueIfNull);\\ntoBoolean(int value);\\ntoBooleanObject(int value);\\ntoBooleanObject(Integer value);\\ntoBoolean(int value,int trueValue,int falseValue);\\ntoBoolean(Integer value,Integer trueValue,Integer falseValue);\\ntoBooleanObject(int value,int trueValue,int falseValue,int nullValue);\\ntoBooleanObject(Integer value,Integer trueValue,Integer falseValue,Integer nullValue);\\ntoInteger(boolean bool);\\ntoInteger(boolean bool,int trueValue,int falseValue);\\ntoInteger(Boolean bool,int trueValue,int falseValue,int nullValue);\\ntoIntegerObject(boolean bool,Integer trueValue,Integer falseValue);\\ntoIntegerObject(Boolean bool,Integer trueValue,Integer falseValue,Integer nullValue);\\ntoBooleanObject(String str);\\ntoBooleanObject(String str,String trueString,String falseString,String nullString);\\ntoBoolean(String str);\\ntoBoolean(String str,String trueString,String falseString);\\ntoStringTrueFalse(Boolean bool);\\ntoStringOnOff(Boolean bool);\\ntoStringYesNo(Boolean bool);\\ntoString(Boolean bool,String trueString,String falseString,String nullString);\\ntoStringTrueFalse(boolean bool);\\ntoStringOnOff(boolean bool);\\ntoStringYesNo(boolean bool);\\ntoString(boolean bool,String trueString,String falseString);\\nxor(boolean[] array);\\nxor(Boolean[] array);\\nisBooleanType(Class targetType);\\nnegate(Boolean bool);\\n\", \"repo_level\" : \"\" }",
            "class_name": "BooleanUtils",
            "code": "public static boolean isNotTrue(Boolean bool){\n  return !isTrue(bool);\n}\n",
            "docstring": "/** \n * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>true</code>, handling <code>null</code> by returning <code>true</code>.</p> <pre> BooleanUtils.isNotTrue(Boolean.TRUE)  = false BooleanUtils.isNotTrue(Boolean.FALSE) = true BooleanUtils.isNotTrue(null)          = true </pre>\n * @param bool  the boolean to check, null returns <code>true</code>\n * @return <code>true</code> if the input is null or false\n * @since 2.3\n */\n",
            "end_lineno": "106",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils;\n/**\n * <p>Operations on boolean primitives and Boolean objects.</p>\n *\n * <p>This class tries to handle <code>null</code> input gracefully.\n * An exception will not be thrown for a <code>null</code> input.\n * Each method documents its behaviour in more detail.</p>\n *\n * <p>#ThreadSafe#</p>\n * @author Apache Software Foundation\n * @author Matthew Hawthorne\n * @author Gary Gregory\n * @since 2.0\n * @version $Id: BooleanUtils.java 1057037 2011-01-09 21:35:32Z niallp $\n */\npublic class BooleanUtils {\n    /**\n     * <p><code>BooleanUtils</code> instances should NOT be constructed in standard programming.\n     * Instead, the class should be used as <code>BooleanUtils.toBooleanObject(true);</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     */\n    public BooleanUtils() {\n        super();\n    }\n    // Boolean utilities\n    //--------------------------------------------------------------------------\n\n    /**\n     * <p>Negates the specified boolean.</p>\n     *\n     * <p>If <code>null</code> is passed in, <code>null</code> will be returned.</p>\n     *\n     * <pre>\n     *   BooleanUtils.negate(Boolean.TRUE)  = Boolean.FALSE;\n     *   BooleanUtils.negate(Boolean.FALSE) = Boolean.TRUE;\n     *   BooleanUtils.negate(null)          = null;\n     * </pre>\n     *\n     * @param bool  the Boolean to negate, may be null\n     * @return the negated Boolean, or <code>null</code> if <code>null</code> input\n     */\n    public static Boolean negate(Boolean bool) {\n        if (bool == null) {\n            return null;\n        }\n        return (bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE);\n    }\n    // boolean Boolean methods\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if a <code>Boolean</code> value is <code>true</code>,\n     * handling <code>null</code> by returning <code>false</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.isTrue(Boolean.TRUE)  = true\n     *   BooleanUtils.isTrue(Boolean.FALSE) = false\n     *   BooleanUtils.isTrue(null)          = false\n     * </pre>\n     *\n     * @param bool  the boolean to check, null returns <code>false</code>\n     * @return <code>true</code> only if the input is non-null and true\n     * @since 2.1\n     */\n    public static boolean isTrue(Boolean bool) {\n        if (bool == null) {\n            return false;\n        }\n        return bool.booleanValue() ? true : false;\n    }\n\n    /**\n     * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>true</code>,\n     * handling <code>null</code> by returning <code>true</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.isNotTrue(Boolean.TRUE)  = false\n     *   BooleanUtils.isNotTrue(Boolean.FALSE) = true\n     *   BooleanUtils.isNotTrue(null)          = true\n     * </pre>\n     *\n     * @param bool  the boolean to check, null returns <code>true</code>\n     * @return <code>true</code> if the input is null or false\n     * @since 2.3\n     */\n    public static boolean isNotTrue(Boolean bool) {\n        return !isTrue(bool);\n    }\n\n    /**\n     * <p>Checks if a <code>Boolean</code> value is <code>false</code>,\n     * handling <code>null</code> by returning <code>false</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.isFalse(Boolean.TRUE)  = false\n     *   BooleanUtils.isFalse(Boolean.FALSE) = true\n     *   BooleanUtils.isFalse(null)          = false\n     * </pre>\n     *\n     * @param bool  the boolean to check, null returns <code>false</code>\n     * @return <code>true</code> only if the input is non-null and false\n     * @since 2.1\n     */\n    public static boolean isFalse(Boolean bool) {\n        if (bool == null) {\n            return false;\n        }\n        return bool.booleanValue() ? false : true;\n    }\n\n    /**\n     * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>false</code>,\n     * handling <code>null</code> by returning <code>true</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.isNotFalse(Boolean.TRUE)  = true\n     *   BooleanUtils.isNotFalse(Boolean.FALSE) = false\n     *   BooleanUtils.isNotFalse(null)          = true\n     * </pre>\n     *\n     * @param bool  the boolean to check, null returns <code>true</code>\n     * @return <code>true</code> if the input is null or true\n     * @since 2.3\n     */\n    public static boolean isNotFalse(Boolean bool) {\n        return !isFalse(bool);\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Boolean factory that avoids creating new Boolean objecs all the time.</p>\n     *\n     * <p>This method was added to JDK1.4 but is available here for earlier JDKs.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBooleanObject(false) = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(true)  = Boolean.TRUE\n     * </pre>\n     *\n     * @param bool  the boolean to convert\n     * @return Boolean.TRUE or Boolean.FALSE as appropriate\n     */\n    public static Boolean toBooleanObject(boolean bool) {\n        return bool ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    /**\n     * <p>Converts a Boolean to a boolean handling <code>null</code>\n     * by returning <code>false</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(Boolean.TRUE)  = true\n     *   BooleanUtils.toBoolean(Boolean.FALSE) = false\n     *   BooleanUtils.toBoolean(null)          = false\n     * </pre>\n     *\n     * @param bool  the boolean to convert\n     * @return <code>true</code> or <code>false</code>, \n     *  <code>null</code> returns <code>false</code>\n     */\n    public static boolean toBoolean(Boolean bool) {\n        if (bool == null) {\n            return false;\n        }\n        return bool.booleanValue() ? true : false;\n    }\n\n    /**\n     * <p>Converts a Boolean to a boolean handling <code>null</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, false) = true\n     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, true) = false\n     *   BooleanUtils.toBooleanDefaultIfNull(null, true)          = true\n     * </pre>\n     *\n     * @param bool  the boolean to convert\n     * @param valueIfNull  the boolean value to return if <code>null</code>\n     * @return <code>true</code> or <code>false</code>\n     */\n    public static boolean toBooleanDefaultIfNull(Boolean bool, boolean valueIfNull) {\n        if (bool == null) {\n            return valueIfNull;\n        }\n        return bool.booleanValue() ? true : false;\n    }\n    // Integer to Boolean methods\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts an int to a boolean using the convention that <code>zero</code>\n     * is <code>false</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(0) = false\n     *   BooleanUtils.toBoolean(1) = true\n     *   BooleanUtils.toBoolean(2) = true\n     * </pre>\n     *\n     * @param value  the int to convert\n     * @return <code>true</code> if non-zero, <code>false</code>\n     *  if zero\n     */\n    public static boolean toBoolean(int value) {\n        return value == 0 ? false : true;\n    }\n\n    /**\n     * <p>Converts an int to a Boolean using the convention that <code>zero</code>\n     * is <code>false</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(0) = Boolean.FALSE\n     *   BooleanUtils.toBoolean(1) = Boolean.TRUE\n     *   BooleanUtils.toBoolean(2) = Boolean.TRUE\n     * </pre>\n     *\n     * @param value  the int to convert\n     * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n     *  <code>null</code> if <code>null</code>\n     */\n    public static Boolean toBooleanObject(int value) {\n        return value == 0 ? Boolean.FALSE : Boolean.TRUE;\n    }\n\n    /**\n     * <p>Converts an Integer to a Boolean using the convention that <code>zero</code>\n     * is <code>false</code>.</p>\n     *\n     * <p><code>null</code> will be converted to <code>null</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(new Integer(0))    = Boolean.FALSE\n     *   BooleanUtils.toBoolean(new Integer(1))    = Boolean.TRUE\n     *   BooleanUtils.toBoolean(new Integer(null)) = null\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n     *  <code>null</code> if <code>null</code> input\n     */\n    public static Boolean toBooleanObject(Integer value) {\n        if (value == null) {\n            return null;\n        }\n        return value.intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n    }\n\n    /**\n     * <p>Converts an int to a boolean specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(0, 1, 0) = false\n     *   BooleanUtils.toBoolean(1, 1, 0) = true\n     *   BooleanUtils.toBoolean(2, 1, 2) = false\n     *   BooleanUtils.toBoolean(2, 2, 0) = true\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @param trueValue  the value to match for <code>true</code>\n     * @param falseValue  the value to match for <code>false</code>\n     * @return <code>true</code> or <code>false</code>\n     * @throws IllegalArgumentException if no match\n     */\n    public static boolean toBoolean(int value, int trueValue, int falseValue) {\n        if (value == trueValue) {\n            return true;\n        } else if (value == falseValue) {\n            return false;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n    }\n\n    /**\n     * <p>Converts an Integer to a boolean specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(new Integer(0), new Integer(1), new Integer(0)) = false\n     *   BooleanUtils.toBoolean(new Integer(1), new Integer(1), new Integer(0)) = true\n     *   BooleanUtils.toBoolean(new Integer(2), new Integer(1), new Integer(2)) = false\n     *   BooleanUtils.toBoolean(new Integer(2), new Integer(2), new Integer(0)) = true\n     *   BooleanUtils.toBoolean(null, null, new Integer(0))                     = true\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @param trueValue  the value to match for <code>true</code>,\n     *  may be <code>null</code>\n     * @param falseValue  the value to match for <code>false</code>,\n     *  may be <code>null</code>\n     * @return <code>true</code> or <code>false</code>\n     * @throws IllegalArgumentException if no match\n     */\n    public static boolean toBoolean(Integer value, Integer trueValue, Integer falseValue) {\n        if (value == null) {\n            if (trueValue == null) {\n                return true;\n            } else if (falseValue == null) {\n                return false;\n            }\n        } else if (value.equals(trueValue)) {\n            return true;\n        } else if (value.equals(falseValue)) {\n            return false;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n    }\n\n    /**\n     * <p>Converts an int to a Boolean specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBooleanObject(0, 0, 2, 3) = Boolean.TRUE\n     *   BooleanUtils.toBooleanObject(2, 1, 2, 3) = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(3, 1, 2, 3) = null\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @param trueValue  the value to match for <code>true</code>\n     * @param falseValue  the value to match for <code>false</code>\n     * @param nullValue  the value to to match for <code>null</code>\n     * @return Boolean.TRUE, Boolean.FALSE, or <code>null</code>\n     * @throws IllegalArgumentException if no match\n     */\n    public static Boolean toBooleanObject(int value, int trueValue, int falseValue, int nullValue) {\n        if (value == trueValue) {\n            return Boolean.TRUE;\n        } else if (value == falseValue) {\n            return Boolean.FALSE;\n        } else if (value == nullValue) {\n            return null;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n    }\n\n    /**\n     * <p>Converts an Integer to a Boolean specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBooleanObject(new Integer(0), new Integer(0), new Integer(2), new Integer(3)) = Boolean.TRUE\n     *   BooleanUtils.toBooleanObject(new Integer(2), new Integer(1), new Integer(2), new Integer(3)) = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(new Integer(3), new Integer(1), new Integer(2), new Integer(3)) = null\n     * </pre>\n     *\n     * @param value  the Integer to convert\n     * @param trueValue  the value to match for <code>true</code>,\n     *  may be <code>null</code>\n     * @param falseValue  the value to match for <code>false</code>,\n     *  may be <code>null</code>\n     * @param nullValue  the value to to match for <code>null</code>,\n     *  may be <code>null</code>\n     * @return Boolean.TRUE, Boolean.FALSE, or <code>null</code>\n     * @throws IllegalArgumentException if no match\n     */\n    public static Boolean toBooleanObject(Integer value, Integer trueValue, Integer falseValue, Integer nullValue) {\n        if (value == null) {\n            if (trueValue == null) {\n                return Boolean.TRUE;\n            } else if (falseValue == null) {\n                return Boolean.FALSE;\n            } else if (nullValue == null) {\n                return null;\n            }\n        } else if (value.equals(trueValue)) {\n            return Boolean.TRUE;\n        } else if (value.equals(falseValue)) {\n            return Boolean.FALSE;\n        } else if (value.equals(nullValue)) {\n            return null;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n    }\n    // Boolean to Integer methods\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts a boolean to an int using the convention that\n     * <code>zero</code> is <code>false</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toInteger(true)  = 1\n     *   BooleanUtils.toInteger(false) = 0\n     * </pre>\n     *\n     * @param bool  the boolean to convert\n     * @return one if <code>true</code>, zero if <code>false</code>\n     */\n    public static int toInteger(boolean bool) {\n        return bool ? 1 : 0;\n    }\n\n    /**\n     * <p>Converts a boolean to an int specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toInteger(true, 1, 0)  = 1\n     *   BooleanUtils.toInteger(false, 1, 0) = 0\n     * </pre>\n     *\n     * @param bool  the to convert\n     * @param trueValue  the value to return if <code>true</code>\n     * @param falseValue  the value to return if <code>false</code>\n     * @return the appropriate value\n     */\n    public static int toInteger(boolean bool, int trueValue, int falseValue) {\n        return bool ? trueValue : falseValue;\n    }\n\n    /**\n     * <p>Converts a Boolean to an int specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toInteger(Boolean.TRUE, 1, 0, 2)  = 1\n     *   BooleanUtils.toInteger(Boolean.FALSE, 1, 0, 2) = 0\n     *   BooleanUtils.toInteger(null, 1, 0, 2)          = 2\n     * </pre>\n     *\n     * @param bool  the Boolean to convert\n     * @param trueValue  the value to return if <code>true</code>\n     * @param falseValue  the value to return if <code>false</code>\n     * @param nullValue  the value to return if <code>null</code>\n     * @return the appropriate value\n     */\n    public static int toInteger(Boolean bool, int trueValue, int falseValue, int nullValue) {\n        if (bool == null) {\n            return nullValue;\n        }\n        return bool.booleanValue() ? trueValue : falseValue;\n    }\n\n    /**\n     * <p>Converts a boolean to an Integer specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toIntegerObject(true, new Integer(1), new Integer(0))  = new Integer(1)\n     *   BooleanUtils.toIntegerObject(false, new Integer(1), new Integer(0)) = new Integer(0)\n     * </pre>\n     *\n     * @param bool  the to convert\n     * @param trueValue  the value to return if <code>true</code>,\n     *  may be <code>null</code>\n     * @param falseValue  the value to return if <code>false</code>,\n     *  may be <code>null</code>\n     * @return the appropriate value\n     */\n    public static Integer toIntegerObject(boolean bool, Integer trueValue, Integer falseValue) {\n        return bool ? trueValue : falseValue;\n    }\n\n    /**\n     * <p>Converts a Boolean to an Integer specifying the conversion values.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toIntegerObject(Boolean.TRUE, new Integer(1), new Integer(0), new Integer(2))  = new Integer(1)\n     *   BooleanUtils.toIntegerObject(Boolean.FALSE, new Integer(1), new Integer(0), new Integer(2)) = new Integer(0)\n     *   BooleanUtils.toIntegerObject(null, new Integer(1), new Integer(0), new Integer(2))          = new Integer(2)\n     * </pre>\n     *\n     * @param bool  the Boolean to convert\n     * @param trueValue  the value to return if <code>true</code>,\n     *  may be <code>null</code>\n     * @param falseValue  the value to return if <code>false</code>,\n     *  may be <code>null</code>\n     * @param nullValue  the value to return if <code>null</code>,\n     *  may be <code>null</code>\n     * @return the appropriate value\n     */\n    public static Integer toIntegerObject(Boolean bool, Integer trueValue, Integer falseValue, Integer nullValue) {\n        if (bool == null) {\n            return nullValue;\n        }\n        return bool.booleanValue() ? trueValue : falseValue;\n    }\n    // String to Boolean methods\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts a String to a Boolean.</p>\n     *\n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>.\n     * <code>'false'</code>, <code>'off'</code> or <code>'no'</code>\n     * (case insensitive) will return <code>false</code>.\n     * Otherwise, <code>null</code> is returned.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBooleanObject(null)    = null\n     *   BooleanUtils.toBooleanObject(\"true\")  = Boolean.TRUE\n     *   BooleanUtils.toBooleanObject(\"false\") = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(\"on\")    = Boolean.TRUE\n     *   BooleanUtils.toBooleanObject(\"ON\")    = Boolean.TRUE\n     *   BooleanUtils.toBooleanObject(\"off\")   = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(\"oFf\")   = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(\"blue\")  = null\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the Boolean value of the string,\n     *  <code>null</code> if no match or <code>null</code> input\n     */\n    public static Boolean toBooleanObject(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == null) {\n            return null;\n        }\n        if (\"true\".equals(str)) {\n            return Boolean.TRUE;\n        }\n        switch (str.length()) {\n        case 1: {\n            char ch0 = str.charAt(0);\n            if ((ch0 == 'y' || ch0 == 'Y') || (ch0 == 't' || ch0 == 'T')) {\n                return Boolean.TRUE;\n            }\n            if ((ch0 == 'n' || ch0 == 'N') || (ch0 == 'f' || ch0 == 'F')) {\n                return Boolean.FALSE;\n            }\n            break;\n        }\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) {\n                return Boolean.TRUE;\n            }\n            if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) {\n                return Boolean.FALSE;\n            }\n            break;\n        }\n        case 3: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) {\n                return Boolean.TRUE;\n            }\n            if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) {\n                return Boolean.FALSE;\n            }\n            break;\n        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) {\n                return Boolean.TRUE;\n            }\n            break;\n        }\n        case 5: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) {\n                return Boolean.FALSE;\n            }\n            break;\n        }\n        }\n        return null;\n    }\n\n    /**\n     * <p>Converts a String to a Boolean throwing an exception if no match.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBooleanObject(\"true\", \"true\", \"false\", \"null\")  = Boolean.TRUE\n     *   BooleanUtils.toBooleanObject(\"false\", \"true\", \"false\", \"null\") = Boolean.FALSE\n     *   BooleanUtils.toBooleanObject(\"null\", \"true\", \"false\", \"null\")  = null\n     * </pre>\n     *\n     * @param str  the String to check\n     * @param trueString  the String to match for <code>true</code>\n     *  (case sensitive), may be <code>null</code>\n     * @param falseString  the String to match for <code>false</code>\n     *  (case sensitive), may be <code>null</code>\n     * @param nullString  the String to match for <code>null</code>\n     *  (case sensitive), may be <code>null</code>\n     * @return the Boolean value of the string,\n     *  <code>null</code> if either the String matches <code>nullString</code>\n     *  or if <code>null</code> input and <code>nullString</code> is\n     *  <code>null</code>\n     * @throws IllegalArgumentException if the String doesn't match\n     */\n    public static Boolean toBooleanObject(String str, String trueString, String falseString, String nullString) {\n        if (str == null) {\n            if (trueString == null) {\n                return Boolean.TRUE;\n            } else if (falseString == null) {\n                return Boolean.FALSE;\n            } else if (nullString == null) {\n                return null;\n            }\n        } else if (str.equals(trueString)) {\n            return Boolean.TRUE;\n        } else if (str.equals(falseString)) {\n            return Boolean.FALSE;\n        } else if (str.equals(nullString)) {\n            return null;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The String did not match any specified value\");\n    }\n    // String to boolean methods\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts a String to a boolean (optimised for performance).</p>\n     *\n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>. Otherwise,\n     * <code>false</code> is returned.</p>\n     *\n     * <p>This method performs 4 times faster (JDK1.4) than\n     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n     * 'on' and 'yes' as true values.\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(null)    = false\n     *   BooleanUtils.toBoolean(\"true\")  = true\n     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n     *   BooleanUtils.toBoolean(\"on\")    = true\n     *   BooleanUtils.toBoolean(\"yes\")   = true\n     *   BooleanUtils.toBoolean(\"false\") = false\n     *   BooleanUtils.toBoolean(\"x gti\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the boolean value of the string, <code>false</code> if no match or the String is null\n     */\n    public static boolean toBoolean(String str) {\n        return toBoolean(toBooleanObject(str));\n    }\n\n    /**\n     * <p>Converts a String to a Boolean throwing an exception if no match found.</p>\n     *\n     * <p>null is returned if there is no match.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(\"true\", \"true\", \"false\")  = true\n     *   BooleanUtils.toBoolean(\"false\", \"true\", \"false\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @param trueString  the String to match for <code>true</code>\n     *  (case sensitive), may be <code>null</code>\n     * @param falseString  the String to match for <code>false</code>\n     *  (case sensitive), may be <code>null</code>\n     * @return the boolean value of the string\n     * @throws IllegalArgumentException if the String doesn't match\n     */\n    public static boolean toBoolean(String str, String trueString, String falseString) {\n        if (str == null) {\n            if (trueString == null) {\n                return true;\n            } else if (falseString == null) {\n                return false;\n            }\n        } else if (str.equals(trueString)) {\n            return true;\n        } else if (str.equals(falseString)) {\n            return false;\n        }\n        // no match\n        throw new IllegalArgumentException(\"The String did not match either specified value\");\n    }\n    // Boolean to String methods\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts a Boolean to a String returning <code>'true'</code>,\n     * <code>'false'</code>, or <code>null</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toStringTrueFalse(Boolean.TRUE)  = \"true\"\n     *   BooleanUtils.toStringTrueFalse(Boolean.FALSE) = \"false\"\n     *   BooleanUtils.toStringTrueFalse(null)          = null;\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @return <code>'true'</code>, <code>'false'</code>,\n     *  or <code>null</code>\n     */\n    public static String toStringTrueFalse(Boolean bool) {\n        return toString(bool, \"true\", \"false\", null);\n    }\n\n    /**\n     * <p>Converts a Boolean to a String returning <code>'on'</code>,\n     * <code>'off'</code>, or <code>null</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toStringOnOff(Boolean.TRUE)  = \"on\"\n     *   BooleanUtils.toStringOnOff(Boolean.FALSE) = \"off\"\n     *   BooleanUtils.toStringOnOff(null)          = null;\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @return <code>'on'</code>, <code>'off'</code>,\n     *  or <code>null</code>\n     */\n    public static String toStringOnOff(Boolean bool) {\n        return toString(bool, \"on\", \"off\", null);\n    }\n\n    /**\n     * <p>Converts a Boolean to a String returning <code>'yes'</code>,\n     * <code>'no'</code>, or <code>null</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toStringYesNo(Boolean.TRUE)  = \"yes\"\n     *   BooleanUtils.toStringYesNo(Boolean.FALSE) = \"no\"\n     *   BooleanUtils.toStringYesNo(null)          = null;\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @return <code>'yes'</code>, <code>'no'</code>,\n     *  or <code>null</code>\n     */\n    public static String toStringYesNo(Boolean bool) {\n        return toString(bool, \"yes\", \"no\", null);\n    }\n\n    /**\n     * <p>Converts a Boolean to a String returning one of the input Strings.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toString(Boolean.TRUE, \"true\", \"false\", null)   = \"true\"\n     *   BooleanUtils.toString(Boolean.FALSE, \"true\", \"false\", null)  = \"false\"\n     *   BooleanUtils.toString(null, \"true\", \"false\", null)           = null;\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @param trueString  the String to return if <code>true</code>,\n     *  may be <code>null</code>\n     * @param falseString  the String to return if <code>false</code>,\n     *  may be <code>null</code>\n     * @param nullString  the String to return if <code>null</code>,\n     *  may be <code>null</code>\n     * @return one of the three input Strings\n     */\n    public static String toString(Boolean bool, String trueString, String falseString, String nullString) {\n        if (bool == null) {\n            return nullString;\n        }\n        return bool.booleanValue() ? trueString : falseString;\n    }\n    // boolean to String methods\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts a boolean to a String returning <code>'true'</code>\n     * or <code>'false'</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toStringTrueFalse(true)   = \"true\"\n     *   BooleanUtils.toStringTrueFalse(false)  = \"false\"\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @return <code>'true'</code>, <code>'false'</code>,\n     *  or <code>null</code>\n     */\n    public static String toStringTrueFalse(boolean bool) {\n        return toString(bool, \"true\", \"false\");\n    }\n\n    /**\n     * <p>Converts a boolean to a String returning <code>'on'</code>\n     * or <code>'off'</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toStringOnOff(true)   = \"on\"\n     *   BooleanUtils.toStringOnOff(false)  = \"off\"\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @return <code>'on'</code>, <code>'off'</code>,\n     *  or <code>null</code>\n     */\n    public static String toStringOnOff(boolean bool) {\n        return toString(bool, \"on\", \"off\");\n    }\n\n    /**\n     * <p>Converts a boolean to a String returning <code>'yes'</code>\n     * or <code>'no'</code>.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toStringYesNo(true)   = \"yes\"\n     *   BooleanUtils.toStringYesNo(false)  = \"no\"\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @return <code>'yes'</code>, <code>'no'</code>,\n     *  or <code>null</code>\n     */\n    public static String toStringYesNo(boolean bool) {\n        return toString(bool, \"yes\", \"no\");\n    }\n\n    /**\n     * <p>Converts a boolean to a String returning one of the input Strings.</p>\n     *\n     * <pre>\n     *   BooleanUtils.toString(true, \"true\", \"false\")   = \"true\"\n     *   BooleanUtils.toString(false, \"true\", \"false\")  = \"false\"\n     * </pre>\n     *\n     * @param bool  the Boolean to check\n     * @param trueString  the String to return if <code>true</code>,\n     *  may be <code>null</code>\n     * @param falseString  the String to return if <code>false</code>,\n     *  may be <code>null</code>\n     * @return one of the two input Strings\n     */\n    public static String toString(boolean bool, String trueString, String falseString) {\n        return bool ? trueString : falseString;\n    }\n    // xor methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * <p>Performs an xor on a set of booleans.</p>\n     *\n     * <pre>\n     *   BooleanUtils.xor(new boolean[] { true, true })   = false\n     *   BooleanUtils.xor(new boolean[] { false, false }) = false\n     *   BooleanUtils.xor(new boolean[] { true, false })  = true\n     * </pre>\n     *\n     * @param array  an array of <code>boolean<code>s\n     * @return <code>true</code> if the xor is successful.\n     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n     * @throws IllegalArgumentException if <code>array</code> is empty.\n     */\n    public static boolean xor(boolean[] array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        // Loops through array, comparing each item\n        int trueCount = 0;\n        for (int i = 0; i < array.length; i++) {\n            // If item is true, and trueCount is < 1, increments count\n            // Else, xor fails\n            if (array[i]) {\n                if (trueCount < 1) {\n                    trueCount++;\n                } else {\n                    return false;\n                }\n            }\n        }\n        // Returns true if there was exactly 1 true item\n        return trueCount == 1;\n    }\n\n    /**\n     * <p>Performs an xor on an array of Booleans.</p>\n     *\n     * <pre>\n     *   BooleanUtils.xor(new Boolean[] { Boolean.TRUE, Boolean.TRUE })   = Boolean.FALSE\n     *   BooleanUtils.xor(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) = Boolean.FALSE\n     *   BooleanUtils.xor(new Boolean[] { Boolean.TRUE, Boolean.FALSE })  = Boolean.TRUE\n     * </pre>\n     *\n     * @param array  an array of <code>Boolean<code>s\n     * @return <code>true</code> if the xor is successful.\n     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n     * @throws IllegalArgumentException if <code>array</code> is empty.\n     * @throws IllegalArgumentException if <code>array</code> contains a <code>null</code>\n     */\n    public static Boolean xor(Boolean[] array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        boolean[] primitive = null;\n        try {\n            primitive = ArrayUtils.toPrimitive(array);\n        } catch (NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n        return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    //\n    public static boolean isBooleanType(Class targetType) {\n        return targetType.equals(Boolean.class) || targetType.equals(Boolean.TYPE);\n    }\n}\n",
            "file_name": "BooleanUtils.java",
            "human_label": "Check whether the parameter bool is not true.",
            "level": "self_contained",
            "lineno": "90",
            "name": "isNotTrue",
            "oracle_context": "{ \"apis\" : \"[isTrue]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
            "package": "net.hasor.utils",
            "project": "hasor-master"
        },
        {
            "_id": "6367675c1a6d9265ec018058",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.graph.*;\\nimport java.io.*;\\nimport java.lang.reflect.*;\\nimport java.util.*;\\nimport java.util.function.*;\\nSupplier<DefaultEdge> DEFAULT_EDGE_SUPPLIER;\\nSupplier<DefaultWeightedEdge> DEFAULT_WEIGHTED_EDGE_SUPPLIER;\\nSupplier<Object> OBJECT_SUPPLIER;\\nConstructor<? extends T> constructor;\\nlong serialVersionUID;\\nClass<T> type;\\ngetThrowingSupplier(Throwable e);\\ncreateDefaultEdgeSupplier();\\ncreateDefaultWeightedEdgeSupplier();\\ncreateIntegerSupplier();\\ncreateIntegerSupplier(int start);\\ncreateLongSupplier();\\ncreateLongSupplier(long start);\\ncreateStringSupplier();\\ncreateRandomUUIDStringSupplier();\\ncreateStringSupplier(int start);\\nSerializedForm(Class type);\\nreadResolve();\\nConstructorSupplier(Constructor constructor);\\nget();\\nwriteReplace();\\ncreateSupplier(Class clazz);\\n\", \"repo_level\" : \"\" }",
            "class_name": "SupplierUtil",
            "code": "@SuppressWarnings(\"unchecked\") public static Supplier<String> createStringSupplier(int start){\n  int[] container=new int[]{start};\n  return (Supplier<String> & Serializable)() -> String.valueOf(container[0]++);\n}\n",
            "docstring": "/** \n * Create a string supplier which returns unique strings. The returns strings are simply integers starting from start.\n * @param start where to start the sequence\n * @return a string supplier\n */\n",
            "end_lineno": "198",
            "file_content": "/*\n * (C) Copyright 2018-2021, by Dimitrios Michail and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.util;\n\nimport org.jgrapht.graph.*;\n\nimport java.io.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport java.util.function.*;\n\n/**\n * Helper class for suppliers.\n *\n * @author Dimitrios Michail\n */\npublic class SupplierUtil\n{\n\n    /**\n     * Supplier for {@link DefaultEdge}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Supplier<DefaultEdge> DEFAULT_EDGE_SUPPLIER =\n        (Supplier<DefaultEdge> & Serializable) DefaultEdge::new;\n\n    /**\n     * Supplier for {@link DefaultWeightedEdge}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Supplier<DefaultWeightedEdge> DEFAULT_WEIGHTED_EDGE_SUPPLIER =\n        (Supplier<DefaultWeightedEdge> & Serializable) DefaultWeightedEdge::new;\n\n    /**\n     * Supplier for {@link Object}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Supplier<Object> OBJECT_SUPPLIER =\n        (Supplier<Object> & Serializable) Object::new;\n\n    /**\n     * Create a supplier from a class which calls the default constructor.\n     * \n     * @param clazz the class\n     * @return the supplier\n     * @param <T> the type of results supplied by this supplier\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Supplier<T> createSupplier(Class<? extends T> clazz)\n    {\n        // shortcut to use pre-defined constructor method reference based suppliers\n        if (clazz == DefaultEdge.class) {\n            return (Supplier<T>) DEFAULT_EDGE_SUPPLIER;\n        } else if (clazz == DefaultWeightedEdge.class) {\n            return (Supplier<T>) DEFAULT_WEIGHTED_EDGE_SUPPLIER;\n        } else if (clazz == Object.class) {\n            return (Supplier<T>) OBJECT_SUPPLIER;\n        }\n\n        try {\n            final Constructor<? extends T> constructor = clazz.getDeclaredConstructor();\n            if ((!Modifier.isPublic(constructor.getModifiers())\n                || !Modifier.isPublic(constructor.getDeclaringClass().getModifiers()))\n                && !constructor.canAccess(null))\n            {\n                constructor.setAccessible(true);\n            }\n            return new ConstructorSupplier<>(constructor);\n        } catch (ReflectiveOperationException e) {\n            // Defer throwing an exception to the first time the supplier is called\n            return getThrowingSupplier(e);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T> Supplier<T> getThrowingSupplier(Throwable e)\n    {\n        return (Supplier<T> & Serializable) () -> {\n            throw new SupplierException(e.getMessage(), e);\n        };\n    }\n\n    /**\n     * Create a default edge supplier.\n     * \n     * @return a default edge supplier\n     */\n    public static Supplier<DefaultEdge> createDefaultEdgeSupplier()\n    {\n        return DEFAULT_EDGE_SUPPLIER;\n    }\n\n    /**\n     * Create a default weighted edge supplier.\n     * \n     * @return a default weighted edge supplier\n     */\n    public static Supplier<DefaultWeightedEdge> createDefaultWeightedEdgeSupplier()\n    {\n        return DEFAULT_WEIGHTED_EDGE_SUPPLIER;\n    }\n\n    /**\n     * Create an integer supplier which returns a sequence starting from zero.\n     * \n     * @return an integer supplier\n     */\n    public static Supplier<Integer> createIntegerSupplier()\n    {\n        return createIntegerSupplier(0);\n    }\n\n    /**\n     * Create an integer supplier which returns a sequence starting from a specific numbers.\n     * \n     * @param start where to start the sequence\n     * @return an integer supplier\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static Supplier<Integer> createIntegerSupplier(int start)\n    {\n        int[] modifiableInt = new int[] { start }; // like a modifiable int\n        return (Supplier<Integer> & Serializable) () -> modifiableInt[0]++;\n    }\n\n    /**\n     * Create a long supplier which returns a sequence starting from zero.\n     * \n     * @return a long supplier\n     */\n    public static Supplier<Long> createLongSupplier()\n    {\n        return createLongSupplier(0);\n    }\n\n    /**\n     * Create a long supplier which returns a sequence starting from a specific numbers.\n     * \n     * @param start where to start the sequence\n     * @return a long supplier\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static Supplier<Long> createLongSupplier(long start)\n    {\n        long[] modifiableLong = new long[] { start }; // like a modifiable long\n        return (Supplier<Long> & Serializable) () -> modifiableLong[0]++;\n    }\n\n    /**\n     * Create a string supplier which returns unique strings. The returns strings are simply\n     * integers starting from zero.\n     * \n     * @return a string supplier\n     */\n    public static Supplier<String> createStringSupplier()\n    {\n        return createStringSupplier(0);\n    }\n\n    /**\n     * Create a string supplier which returns random UUIDs.\n     * \n     * @return a string supplier\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static Supplier<String> createRandomUUIDStringSupplier()\n    {\n        return (Supplier<String> & Serializable) () -> UUID.randomUUID().toString();\n    }\n\n    /**\n     * Create a string supplier which returns unique strings. The returns strings are simply\n     * integers starting from start.\n     * \n     * @param start where to start the sequence\n     * @return a string supplier\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static Supplier<String> createStringSupplier(int start)\n    {\n        int[] container = new int[] { start };\n        return (Supplier<String> & Serializable) () -> String.valueOf(container[0]++);\n    }\n\n    private static class ConstructorSupplier<T>\n        implements\n        Supplier<T>,\n        Serializable\n    {\n        private final Constructor<? extends T> constructor;\n\n        private static class SerializedForm<T>\n            implements\n            Serializable\n        {\n            private static final long serialVersionUID = -2385289829144892760L;\n\n            private final Class<T> type;\n\n            public SerializedForm(Class<T> type)\n            {\n                this.type = type;\n            }\n\n            Object readResolve()\n                throws ObjectStreamException\n            {\n                try {\n                    return new ConstructorSupplier<>(type.getDeclaredConstructor());\n                } catch (ReflectiveOperationException e) {\n                    InvalidObjectException ex = new InvalidObjectException(\n                        \"Failed to get no-args constructor from \" + type);\n                    ex.initCause(e);\n                    throw ex;\n                }\n            }\n        }\n\n        public ConstructorSupplier(Constructor<? extends T> constructor)\n        {\n            this.constructor = constructor;\n        }\n\n        @Override\n        public T get()\n        {\n            try {\n                return constructor.newInstance();\n            } catch (ReflectiveOperationException ex) {\n                throw new SupplierException(\"Supplier failed\", ex);\n            }\n        }\n\n        Object writeReplace()\n            throws ObjectStreamException\n        {\n            return new SerializedForm<>(constructor.getDeclaringClass());\n        }\n    }\n}\n",
            "file_name": "SupplierUtil.java",
            "human_label": "Create a string supplier which returns unique integer strings starting from the given start.",
            "level": "slib_runnable",
            "lineno": "186",
            "name": "createStringSupplier",
            "oracle_context": "{ \"apis\" : \"[valueOf]\", \"classes\" : \"[int[]]\", \"vars\" : \"[]\" }",
            "package": "org.jgrapht.util",
            "project": "jgrapht-master"
        },
        {
            "_id": "6367670a1a6d9265ec0179dc",
            "all_context": "{ \"class_level\" : \"int COMPUTE_NOTHING;\\nint COMPUTE_MAX_STACK_AND_LOCAL;\\nint COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES;\\nint COMPUTE_INSERTED_FRAMES;\\nint COMPUTE_ALL_FRAMES;\\nint NA;\\nint[] STACK_SIZE_DELTA;\\nSymbolTable symbolTable;\\nint accessFlags;\\nint nameIndex;\\nString name;\\nint descriptorIndex;\\nString descriptor;\\nint maxStack;\\nint maxLocals;\\nByteVector code;\\nHandler firstHandler;\\nHandler lastHandler;\\nint lineNumberTableLength;\\nByteVector lineNumberTable;\\nint localVariableTableLength;\\nByteVector localVariableTable;\\nint localVariableTypeTableLength;\\nByteVector localVariableTypeTable;\\nint stackMapTableNumberOfEntries;\\nByteVector stackMapTableEntries;\\nAnnotationWriter lastCodeRuntimeVisibleTypeAnnotation;\\nAnnotationWriter lastCodeRuntimeInvisibleTypeAnnotation;\\nAttribute firstCodeAttribute;\\nint numberOfExceptions;\\nint[] exceptionIndexTable;\\nint signatureIndex;\\nAnnotationWriter lastRuntimeVisibleAnnotation;\\nAnnotationWriter lastRuntimeInvisibleAnnotation;\\nint visibleAnnotableParameterCount;\\nAnnotationWriter[] lastRuntimeVisibleParameterAnnotations;\\nint invisibleAnnotableParameterCount;\\nAnnotationWriter[] lastRuntimeInvisibleParameterAnnotations;\\nAnnotationWriter lastRuntimeVisibleTypeAnnotation;\\nAnnotationWriter lastRuntimeInvisibleTypeAnnotation;\\nByteVector defaultValue;\\nint parametersCount;\\nByteVector parameters;\\nAttribute firstAttribute;\\nint compute;\\nLabel firstBasicBlock;\\nLabel lastBasicBlock;\\nLabel currentBasicBlock;\\nint relativeStackSize;\\nint maxRelativeStackSize;\\nint currentLocals;\\nint previousFrameOffset;\\nint[] previousFrame;\\nint[] currentFrame;\\nboolean hasSubroutines;\\nboolean hasAsmInstructions;\\nint lastBytecodeOffset;\\nint sourceOffset;\\nint sourceLength;\\nMethodWriter(SymbolTable symbolTable,int access,String name,String descriptor,String signature,String[] exceptions,int compute);\\nhasFrames();\\nhasAsmInstructions();\\nvisitParameter(String name,int access);\\nvisitAnnotationDefault();\\nvisitAnnotation(String descriptor,boolean visible);\\nvisitTypeAnnotation(int typeRef,TypePath typePath,String descriptor,boolean visible);\\nvisitAnnotableParameterCount(int parameterCount,boolean visible);\\nvisitParameterAnnotation(int parameter,String annotationDescriptor,boolean visible);\\nvisitAttribute(Attribute attribute);\\nvisitCode();\\nvisitFrame(int type,int numLocal,Object[] local,int numStack,Object[] stack);\\nvisitInsn(int opcode);\\nvisitIntInsn(int opcode,int operand);\\nvisitVarInsn(int opcode,int var);\\nvisitTypeInsn(int opcode,String type);\\nvisitFieldInsn(int opcode,String owner,String name,String descriptor);\\nvisitMethodInsn(int opcode,String owner,String name,String descriptor,boolean isInterface);\\nvisitInvokeDynamicInsn(String name,String descriptor,Handle bootstrapMethodHandle,Object bootstrapMethodArguments);\\nvisitJumpInsn(int opcode,Label label);\\nvisitLabel(Label label);\\nvisitLdcInsn(Object value);\\nvisitIincInsn(int var,int increment);\\nvisitTableSwitchInsn(int min,int max,Label dflt,Label labels);\\nvisitLookupSwitchInsn(Label dflt,int[] keys,Label[] labels);\\nvisitSwitchInsn(Label dflt,Label[] labels);\\nvisitMultiANewArrayInsn(String descriptor,int numDimensions);\\nvisitInsnAnnotation(int typeRef,TypePath typePath,String descriptor,boolean visible);\\nvisitTryCatchBlock(Label start,Label end,Label handler,String type);\\nvisitTryCatchAnnotation(int typeRef,TypePath typePath,String descriptor,boolean visible);\\nvisitLocalVariable(String name,String descriptor,String signature,Label start,Label end,int index);\\nvisitLocalVariableAnnotation(int typeRef,TypePath typePath,Label[] start,Label[] end,int[] index,String descriptor,boolean visible);\\nvisitLineNumber(int line,Label start);\\nvisitMaxs(int maxStack,int maxLocals);\\ncomputeMaxStackAndLocal();\\nvisitEnd();\\naddSuccessorToCurrentBasicBlock(int info,Label successor);\\nendCurrentBasicBlockWithNoSuccessor();\\nvisitFrameStart(int offset,int numLocal,int numStack);\\nvisitAbstractType(int frameIndex,int abstractType);\\nvisitFrameEnd();\\nputFrame();\\nputAbstractTypes(int start,int end);\\nputFrameType(Object type);\\ncanCopyMethodAttributes(ClassReader source,boolean hasSyntheticAttribute,boolean hasDeprecatedAttribute,int descriptorIndex,int signatureIndex,int exceptionsOffset);\\nsetMethodAttributesSource(int methodInfoOffset,int methodInfoLength);\\ncomputeMethodInfoSize();\\nputMethodInfo(ByteVector output);\\ncollectAttributePrototypes(Set attributePrototypes);\\ncomputeAllFrames();\\n\", \"repo_level\" : \"\" }",
            "class_name": "MethodWriter",
            "code": "private void putAbstractTypes(final int start,final int end){\n  for (int i=start; i < end; ++i) {\n    Frame.putAbstractType(symbolTable,currentFrame[i],stackMapTableEntries);\n  }\n}\n",
            "docstring": "/** \n * Puts some abstract types of  {@link #currentFrame} in {@link #stackMapTableEntries} , using theJVMS verification_type_info format used in StackMapTable attributes.\n * @param start index of the first type in {@link #currentFrame} to write.\n * @param end index of last type in {@link #currentFrame} to write (exclusive).\n */\n",
            "end_lineno": "1743",
            "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage net.hasor.utils.asm;\n/**\n * A {@link MethodVisitor} that generates a corresponding 'method_info' structure, as defined in the\n * Java Virtual Machine Specification (JVMS).\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.6\">JVMS\n *     4.6</a>\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\nfinal class MethodWriter extends MethodVisitor {\n    /** Indicates that nothing must be computed. */\n    static final         int                COMPUTE_NOTHING                         = 0;\n    /**\n     * Indicates that the maximum stack size and the maximum number of local variables must be\n     * computed, from scratch.\n     */\n    static final         int                COMPUTE_MAX_STACK_AND_LOCAL             = 1;\n    /**\n     * Indicates that the maximum stack size and the maximum number of local variables must be\n     * computed, from the existing stack map frames. This can be done more efficiently than with the\n     * control flow graph algorithm used for {@link #COMPUTE_MAX_STACK_AND_LOCAL}, by using a linear\n     * scan of the bytecode instructions.\n     */\n    static final         int                COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES = 2;\n    /**\n     * Indicates that the stack map frames of type F_INSERT must be computed. The other frames are not\n     * computed. They should all be of type F_NEW and should be sufficient to compute the content of\n     * the F_INSERT frames, together with the bytecode instructions between a F_NEW and a F_INSERT\n     * frame - and without any knowledge of the type hierarchy (by definition of F_INSERT).\n     */\n    static final         int                COMPUTE_INSERTED_FRAMES                 = 3;\n    /**\n     * Indicates that all the stack map frames must be computed. In this case the maximum stack size\n     * and the maximum number of local variables is also computed.\n     */\n    static final         int                COMPUTE_ALL_FRAMES                      = 4;\n    /** Indicates that {@link #STACK_SIZE_DELTA} is not applicable (not constant or never used). */\n    private static final int                NA                                      = 0;\n    /**\n     * The stack size variation corresponding to each JVM opcode. The stack size variation for opcode\n     * 'o' is given by the array element at index 'o'.\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html\">JVMS 6</a>\n     */\n    private static final int[]              STACK_SIZE_DELTA                        = { 0, // nop = 0 (0x0)\n            1, // aconst_null = 1 (0x1)\n            1, // iconst_m1 = 2 (0x2)\n            1, // iconst_0 = 3 (0x3)\n            1, // iconst_1 = 4 (0x4)\n            1, // iconst_2 = 5 (0x5)\n            1, // iconst_3 = 6 (0x6)\n            1, // iconst_4 = 7 (0x7)\n            1, // iconst_5 = 8 (0x8)\n            2, // lconst_0 = 9 (0x9)\n            2, // lconst_1 = 10 (0xa)\n            1, // fconst_0 = 11 (0xb)\n            1, // fconst_1 = 12 (0xc)\n            1, // fconst_2 = 13 (0xd)\n            2, // dconst_0 = 14 (0xe)\n            2, // dconst_1 = 15 (0xf)\n            1, // bipush = 16 (0x10)\n            1, // sipush = 17 (0x11)\n            1, // ldc = 18 (0x12)\n            NA, // ldc_w = 19 (0x13)\n            NA, // ldc2_w = 20 (0x14)\n            1, // iload = 21 (0x15)\n            2, // lload = 22 (0x16)\n            1, // fload = 23 (0x17)\n            2, // dload = 24 (0x18)\n            1, // aload = 25 (0x19)\n            NA, // iload_0 = 26 (0x1a)\n            NA, // iload_1 = 27 (0x1b)\n            NA, // iload_2 = 28 (0x1c)\n            NA, // iload_3 = 29 (0x1d)\n            NA, // lload_0 = 30 (0x1e)\n            NA, // lload_1 = 31 (0x1f)\n            NA, // lload_2 = 32 (0x20)\n            NA, // lload_3 = 33 (0x21)\n            NA, // fload_0 = 34 (0x22)\n            NA, // fload_1 = 35 (0x23)\n            NA, // fload_2 = 36 (0x24)\n            NA, // fload_3 = 37 (0x25)\n            NA, // dload_0 = 38 (0x26)\n            NA, // dload_1 = 39 (0x27)\n            NA, // dload_2 = 40 (0x28)\n            NA, // dload_3 = 41 (0x29)\n            NA, // aload_0 = 42 (0x2a)\n            NA, // aload_1 = 43 (0x2b)\n            NA, // aload_2 = 44 (0x2c)\n            NA, // aload_3 = 45 (0x2d)\n            -1, // iaload = 46 (0x2e)\n            0, // laload = 47 (0x2f)\n            -1, // faload = 48 (0x30)\n            0, // daload = 49 (0x31)\n            -1, // aaload = 50 (0x32)\n            -1, // baload = 51 (0x33)\n            -1, // caload = 52 (0x34)\n            -1, // saload = 53 (0x35)\n            -1, // istore = 54 (0x36)\n            -2, // lstore = 55 (0x37)\n            -1, // fstore = 56 (0x38)\n            -2, // dstore = 57 (0x39)\n            -1, // astore = 58 (0x3a)\n            NA, // istore_0 = 59 (0x3b)\n            NA, // istore_1 = 60 (0x3c)\n            NA, // istore_2 = 61 (0x3d)\n            NA, // istore_3 = 62 (0x3e)\n            NA, // lstore_0 = 63 (0x3f)\n            NA, // lstore_1 = 64 (0x40)\n            NA, // lstore_2 = 65 (0x41)\n            NA, // lstore_3 = 66 (0x42)\n            NA, // fstore_0 = 67 (0x43)\n            NA, // fstore_1 = 68 (0x44)\n            NA, // fstore_2 = 69 (0x45)\n            NA, // fstore_3 = 70 (0x46)\n            NA, // dstore_0 = 71 (0x47)\n            NA, // dstore_1 = 72 (0x48)\n            NA, // dstore_2 = 73 (0x49)\n            NA, // dstore_3 = 74 (0x4a)\n            NA, // astore_0 = 75 (0x4b)\n            NA, // astore_1 = 76 (0x4c)\n            NA, // astore_2 = 77 (0x4d)\n            NA, // astore_3 = 78 (0x4e)\n            -3, // iastore = 79 (0x4f)\n            -4, // lastore = 80 (0x50)\n            -3, // fastore = 81 (0x51)\n            -4, // dastore = 82 (0x52)\n            -3, // aastore = 83 (0x53)\n            -3, // bastore = 84 (0x54)\n            -3, // castore = 85 (0x55)\n            -3, // sastore = 86 (0x56)\n            -1, // pop = 87 (0x57)\n            -2, // pop2 = 88 (0x58)\n            1, // dup = 89 (0x59)\n            1, // dup_x1 = 90 (0x5a)\n            1, // dup_x2 = 91 (0x5b)\n            2, // dup2 = 92 (0x5c)\n            2, // dup2_x1 = 93 (0x5d)\n            2, // dup2_x2 = 94 (0x5e)\n            0, // swap = 95 (0x5f)\n            -1, // iadd = 96 (0x60)\n            -2, // ladd = 97 (0x61)\n            -1, // fadd = 98 (0x62)\n            -2, // dadd = 99 (0x63)\n            -1, // isub = 100 (0x64)\n            -2, // lsub = 101 (0x65)\n            -1, // fsub = 102 (0x66)\n            -2, // dsub = 103 (0x67)\n            -1, // imul = 104 (0x68)\n            -2, // lmul = 105 (0x69)\n            -1, // fmul = 106 (0x6a)\n            -2, // dmul = 107 (0x6b)\n            -1, // idiv = 108 (0x6c)\n            -2, // ldiv = 109 (0x6d)\n            -1, // fdiv = 110 (0x6e)\n            -2, // ddiv = 111 (0x6f)\n            -1, // irem = 112 (0x70)\n            -2, // lrem = 113 (0x71)\n            -1, // frem = 114 (0x72)\n            -2, // drem = 115 (0x73)\n            0, // ineg = 116 (0x74)\n            0, // lneg = 117 (0x75)\n            0, // fneg = 118 (0x76)\n            0, // dneg = 119 (0x77)\n            -1, // ishl = 120 (0x78)\n            -1, // lshl = 121 (0x79)\n            -1, // ishr = 122 (0x7a)\n            -1, // lshr = 123 (0x7b)\n            -1, // iushr = 124 (0x7c)\n            -1, // lushr = 125 (0x7d)\n            -1, // iand = 126 (0x7e)\n            -2, // land = 127 (0x7f)\n            -1, // ior = 128 (0x80)\n            -2, // lor = 129 (0x81)\n            -1, // ixor = 130 (0x82)\n            -2, // lxor = 131 (0x83)\n            0, // iinc = 132 (0x84)\n            1, // i2l = 133 (0x85)\n            0, // i2f = 134 (0x86)\n            1, // i2d = 135 (0x87)\n            -1, // l2i = 136 (0x88)\n            -1, // l2f = 137 (0x89)\n            0, // l2d = 138 (0x8a)\n            0, // f2i = 139 (0x8b)\n            1, // f2l = 140 (0x8c)\n            1, // f2d = 141 (0x8d)\n            -1, // d2i = 142 (0x8e)\n            0, // d2l = 143 (0x8f)\n            -1, // d2f = 144 (0x90)\n            0, // i2b = 145 (0x91)\n            0, // i2c = 146 (0x92)\n            0, // i2s = 147 (0x93)\n            -3, // lcmp = 148 (0x94)\n            -1, // fcmpl = 149 (0x95)\n            -1, // fcmpg = 150 (0x96)\n            -3, // dcmpl = 151 (0x97)\n            -3, // dcmpg = 152 (0x98)\n            -1, // ifeq = 153 (0x99)\n            -1, // ifne = 154 (0x9a)\n            -1, // iflt = 155 (0x9b)\n            -1, // ifge = 156 (0x9c)\n            -1, // ifgt = 157 (0x9d)\n            -1, // ifle = 158 (0x9e)\n            -2, // if_icmpeq = 159 (0x9f)\n            -2, // if_icmpne = 160 (0xa0)\n            -2, // if_icmplt = 161 (0xa1)\n            -2, // if_icmpge = 162 (0xa2)\n            -2, // if_icmpgt = 163 (0xa3)\n            -2, // if_icmple = 164 (0xa4)\n            -2, // if_acmpeq = 165 (0xa5)\n            -2, // if_acmpne = 166 (0xa6)\n            0, // goto = 167 (0xa7)\n            1, // jsr = 168 (0xa8)\n            0, // ret = 169 (0xa9)\n            -1, // tableswitch = 170 (0xaa)\n            -1, // lookupswitch = 171 (0xab)\n            -1, // ireturn = 172 (0xac)\n            -2, // lreturn = 173 (0xad)\n            -1, // freturn = 174 (0xae)\n            -2, // dreturn = 175 (0xaf)\n            -1, // areturn = 176 (0xb0)\n            0, // return = 177 (0xb1)\n            NA, // getstatic = 178 (0xb2)\n            NA, // putstatic = 179 (0xb3)\n            NA, // getfield = 180 (0xb4)\n            NA, // putfield = 181 (0xb5)\n            NA, // invokevirtual = 182 (0xb6)\n            NA, // invokespecial = 183 (0xb7)\n            NA, // invokestatic = 184 (0xb8)\n            NA, // invokeinterface = 185 (0xb9)\n            NA, // invokedynamic = 186 (0xba)\n            1, // new = 187 (0xbb)\n            0, // newarray = 188 (0xbc)\n            0, // anewarray = 189 (0xbd)\n            0, // arraylength = 190 (0xbe)\n            NA, // athrow = 191 (0xbf)\n            0, // checkcast = 192 (0xc0)\n            0, // instanceof = 193 (0xc1)\n            -1, // monitorenter = 194 (0xc2)\n            -1, // monitorexit = 195 (0xc3)\n            NA, // wide = 196 (0xc4)\n            NA, // multianewarray = 197 (0xc5)\n            -1, // ifnull = 198 (0xc6)\n            -1, // ifnonnull = 199 (0xc7)\n            NA, // goto_w = 200 (0xc8)\n            NA // jsr_w = 201 (0xc9)\n    };\n    /** Where the constants used in this MethodWriter must be stored. */\n    private final        SymbolTable        symbolTable;\n    // Note: fields are ordered as in the method_info structure, and those related to attributes are\n    // ordered as in Section 4.7 of the JVMS.\n    /**\n     * The access_flags field of the method_info JVMS structure. This field can contain ASM specific\n     * access flags, such as {@link Opcodes#ACC_DEPRECATED}, which are removed when generating the\n     * ClassFile structure.\n     */\n    private final        int                accessFlags;\n    /** The name_index field of the method_info JVMS structure. */\n    private final        int                nameIndex;\n    /** The name of this method. */\n    private final        String             name;\n    /** The descriptor_index field of the method_info JVMS structure. */\n    private final        int                descriptorIndex;\n    /** The descriptor of this method. */\n    private final        String             descriptor;\n    // Code attribute fields and sub attributes:\n    /** The max_stack field of the Code attribute. */\n    private              int                maxStack;\n    /** The max_locals field of the Code attribute. */\n    private              int                maxLocals;\n    /** The 'code' field of the Code attribute. */\n    private final        ByteVector         code                                    = new ByteVector();\n    /**\n     * The first element in the exception handler list (used to generate the exception_table of the\n     * Code attribute). The next ones can be accessed with the {@link Handler#nextHandler} field. May\n     * be {@literal null}.\n     */\n    private              Handler            firstHandler;\n    /**\n     * The last element in the exception handler list (used to generate the exception_table of the\n     * Code attribute). The next ones can be accessed with the {@link Handler#nextHandler} field. May\n     * be {@literal null}.\n     */\n    private              Handler            lastHandler;\n    /** The line_number_table_length field of the LineNumberTable code attribute. */\n    private              int                lineNumberTableLength;\n    /** The line_number_table array of the LineNumberTable code attribute, or {@literal null}. */\n    private              ByteVector         lineNumberTable;\n    /** The local_variable_table_length field of the LocalVariableTable code attribute. */\n    private              int                localVariableTableLength;\n    /**\n     * The local_variable_table array of the LocalVariableTable code attribute, or {@literal null}.\n     */\n    private              ByteVector         localVariableTable;\n    /** The local_variable_type_table_length field of the LocalVariableTypeTable code attribute. */\n    private              int                localVariableTypeTableLength;\n    /**\n     * The local_variable_type_table array of the LocalVariableTypeTable code attribute, or {@literal\n     * null}.\n     */\n    private              ByteVector         localVariableTypeTable;\n    /** The number_of_entries field of the StackMapTable code attribute. */\n    private              int                stackMapTableNumberOfEntries;\n    /** The 'entries' array of the StackMapTable code attribute. */\n    private              ByteVector         stackMapTableEntries;\n    /**\n     * The last runtime visible type annotation of the Code attribute. The previous ones can be\n     * accessed with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\n     */\n    private              AnnotationWriter   lastCodeRuntimeVisibleTypeAnnotation;\n    /**\n     * The last runtime invisible type annotation of the Code attribute. The previous ones can be\n     * accessed with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\n     */\n    private              AnnotationWriter   lastCodeRuntimeInvisibleTypeAnnotation;\n    /**\n     * The first non standard attribute of the Code attribute. The next ones can be accessed with the\n     * {@link Attribute#nextAttribute} field. May be {@literal null}.\n     *\n     * <p><b>WARNING</b>: this list stores the attributes in the <i>reverse</i> order of their visit.\n     * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link\n     * #putMethodInfo} method writes the attributes in the order defined by this list, i.e. in the\n     * reverse order specified by the user.\n     */\n    private              Attribute          firstCodeAttribute;\n    // Other method_info attributes:\n    /** The number_of_exceptions field of the Exceptions attribute. */\n    private final        int                numberOfExceptions;\n    /** The exception_index_table array of the Exceptions attribute, or {@literal null}. */\n    private final        int[]              exceptionIndexTable;\n    /** The signature_index field of the Signature attribute. */\n    private final        int                signatureIndex;\n    /**\n     * The last runtime visible annotation of this method. The previous ones can be accessed with the\n     * {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\n     */\n    private              AnnotationWriter   lastRuntimeVisibleAnnotation;\n    /**\n     * The last runtime invisible annotation of this method. The previous ones can be accessed with\n     * the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\n     */\n    private              AnnotationWriter   lastRuntimeInvisibleAnnotation;\n    /** The number of method parameters that can have runtime visible annotations, or 0. */\n    private              int                visibleAnnotableParameterCount;\n    /**\n     * The runtime visible parameter annotations of this method. Each array element contains the last\n     * annotation of a parameter (which can be {@literal null} - the previous ones can be accessed\n     * with the {@link AnnotationWriter#previousAnnotation} field). May be {@literal null}.\n     */\n    private              AnnotationWriter[] lastRuntimeVisibleParameterAnnotations;\n    /** The number of method parameters that can have runtime visible annotations, or 0. */\n    private              int                invisibleAnnotableParameterCount;\n    /**\n     * The runtime invisible parameter annotations of this method. Each array element contains the\n     * last annotation of a parameter (which can be {@literal null} - the previous ones can be\n     * accessed with the {@link AnnotationWriter#previousAnnotation} field). May be {@literal null}.\n     */\n    private              AnnotationWriter[] lastRuntimeInvisibleParameterAnnotations;\n    /**\n     * The last runtime visible type annotation of this method. The previous ones can be accessed with\n     * the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\n     */\n    private              AnnotationWriter   lastRuntimeVisibleTypeAnnotation;\n    /**\n     * The last runtime invisible type annotation of this method. The previous ones can be accessed\n     * with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\n     */\n    private              AnnotationWriter   lastRuntimeInvisibleTypeAnnotation;\n    /** The default_value field of the AnnotationDefault attribute, or {@literal null}. */\n    private              ByteVector         defaultValue;\n    /** The parameters_count field of the MethodParameters attribute. */\n    private              int                parametersCount;\n    /** The 'parameters' array of the MethodParameters attribute, or {@literal null}. */\n    private              ByteVector         parameters;\n    /**\n     * The first non standard attribute of this method. The next ones can be accessed with the {@link\n     * Attribute#nextAttribute} field. May be {@literal null}.\n     *\n     * <p><b>WARNING</b>: this list stores the attributes in the <i>reverse</i> order of their visit.\n     * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link\n     * #putMethodInfo} method writes the attributes in the order defined by this list, i.e. in the\n     * reverse order specified by the user.\n     */\n    private              Attribute          firstAttribute;\n    // -----------------------------------------------------------------------------------------------\n    // Fields used to compute the maximum stack size and number of locals, and the stack map frames\n    // -----------------------------------------------------------------------------------------------\n    /**\n     * Indicates what must be computed. Must be one of {@link #COMPUTE_ALL_FRAMES}, {@link\n     * #COMPUTE_INSERTED_FRAMES}, {@link #COMPUTE_MAX_STACK_AND_LOCAL} or {@link #COMPUTE_NOTHING}.\n     */\n    private final        int                compute;\n    /**\n     * The first basic block of the method. The next ones (in bytecode offset order) can be accessed\n     * with the {@link Label#nextBasicBlock} field.\n     */\n    private              Label              firstBasicBlock;\n    /**\n     * The last basic block of the method (in bytecode offset order). This field is updated each time\n     * a basic block is encountered, and is used to append it at the end of the basic block list.\n     */\n    private              Label              lastBasicBlock;\n    /**\n     * The current basic block, i.e. the basic block of the last visited instruction. When {@link\n     * #compute} is equal to {@link #COMPUTE_MAX_STACK_AND_LOCAL} or {@link #COMPUTE_ALL_FRAMES}, this\n     * field is {@literal null} for unreachable code. When {@link #compute} is equal to {@link\n     * #COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES} or {@link #COMPUTE_INSERTED_FRAMES}, this field stays\n     * unchanged throughout the whole method (i.e. the whole code is seen as a single basic block;\n     * indeed, the existing frames are sufficient by hypothesis to compute any intermediate frame -\n     * and the maximum stack size as well - without using any control flow graph).\n     */\n    private              Label              currentBasicBlock;\n    /**\n     * The relative stack size after the last visited instruction. This size is relative to the\n     * beginning of {@link #currentBasicBlock}, i.e. the true stack size after the last visited\n     * instruction is equal to the {@link Label#inputStackSize} of the current basic block plus {@link\n     * #relativeStackSize}. When {@link #compute} is equal to {@link\n     * #COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link #currentBasicBlock} is always the start of\n     * the method, so this relative size is also equal to the absolute stack size after the last\n     * visited instruction.\n     */\n    private              int                relativeStackSize;\n    /**\n     * The maximum relative stack size after the last visited instruction. This size is relative to\n     * the beginning of {@link #currentBasicBlock}, i.e. the true maximum stack size after the last\n     * visited instruction is equal to the {@link Label#inputStackSize} of the current basic block\n     * plus {@link #maxRelativeStackSize}.When {@link #compute} is equal to {@link\n     * #COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link #currentBasicBlock} is always the start of\n     * the method, so this relative size is also equal to the absolute maximum stack size after the\n     * last visited instruction.\n     */\n    private              int                maxRelativeStackSize;\n    /** The number of local variables in the last visited stack map frame. */\n    private              int                currentLocals;\n    /** The bytecode offset of the last frame that was written in {@link #stackMapTableEntries}. */\n    private              int                previousFrameOffset;\n    /**\n     * The last frame that was written in {@link #stackMapTableEntries}. This field has the same\n     * format as {@link #currentFrame}.\n     */\n    private              int[]              previousFrame;\n    /**\n     * The current stack map frame. The first element contains the bytecode offset of the instruction\n     * to which the frame corresponds, the second element is the number of locals and the third one is\n     * the number of stack elements. The local variables start at index 3 and are followed by the\n     * operand stack elements. In summary frame[0] = offset, frame[1] = numLocal, frame[2] = numStack.\n     * Local variables and operand stack entries contain abstract types, as defined in {@link Frame},\n     * but restricted to {@link Frame#CONSTANT_KIND}, {@link Frame#REFERENCE_KIND} or {@link\n     * Frame#UNINITIALIZED_KIND} abstract types. Long and double types use only one array entry.\n     */\n    private              int[]              currentFrame;\n    /** Whether this method contains subroutines. */\n    private              boolean            hasSubroutines;\n    // -----------------------------------------------------------------------------------------------\n    // Other miscellaneous status fields\n    // -----------------------------------------------------------------------------------------------\n    /** Whether the bytecode of this method contains ASM specific instructions. */\n    private              boolean            hasAsmInstructions;\n    /**\n     * The start offset of the last visited instruction. Used to set the offset field of type\n     * annotations of type 'offset_target' (see <a\n     * href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.1\">JVMS\n     * 4.7.20.1</a>).\n     */\n    private              int                lastBytecodeOffset;\n    /**\n     * The offset in bytes in {@link SymbolTable#getSource} from which the method_info for this method\n     * (excluding its first 6 bytes) must be copied, or 0.\n     */\n    private              int                sourceOffset;\n    /**\n     * The length in bytes in {@link SymbolTable#getSource} which must be copied to get the\n     * method_info for this method (excluding its first 6 bytes for access_flags, name_index and\n     * descriptor_index).\n     */\n    private              int                sourceLength;\n    // -----------------------------------------------------------------------------------------------\n    // Constructor and accessors\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Constructs a new {@link MethodWriter}.\n     *\n     * @param symbolTable where the constants used in this AnnotationWriter must be stored.\n     * @param access the method's access flags (see {@link Opcodes}).\n     * @param name the method's name.\n     * @param descriptor the method's descriptor (see {@link Type}).\n     * @param signature the method's signature. May be {@literal null}.\n     * @param exceptions the internal names of the method's exceptions. May be {@literal null}.\n     * @param compute indicates what must be computed (see #compute).\n     */\n    MethodWriter(final SymbolTable symbolTable, final int access, final String name, final String descriptor, final String signature, final String[] exceptions, final int compute) {\n        super(/* latest api = */ Opcodes.ASM7);\n        this.symbolTable = symbolTable;\n        this.accessFlags = \"<init>\".equals(name) ? access | Constants.ACC_CONSTRUCTOR : access;\n        this.nameIndex = symbolTable.addConstantUtf8(name);\n        this.name = name;\n        this.descriptorIndex = symbolTable.addConstantUtf8(descriptor);\n        this.descriptor = descriptor;\n        this.signatureIndex = signature == null ? 0 : symbolTable.addConstantUtf8(signature);\n        if (exceptions != null && exceptions.length > 0) {\n            numberOfExceptions = exceptions.length;\n            this.exceptionIndexTable = new int[numberOfExceptions];\n            for (int i = 0; i < numberOfExceptions; ++i) {\n                this.exceptionIndexTable[i] = symbolTable.addConstantClass(exceptions[i]).index;\n            }\n        } else {\n            numberOfExceptions = 0;\n            this.exceptionIndexTable = null;\n        }\n        this.compute = compute;\n        if (compute != COMPUTE_NOTHING) {\n            // Update maxLocals and currentLocals.\n            int argumentsSize = Type.getArgumentsAndReturnSizes(descriptor) >> 2;\n            if ((access & Opcodes.ACC_STATIC) != 0) {\n                --argumentsSize;\n            }\n            maxLocals = argumentsSize;\n            currentLocals = argumentsSize;\n            // Create and visit the label for the first basic block.\n            firstBasicBlock = new Label();\n            visitLabel(firstBasicBlock);\n        }\n    }\n\n    boolean hasFrames() {\n        return stackMapTableNumberOfEntries > 0;\n    }\n\n    boolean hasAsmInstructions() {\n        return hasAsmInstructions;\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Implementation of the MethodVisitor abstract class\n    // -----------------------------------------------------------------------------------------------\n\n    @Override\n    public void visitParameter(final String name, final int access) {\n        if (parameters == null) {\n            parameters = new ByteVector();\n        }\n        ++parametersCount;\n        parameters.putShort((name == null) ? 0 : symbolTable.addConstantUtf8(name)).putShort(access);\n    }\n\n    @Override\n    public AnnotationVisitor visitAnnotationDefault() {\n        defaultValue = new ByteVector();\n        return new AnnotationWriter(symbolTable, /* useNamedValues = */ false, defaultValue, null);\n    }\n\n    @Override\n    public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\n        if (visible) {\n            return lastRuntimeVisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeVisibleAnnotation);\n        } else {\n            return lastRuntimeInvisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeInvisibleAnnotation);\n        }\n    }\n\n    @Override\n    public AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n        if (visible) {\n            return lastRuntimeVisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeVisibleTypeAnnotation);\n        } else {\n            return lastRuntimeInvisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);\n        }\n    }\n\n    @Override\n    public void visitAnnotableParameterCount(final int parameterCount, final boolean visible) {\n        if (visible) {\n            visibleAnnotableParameterCount = parameterCount;\n        } else {\n            invisibleAnnotableParameterCount = parameterCount;\n        }\n    }\n\n    @Override\n    public AnnotationVisitor visitParameterAnnotation(final int parameter, final String annotationDescriptor, final boolean visible) {\n        if (visible) {\n            if (lastRuntimeVisibleParameterAnnotations == null) {\n                lastRuntimeVisibleParameterAnnotations = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];\n            }\n            return lastRuntimeVisibleParameterAnnotations[parameter] = AnnotationWriter.create(symbolTable, annotationDescriptor, lastRuntimeVisibleParameterAnnotations[parameter]);\n        } else {\n            if (lastRuntimeInvisibleParameterAnnotations == null) {\n                lastRuntimeInvisibleParameterAnnotations = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];\n            }\n            return lastRuntimeInvisibleParameterAnnotations[parameter] = AnnotationWriter.create(symbolTable, annotationDescriptor, lastRuntimeInvisibleParameterAnnotations[parameter]);\n        }\n    }\n\n    @Override\n    public void visitAttribute(final Attribute attribute) {\n        // Store the attributes in the <i>reverse</i> order of their visit by this method.\n        if (attribute.isCodeAttribute()) {\n            attribute.nextAttribute = firstCodeAttribute;\n            firstCodeAttribute = attribute;\n        } else {\n            attribute.nextAttribute = firstAttribute;\n            firstAttribute = attribute;\n        }\n    }\n\n    @Override\n    public void visitCode() {\n        // Nothing to do.\n    }\n\n    @Override\n    public void visitFrame(final int type, final int numLocal, final Object[] local, final int numStack, final Object[] stack) {\n        if (compute == COMPUTE_ALL_FRAMES) {\n            return;\n        }\n        if (compute == COMPUTE_INSERTED_FRAMES) {\n            if (currentBasicBlock.frame == null) {\n                // This should happen only once, for the implicit first frame (which is explicitly visited\n                // in ClassReader if the EXPAND_ASM_INSNS option is used - and COMPUTE_INSERTED_FRAMES\n                // can't be set if EXPAND_ASM_INSNS is not used).\n                currentBasicBlock.frame = new CurrentFrame(currentBasicBlock);\n                currentBasicBlock.frame.setInputFrameFromDescriptor(symbolTable, accessFlags, descriptor, numLocal);\n                currentBasicBlock.frame.accept(this);\n            } else {\n                if (type == Opcodes.F_NEW) {\n                    currentBasicBlock.frame.setInputFrameFromApiFormat(symbolTable, numLocal, local, numStack, stack);\n                }\n                // If type is not F_NEW then it is F_INSERT by hypothesis, and currentBlock.frame contains\n                // the stack map frame at the current instruction, computed from the last F_NEW frame and\n                // the bytecode instructions in between (via calls to CurrentFrame#execute).\n                currentBasicBlock.frame.accept(this);\n            }\n        } else if (type == Opcodes.F_NEW) {\n            if (previousFrame == null) {\n                int argumentsSize = Type.getArgumentsAndReturnSizes(descriptor) >> 2;\n                Frame implicitFirstFrame = new Frame(new Label());\n                implicitFirstFrame.setInputFrameFromDescriptor(symbolTable, accessFlags, descriptor, argumentsSize);\n                implicitFirstFrame.accept(this);\n            }\n            currentLocals = numLocal;\n            int frameIndex = visitFrameStart(code.length, numLocal, numStack);\n            for (int i = 0; i < numLocal; ++i) {\n                currentFrame[frameIndex++] = Frame.getAbstractTypeFromApiFormat(symbolTable, local[i]);\n            }\n            for (int i = 0; i < numStack; ++i) {\n                currentFrame[frameIndex++] = Frame.getAbstractTypeFromApiFormat(symbolTable, stack[i]);\n            }\n            visitFrameEnd();\n        } else {\n            if (symbolTable.getMajorVersion() < Opcodes.V1_6) {\n                throw new IllegalArgumentException(\"Class versions V1_5 or less must use F_NEW frames.\");\n            }\n            int offsetDelta;\n            if (stackMapTableEntries == null) {\n                stackMapTableEntries = new ByteVector();\n                offsetDelta = code.length;\n            } else {\n                offsetDelta = code.length - previousFrameOffset - 1;\n                if (offsetDelta < 0) {\n                    if (type == Opcodes.F_SAME) {\n                        return;\n                    } else {\n                        throw new IllegalStateException();\n                    }\n                }\n            }\n            switch (type) {\n            case Opcodes.F_FULL:\n                currentLocals = numLocal;\n                stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(numLocal);\n                for (int i = 0; i < numLocal; ++i) {\n                    putFrameType(local[i]);\n                }\n                stackMapTableEntries.putShort(numStack);\n                for (int i = 0; i < numStack; ++i) {\n                    putFrameType(stack[i]);\n                }\n                break;\n            case Opcodes.F_APPEND:\n                currentLocals += numLocal;\n                stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED + numLocal).putShort(offsetDelta);\n                for (int i = 0; i < numLocal; ++i) {\n                    putFrameType(local[i]);\n                }\n                break;\n            case Opcodes.F_CHOP:\n                currentLocals -= numLocal;\n                stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED - numLocal).putShort(offsetDelta);\n                break;\n            case Opcodes.F_SAME:\n                if (offsetDelta < 64) {\n                    stackMapTableEntries.putByte(offsetDelta);\n                } else {\n                    stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);\n                }\n                break;\n            case Opcodes.F_SAME1:\n                if (offsetDelta < 64) {\n                    stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);\n                } else {\n                    stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(offsetDelta);\n                }\n                putFrameType(stack[0]);\n                break;\n            default:\n                throw new IllegalArgumentException();\n            }\n            previousFrameOffset = code.length;\n            ++stackMapTableNumberOfEntries;\n        }\n        if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {\n            relativeStackSize = numStack;\n            for (int i = 0; i < numStack; ++i) {\n                if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {\n                    relativeStackSize++;\n                }\n            }\n            if (relativeStackSize > maxRelativeStackSize) {\n                maxRelativeStackSize = relativeStackSize;\n            }\n        }\n        maxStack = Math.max(maxStack, numStack);\n        maxLocals = Math.max(maxLocals, currentLocals);\n    }\n\n    @Override\n    public void visitInsn(final int opcode) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        code.putByte(opcode);\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n                currentBasicBlock.frame.execute(opcode, 0, null, null);\n            } else {\n                int size = relativeStackSize + STACK_SIZE_DELTA[opcode];\n                if (size > maxRelativeStackSize) {\n                    maxRelativeStackSize = size;\n                }\n                relativeStackSize = size;\n            }\n            if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN) || opcode == Opcodes.ATHROW) {\n                endCurrentBasicBlockWithNoSuccessor();\n            }\n        }\n    }\n\n    @Override\n    public void visitIntInsn(final int opcode, final int operand) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        if (opcode == Opcodes.SIPUSH) {\n            code.put12(opcode, operand);\n        } else { // BIPUSH or NEWARRAY\n            code.put11(opcode, operand);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n                currentBasicBlock.frame.execute(opcode, operand, null, null);\n            } else if (opcode != Opcodes.NEWARRAY) {\n                // The stack size delta is 1 for BIPUSH or SIPUSH, and 0 for NEWARRAY.\n                int size = relativeStackSize + 1;\n                if (size > maxRelativeStackSize) {\n                    maxRelativeStackSize = size;\n                }\n                relativeStackSize = size;\n            }\n        }\n    }\n\n    @Override\n    public void visitVarInsn(final int opcode, final int var) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        if (var < 4 && opcode != Opcodes.RET) {\n            int optimizedOpcode;\n            if (opcode < Opcodes.ISTORE) {\n                optimizedOpcode = Constants.ILOAD_0 + ((opcode - Opcodes.ILOAD) << 2) + var;\n            } else {\n                optimizedOpcode = Constants.ISTORE_0 + ((opcode - Opcodes.ISTORE) << 2) + var;\n            }\n            code.putByte(optimizedOpcode);\n        } else if (var >= 256) {\n            code.putByte(Constants.WIDE).put12(opcode, var);\n        } else {\n            code.put11(opcode, var);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n                currentBasicBlock.frame.execute(opcode, var, null, null);\n            } else {\n                if (opcode == Opcodes.RET) {\n                    // No stack size delta.\n                    currentBasicBlock.flags |= Label.FLAG_SUBROUTINE_END;\n                    currentBasicBlock.outputStackSize = (short) relativeStackSize;\n                    endCurrentBasicBlockWithNoSuccessor();\n                } else { // xLOAD or xSTORE\n                    int size = relativeStackSize + STACK_SIZE_DELTA[opcode];\n                    if (size > maxRelativeStackSize) {\n                        maxRelativeStackSize = size;\n                    }\n                    relativeStackSize = size;\n                }\n            }\n        }\n        if (compute != COMPUTE_NOTHING) {\n            int currentMaxLocals;\n            if (opcode == Opcodes.LLOAD || opcode == Opcodes.DLOAD || opcode == Opcodes.LSTORE || opcode == Opcodes.DSTORE) {\n                currentMaxLocals = var + 2;\n            } else {\n                currentMaxLocals = var + 1;\n            }\n            if (currentMaxLocals > maxLocals) {\n                maxLocals = currentMaxLocals;\n            }\n        }\n        if (opcode >= Opcodes.ISTORE && compute == COMPUTE_ALL_FRAMES && firstHandler != null) {\n            // If there are exception handler blocks, each instruction within a handler range is, in\n            // theory, a basic block (since execution can jump from this instruction to the exception\n            // handler). As a consequence, the local variable types at the beginning of the handler\n            // block should be the merge of the local variable types at all the instructions within the\n            // handler range. However, instead of creating a basic block for each instruction, we can\n            // get the same result in a more efficient way. Namely, by starting a new basic block after\n            // each xSTORE instruction, which is what we do here.\n            visitLabel(new Label());\n        }\n    }\n\n    @Override\n    public void visitTypeInsn(final int opcode, final String type) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol typeSymbol = symbolTable.addConstantClass(type);\n        code.put12(opcode, typeSymbol.index);\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n                currentBasicBlock.frame.execute(opcode, lastBytecodeOffset, typeSymbol, symbolTable);\n            } else if (opcode == Opcodes.NEW) {\n                // The stack size delta is 1 for NEW, and 0 for ANEWARRAY, CHECKCAST, or INSTANCEOF.\n                int size = relativeStackSize + 1;\n                if (size > maxRelativeStackSize) {\n                    maxRelativeStackSize = size;\n                }\n                relativeStackSize = size;\n            }\n        }\n    }\n\n    @Override\n    public void visitFieldInsn(final int opcode, final String owner, final String name, final String descriptor) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol fieldrefSymbol = symbolTable.addConstantFieldref(owner, name, descriptor);\n        code.put12(opcode, fieldrefSymbol.index);\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n                currentBasicBlock.frame.execute(opcode, 0, fieldrefSymbol, symbolTable);\n            } else {\n                int size;\n                char firstDescChar = descriptor.charAt(0);\n                switch (opcode) {\n                case Opcodes.GETSTATIC:\n                    size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? 2 : 1);\n                    break;\n                case Opcodes.PUTSTATIC:\n                    size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? -2 : -1);\n                    break;\n                case Opcodes.GETFIELD:\n                    size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? 1 : 0);\n                    break;\n                case Opcodes.PUTFIELD:\n                default:\n                    size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? -3 : -2);\n                    break;\n                }\n                if (size > maxRelativeStackSize) {\n                    maxRelativeStackSize = size;\n                }\n                relativeStackSize = size;\n            }\n        }\n    }\n\n    @Override\n    public void visitMethodInsn(final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol methodrefSymbol = symbolTable.addConstantMethodref(owner, name, descriptor, isInterface);\n        if (opcode == Opcodes.INVOKEINTERFACE) {\n            code.put12(Opcodes.INVOKEINTERFACE, methodrefSymbol.index).put11(methodrefSymbol.getArgumentsAndReturnSizes() >> 2, 0);\n        } else {\n            code.put12(opcode, methodrefSymbol.index);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n                currentBasicBlock.frame.execute(opcode, 0, methodrefSymbol, symbolTable);\n            } else {\n                int argumentsAndReturnSize = methodrefSymbol.getArgumentsAndReturnSizes();\n                int stackSizeDelta = (argumentsAndReturnSize & 3) - (argumentsAndReturnSize >> 2);\n                int size;\n                if (opcode == Opcodes.INVOKESTATIC) {\n                    size = relativeStackSize + stackSizeDelta + 1;\n                } else {\n                    size = relativeStackSize + stackSizeDelta;\n                }\n                if (size > maxRelativeStackSize) {\n                    maxRelativeStackSize = size;\n                }\n                relativeStackSize = size;\n            }\n        }\n    }\n\n    @Override\n    public void visitInvokeDynamicInsn(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol invokeDynamicSymbol = symbolTable.addConstantInvokeDynamic(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\n        code.put12(Opcodes.INVOKEDYNAMIC, invokeDynamicSymbol.index);\n        code.putShort(0);\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n                currentBasicBlock.frame.execute(Opcodes.INVOKEDYNAMIC, 0, invokeDynamicSymbol, symbolTable);\n            } else {\n                int argumentsAndReturnSize = invokeDynamicSymbol.getArgumentsAndReturnSizes();\n                int stackSizeDelta = (argumentsAndReturnSize & 3) - (argumentsAndReturnSize >> 2) + 1;\n                int size = relativeStackSize + stackSizeDelta;\n                if (size > maxRelativeStackSize) {\n                    maxRelativeStackSize = size;\n                }\n                relativeStackSize = size;\n            }\n        }\n    }\n\n    @Override\n    public void visitJumpInsn(final int opcode, final Label label) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        // Compute the 'base' opcode, i.e. GOTO or JSR if opcode is GOTO_W or JSR_W, otherwise opcode.\n        int baseOpcode = opcode >= Constants.GOTO_W ? opcode - Constants.WIDE_JUMP_OPCODE_DELTA : opcode;\n        boolean nextInsnIsJumpTarget = false;\n        if ((label.flags & Label.FLAG_RESOLVED) != 0 && label.bytecodeOffset - code.length < Short.MIN_VALUE) {\n            // Case of a backward jump with an offset < -32768. In this case we automatically replace GOTO\n            // with GOTO_W, JSR with JSR_W and IFxxx <l> with IFNOTxxx <L> GOTO_W <l> L:..., where\n            // IFNOTxxx is the \"opposite\" opcode of IFxxx (e.g. IFNE for IFEQ) and where <L> designates\n            // the instruction just after the GOTO_W.\n            if (baseOpcode == Opcodes.GOTO) {\n                code.putByte(Constants.GOTO_W);\n            } else if (baseOpcode == Opcodes.JSR) {\n                code.putByte(Constants.JSR_W);\n            } else {\n                // Put the \"opposite\" opcode of baseOpcode. This can be done by flipping the least\n                // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ (with a\n                // pre and post offset by 1). The jump offset is 8 bytes (3 for IFNOTxxx, 5 for GOTO_W).\n                code.putByte(baseOpcode >= Opcodes.IFNULL ? baseOpcode ^ 1 : ((baseOpcode + 1) ^ 1) - 1);\n                code.putShort(8);\n                // Here we could put a GOTO_W in theory, but if ASM specific instructions are used in this\n                // method or another one, and if the class has frames, we will need to insert a frame after\n                // this GOTO_W during the additional ClassReader -> ClassWriter round trip to remove the ASM\n                // specific instructions. To not miss this additional frame, we need to use an ASM_GOTO_W\n                // here, which has the unfortunate effect of forcing this additional round trip (which in\n                // some case would not have been really necessary, but we can't know this at this point).\n                code.putByte(Constants.ASM_GOTO_W);\n                hasAsmInstructions = true;\n                // The instruction after the GOTO_W becomes the target of the IFNOT instruction.\n                nextInsnIsJumpTarget = true;\n            }\n            label.put(code, code.length - 1, true);\n        } else if (baseOpcode != opcode) {\n            // Case of a GOTO_W or JSR_W specified by the user (normally ClassReader when used to remove\n            // ASM specific instructions). In this case we keep the original instruction.\n            code.putByte(opcode);\n            label.put(code, code.length - 1, true);\n        } else {\n            // Case of a jump with an offset >= -32768, or of a jump with an unknown offset. In these\n            // cases we store the offset in 2 bytes (which will be increased via a ClassReader ->\n            // ClassWriter round trip if it turns out that 2 bytes are not sufficient).\n            code.putByte(baseOpcode);\n            label.put(code, code.length - 1, false);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            Label nextBasicBlock = null;\n            if (compute == COMPUTE_ALL_FRAMES) {\n                currentBasicBlock.frame.execute(baseOpcode, 0, null, null);\n                // Record the fact that 'label' is the target of a jump instruction.\n                label.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\n                // Add 'label' as a successor of the current basic block.\n                addSuccessorToCurrentBasicBlock(Edge.JUMP, label);\n                if (baseOpcode != Opcodes.GOTO) {\n                    // The next instruction starts a new basic block (except for GOTO: by default the code\n                    // following a goto is unreachable - unless there is an explicit label for it - and we\n                    // should not compute stack frame types for its instructions).\n                    nextBasicBlock = new Label();\n                }\n            } else if (compute == COMPUTE_INSERTED_FRAMES) {\n                currentBasicBlock.frame.execute(baseOpcode, 0, null, null);\n            } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {\n                // No need to update maxRelativeStackSize (the stack size delta is always negative).\n                relativeStackSize += STACK_SIZE_DELTA[baseOpcode];\n            } else {\n                if (baseOpcode == Opcodes.JSR) {\n                    // Record the fact that 'label' designates a subroutine, if not already done.\n                    if ((label.flags & Label.FLAG_SUBROUTINE_START) == 0) {\n                        label.flags |= Label.FLAG_SUBROUTINE_START;\n                        hasSubroutines = true;\n                    }\n                    currentBasicBlock.flags |= Label.FLAG_SUBROUTINE_CALLER;\n                    // Note that, by construction in this method, a block which calls a subroutine has at\n                    // least two successors in the control flow graph: the first one (added below) leads to\n                    // the instruction after the JSR, while the second one (added here) leads to the JSR\n                    // target. Note that the first successor is virtual (it does not correspond to a possible\n                    // execution path): it is only used to compute the successors of the basic blocks ending\n                    // with a ret, in {@link Label#addSubroutineRetSuccessors}.\n                    addSuccessorToCurrentBasicBlock(relativeStackSize + 1, label);\n                    // The instruction after the JSR starts a new basic block.\n                    nextBasicBlock = new Label();\n                } else {\n                    // No need to update maxRelativeStackSize (the stack size delta is always negative).\n                    relativeStackSize += STACK_SIZE_DELTA[baseOpcode];\n                    addSuccessorToCurrentBasicBlock(relativeStackSize, label);\n                }\n            }\n            // If the next instruction starts a new basic block, call visitLabel to add the label of this\n            // instruction as a successor of the current block, and to start a new basic block.\n            if (nextBasicBlock != null) {\n                if (nextInsnIsJumpTarget) {\n                    nextBasicBlock.flags |= Label.FLAG_JUMP_TARGET;\n                }\n                visitLabel(nextBasicBlock);\n            }\n            if (baseOpcode == Opcodes.GOTO) {\n                endCurrentBasicBlockWithNoSuccessor();\n            }\n        }\n    }\n\n    @Override\n    public void visitLabel(final Label label) {\n        // Resolve the forward references to this label, if any.\n        hasAsmInstructions |= label.resolve(code.data, code.length);\n        // visitLabel starts a new basic block (except for debug only labels), so we need to update the\n        // previous and current block references and list of successors.\n        if ((label.flags & Label.FLAG_DEBUG_ONLY) != 0) {\n            return;\n        }\n        if (compute == COMPUTE_ALL_FRAMES) {\n            if (currentBasicBlock != null) {\n                if (label.bytecodeOffset == currentBasicBlock.bytecodeOffset) {\n                    // We use {@link Label#getCanonicalInstance} to store the state of a basic block in only\n                    // one place, but this does not work for labels which have not been visited yet.\n                    // Therefore, when we detect here two labels having the same bytecode offset, we need to\n                    // - consolidate the state scattered in these two instances into the canonical instance:\n                    currentBasicBlock.flags |= (label.flags & Label.FLAG_JUMP_TARGET);\n                    // - make sure the two instances share the same Frame instance (the implementation of\n                    // {@link Label#getCanonicalInstance} relies on this property; here label.frame should be\n                    // null):\n                    label.frame = currentBasicBlock.frame;\n                    // - and make sure to NOT assign 'label' into 'currentBasicBlock' or 'lastBasicBlock', so\n                    // that they still refer to the canonical instance for this bytecode offset.\n                    return;\n                }\n                // End the current basic block (with one new successor).\n                addSuccessorToCurrentBasicBlock(Edge.JUMP, label);\n            }\n            // Append 'label' at the end of the basic block list.\n            if (lastBasicBlock != null) {\n                if (label.bytecodeOffset == lastBasicBlock.bytecodeOffset) {\n                    // Same comment as above.\n                    lastBasicBlock.flags |= (label.flags & Label.FLAG_JUMP_TARGET);\n                    // Here label.frame should be null.\n                    label.frame = lastBasicBlock.frame;\n                    currentBasicBlock = lastBasicBlock;\n                    return;\n                }\n                lastBasicBlock.nextBasicBlock = label;\n            }\n            lastBasicBlock = label;\n            // Make it the new current basic block.\n            currentBasicBlock = label;\n            // Here label.frame should be null.\n            label.frame = new Frame(label);\n        } else if (compute == COMPUTE_INSERTED_FRAMES) {\n            if (currentBasicBlock == null) {\n                // This case should happen only once, for the visitLabel call in the constructor. Indeed, if\n                // compute is equal to COMPUTE_INSERTED_FRAMES, currentBasicBlock stays unchanged.\n                currentBasicBlock = label;\n            } else {\n                // Update the frame owner so that a correct frame offset is computed in Frame.accept().\n                currentBasicBlock.frame.owner = label;\n            }\n        } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\n            if (currentBasicBlock != null) {\n                // End the current basic block (with one new successor).\n                currentBasicBlock.outputStackMax = (short) maxRelativeStackSize;\n                addSuccessorToCurrentBasicBlock(relativeStackSize, label);\n            }\n            // Start a new current basic block, and reset the current and maximum relative stack sizes.\n            currentBasicBlock = label;\n            relativeStackSize = 0;\n            maxRelativeStackSize = 0;\n            // Append the new basic block at the end of the basic block list.\n            if (lastBasicBlock != null) {\n                lastBasicBlock.nextBasicBlock = label;\n            }\n            lastBasicBlock = label;\n        } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES && currentBasicBlock == null) {\n            // This case should happen only once, for the visitLabel call in the constructor. Indeed, if\n            // compute is equal to COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES, currentBasicBlock stays\n            // unchanged.\n            currentBasicBlock = label;\n        }\n    }\n\n    @Override\n    public void visitLdcInsn(final Object value) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol constantSymbol = symbolTable.addConstant(value);\n        int constantIndex = constantSymbol.index;\n        char firstDescriptorChar;\n        boolean isLongOrDouble = constantSymbol.tag == Symbol.CONSTANT_LONG_TAG || constantSymbol.tag == Symbol.CONSTANT_DOUBLE_TAG || (constantSymbol.tag == Symbol.CONSTANT_DYNAMIC_TAG && ((firstDescriptorChar = constantSymbol.value.charAt(0)) == 'J' || firstDescriptorChar == 'D'));\n        if (isLongOrDouble) {\n            code.put12(Constants.LDC2_W, constantIndex);\n        } else if (constantIndex >= 256) {\n            code.put12(Constants.LDC_W, constantIndex);\n        } else {\n            code.put11(Opcodes.LDC, constantIndex);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n                currentBasicBlock.frame.execute(Opcodes.LDC, 0, constantSymbol, symbolTable);\n            } else {\n                int size = relativeStackSize + (isLongOrDouble ? 2 : 1);\n                if (size > maxRelativeStackSize) {\n                    maxRelativeStackSize = size;\n                }\n                relativeStackSize = size;\n            }\n        }\n    }\n\n    @Override\n    public void visitIincInsn(final int var, final int increment) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        if ((var > 255) || (increment > 127) || (increment < -128)) {\n            code.putByte(Constants.WIDE).put12(Opcodes.IINC, var).putShort(increment);\n        } else {\n            code.putByte(Opcodes.IINC).put11(var, increment);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null && (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES)) {\n            currentBasicBlock.frame.execute(Opcodes.IINC, var, null, null);\n        }\n        if (compute != COMPUTE_NOTHING) {\n            int currentMaxLocals = var + 1;\n            if (currentMaxLocals > maxLocals) {\n                maxLocals = currentMaxLocals;\n            }\n        }\n    }\n\n    @Override\n    public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label... labels) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        code.putByte(Opcodes.TABLESWITCH).putByteArray(null, 0, (4 - code.length % 4) % 4);\n        dflt.put(code, lastBytecodeOffset, true);\n        code.putInt(min).putInt(max);\n        for (Label label : labels) {\n            label.put(code, lastBytecodeOffset, true);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        visitSwitchInsn(dflt, labels);\n    }\n\n    @Override\n    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        code.putByte(Opcodes.LOOKUPSWITCH).putByteArray(null, 0, (4 - code.length % 4) % 4);\n        dflt.put(code, lastBytecodeOffset, true);\n        code.putInt(labels.length);\n        for (int i = 0; i < labels.length; ++i) {\n            code.putInt(keys[i]);\n            labels[i].put(code, lastBytecodeOffset, true);\n        }\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        visitSwitchInsn(dflt, labels);\n    }\n\n    private void visitSwitchInsn(final Label dflt, final Label[] labels) {\n        if (currentBasicBlock != null) {\n            if (compute == COMPUTE_ALL_FRAMES) {\n                currentBasicBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);\n                // Add all the labels as successors of the current basic block.\n                addSuccessorToCurrentBasicBlock(Edge.JUMP, dflt);\n                dflt.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\n                for (Label label : labels) {\n                    addSuccessorToCurrentBasicBlock(Edge.JUMP, label);\n                    label.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\n                }\n            } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\n                // No need to update maxRelativeStackSize (the stack size delta is always negative).\n                --relativeStackSize;\n                // Add all the labels as successors of the current basic block.\n                addSuccessorToCurrentBasicBlock(relativeStackSize, dflt);\n                for (Label label : labels) {\n                    addSuccessorToCurrentBasicBlock(relativeStackSize, label);\n                }\n            }\n            // End the current basic block.\n            endCurrentBasicBlockWithNoSuccessor();\n        }\n    }\n\n    @Override\n    public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {\n        lastBytecodeOffset = code.length;\n        // Add the instruction to the bytecode of the method.\n        Symbol descSymbol = symbolTable.addConstantClass(descriptor);\n        code.put12(Opcodes.MULTIANEWARRAY, descSymbol.index).putByte(numDimensions);\n        // If needed, update the maximum stack size and number of locals, and stack map frames.\n        if (currentBasicBlock != null) {\n            if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n                currentBasicBlock.frame.execute(Opcodes.MULTIANEWARRAY, numDimensions, descSymbol, symbolTable);\n            } else {\n                // No need to update maxRelativeStackSize (the stack size delta is always negative).\n                relativeStackSize += 1 - numDimensions;\n            }\n        }\n    }\n\n    @Override\n    public AnnotationVisitor visitInsnAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n        if (visible) {\n            return lastCodeRuntimeVisibleTypeAnnotation = AnnotationWriter.create(symbolTable, (typeRef & 0xFF0000FF) | (lastBytecodeOffset << 8), typePath, descriptor, lastCodeRuntimeVisibleTypeAnnotation);\n        } else {\n            return lastCodeRuntimeInvisibleTypeAnnotation = AnnotationWriter.create(symbolTable, (typeRef & 0xFF0000FF) | (lastBytecodeOffset << 8), typePath, descriptor, lastCodeRuntimeInvisibleTypeAnnotation);\n        }\n    }\n\n    @Override\n    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\n        Handler newHandler = new Handler(start, end, handler, type != null ? symbolTable.addConstantClass(type).index : 0, type);\n        if (firstHandler == null) {\n            firstHandler = newHandler;\n        } else {\n            lastHandler.nextHandler = newHandler;\n        }\n        lastHandler = newHandler;\n    }\n\n    @Override\n    public AnnotationVisitor visitTryCatchAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n        if (visible) {\n            return lastCodeRuntimeVisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastCodeRuntimeVisibleTypeAnnotation);\n        } else {\n            return lastCodeRuntimeInvisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastCodeRuntimeInvisibleTypeAnnotation);\n        }\n    }\n\n    @Override\n    public void visitLocalVariable(final String name, final String descriptor, final String signature, final Label start, final Label end, final int index) {\n        if (signature != null) {\n            if (localVariableTypeTable == null) {\n                localVariableTypeTable = new ByteVector();\n            }\n            ++localVariableTypeTableLength;\n            localVariableTypeTable.putShort(start.bytecodeOffset).putShort(end.bytecodeOffset - start.bytecodeOffset).putShort(symbolTable.addConstantUtf8(name)).putShort(symbolTable.addConstantUtf8(signature)).putShort(index);\n        }\n        if (localVariableTable == null) {\n            localVariableTable = new ByteVector();\n        }\n        ++localVariableTableLength;\n        localVariableTable.putShort(start.bytecodeOffset).putShort(end.bytecodeOffset - start.bytecodeOffset).putShort(symbolTable.addConstantUtf8(name)).putShort(symbolTable.addConstantUtf8(descriptor)).putShort(index);\n        if (compute != COMPUTE_NOTHING) {\n            char firstDescChar = descriptor.charAt(0);\n            int currentMaxLocals = index + (firstDescChar == 'J' || firstDescChar == 'D' ? 2 : 1);\n            if (currentMaxLocals > maxLocals) {\n                maxLocals = currentMaxLocals;\n            }\n        }\n    }\n\n    @Override\n    public AnnotationVisitor visitLocalVariableAnnotation(final int typeRef, final TypePath typePath, final Label[] start, final Label[] end, final int[] index, final String descriptor, final boolean visible) {\n        // Create a ByteVector to hold a 'type_annotation' JVMS structure.\n        // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.\n        ByteVector typeAnnotation = new ByteVector();\n        // Write target_type, target_info, and target_path.\n        typeAnnotation.putByte(typeRef >>> 24).putShort(start.length);\n        for (int i = 0; i < start.length; ++i) {\n            typeAnnotation.putShort(start[i].bytecodeOffset).putShort(end[i].bytecodeOffset - start[i].bytecodeOffset).putShort(index[i]);\n        }\n        TypePath.put(typePath, typeAnnotation);\n        // Write type_index and reserve space for num_element_value_pairs.\n        typeAnnotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);\n        if (visible) {\n            return lastCodeRuntimeVisibleTypeAnnotation = new AnnotationWriter(symbolTable,\n                    /* useNamedValues = */ true, typeAnnotation, lastCodeRuntimeVisibleTypeAnnotation);\n        } else {\n            return lastCodeRuntimeInvisibleTypeAnnotation = new AnnotationWriter(symbolTable,\n                    /* useNamedValues = */ true, typeAnnotation, lastCodeRuntimeInvisibleTypeAnnotation);\n        }\n    }\n\n    @Override\n    public void visitLineNumber(final int line, final Label start) {\n        if (lineNumberTable == null) {\n            lineNumberTable = new ByteVector();\n        }\n        ++lineNumberTableLength;\n        lineNumberTable.putShort(start.bytecodeOffset);\n        lineNumberTable.putShort(line);\n    }\n\n    @Override\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n        if (compute == COMPUTE_ALL_FRAMES) {\n            computeAllFrames();\n        } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\n            computeMaxStackAndLocal();\n        } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {\n            this.maxStack = maxRelativeStackSize;\n        } else {\n            this.maxStack = maxStack;\n            this.maxLocals = maxLocals;\n        }\n    }\n\n    /** Computes all the stack map frames of the method, from scratch. */\n    private void computeAllFrames() {\n        // Complete the control flow graph with exception handler blocks.\n        Handler handler = firstHandler;\n        while (handler != null) {\n            String catchTypeDescriptor = handler.catchTypeDescriptor == null ? \"java/lang/Throwable\" : handler.catchTypeDescriptor;\n            int catchType = Frame.getAbstractTypeFromInternalName(symbolTable, catchTypeDescriptor);\n            // Mark handlerBlock as an exception handler.\n            Label handlerBlock = handler.handlerPc.getCanonicalInstance();\n            handlerBlock.flags |= Label.FLAG_JUMP_TARGET;\n            // Add handlerBlock as a successor of all the basic blocks in the exception handler range.\n            Label handlerRangeBlock = handler.startPc.getCanonicalInstance();\n            Label handlerRangeEnd = handler.endPc.getCanonicalInstance();\n            while (handlerRangeBlock != handlerRangeEnd) {\n                handlerRangeBlock.outgoingEdges = new Edge(catchType, handlerBlock, handlerRangeBlock.outgoingEdges);\n                handlerRangeBlock = handlerRangeBlock.nextBasicBlock;\n            }\n            handler = handler.nextHandler;\n        }\n        // Create and visit the first (implicit) frame.\n        Frame firstFrame = firstBasicBlock.frame;\n        firstFrame.setInputFrameFromDescriptor(symbolTable, accessFlags, descriptor, this.maxLocals);\n        firstFrame.accept(this);\n        // Fix point algorithm: add the first basic block to a list of blocks to process (i.e. blocks\n        // whose stack map frame has changed) and, while there are blocks to process, remove one from\n        // the list and update the stack map frames of its successor blocks in the control flow graph\n        // (which might change them, in which case these blocks must be processed too, and are thus\n        // added to the list of blocks to process). Also compute the maximum stack size of the method,\n        // as a by-product.\n        Label listOfBlocksToProcess = firstBasicBlock;\n        listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;\n        int maxStackSize = 0;\n        while (listOfBlocksToProcess != Label.EMPTY_LIST) {\n            // Remove a basic block from the list of blocks to process.\n            Label basicBlock = listOfBlocksToProcess;\n            listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;\n            basicBlock.nextListElement = null;\n            // By definition, basicBlock is reachable.\n            basicBlock.flags |= Label.FLAG_REACHABLE;\n            // Update the (absolute) maximum stack size.\n            int maxBlockStackSize = basicBlock.frame.getInputStackSize() + basicBlock.outputStackMax;\n            if (maxBlockStackSize > maxStackSize) {\n                maxStackSize = maxBlockStackSize;\n            }\n            // Update the successor blocks of basicBlock in the control flow graph.\n            Edge outgoingEdge = basicBlock.outgoingEdges;\n            while (outgoingEdge != null) {\n                Label successorBlock = outgoingEdge.successor.getCanonicalInstance();\n                boolean successorBlockChanged = basicBlock.frame.merge(symbolTable, successorBlock.frame, outgoingEdge.info);\n                if (successorBlockChanged && successorBlock.nextListElement == null) {\n                    // If successorBlock has changed it must be processed. Thus, if it is not already in the\n                    // list of blocks to process, add it to this list.\n                    successorBlock.nextListElement = listOfBlocksToProcess;\n                    listOfBlocksToProcess = successorBlock;\n                }\n                outgoingEdge = outgoingEdge.nextEdge;\n            }\n        }\n        // Loop over all the basic blocks and visit the stack map frames that must be stored in the\n        // StackMapTable attribute. Also replace unreachable code with NOP* ATHROW, and remove it from\n        // exception handler ranges.\n        Label basicBlock = firstBasicBlock;\n        while (basicBlock != null) {\n            if ((basicBlock.flags & (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE)) == (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE)) {\n                basicBlock.frame.accept(this);\n            }\n            if ((basicBlock.flags & Label.FLAG_REACHABLE) == 0) {\n                // Find the start and end bytecode offsets of this unreachable block.\n                Label nextBasicBlock = basicBlock.nextBasicBlock;\n                int startOffset = basicBlock.bytecodeOffset;\n                int endOffset = (nextBasicBlock == null ? code.length : nextBasicBlock.bytecodeOffset) - 1;\n                if (endOffset >= startOffset) {\n                    // Replace its instructions with NOP ... NOP ATHROW.\n                    for (int i = startOffset; i < endOffset; ++i) {\n                        code.data[i] = Opcodes.NOP;\n                    }\n                    code.data[endOffset] = (byte) Opcodes.ATHROW;\n                    // Emit a frame for this unreachable block, with no local and a Throwable on the stack\n                    // (so that the ATHROW could consume this Throwable if it were reachable).\n                    int frameIndex = visitFrameStart(startOffset, /* numLocal = */ 0, /* numStack = */ 1);\n                    currentFrame[frameIndex] = Frame.getAbstractTypeFromInternalName(symbolTable, \"java/lang/Throwable\");\n                    visitFrameEnd();\n                    // Remove this unreachable basic block from the exception handler ranges.\n                    firstHandler = Handler.removeRange(firstHandler, basicBlock, nextBasicBlock);\n                    // The maximum stack size is now at least one, because of the Throwable declared above.\n                    maxStackSize = Math.max(maxStackSize, 1);\n                }\n            }\n            basicBlock = basicBlock.nextBasicBlock;\n        }\n        this.maxStack = maxStackSize;\n    }\n\n    /** Computes the maximum stack size of the method. */\n    private void computeMaxStackAndLocal() {\n        // Complete the control flow graph with exception handler blocks.\n        Handler handler = firstHandler;\n        while (handler != null) {\n            Label handlerBlock = handler.handlerPc;\n            Label handlerRangeBlock = handler.startPc;\n            Label handlerRangeEnd = handler.endPc;\n            // Add handlerBlock as a successor of all the basic blocks in the exception handler range.\n            while (handlerRangeBlock != handlerRangeEnd) {\n                if ((handlerRangeBlock.flags & Label.FLAG_SUBROUTINE_CALLER) == 0) {\n                    handlerRangeBlock.outgoingEdges = new Edge(Edge.EXCEPTION, handlerBlock, handlerRangeBlock.outgoingEdges);\n                } else {\n                    // If handlerRangeBlock is a JSR block, add handlerBlock after the first two outgoing\n                    // edges to preserve the hypothesis about JSR block successors order (see\n                    // {@link #visitJumpInsn}).\n                    handlerRangeBlock.outgoingEdges.nextEdge.nextEdge = new Edge(Edge.EXCEPTION, handlerBlock, handlerRangeBlock.outgoingEdges.nextEdge.nextEdge);\n                }\n                handlerRangeBlock = handlerRangeBlock.nextBasicBlock;\n            }\n            handler = handler.nextHandler;\n        }\n        // Complete the control flow graph with the successor blocks of subroutines, if needed.\n        if (hasSubroutines) {\n            // First step: find the subroutines. This step determines, for each basic block, to which\n            // subroutine(s) it belongs. Start with the main \"subroutine\":\n            short numSubroutines = 1;\n            firstBasicBlock.markSubroutine(numSubroutines);\n            // Then, mark the subroutines called by the main subroutine, then the subroutines called by\n            // those called by the main subroutine, etc.\n            for (short currentSubroutine = 1; currentSubroutine <= numSubroutines; ++currentSubroutine) {\n                Label basicBlock = firstBasicBlock;\n                while (basicBlock != null) {\n                    if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0 && basicBlock.subroutineId == currentSubroutine) {\n                        Label jsrTarget = basicBlock.outgoingEdges.nextEdge.successor;\n                        if (jsrTarget.subroutineId == 0) {\n                            // If this subroutine has not been marked yet, find its basic blocks.\n                            jsrTarget.markSubroutine(++numSubroutines);\n                        }\n                    }\n                    basicBlock = basicBlock.nextBasicBlock;\n                }\n            }\n            // Second step: find the successors in the control flow graph of each subroutine basic block\n            // 'r' ending with a RET instruction. These successors are the virtual successors of the basic\n            // blocks ending with JSR instructions (see {@link #visitJumpInsn)} that can reach 'r'.\n            Label basicBlock = firstBasicBlock;\n            while (basicBlock != null) {\n                if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0) {\n                    // By construction, jsr targets are stored in the second outgoing edge of basic blocks\n                    // that ends with a jsr instruction (see {@link #FLAG_SUBROUTINE_CALLER}).\n                    Label subroutine = basicBlock.outgoingEdges.nextEdge.successor;\n                    subroutine.addSubroutineRetSuccessors(basicBlock);\n                }\n                basicBlock = basicBlock.nextBasicBlock;\n            }\n        }\n        // Data flow algorithm: put the first basic block in a list of blocks to process (i.e. blocks\n        // whose input stack size has changed) and, while there are blocks to process, remove one\n        // from the list, update the input stack size of its successor blocks in the control flow\n        // graph, and add these blocks to the list of blocks to process (if not already done).\n        Label listOfBlocksToProcess = firstBasicBlock;\n        listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;\n        int maxStackSize = maxStack;\n        while (listOfBlocksToProcess != Label.EMPTY_LIST) {\n            // Remove a basic block from the list of blocks to process. Note that we don't reset\n            // basicBlock.nextListElement to null on purpose, to make sure we don't reprocess already\n            // processed basic blocks.\n            Label basicBlock = listOfBlocksToProcess;\n            listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;\n            // Compute the (absolute) input stack size and maximum stack size of this block.\n            int inputStackTop = basicBlock.inputStackSize;\n            int maxBlockStackSize = inputStackTop + basicBlock.outputStackMax;\n            // Update the absolute maximum stack size of the method.\n            if (maxBlockStackSize > maxStackSize) {\n                maxStackSize = maxBlockStackSize;\n            }\n            // Update the input stack size of the successor blocks of basicBlock in the control flow\n            // graph, and add these blocks to the list of blocks to process, if not already done.\n            Edge outgoingEdge = basicBlock.outgoingEdges;\n            if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0) {\n                // Ignore the first outgoing edge of the basic blocks ending with a jsr: these are virtual\n                // edges which lead to the instruction just after the jsr, and do not correspond to a\n                // possible execution path (see {@link #visitJumpInsn} and\n                // {@link Label#FLAG_SUBROUTINE_CALLER}).\n                outgoingEdge = outgoingEdge.nextEdge;\n            }\n            while (outgoingEdge != null) {\n                Label successorBlock = outgoingEdge.successor;\n                if (successorBlock.nextListElement == null) {\n                    successorBlock.inputStackSize = (short) (outgoingEdge.info == Edge.EXCEPTION ? 1 : inputStackTop + outgoingEdge.info);\n                    successorBlock.nextListElement = listOfBlocksToProcess;\n                    listOfBlocksToProcess = successorBlock;\n                }\n                outgoingEdge = outgoingEdge.nextEdge;\n            }\n        }\n        this.maxStack = maxStackSize;\n    }\n\n    @Override\n    public void visitEnd() {\n        // Nothing to do.\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Utility methods: control flow analysis algorithm\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Adds a successor to {@link #currentBasicBlock} in the control flow graph.\n     *\n     * @param info information about the control flow edge to be added.\n     * @param successor the successor block to be added to the current basic block.\n     */\n    private void addSuccessorToCurrentBasicBlock(final int info, final Label successor) {\n        currentBasicBlock.outgoingEdges = new Edge(info, successor, currentBasicBlock.outgoingEdges);\n    }\n\n    /**\n     * Ends the current basic block. This method must be used in the case where the current basic\n     * block does not have any successor.\n     *\n     * <p>WARNING: this method must be called after the currently visited instruction has been put in\n     * {@link #code} (if frames are computed, this method inserts a new Label to start a new basic\n     * block after the current instruction).\n     */\n    private void endCurrentBasicBlockWithNoSuccessor() {\n        if (compute == COMPUTE_ALL_FRAMES) {\n            Label nextBasicBlock = new Label();\n            nextBasicBlock.frame = new Frame(nextBasicBlock);\n            nextBasicBlock.resolve(code.data, code.length);\n            lastBasicBlock.nextBasicBlock = nextBasicBlock;\n            lastBasicBlock = nextBasicBlock;\n            currentBasicBlock = null;\n        } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\n            currentBasicBlock.outputStackMax = (short) maxRelativeStackSize;\n            currentBasicBlock = null;\n        }\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Utility methods: stack map frames\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Starts the visit of a new stack map frame, stored in {@link #currentFrame}.\n     *\n     * @param offset the bytecode offset of the instruction to which the frame corresponds.\n     * @param numLocal the number of local variables in the frame.\n     * @param numStack the number of stack elements in the frame.\n     * @return the index of the next element to be written in this frame.\n     */\n    int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n        int frameLength = 3 + numLocal + numStack;\n        if (currentFrame == null || currentFrame.length < frameLength) {\n            currentFrame = new int[frameLength];\n        }\n        currentFrame[0] = offset;\n        currentFrame[1] = numLocal;\n        currentFrame[2] = numStack;\n        return 3;\n    }\n\n    /**\n     * Sets an abstract type in {@link #currentFrame}.\n     *\n     * @param frameIndex the index of the element to be set in {@link #currentFrame}.\n     * @param abstractType an abstract type.\n     */\n    void visitAbstractType(final int frameIndex, final int abstractType) {\n        currentFrame[frameIndex] = abstractType;\n    }\n\n    /**\n     * Ends the visit of {@link #currentFrame} by writing it in the StackMapTable entries and by\n     * updating the StackMapTable number_of_entries (except if the current frame is the first one,\n     * which is implicit in StackMapTable). Then resets {@link #currentFrame} to {@literal null}.\n     */\n    void visitFrameEnd() {\n        if (previousFrame != null) {\n            if (stackMapTableEntries == null) {\n                stackMapTableEntries = new ByteVector();\n            }\n            putFrame();\n            ++stackMapTableNumberOfEntries;\n        }\n        previousFrame = currentFrame;\n        currentFrame = null;\n    }\n\n    /** Compresses and writes {@link #currentFrame} in a new StackMapTable entry. */\n    private void putFrame() {\n        final int numLocal = currentFrame[1];\n        final int numStack = currentFrame[2];\n        if (symbolTable.getMajorVersion() < Opcodes.V1_6) {\n            // Generate a StackMap attribute entry, which are always uncompressed.\n            stackMapTableEntries.putShort(currentFrame[0]).putShort(numLocal);\n            putAbstractTypes(3, 3 + numLocal);\n            stackMapTableEntries.putShort(numStack);\n            putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);\n            return;\n        }\n        final int offsetDelta = stackMapTableNumberOfEntries == 0 ? currentFrame[0] : currentFrame[0] - previousFrame[0] - 1;\n        final int previousNumlocal = previousFrame[1];\n        final int numLocalDelta = numLocal - previousNumlocal;\n        int type = Frame.FULL_FRAME;\n        if (numStack == 0) {\n            switch (numLocalDelta) {\n            case -3:\n            case -2:\n            case -1:\n                type = Frame.CHOP_FRAME;\n                break;\n            case 0:\n                type = offsetDelta < 64 ? Frame.SAME_FRAME : Frame.SAME_FRAME_EXTENDED;\n                break;\n            case 1:\n            case 2:\n            case 3:\n                type = Frame.APPEND_FRAME;\n                break;\n            default:\n                // Keep the FULL_FRAME type.\n                break;\n            }\n        } else if (numLocalDelta == 0 && numStack == 1) {\n            type = offsetDelta < 63 ? Frame.SAME_LOCALS_1_STACK_ITEM_FRAME : Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\n        }\n        if (type != Frame.FULL_FRAME) {\n            // Verify if locals are the same as in the previous frame.\n            int frameIndex = 3;\n            for (int i = 0; i < previousNumlocal && i < numLocal; i++) {\n                if (currentFrame[frameIndex] != previousFrame[frameIndex]) {\n                    type = Frame.FULL_FRAME;\n                    break;\n                }\n                frameIndex++;\n            }\n        }\n        switch (type) {\n        case Frame.SAME_FRAME:\n            stackMapTableEntries.putByte(offsetDelta);\n            break;\n        case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME:\n            stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);\n            putAbstractTypes(3 + numLocal, 4 + numLocal);\n            break;\n        case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:\n            stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(offsetDelta);\n            putAbstractTypes(3 + numLocal, 4 + numLocal);\n            break;\n        case Frame.SAME_FRAME_EXTENDED:\n            stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);\n            break;\n        case Frame.CHOP_FRAME:\n            stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta).putShort(offsetDelta);\n            break;\n        case Frame.APPEND_FRAME:\n            stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta).putShort(offsetDelta);\n            putAbstractTypes(3 + previousNumlocal, 3 + numLocal);\n            break;\n        case Frame.FULL_FRAME:\n        default:\n            stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(numLocal);\n            putAbstractTypes(3, 3 + numLocal);\n            stackMapTableEntries.putShort(numStack);\n            putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);\n            break;\n        }\n    }\n\n    /**\n     * Puts some abstract types of {@link #currentFrame} in {@link #stackMapTableEntries} , using the\n     * JVMS verification_type_info format used in StackMapTable attributes.\n     *\n     * @param start index of the first type in {@link #currentFrame} to write.\n     * @param end index of last type in {@link #currentFrame} to write (exclusive).\n     */\n    private void putAbstractTypes(final int start, final int end) {\n        for (int i = start; i < end; ++i) {\n            Frame.putAbstractType(symbolTable, currentFrame[i], stackMapTableEntries);\n        }\n    }\n\n    /**\n     * Puts the given public API frame element type in {@link #stackMapTableEntries} , using the JVMS\n     * verification_type_info format used in StackMapTable attributes.\n     *\n     * @param type a frame element type described using the same format as in {@link\n     *     MethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\n     *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or\n     *     {@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating\n     *     a NEW instruction (for uninitialized types).\n     */\n    private void putFrameType(final Object type) {\n        if (type instanceof Integer) {\n            stackMapTableEntries.putByte(((Integer) type).intValue());\n        } else if (type instanceof String) {\n            stackMapTableEntries.putByte(Frame.ITEM_OBJECT).putShort(symbolTable.addConstantClass((String) type).index);\n        } else {\n            stackMapTableEntries.putByte(Frame.ITEM_UNINITIALIZED).putShort(((Label) type).bytecodeOffset);\n        }\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Utility methods\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns whether the attributes of this method can be copied from the attributes of the given\n     * method (assuming there is no method visitor between the given ClassReader and this\n     * MethodWriter). This method should only be called just after this MethodWriter has been created,\n     * and before any content is visited. It returns true if the attributes corresponding to the\n     * constructor arguments (at most a Signature, an Exception, a Deprecated and a Synthetic\n     * attribute) are the same as the corresponding attributes in the given method.\n     *\n     * @param source the source ClassReader from which the attributes of this method might be copied.\n     * @param hasSyntheticAttribute whether the method_info JVMS structure from which the attributes\n     *     of this method might be copied contains a Synthetic attribute.\n     * @param hasDeprecatedAttribute whether the method_info JVMS structure from which the attributes\n     *     of this method might be copied contains a Deprecated attribute.\n     * @param descriptorIndex the descriptor_index field of the method_info JVMS structure from which\n     *     the attributes of this method might be copied.\n     * @param signatureIndex the constant pool index contained in the Signature attribute of the\n     *     method_info JVMS structure from which the attributes of this method might be copied, or 0.\n     * @param exceptionsOffset the offset in 'source.b' of the Exceptions attribute of the method_info\n     *     JVMS structure from which the attributes of this method might be copied, or 0.\n     * @return whether the attributes of this method can be copied from the attributes of the\n     *     method_info JVMS structure in 'source.b', between 'methodInfoOffset' and 'methodInfoOffset'\n     *     + 'methodInfoLength'.\n     */\n    boolean canCopyMethodAttributes(final ClassReader source, final boolean hasSyntheticAttribute, final boolean hasDeprecatedAttribute, final int descriptorIndex, final int signatureIndex, final int exceptionsOffset) {\n        // If the method descriptor has changed, with more locals than the max_locals field of the\n        // original Code attribute, if any, then the original method attributes can't be copied. A\n        // conservative check on the descriptor changes alone ensures this (being more precise is not\n        // worth the additional complexity, because these cases should be rare -- if a transform changes\n        // a method descriptor, most of the time it needs to change the method's code too).\n        if (source != symbolTable.getSource() || descriptorIndex != this.descriptorIndex || signatureIndex != this.signatureIndex || hasDeprecatedAttribute != ((accessFlags & Opcodes.ACC_DEPRECATED) != 0)) {\n            return false;\n        }\n        boolean needSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5 && (accessFlags & Opcodes.ACC_SYNTHETIC) != 0;\n        if (hasSyntheticAttribute != needSyntheticAttribute) {\n            return false;\n        }\n        if (exceptionsOffset == 0) {\n            if (numberOfExceptions != 0) {\n                return false;\n            }\n        } else if (source.readUnsignedShort(exceptionsOffset) == numberOfExceptions) {\n            int currentExceptionOffset = exceptionsOffset + 2;\n            for (int i = 0; i < numberOfExceptions; ++i) {\n                if (source.readUnsignedShort(currentExceptionOffset) != exceptionIndexTable[i]) {\n                    return false;\n                }\n                currentExceptionOffset += 2;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Sets the source from which the attributes of this method will be copied.\n     *\n     * @param methodInfoOffset the offset in 'symbolTable.getSource()' of the method_info JVMS\n     *     structure from which the attributes of this method will be copied.\n     * @param methodInfoLength the length in 'symbolTable.getSource()' of the method_info JVMS\n     *     structure from which the attributes of this method will be copied.\n     */\n    void setMethodAttributesSource(final int methodInfoOffset, final int methodInfoLength) {\n        // Don't copy the attributes yet, instead store their location in the source class reader so\n        // they can be copied later, in {@link #putMethodInfo}. Note that we skip the 6 header bytes\n        // of the method_info JVMS structure.\n        this.sourceOffset = methodInfoOffset + 6;\n        this.sourceLength = methodInfoLength - 6;\n    }\n\n    /**\n     * Returns the size of the method_info JVMS structure generated by this MethodWriter. Also add the\n     * names of the attributes of this method in the constant pool.\n     *\n     * @return the size in bytes of the method_info JVMS structure.\n     */\n    int computeMethodInfoSize() {\n        // If this method_info must be copied from an existing one, the size computation is trivial.\n        if (sourceOffset != 0) {\n            // sourceLength excludes the first 6 bytes for access_flags, name_index and descriptor_index.\n            return 6 + sourceLength;\n        }\n        // 2 bytes each for access_flags, name_index, descriptor_index and attributes_count.\n        int size = 8;\n        // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\n        if (code.length > 0) {\n            if (code.length > 65535) {\n                throw new MethodTooLargeException(symbolTable.getClassName(), name, descriptor, code.length);\n            }\n            symbolTable.addConstantUtf8(Constants.CODE);\n            // The Code attribute has 6 header bytes, plus 2, 2, 4 and 2 bytes respectively for max_stack,\n            // max_locals, code_length and attributes_count, plus the bytecode and the exception table.\n            size += 16 + code.length + Handler.getExceptionTableSize(firstHandler);\n            if (stackMapTableEntries != null) {\n                boolean useStackMapTable = symbolTable.getMajorVersion() >= Opcodes.V1_6;\n                symbolTable.addConstantUtf8(useStackMapTable ? Constants.STACK_MAP_TABLE : \"StackMap\");\n                // 6 header bytes and 2 bytes for number_of_entries.\n                size += 8 + stackMapTableEntries.length;\n            }\n            if (lineNumberTable != null) {\n                symbolTable.addConstantUtf8(Constants.LINE_NUMBER_TABLE);\n                // 6 header bytes and 2 bytes for line_number_table_length.\n                size += 8 + lineNumberTable.length;\n            }\n            if (localVariableTable != null) {\n                symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TABLE);\n                // 6 header bytes and 2 bytes for local_variable_table_length.\n                size += 8 + localVariableTable.length;\n            }\n            if (localVariableTypeTable != null) {\n                symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TYPE_TABLE);\n                // 6 header bytes and 2 bytes for local_variable_type_table_length.\n                size += 8 + localVariableTypeTable.length;\n            }\n            if (lastCodeRuntimeVisibleTypeAnnotation != null) {\n                size += lastCodeRuntimeVisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n            }\n            if (lastCodeRuntimeInvisibleTypeAnnotation != null) {\n                size += lastCodeRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n            }\n            if (firstCodeAttribute != null) {\n                size += firstCodeAttribute.computeAttributesSize(symbolTable, code.data, code.length, maxStack, maxLocals);\n            }\n        }\n        if (numberOfExceptions > 0) {\n            symbolTable.addConstantUtf8(Constants.EXCEPTIONS);\n            size += 8 + 2 * numberOfExceptions;\n        }\n        size += Attribute.computeAttributesSize(symbolTable, accessFlags, signatureIndex);\n        size += AnnotationWriter.computeAnnotationsSize(lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation);\n        if (lastRuntimeVisibleParameterAnnotations != null) {\n            size += AnnotationWriter.computeParameterAnnotationsSize(Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, lastRuntimeVisibleParameterAnnotations, visibleAnnotableParameterCount == 0 ? lastRuntimeVisibleParameterAnnotations.length : visibleAnnotableParameterCount);\n        }\n        if (lastRuntimeInvisibleParameterAnnotations != null) {\n            size += AnnotationWriter.computeParameterAnnotationsSize(Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, lastRuntimeInvisibleParameterAnnotations, invisibleAnnotableParameterCount == 0 ? lastRuntimeInvisibleParameterAnnotations.length : invisibleAnnotableParameterCount);\n        }\n        if (defaultValue != null) {\n            symbolTable.addConstantUtf8(Constants.ANNOTATION_DEFAULT);\n            size += 6 + defaultValue.length;\n        }\n        if (parameters != null) {\n            symbolTable.addConstantUtf8(Constants.METHOD_PARAMETERS);\n            // 6 header bytes and 1 byte for parameters_count.\n            size += 7 + parameters.length;\n        }\n        if (firstAttribute != null) {\n            size += firstAttribute.computeAttributesSize(symbolTable);\n        }\n        return size;\n    }\n\n    /**\n     * Puts the content of the method_info JVMS structure generated by this MethodWriter into the\n     * given ByteVector.\n     *\n     * @param output where the method_info structure must be put.\n     */\n    void putMethodInfo(final ByteVector output) {\n        boolean useSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5;\n        int mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : 0;\n        output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex);\n        // If this method_info must be copied from an existing one, copy it now and return early.\n        if (sourceOffset != 0) {\n            output.putByteArray(symbolTable.getSource().classFileBuffer, sourceOffset, sourceLength);\n            return;\n        }\n        // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\n        int attributeCount = 0;\n        if (code.length > 0) {\n            ++attributeCount;\n        }\n        if (numberOfExceptions > 0) {\n            ++attributeCount;\n        }\n        if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) {\n            ++attributeCount;\n        }\n        if (signatureIndex != 0) {\n            ++attributeCount;\n        }\n        if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\n            ++attributeCount;\n        }\n        if (lastRuntimeVisibleAnnotation != null) {\n            ++attributeCount;\n        }\n        if (lastRuntimeInvisibleAnnotation != null) {\n            ++attributeCount;\n        }\n        if (lastRuntimeVisibleParameterAnnotations != null) {\n            ++attributeCount;\n        }\n        if (lastRuntimeInvisibleParameterAnnotations != null) {\n            ++attributeCount;\n        }\n        if (lastRuntimeVisibleTypeAnnotation != null) {\n            ++attributeCount;\n        }\n        if (lastRuntimeInvisibleTypeAnnotation != null) {\n            ++attributeCount;\n        }\n        if (defaultValue != null) {\n            ++attributeCount;\n        }\n        if (parameters != null) {\n            ++attributeCount;\n        }\n        if (firstAttribute != null) {\n            attributeCount += firstAttribute.getAttributeCount();\n        }\n        // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\n        output.putShort(attributeCount);\n        if (code.length > 0) {\n            // 2, 2, 4 and 2 bytes respectively for max_stack, max_locals, code_length and\n            // attributes_count, plus the bytecode and the exception table.\n            int size = 10 + code.length + Handler.getExceptionTableSize(firstHandler);\n            int codeAttributeCount = 0;\n            if (stackMapTableEntries != null) {\n                // 6 header bytes and 2 bytes for number_of_entries.\n                size += 8 + stackMapTableEntries.length;\n                ++codeAttributeCount;\n            }\n            if (lineNumberTable != null) {\n                // 6 header bytes and 2 bytes for line_number_table_length.\n                size += 8 + lineNumberTable.length;\n                ++codeAttributeCount;\n            }\n            if (localVariableTable != null) {\n                // 6 header bytes and 2 bytes for local_variable_table_length.\n                size += 8 + localVariableTable.length;\n                ++codeAttributeCount;\n            }\n            if (localVariableTypeTable != null) {\n                // 6 header bytes and 2 bytes for local_variable_type_table_length.\n                size += 8 + localVariableTypeTable.length;\n                ++codeAttributeCount;\n            }\n            if (lastCodeRuntimeVisibleTypeAnnotation != null) {\n                size += lastCodeRuntimeVisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n                ++codeAttributeCount;\n            }\n            if (lastCodeRuntimeInvisibleTypeAnnotation != null) {\n                size += lastCodeRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n                ++codeAttributeCount;\n            }\n            if (firstCodeAttribute != null) {\n                size += firstCodeAttribute.computeAttributesSize(symbolTable, code.data, code.length, maxStack, maxLocals);\n                codeAttributeCount += firstCodeAttribute.getAttributeCount();\n            }\n            output.putShort(symbolTable.addConstantUtf8(Constants.CODE)).putInt(size).putShort(maxStack).putShort(maxLocals).putInt(code.length).putByteArray(code.data, 0, code.length);\n            Handler.putExceptionTable(firstHandler, output);\n            output.putShort(codeAttributeCount);\n            if (stackMapTableEntries != null) {\n                boolean useStackMapTable = symbolTable.getMajorVersion() >= Opcodes.V1_6;\n                output.putShort(symbolTable.addConstantUtf8(useStackMapTable ? Constants.STACK_MAP_TABLE : \"StackMap\")).putInt(2 + stackMapTableEntries.length).putShort(stackMapTableNumberOfEntries).putByteArray(stackMapTableEntries.data, 0, stackMapTableEntries.length);\n            }\n            if (lineNumberTable != null) {\n                output.putShort(symbolTable.addConstantUtf8(Constants.LINE_NUMBER_TABLE)).putInt(2 + lineNumberTable.length).putShort(lineNumberTableLength).putByteArray(lineNumberTable.data, 0, lineNumberTable.length);\n            }\n            if (localVariableTable != null) {\n                output.putShort(symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TABLE)).putInt(2 + localVariableTable.length).putShort(localVariableTableLength).putByteArray(localVariableTable.data, 0, localVariableTable.length);\n            }\n            if (localVariableTypeTable != null) {\n                output.putShort(symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TYPE_TABLE)).putInt(2 + localVariableTypeTable.length).putShort(localVariableTypeTableLength).putByteArray(localVariableTypeTable.data, 0, localVariableTypeTable.length);\n            }\n            if (lastCodeRuntimeVisibleTypeAnnotation != null) {\n                lastCodeRuntimeVisibleTypeAnnotation.putAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output);\n            }\n            if (lastCodeRuntimeInvisibleTypeAnnotation != null) {\n                lastCodeRuntimeInvisibleTypeAnnotation.putAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output);\n            }\n            if (firstCodeAttribute != null) {\n                firstCodeAttribute.putAttributes(symbolTable, code.data, code.length, maxStack, maxLocals, output);\n            }\n        }\n        if (numberOfExceptions > 0) {\n            output.putShort(symbolTable.addConstantUtf8(Constants.EXCEPTIONS)).putInt(2 + 2 * numberOfExceptions).putShort(numberOfExceptions);\n            for (int exceptionIndex : exceptionIndexTable) {\n                output.putShort(exceptionIndex);\n            }\n        }\n        Attribute.putAttributes(symbolTable, accessFlags, signatureIndex, output);\n        AnnotationWriter.putAnnotations(symbolTable, lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation, output);\n        if (lastRuntimeVisibleParameterAnnotations != null) {\n            AnnotationWriter.putParameterAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS), lastRuntimeVisibleParameterAnnotations, visibleAnnotableParameterCount == 0 ? lastRuntimeVisibleParameterAnnotations.length : visibleAnnotableParameterCount, output);\n        }\n        if (lastRuntimeInvisibleParameterAnnotations != null) {\n            AnnotationWriter.putParameterAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS), lastRuntimeInvisibleParameterAnnotations, invisibleAnnotableParameterCount == 0 ? lastRuntimeInvisibleParameterAnnotations.length : invisibleAnnotableParameterCount, output);\n        }\n        if (defaultValue != null) {\n            output.putShort(symbolTable.addConstantUtf8(Constants.ANNOTATION_DEFAULT)).putInt(defaultValue.length).putByteArray(defaultValue.data, 0, defaultValue.length);\n        }\n        if (parameters != null) {\n            output.putShort(symbolTable.addConstantUtf8(Constants.METHOD_PARAMETERS)).putInt(1 + parameters.length).putByte(parametersCount).putByteArray(parameters.data, 0, parameters.length);\n        }\n        if (firstAttribute != null) {\n            firstAttribute.putAttributes(symbolTable, output);\n        }\n    }\n\n    /**\n     * Collects the attributes of this method into the given set of attribute prototypes.\n     *\n     * @param attributePrototypes a set of attribute prototypes.\n     */\n    final void collectAttributePrototypes(final Attribute.Set attributePrototypes) {\n        attributePrototypes.addAttributes(firstAttribute);\n        attributePrototypes.addAttributes(firstCodeAttribute);\n    }\n}\n",
            "file_name": "MethodWriter.java",
            "human_label": "Add the elements indexed from start to end in currentFrame to Frame.",
            "level": "project_runnable",
            "lineno": "1732",
            "name": "putAbstractTypes",
            "oracle_context": "{ \"apis\" : \"[putAbstractType]\", \"classes\" : \"[]\", \"vars\" : \"[symbolTable, currentFrame, stackMapTableEntries]\" }",
            "package": "net.hasor.utils.asm",
            "project": "hasor-master"
        },
        {
            "_id": "636766801a6d9265ec017482",
            "all_context": "{ \"class_level\" : \"import java.io.DataInput;\\nimport java.io.DataInputStream;\\nimport java.io.EOFException;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nbyte[] buffer;\\nint size;\\nint pointer;\\nClassFileBuffer();\\nClassFileBuffer(int initialCapacity);\\nseek(int position);\\nsize();\\nreadFully(byte bytes);\\nreadFully(byte bytes,int offset,int length);\\nskipBytes(int n);\\nreadByte();\\nreadBoolean();\\nreadUnsignedByte();\\nreadUnsignedShort();\\nreadShort();\\nreadChar();\\nreadInt();\\nreadLong();\\nreadFloat();\\nreadDouble();\\nreadLine();\\nreadUTF();\\nread();\\nresizeIfNeeded();\\ndestroy();\\n\", \"repo_level\" : \"\" }",
            "class_name": "ClassFileBuffer",
            "code": "public void readFrom(final InputStream in) throws IOException {\n  pointer=0;\n  size=0;\n  int n;\n  do {\n    n=in.read(buffer,size,buffer.length - size);\n    if (n > 0) {\n      size+=n;\n    }\n    resizeIfNeeded();\n  }\n while (n >= 0);\n}\n",
            "docstring": "/** \n * Clear and fill the buffer of this  {@code ClassFileBuffer} with thesupplied byte stream. The read pointer is reset to the start of the byte array.\n */\n",
            "end_lineno": "100",
            "file_content": "/*\n * Copyright 2008-2022 Async-IO.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *//* ClassFileBuffer.java\n * \n ******************************************************************************\n *\n * Created: Oct 10, 2011\n * Character encoding: UTF-8\n * \n * Copyright (c) 2011 - XIAM Solutions B.V. The Netherlands, http://www.xiam.nl\n * \n ********************************* LICENSE ************************************\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.atmosphere.util.annotation;\n\nimport java.io.DataInput;\nimport java.io.DataInputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * {@code ClassFileBuffer} is used by {@link eu.infomas.annotation.AnnotationDetector} to efficiently\n * read Java ClassFile files from an {@link java.io.InputStream} and parse the content\n * via the {@link java.io.DataInput} interface.\n * <br/>\n * Note that Java ClassFile files can grow really big,\n * {@code com.sun.corba.se.impl.logging.ORBUtilSystemException} is 128.2 kb!\n *\n * @author <a href=\"mailto:rmuller@xiam.nl\">Ronald K. Muller</a>\n * @since annotation-detector 3.0.0\n */\nfinal class ClassFileBuffer implements DataInput {\n\n    private byte[] buffer;\n    private int size; // the number of significant bytes read\n    private int pointer; // the \"read pointer\"\n\n    /**\n     * Create a new, empty {@code ClassFileBuffer} with the default initial capacity (8 kb).\n     */\n    ClassFileBuffer() {\n        this(8 * 1024);\n    }\n\n    /**\n     * Create a new, empty {@code ClassFileBuffer} with the specified initial capacity.\n     * The initial capacity must be greater than zero. The internal buffer will grow\n     * automatically when a higher capacity is required. However, buffer resizing occurs\n     * extra overhead. So in good initial capacity is important in performance critical\n     * situations.\n     */\n    ClassFileBuffer(final int initialCapacity) {\n        if (initialCapacity < 1) {\n            throw new IllegalArgumentException(\"initialCapacity < 1: \" + initialCapacity);\n        }\n        this.buffer = new byte[initialCapacity];\n    }\n\n    /**\n     * Clear and fill the buffer of this {@code ClassFileBuffer} with the\n     * supplied byte stream.\n     * The read pointer is reset to the start of the byte array.\n     */\n    public void readFrom(final InputStream in) throws IOException {\n        pointer = 0;\n        size = 0;\n        int n;\n        do {\n            n = in.read(buffer, size, buffer.length - size);\n            if (n > 0) {\n                size += n;\n            }\n            resizeIfNeeded();\n        } while (n >= 0);\n    }\n\n    /**\n     * Sets the file-pointer offset, measured from the beginning of this file,\n     * at which the next read or write occurs.\n     */\n    public void seek(final int position) throws IOException {\n        if (position < 0) {\n            throw new IllegalArgumentException(\"position < 0: \" + position);\n        }\n        if (position > size) {\n            throw new EOFException();\n        }\n        this.pointer = position;\n    }\n\n    /**\n     * Return the size (in bytes) of this Java ClassFile file.\n     */\n    public int size() {\n        return size;\n    }\n\n    // DataInput\n\n    @Override\n    public void readFully(final byte bytes[]) throws IOException {\n        readFully(bytes, 0, bytes.length);\n    }\n\n    @Override\n    public void readFully(final byte bytes[], final int offset, final int length) throws IOException {\n        if (length < 0 || offset < 0 || offset + length > bytes.length) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (pointer + length > size) {\n            throw new EOFException();\n        }\n        System.arraycopy(buffer, pointer, bytes, offset, length);\n        pointer += length;\n    }\n\n    @Override\n    public int skipBytes(final int n) throws IOException {\n        seek(pointer + n);\n        return n;\n    }\n\n    @Override\n    public byte readByte() throws IOException {\n        if (pointer >= size) {\n            throw new EOFException();\n        }\n        return buffer[pointer++];\n    }\n\n    @Override\n    public boolean readBoolean() throws IOException {\n        return readByte() != 0;\n    }\n\n    @Override\n    public int readUnsignedByte() throws IOException {\n        if (pointer >= size) {\n            throw new EOFException();\n        }\n        return read();\n    }\n\n    @Override\n    public int readUnsignedShort() throws IOException {\n        if (pointer + 2 > size) {\n            throw new EOFException();\n        }\n        return (read() << 8) + read();\n    }\n\n    @Override\n    public short readShort() throws IOException {\n        return (short) readUnsignedShort();\n    }\n\n    @Override\n    public char readChar() throws IOException {\n        return (char) readUnsignedShort();\n    }\n\n    @Override\n    public int readInt() throws IOException {\n        if (pointer + 4 > size) {\n            throw new EOFException();\n        }\n        return (read() << 24) +\n                (read() << 16) +\n                (read() << 8) +\n                read();\n    }\n\n    @Override\n    public long readLong() throws IOException {\n        if (pointer + 8 > size) {\n            throw new EOFException();\n        }\n        return (read() << 56) +\n                (read() << 48) +\n                (read() << 40) +\n                (read() << 32) +\n                (read() << 24) +\n                (read() << 16) +\n                (read() << 8) +\n                read();\n    }\n\n    @Override\n    public float readFloat() throws IOException {\n        return Float.intBitsToFloat(readInt());\n    }\n\n    @Override\n    public double readDouble() throws IOException {\n        return Double.longBitsToDouble(readLong());\n    }\n\n    /**\n     * This methods throws an {@link UnsupportedOperationException} because the method\n     * is deprecated and not used in the context of this implementation.\n     */\n    @Override\n    @Deprecated\n    public String readLine() throws IOException {\n        throw new UnsupportedOperationException(\"readLine() is deprecated and not supported\");\n    }\n\n    @Override\n    public String readUTF() throws IOException {\n        return DataInputStream.readUTF(this);\n    }\n\n    // private\n\n    private int read() {\n        return buffer[pointer++] & 0xff;\n    }\n\n    private void resizeIfNeeded() {\n        if (size >= buffer.length) {\n            final byte[] newBuffer = new byte[buffer.length * 2];\n            System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);\n            buffer = newBuffer;\n        }\n    }\n\n    public void destroy() {\n        buffer = null;\n    }\n}\n",
            "file_name": "ClassFileBuffer.java",
            "human_label": "Read from the buffer.",
            "level": "class_runnable",
            "lineno": "84",
            "name": "readFrom",
            "oracle_context": "{ \"apis\" : \"[read, resizeIfNeeded, size]\", \"classes\" : \"[buffer]\", \"vars\" : \"[length, pointer, size, buffer]\" }",
            "package": "org.atmosphere.util.annotation",
            "project": "atmosphere-atmosphere-2.7.x"
        },
        {
            "_id": "6367670a1a6d9265ec0179d8",
            "all_context": "{ \"class_level\" : \"import java.io.IOException;\\nimport java.io.OutputStream;\\nimport java.io.Writer;\\nWriter writer;\\nString encoding;\\nbyte[] buf;\\nWriterOutputStream(Writer writer,String encoding);\\nWriterOutputStream(Writer writer);\\nflush();\\nwrite(byte[] b);\\nwrite(byte[] b,int off,int len);\\nwrite(int b);\\nclose();\\n\", \"repo_level\" : \"\" }",
            "class_name": "WriterOutputStream",
            "code": "@Override public void write(final byte[] b) throws IOException {\n  if (this.encoding == null) {\n    this.writer.write(new String(b));\n  }\n else {\n    this.writer.write(new String(b,this.encoding));\n  }\n}\n",
            "docstring": "/** \n * @see OutputStream#write(byte[]) \n */\n",
            "end_lineno": "73",
            "file_content": "/*\n * Copyright 2008-2009 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.io.output;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.Writer;\n\n/**\n * OutputStreamWriter\n * @version 2009-5-13\n * @author \n */\npublic class WriterOutputStream extends OutputStream {\n    private Writer writer   = null;\n    private String encoding = null;\n    private byte[] buf      = new byte[1];\n    //========================================================================================\n\n    /**\n     * Writer\n     * @param writer   - OutputStreamReader\n     * @param encoding - OutputStream\n     */\n    public WriterOutputStream(final Writer writer, final String encoding) {\n        this.writer = writer;\n        this.encoding = encoding;\n    }\n\n    /**\n     * Writer\n     * @param writer - OutputStreamWriter\n     */\n    public WriterOutputStream(final Writer writer) {\n        this.writer = writer;\n    }\n    //========================================================================================\n\n    /** @see OutputStream#close() */\n    @Override\n    public void close() throws IOException {\n        this.writer.close();\n        this.writer = null;\n        this.encoding = null;\n    }\n\n    /** @see OutputStream#flush() */\n    @Override\n    public void flush() throws IOException {\n        this.writer.flush();\n    }\n\n    /** @see OutputStream#write(byte[]) */\n    @Override\n    public void write(final byte[] b) throws IOException {\n        if (this.encoding == null) {\n            this.writer.write(new String(b));\n        } else {\n            this.writer.write(new String(b, this.encoding));\n        }\n    }\n\n    /** @see OutputStream#write(byte[], int, int) */\n    @Override\n    public void write(final byte[] b, final int off, final int len) throws IOException {\n        if (this.encoding == null) {\n            this.writer.write(new String(b, off, len));\n        } else {\n            this.writer.write(new String(b, off, len, this.encoding));\n        }\n    }\n\n    /** @see OutputStream#write(int) */\n    @Override\n    public synchronized void write(final int b) throws IOException {\n        this.buf[0] = (byte) b;\n        this.write(this.buf);\n    }\n}\n",
            "file_name": "WriterOutputStream.java",
            "human_label": "Write the byte array b to the buffer based on the encoding.",
            "level": "class_runnable",
            "lineno": "65",
            "name": "write",
            "oracle_context": "{ \"apis\" : \"[]\", \"classes\" : \"[]\", \"vars\" : \"[encoding, writer]\" }",
            "package": "net.hasor.utils.io.output",
            "project": "hasor-master"
        },
        {
            "_id": "636766a81a6d9265ec01757b",
            "all_context": "{ \"class_level\" : \"import com.alibaba.fastjson2.reader.ObjectReader;\\nimport com.alibaba.fastjson2.reader.ObjectReaderImplEnum;\\nimport com.alibaba.fastjson2.reader.ObjectReaderProvider;\\nimport com.alibaba.fastjson2.schema.JSONSchema;\\nimport com.alibaba.fastjson2.util.DateUtils;\\nimport com.alibaba.fastjson2.util.Fnv;\\nimport com.alibaba.fastjson2.util.IOUtils;\\nimport com.alibaba.fastjson2.util.TypeUtils;\\nimport com.alibaba.fastjson2.writer.ObjectWriter;\\nimport com.alibaba.fastjson2.writer.ObjectWriterAdapter;\\nimport java.lang.reflect.Array;\\nimport java.lang.reflect.Type;\\nimport java.math.BigDecimal;\\nimport java.math.BigInteger;\\nimport java.time.Instant;\\nimport java.util.*;\\nimport java.util.function.Function;\\nimport static com.alibaba.fastjson2.JSONObject.NONE_DIRECT_FEATURES;\\nimport static com.alibaba.fastjson2.JSONWriter.Feature.*;\\nlong serialVersionUID;\\nObjectWriter<JSONArray> arrayWriter;\\nJSONArray();\\nJSONArray(int initialCapacity);\\nJSONArray(Collection collection);\\nJSONArray(Object items);\\nset(int index,Object element);\\ngetJSONArray(int index);\\ngetJSONObject(int index);\\ngetString(int index);\\ngetDouble(int index);\\ngetDoubleValue(int index);\\ngetFloat(int index);\\ngetFloatValue(int index);\\ngetLong(int index);\\ngetLongValue(int index);\\ngetInteger(int index);\\ngetIntValue(int index);\\ngetShort(int index);\\ngetShortValue(int index);\\ngetByte(int index);\\ngetByteValue(int index);\\ngetBoolean(int index);\\ngetBooleanValue(int index);\\ngetBigInteger(int index);\\ngetBigDecimal(int index);\\ngetDate(int index);\\ngetInstant(int index);\\ntoString(Feature features);\\ntoJSONString(Feature features);\\ntoJSONString(Object object,Feature features);\\ntoJSONBBytes(Feature features);\\nto(Type type);\\nto(Class type);\\ntoJavaObject(Type type);\\ntoList(Class itemClass,Feature features);\\ntoArray(Class itemClass,Feature features);\\ntoJavaList(Class clazz,Feature features);\\ngetObject(int index,Type type,Feature features);\\ngetObject(int index,Class type,Feature features);\\ngetObject(int index,Function creator);\\nfluentAdd(Object element);\\nfluentClear();\\nfluentRemove(int index);\\nfluentSet(int index,Object element);\\nfluentRemove(Object o);\\nfluentRemoveAll(Collection c);\\nfluentAddAll(Collection c);\\nisValid(JSONSchema schema);\\nclone();\\nof(Object items);\\nof(Object item);\\nof(Object first,Object second);\\nof(Object first,Object second,Object third);\\nparseArray(String text,Feature features);\\nparse(String text,Feature features);\\ntoString();\\n\", \"repo_level\" : \"public interface ObjectReader {default T createInstance();\\ndefault T createInstance(long features);\\ndefault T createInstance(Collection collection);\\ndefault T createInstance(Map map,Feature features);\\ndefault T createInstance(Map map,long features);\\ndefault T createInstanceNoneDefaultConstructor(Map values);\\ndefault long getFeatures();\\ndefault String getTypeKey();\\ndefault long getTypeKeyHash();\\ndefault Class<T> getObjectClass();\\ndefault FieldReader getFieldReader(long hashCode);\\ndefault FieldReader getFieldReaderLCase(long hashCode);\\ndefault boolean setFieldValue(Object object,String fieldName,long fieldNameHashCode,int value);\\ndefault boolean setFieldValue(Object object,String fieldName,long fieldNameHashCode,long value);\\ndefault FieldReader getFieldReader(String fieldName);\\ndefault Function getBuildFunction();\\ndefault ObjectReader autoType(Context context,long typeHash);\\ndefault ObjectReader autoType(ObjectReaderProvider provider,long typeHash);\\ndefault T readJSONBObject(JSONReader jsonReader,Type fieldType,Object fieldName,long features);\\ndefault T readArrayMappingJSONBObject(JSONReader jsonReader,Type fieldType,Object fieldName,long features);\\ndefault T readArrayMappingObject(JSONReader jsonReader,Type fieldType,Object fieldName,long features);\\ndefault T readObject(JSONReader jsonReader);\\ndefault T readObject(JSONReader jsonReader,long features);\\n T readObject(JSONReader jsonReader,Type fieldType,Object fieldName,long features);\\n }\\npublic interface ObjectReaderImplEnum {public Class getObjectClass();\\npublic Enum getEnumByHashCode(long hashCode);\\npublic Enum getEnumByOrdinal(int ordinal);\\npublic Object readJSONBObject(JSONReader jsonReader,Type fieldType,Object fieldName,long features);\\npublic Object readObject(JSONReader jsonReader,Type fieldType,Object fieldName,long features);\\n }\\npublic interface ObjectReaderProvider {public void registerIfAbsent(long hashCode,ObjectReader objectReader);\\npublic void addAutoTypeAccept(String name);\\npublic Consumer<Class> getAutoTypeHandler();\\npublic void setAutoTypeHandler(Consumer autoTypeHandler);\\npublic Class getMixIn(Class target);\\npublic void mixIn(Class target,Class mixinSource);\\npublic ObjectReader register(Type type,ObjectReader objectReader);\\npublic ObjectReader registerIfAbsent(Type type,ObjectReader objectReader);\\npublic ObjectReader unregisterObjectReader(Type type);\\npublic boolean unregisterObjectReader(Type type,ObjectReader reader);\\npublic boolean register(ObjectReaderModule module);\\npublic boolean unregister(ObjectReaderModule module);\\npublic void cleanup(Class objectClass);\\npublic void cleanup(ClassLoader classLoader);\\npublic ObjectReaderCreator getCreator();\\n void init();\\npublic Function getTypeConvert(Type from,Type to);\\npublic Function registerTypeConvert(Type from,Type to,Function typeConvert);\\npublic ObjectReader getObjectReader(long hashCode);\\npublic ObjectReader getObjectReader(String typeName,Class expectClass,long features);\\nfinal void afterAutoType(String typeName,Class type);\\npublic Class<?> checkAutoType(String typeName,Class expectClass,long features);\\npublic List<ObjectReaderModule> getModules();\\npublic ObjectReader getObjectReader(Type objectType);\\npublic ObjectReader getObjectReader(Type objectType,boolean fieldBased);\\npublic AutoTypeBeforeHandler getAutoTypeBeforeHandler();\\npublic Map<String,Date> getAutoTypeList();\\npublic void setAutoTypeBeforeHandler(AutoTypeBeforeHandler autoTypeBeforeHandler);\\nprotected boolean removeEldestEntry(Map.Entry eldest);\\n }\\npublic interface JSONSchema {static JSONSchema of(JSONObject input,Class objectClass);\\nstatic Not ofNot(JSONObject input,Class objectClass);\\nstatic JSONSchema parseSchema(String schema);\\nstatic JSONSchema of(JSONObject input);\\nstatic JSONSchema of(JSONObject input,JSONSchema parent);\\nstatic AnyOf anyOf(JSONObject input,Class type);\\nstatic AnyOf anyOf(JSONArray array,Class type);\\nstatic AllOf allOf(JSONObject input,Class type);\\nstatic OneOf oneOf(JSONObject input,Class type);\\nstatic OneOf oneOf(JSONArray array,Class type);\\npublic String getTitle();\\npublic String getDescription();\\nabstract Type getType();\\nabstract ValidateResult validate(Object value);\\npublic boolean isValid(Object value);\\npublic boolean isValid(long value);\\npublic boolean isValid(double value);\\npublic boolean isValid(Double value);\\npublic boolean isValid(float value);\\npublic boolean isValid(Float value);\\npublic boolean isValid(Integer value);\\npublic boolean isValid(Long value);\\npublic ValidateResult validate(long value);\\npublic ValidateResult validate(double value);\\npublic ValidateResult validate(Float value);\\npublic ValidateResult validate(Double value);\\npublic ValidateResult validate(Integer value);\\npublic ValidateResult validate(Long value);\\npublic void assertValidate(Object value);\\npublic void assertValidate(Integer value);\\npublic void assertValidate(Long value);\\npublic void assertValidate(Double value);\\npublic void assertValidate(Float value);\\npublic void assertValidate(long value);\\npublic void assertValidate(double value);\\nstatic Type of(String typeStr);\\n }\\npublic interface DateUtils {static Date parseDate(String str);\\nstatic LocalDateTime parseLocalDateTime(String str);\\nstatic LocalDateTime parseLocalDateTime(String str,int off,int len);\\nstatic LocalDate parseLocalDate(String str);\\nstatic LocalDate parseLocalDate(String str,int off,int len);\\nstatic LocalDate parseLocalDate8(String str,int off);\\nstatic LocalDate parseLocalDate9(String str,int off);\\nstatic LocalDate parseLocalDate10(String str,int off);\\nstatic LocalDate parseLocalDate11(String str,int off);\\nstatic LocalDateTime parseLocalDateTime12(String str,int off);\\nstatic LocalDateTime parseLocalDateTime14(String str,int off);\\nstatic LocalDateTime parseLocalDateTime16(String str,int off);\\nstatic LocalDateTime parseLocalDateTime17(String str,int off);\\nstatic LocalDateTime parseLocalDateTime18(String str,int off);\\nstatic LocalDateTime parseLocalDateTime19(String str,int off);\\nstatic LocalDateTime parseLocalDateTimeX(String str,int offset,int len);\\nstatic ZonedDateTime parseZonedDateTime(String str);\\nstatic ZonedDateTime parseZonedDateTime(String str,int offset,int len);\\nstatic ZonedDateTime parseZonedDateTime(String str,int offset,int len,ZoneId defaultZoneId);\\nstatic ZoneId getZoneId(String zoneIdStr,ZoneId defaultZoneId);\\nstatic long toMillis19(String str,int off,ZoneId zoneId);\\nstatic LocalDateTime localDateTime(char y0,char y1,char y2,char y3,char m0,char m1,char d0,char d1,char h0,char h1,char i0,char i1,char s0,char s1,char S0,char S1,char S2,char S3,char S4,char S5,char S6,char S7,char S8);\\nstatic long millis(ZoneId zoneId,int year,int month,int dom,int hour,int minute,int second,int nanoOfSecond);\\nstatic long utcSeconds(int year,int month,int dom,int hour,int minute,int second);\\nstatic String toString(Date date);\\nstatic String toString(long timeMillis,boolean timeZone,ZoneId zoneId);\\n }\\npublic interface Fnv {static long hashCode64LCase(String name);\\nstatic long hashCode64(String name);\\nstatic long hashCode64(byte name);\\n }\\npublic interface IOUtils {static int stringSize(int x);\\nstatic int stringSize(long x);\\nstatic void getChars(int i,int index,byte[] buf);\\nstatic void getChars(int i,int index,char[] buf);\\nstatic void getChars(long i,int index,byte[] buf);\\nstatic void getChars(long i,int index,char[] buf);\\nstatic int encodeUTF8(byte[] src,int offset,int len,byte[] dst,int dp);\\nstatic int encodeUTF8(char[] src,int offset,int len,byte[] dst,int dp);\\nstatic boolean isNumber(String str);\\nstatic void close(Closeable x);\\nstatic int decodeUTF8(byte[] src,int off,int len,byte[] dst);\\nstatic int decodeUTF8(byte[] src,int off,int len,char[] dst);\\nstatic int getShanghaiZoneOffsetTotalSeconds(long seconds);\\n }\\npublic interface TypeUtils {static Class<?> getMapping(Type type);\\nstatic Date toDate(Object obj);\\nstatic Instant toInstant(Object obj);\\nstatic T cast(Object obj,Type type);\\nstatic T cast(Object obj,Class targetClass);\\nstatic T cast(Object obj,Class targetClass,ObjectReaderProvider provider);\\nstatic String getTypeName(Class type);\\nstatic Class getMapping(String typeName);\\nstatic BigDecimal toBigDecimal(Object value);\\nstatic BigInteger toBigInteger(Object value);\\nstatic Long toLong(Object value);\\nstatic long toLongValue(Object value);\\nstatic Integer toInteger(Object value);\\nstatic Byte toByte(Object value);\\nstatic byte toByteValue(Object value);\\nstatic Short toShort(Object value);\\nstatic short toShortValue(Object value);\\nstatic int toIntValue(Object value);\\nstatic boolean toBooleanValue(Object value);\\nstatic Boolean toBoolean(Object value);\\nstatic float toFloatValue(Object value);\\nstatic Float toFloat(Object value);\\nstatic double toDoubleValue(Object value);\\nstatic Double toDouble(Object value);\\nstatic int compare(Object a,Object b);\\nstatic Object getDefaultValue(Type paramType);\\nstatic Class loadClass(String className);\\nstatic Class<?> getArrayClass(Class componentClass);\\nstatic Class<?> getClass(Type type);\\nstatic boolean isProxy(Class clazz);\\nstatic Map getInnerMap(Map object);\\n }\\npublic interface ObjectWriter {default long getFeatures();\\ndefault List<FieldWriter> getFieldWriters();\\ndefault FieldWriter getFieldWriter(long hashCode);\\ndefault FieldWriter getFieldWriter(String name);\\ndefault boolean writeTypeInfo(JSONWriter jsonWriter);\\ndefault void writeJSONB(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\ndefault void writeArrayMappingJSONB(JSONWriter jsonWriter,Object object);\\ndefault void writeArrayMappingJSONB(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\ndefault void writeArrayMapping(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\ndefault boolean hasFilter(JSONWriter jsonWriter);\\ndefault void write(JSONWriter jsonWriter,Object object);\\n void write(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\ndefault void writeWithFilter(JSONWriter jsonWriter,Object object);\\ndefault void writeWithFilter(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\n }\\npublic interface ObjectWriterAdapter {public long getFeatures();\\npublic FieldWriter getFieldWriter(long hashCode);\\nfinal boolean hasFilter(JSONWriter jsonWriter);\\npublic void setPropertyFilter(PropertyFilter propertyFilter);\\npublic void setValueFilter(ValueFilter valueFilter);\\npublic void setNameFilter(NameFilter nameFilter);\\npublic void setPropertyPreFilter(PropertyPreFilter propertyPreFilter);\\npublic void writeArrayMappingJSONB(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\npublic void writeJSONB(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\nprotected void writeClassInfo(JSONWriter jsonWriter);\\npublic void write(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\npublic Map<String,Object> toMap(Object object);\\npublic List<FieldWriter> getFieldWriters();\\npublic boolean writeTypeInfo(JSONWriter jsonWriter);\\npublic void writeWithFilter(JSONWriter jsonWriter,Object object,Object fieldName,Type fieldType,long features);\\npublic JSONObject toJSONObject(T object);\\npublic String toString();\\nprotected void errorOnNoneSerializable();\\n }\\n\" }",
            "class_name": "JSONArray",
            "code": "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n  try (JSONWriter writer=JSONWriter.of(features)){\n    if ((writer.context.features & NONE_DIRECT_FEATURES) == 0) {\n      writer.write(this);\n    }\n else {\n      writer.setRootObject(this);\n      if (arrayWriter == null) {\n        arrayWriter=writer.getObjectWriter(JSONArray.class,JSONArray.class);\n      }\n      arrayWriter.write(writer,this,null,null,0);\n    }\n    return writer.toString();\n  }\n }\n",
            "docstring": "/** \n * Serialize to JSON  {@link String}\n * @param features features to be enabled in serialization\n * @return JSON {@link String}\n */\n",
            "end_lineno": "912",
            "file_content": "package com.alibaba.fastjson2;\n\nimport com.alibaba.fastjson2.reader.ObjectReader;\nimport com.alibaba.fastjson2.reader.ObjectReaderImplEnum;\nimport com.alibaba.fastjson2.reader.ObjectReaderProvider;\nimport com.alibaba.fastjson2.schema.JSONSchema;\nimport com.alibaba.fastjson2.util.DateUtils;\nimport com.alibaba.fastjson2.util.Fnv;\nimport com.alibaba.fastjson2.util.IOUtils;\nimport com.alibaba.fastjson2.util.TypeUtils;\nimport com.alibaba.fastjson2.writer.ObjectWriter;\nimport com.alibaba.fastjson2.writer.ObjectWriterAdapter;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.time.Instant;\nimport java.util.*;\nimport java.util.function.Function;\n\nimport static com.alibaba.fastjson2.JSONObject.NONE_DIRECT_FEATURES;\nimport static com.alibaba.fastjson2.JSONWriter.Feature.*;\n\npublic class JSONArray\n        extends ArrayList<Object> {\n    private static final long serialVersionUID = 1L;\n\n    static ObjectWriter<JSONArray> arrayWriter;\n\n    /**\n     * default\n     */\n    public JSONArray() {\n        super();\n    }\n\n    /**\n     * @param initialCapacity the initial capacity of the {@link JSONArray}\n     * @throws IllegalArgumentException If the specified initial capacity is negative\n     */\n    public JSONArray(int initialCapacity) {\n        super(initialCapacity);\n    }\n\n    /**\n     * @param collection the collection whose elements are to be placed into this {@link JSONArray}\n     * @throws NullPointerException If the specified collection is null\n     */\n    public JSONArray(Collection<?> collection) {\n        super(collection);\n    }\n\n    /**\n     * @param items the array whose elements are to be placed into this {@link JSONArray}\n     * @throws NullPointerException If the specified items is null\n     */\n    public JSONArray(Object... items) {\n        super(items.length);\n        for (Object item : items) {\n            super.add(item);\n        }\n    }\n\n    /**\n     * Replaces the element at the specified position with the specified element\n     *\n     * <pre>{@code\n     *    JSONArray array = new JSONArray();\n     *    array.add(-1); // [-1]\n     *    array.add(2); // [-1,2]\n     *    array.set(0, 1); // [1,2]\n     *    array.set(4, 3); // [1,2,null,null,3]\n     *    array.set(-1, -1); // [1,2,null,null,-1]\n     *    array.set(-2, -2); // [1,2,null,-2,-1]\n     *    array.set(-6, -6); // [-6,1,2,null,-2,-1]\n     * }</pre>\n     *\n     * @param index index of the element to replace\n     * @param element element to be stored at the specified position\n     * @return the element previously at the specified position\n     * @since 2.0.3\n     */\n    @Override\n    public Object set(int index, Object element) {\n        int size = super.size();\n        if (index < 0) {\n            index += size;\n            if (index < 0) {\n                // left join elem\n                super.add(0, element);\n                return null;\n            }\n            return super.set(\n                    index, element\n            );\n        }\n\n        if (index < size) {\n            return super.set(\n                    index, element\n            );\n        }\n\n        // max expansion (size + 4096)\n        if (index < size + 4096) {\n            while (index-- != size) {\n                super.add(null);\n            }\n            super.add(element);\n        }\n        return null;\n    }\n\n    /**\n     * Returns the {@link JSONArray} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link JSONArray} or null\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public JSONArray getJSONArray(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof JSONArray) {\n            return (JSONArray) value;\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            JSONReader reader = JSONReader.of(str);\n            return JSONFactory.ARRAY_READER.readObject(reader, null, null, 0);\n        }\n\n        if (value instanceof Collection) {\n            return new JSONArray((Collection<?>) value);\n        }\n\n        if (value instanceof Object[]) {\n            return JSONArray.of((Object[]) value);\n        }\n\n        Class<?> valueClass = value.getClass();\n        if (valueClass.isArray()) {\n            int length = Array.getLength(value);\n            JSONArray jsonArray = new JSONArray(length);\n            for (int i = 0; i < length; i++) {\n                Object item = Array.get(value, i);\n                jsonArray.add(item);\n            }\n            return jsonArray;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the {@link JSONObject} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link JSONObject} or null\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public JSONObject getJSONObject(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof JSONObject) {\n            return (JSONObject) value;\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            JSONReader reader = JSONReader.of(str);\n            return JSONFactory.OBJECT_READER.readObject(reader, null, null, 0);\n        }\n\n        if (value instanceof Map) {\n            return new JSONObject((Map) value);\n        }\n\n        Class valueClass = value.getClass();\n        ObjectWriter objectWriter = JSONFactory.getDefaultObjectWriterProvider().getObjectWriter(valueClass);\n        if (objectWriter instanceof ObjectWriterAdapter) {\n            ObjectWriterAdapter writerAdapter = (ObjectWriterAdapter) objectWriter;\n            return writerAdapter.toJSONObject(value);\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the {@link String} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link String} or null\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public String getString(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof String) {\n            return (String) value;\n        }\n\n        if (value instanceof Date) {\n            long timeMillis = ((Date) value).getTime();\n            return DateUtils.toString(timeMillis, false, IOUtils.DEFAULT_ZONE_ID);\n        }\n\n        if (value instanceof Boolean\n                || value instanceof Character\n                || value instanceof Number\n                || value instanceof UUID\n                || value instanceof Enum) {\n            return value.toString();\n        }\n\n        return JSON.toJSONString(value);\n    }\n\n    /**\n     * Returns the {@link Double} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Double} or null\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable double\n     * @throws JSONException Unsupported type conversion to {@link Double}\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Double getDouble(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Double) {\n            return (Double) value;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).doubleValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return Double.parseDouble(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to Double\");\n    }\n\n    /**\n     * Returns a double value at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return double\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable double\n     * @throws JSONException Unsupported type conversion to double value\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public double getDoubleValue(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return 0D;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).doubleValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return 0D;\n            }\n\n            return Double.parseDouble(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to double value\");\n    }\n\n    /**\n     * Returns the {@link Float} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Float} or null\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable float\n     * @throws JSONException Unsupported type conversion to {@link Float}\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Float getFloat(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Float) {\n            return (Float) value;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).floatValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return Float.parseFloat(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to Float\");\n    }\n\n    /**\n     * Returns a float value at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return float\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable float\n     * @throws JSONException Unsupported type conversion to float value\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public float getFloatValue(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return 0F;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).floatValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return 0F;\n            }\n\n            return Float.parseFloat(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to float value\");\n    }\n\n    /**\n     * Returns the {@link Long} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Long} or null\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable long\n     * @throws JSONException Unsupported type conversion to {@link Long}\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Long getLong(int index) {\n        Object value = get(index);\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Long) {\n            return ((Long) value);\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).longValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return Long.parseLong(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to Long\");\n    }\n\n    /**\n     * Returns a long value at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return long\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable long\n     * @throws JSONException Unsupported type conversion to long value\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public long getLongValue(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return 0;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).longValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return 0;\n            }\n\n            return Long.parseLong(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to long value\");\n    }\n\n    /**\n     * Returns the {@link Integer} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Integer} or null\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable int\n     * @throws JSONException Unsupported type conversion to {@link Integer}\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Integer getInteger(int index) {\n        Object value = get(index);\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Integer) {\n            return ((Integer) value);\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).intValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return Integer.parseInt(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to Integer\");\n    }\n\n    /**\n     * Returns an int value at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return int\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable int\n     * @throws JSONException Unsupported type conversion to int value\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public int getIntValue(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return 0;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).intValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return 0;\n            }\n\n            return Integer.parseInt(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to int value\");\n    }\n\n    /**\n     * Returns the {@link Short} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Short} or null\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable short\n     * @throws JSONException Unsupported type conversion to {@link Short}\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Short getShort(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Short) {\n            return (Short) value;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).shortValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return Short.parseShort(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to Short\");\n    }\n\n    /**\n     * Returns a short value at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return short\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable short\n     * @throws JSONException Unsupported type conversion to short value\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public short getShortValue(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return 0;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).shortValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return 0;\n            }\n\n            return Short.parseShort(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to short value\");\n    }\n\n    /**\n     * Returns the {@link Byte} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Byte} or null\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable byte\n     * @throws JSONException Unsupported type conversion to {@link Byte}\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Byte getByte(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).byteValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return Byte.parseByte(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to Byte\");\n    }\n\n    /**\n     * Returns a byte value at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return byte\n     * @throws NumberFormatException If the value of get is {@link String} and it contains no parsable byte\n     * @throws JSONException Unsupported type conversion to byte value\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public byte getByteValue(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return 0;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).byteValue();\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return 0;\n            }\n\n            return Byte.parseByte(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to byte value\");\n    }\n\n    /**\n     * Returns the {@link Boolean} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Boolean} or null\n     * @throws JSONException Unsupported type conversion to {@link Boolean}\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Boolean getBoolean(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Boolean) {\n            return (Boolean) value;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).intValue() == 1;\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return \"true\".equalsIgnoreCase(str) || \"1\".equals(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to Boolean\");\n    }\n\n    /**\n     * Returns a boolean value at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return boolean\n     * @throws JSONException Unsupported type conversion to boolean value\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public boolean getBooleanValue(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return false;\n        }\n\n        if (value instanceof Boolean) {\n            return (Boolean) value;\n        }\n\n        if (value instanceof Number) {\n            return ((Number) value).intValue() == 1;\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n            return \"true\".equalsIgnoreCase(str) || \"1\".equals(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to boolean value\");\n    }\n\n    /**\n     * Returns the {@link BigInteger} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link BigInteger} or null\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     * @throws JSONException Unsupported type conversion to {@link BigInteger}\n     * @throws NumberFormatException If the value of get is {@link String} and it is not a valid representation of {@link BigInteger}\n     */\n    public BigInteger getBigInteger(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Number) {\n            if (value instanceof BigInteger) {\n                return (BigInteger) value;\n            }\n\n            if (value instanceof BigDecimal) {\n                return ((BigDecimal) value).toBigInteger();\n            }\n\n            long longValue = ((Number) value).longValue();\n            return BigInteger.valueOf(longValue);\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return new BigInteger(str);\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to BigInteger\");\n    }\n\n    /**\n     * Returns the {@link BigDecimal} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link BigDecimal} or null\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     * @throws JSONException Unsupported type conversion to {@link BigDecimal}\n     * @throws NumberFormatException If the value of get is {@link String} and it is not a valid representation of {@link BigDecimal}\n     */\n    public BigDecimal getBigDecimal(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Number) {\n            if (value instanceof BigDecimal) {\n                return (BigDecimal) value;\n            }\n\n            if (value instanceof BigInteger) {\n                return new BigDecimal((BigInteger) value);\n            }\n\n            if (value instanceof Float\n                    || value instanceof Double) {\n                // Floating point number have no cached BigDecimal\n                return new BigDecimal(value.toString());\n            }\n\n            long longValue = ((Number) value).longValue();\n            return BigDecimal.valueOf(longValue);\n        }\n\n        if (value instanceof String) {\n            String str = (String) value;\n\n            if (str.isEmpty() || \"null\".equalsIgnoreCase(str)) {\n                return null;\n            }\n\n            return new BigDecimal(str);\n        }\n\n        if (value instanceof Boolean) {\n            return (boolean) value ? BigDecimal.ONE : BigDecimal.ZERO;\n        }\n\n        throw new JSONException(\"Can not cast '\" + value.getClass() + \"' to BigDecimal\");\n    }\n\n    /**\n     * Returns the {@link Date} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Date} or null\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Date getDate(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Date) {\n            return (Date) value;\n        }\n\n        if (value instanceof Number) {\n            long millis = ((Number) value).longValue();\n            if (millis == 0) {\n                return null;\n            }\n            return new Date(millis);\n        }\n\n        return TypeUtils.toDate(value);\n    }\n\n    /**\n     * Returns the {@link Instant} at the specified location in this {@link JSONArray}.\n     *\n     * @param index index of the element to return\n     * @return {@link Instant} or null\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    public Instant getInstant(int index) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        if (value instanceof Instant) {\n            return (Instant) value;\n        }\n\n        if (value instanceof Number) {\n            long millis = ((Number) value).longValue();\n            if (millis == 0) {\n                return null;\n            }\n            return Instant.ofEpochMilli(millis);\n        }\n\n        return TypeUtils.toInstant(value);\n    }\n\n    /**\n     * Serialize to JSON {@link String}\n     *\n     * @return JSON {@link String}\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public String toString() {\n        try (JSONWriter writer = JSONWriter.of()) {\n            writer.setRootObject(this);\n            writer.write(this);\n            return writer.toString();\n        }\n    }\n\n    /**\n     * Serialize to JSON {@link String}\n     *\n     * @param features features to be enabled in serialization\n     * @return JSON {@link String}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public String toString(JSONWriter.Feature... features) {\n        try (JSONWriter writer = JSONWriter.of(features)) {\n            if ((writer.context.features & NONE_DIRECT_FEATURES) == 0) {\n                writer.write(this);\n            } else {\n                writer.setRootObject(this);\n                if (arrayWriter == null) {\n                    arrayWriter = writer.getObjectWriter(JSONArray.class, JSONArray.class);\n                }\n                arrayWriter.write(writer, this, null, null, 0);\n            }\n            return writer.toString();\n        }\n    }\n\n    /**\n     * Serialize to JSON {@link String}\n     *\n     * @param features features to be enabled in serialization\n     * @return JSON {@link String}\n     */\n    public String toJSONString(JSONWriter.Feature... features) {\n        return toString(features);\n    }\n\n    /**\n     * Serialize Java Object to JSON {@link String} with specified {@link JSONReader.Feature}s enabled\n     *\n     * @param object Java Object to be serialized into JSON {@link String}\n     * @param features features to be enabled in serialization\n     * @since 2.0.15\n     */\n    public static String toJSONString(Object object, JSONWriter.Feature... features) {\n        return JSON.toJSONString(object, features);\n    }\n\n    /**\n     * Serialize to JSONB bytes\n     *\n     * @param features features to be enabled in serialization\n     * @return JSONB bytes\n     */\n    @SuppressWarnings(\"unchecked\")\n    public byte[] toJSONBBytes(JSONWriter.Feature... features) {\n        try (JSONWriter writer = JSONWriter.ofJSONB(features)) {\n            writer.setRootObject(this);\n            writer.write(this);\n            return writer.getBytes();\n        }\n    }\n\n    /**\n     * Convert this {@link JSONArray} to the specified Object\n     *\n     * <pre>{@code\n     * JSONArray array = ...\n     * List<User> users = array.to(new TypeReference<ArrayList<User>>(){}.getType());\n     * }</pre>\n     *\n     * @param type specify the {@link Type} to be converted\n     * @since 2.0.4\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T to(Type type) {\n        if (type == String.class) {\n            return (T) toString();\n        }\n\n        ObjectReaderProvider provider = JSONFactory.getDefaultObjectReaderProvider();\n        ObjectReader<T> objectReader = provider.getObjectReader(type);\n        return objectReader.createInstance(this);\n    }\n\n    /**\n     * @since 2.0.9\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T to(Class<T> type) {\n        if (type == String.class) {\n            return (T) toString();\n        }\n\n        ObjectReaderProvider provider = JSONFactory.getDefaultObjectReaderProvider();\n        ObjectReader<T> objectReader = provider.getObjectReader(type);\n        return objectReader.createInstance(this);\n    }\n\n    /**\n     * Convert this {@link JSONArray} to the specified Object\n     *\n     * @param type specify the {@link Type} to be converted\n     * @deprecated since 2.0.4, please use {@link #to(Type)}\n     */\n    @Deprecated\n    public <T> T toJavaObject(Type type) {\n        return to(type);\n    }\n\n    /**\n     * Convert all the members of this {@link JSONArray} into the specified Object.\n     *\n     * <pre>{@code\n     * String json = \"[{\\\"id\\\": 1, \\\"name\\\": \\\"fastjson\\\"}, {\\\"id\\\": 2, \\\"name\\\": \\\"fastjson2\\\"}]\";\n     * JSONArray array = JSON.parseArray(json);\n     * List<User> users = array.toList(User.class);\n     * }</pre>\n     *\n     * @param itemClass specify the {@code Class<T>} to be converted\n     * @param features features to be enabled in parsing\n     * @since 2.0.4\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public <T> List<T> toList(Class<T> itemClass, JSONReader.Feature... features) {\n        boolean fieldBased = false;\n        long featuresValue = 0;\n        for (JSONReader.Feature feature : features) {\n            featuresValue |= feature.mask;\n            if (feature == JSONReader.Feature.FieldBased) {\n                fieldBased = true;\n            }\n        }\n\n        ObjectReaderProvider provider = JSONFactory.getDefaultObjectReaderProvider();\n        ObjectReader<?> objectReader = provider.getObjectReader(itemClass, fieldBased);\n\n        List<T> list = new ArrayList<>(size());\n        for (int i = 0; i < this.size(); i++) {\n            Object item = this.get(i);\n\n            T classItem;\n            if (item instanceof JSONObject) {\n                classItem = (T) objectReader.createInstance((Map) item, featuresValue);\n            } else if (item instanceof Map) {\n                classItem = (T) objectReader.createInstance((Map) item, featuresValue);\n            } else if (item == null || itemClass.isInstance(item)) {\n                classItem = (T) item;\n            } else {\n                Class<?> currentItemClass = item.getClass();\n                Function typeConvert = provider.getTypeConvert(currentItemClass, itemClass);\n                if (typeConvert != null) {\n                    Object converted = typeConvert.apply(item);\n                    list.add((T) converted);\n                    continue;\n                }\n\n                throw new JSONException(\n                        currentItemClass + \" cannot be converted to \" + itemClass\n                );\n            }\n            list.add(classItem);\n        }\n\n        return list;\n    }\n\n    /**\n     * Convert all the members of this {@link JSONArray} into the specified Object.\n     *\n     * <pre>{@code\n     * String json = \"[{\\\"id\\\": 1, \\\"name\\\": \\\"fastjson\\\"}, {\\\"id\\\": 2, \\\"name\\\": \\\"fastjson2\\\"}]\";\n     * JSONArray array = JSON.parseArray(json);\n     * List<User> users = array.toList(User.class);\n     * }</pre>\n     *\n     * @param itemClass specify the {@code Class<T>} to be converted\n     * @param features features to be enabled in parsing\n     * @since 2.0.4\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public <T> T[] toArray(Class<T> itemClass, JSONReader.Feature... features) {\n        boolean fieldBased = false;\n        long featuresValue = 0;\n        for (JSONReader.Feature feature : features) {\n            featuresValue |= feature.mask;\n            if (feature == JSONReader.Feature.FieldBased) {\n                fieldBased = true;\n            }\n        }\n\n        ObjectReaderProvider provider = JSONFactory.getDefaultObjectReaderProvider();\n        ObjectReader<?> objectReader = provider.getObjectReader(itemClass, fieldBased);\n\n        T[] list = (T[]) Array.newInstance(itemClass, size());\n        for (int i = 0; i < this.size(); i++) {\n            Object item = this.get(i);\n\n            T classItem;\n            if (item instanceof JSONObject) {\n                classItem = (T) objectReader.createInstance((Map) item, featuresValue);\n            } else if (item instanceof Map) {\n                classItem = (T) objectReader.createInstance((Map) item, featuresValue);\n            } else if (item == null || itemClass.isInstance(item)) {\n                classItem = (T) item;\n            } else {\n                Class<?> currentItemClass = item.getClass();\n                Function typeConvert = provider.getTypeConvert(currentItemClass, itemClass);\n                if (typeConvert != null) {\n                    Object converted = typeConvert.apply(item);\n                    list[i] = (T) converted;\n                    continue;\n                }\n\n                throw new JSONException(\n                        currentItemClass + \" cannot be converted to \" + itemClass\n                );\n            }\n            list[i] = classItem;\n        }\n\n        return list;\n    }\n\n    /**\n     * Convert all the members of this {@link JSONArray} into the specified Object.\n     *\n     * @param clazz specify the {@code Class<T>} to be converted\n     * @param features features to be enabled in parsing\n     * please use {@link #toList(Class, JSONReader.Feature...)}\n     */\n    public <T> List<T> toJavaList(Class<T> clazz, JSONReader.Feature... features) {\n        return toList(clazz, features);\n    }\n\n    /**\n     * Returns the result of the {@link Type} converter conversion of the element at the specified position in this {@link JSONArray}.\n     *\n     * <pre>{@code\n     * JSONArray array = ...\n     * User user = array.getObject(0, TypeReference<HashMap<String ,User>>(){}.getType());\n     * }</pre>\n     *\n     * @param index index of the element to return\n     * @param type specify the {@link Type} to be converted\n     * @return {@code <T>} or null\n     * @throws JSONException If no suitable conversion method is found\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public <T> T getObject(int index, Type type, JSONReader.Feature... features) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        Class<?> valueClass = value.getClass();\n        ObjectReaderProvider provider = JSONFactory.getDefaultObjectReaderProvider();\n        Function typeConvert = provider.getTypeConvert(valueClass, type);\n\n        if (typeConvert != null) {\n            return (T) typeConvert.apply(value);\n        }\n\n        boolean fieldBased = false;\n        long featuresValue = 0;\n        for (JSONReader.Feature feature : features) {\n            featuresValue |= feature.mask;\n            if (feature == JSONReader.Feature.FieldBased) {\n                fieldBased = true;\n            }\n        }\n\n        if (value instanceof Map) {\n            ObjectReader<T> objectReader = provider.getObjectReader(type, fieldBased);\n            return objectReader.createInstance((Map) value, featuresValue);\n        }\n\n        if (value instanceof Collection) {\n            ObjectReader<T> objectReader = provider.getObjectReader(type, fieldBased);\n            return objectReader.createInstance((Collection) value);\n        }\n\n        Class clazz = TypeUtils.getMapping(type);\n        if (clazz.isInstance(value)) {\n            return (T) value;\n        }\n\n        String json = JSON.toJSONString(value);\n        JSONReader jsonReader = JSONReader.of(json);\n        jsonReader.context.config(features);\n\n        ObjectReader objectReader = provider.getObjectReader(clazz, fieldBased);\n        return (T) objectReader.readObject(jsonReader, null, null, 0);\n    }\n\n    /**\n     * Returns the result of the {@link Type} converter conversion of the element at the specified position in this {@link JSONArray}.\n     * <p>\n     * {@code User user = jsonArray.getObject(0, User.class);}\n     *\n     * @param index index of the element to return\n     * @param type specify the {@link Class} to be converted\n     * @return {@code <T>} or null\n     * @throws JSONException If no suitable conversion method is found\n     * @throws IndexOutOfBoundsException if the index is out of range {@code (index < 0 || index >= size())}\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public <T> T getObject(int index, Class<T> type, JSONReader.Feature... features) {\n        Object value = get(index);\n\n        if (value == null) {\n            return null;\n        }\n\n        Class<?> valueClass = value.getClass();\n        ObjectReaderProvider provider = JSONFactory.getDefaultObjectReaderProvider();\n        Function typeConvert = provider.getTypeConvert(valueClass, type);\n\n        if (typeConvert != null) {\n            return (T) typeConvert.apply(value);\n        }\n\n        boolean fieldBased = false;\n        long featuresValue = 0;\n        for (JSONReader.Feature feature : features) {\n            featuresValue |= feature.mask;\n            if (feature == JSONReader.Feature.FieldBased) {\n                fieldBased = true;\n            }\n        }\n\n        if (value instanceof Map) {\n            ObjectReader<T> objectReader = provider.getObjectReader(type, fieldBased);\n            return objectReader.createInstance((Map) value, featuresValue);\n        }\n\n        if (value instanceof Collection) {\n            ObjectReader<T> objectReader = provider.getObjectReader(type, fieldBased);\n            return objectReader.createInstance((Collection) value);\n        }\n\n        Class clazz = TypeUtils.getMapping(type);\n        if (clazz.isInstance(value)) {\n            return (T) value;\n        }\n\n        ObjectReader objectReader = null;\n\n        if (value instanceof String) {\n            String str = (String) value;\n            if (str.isEmpty() || \"null\".equals(str)) {\n                return null;\n            }\n\n            if (clazz.isEnum()) {\n                objectReader = provider.getObjectReader(clazz, fieldBased);\n                if (objectReader instanceof ObjectReaderImplEnum) {\n                    long hashCode64 = Fnv.hashCode64(str);\n                    ObjectReaderImplEnum enumReader = (ObjectReaderImplEnum) objectReader;\n                    return (T) enumReader.getEnumByHashCode(hashCode64);\n                }\n            }\n        }\n\n        String json = JSON.toJSONString(value);\n        JSONReader jsonReader = JSONReader.of(json);\n        jsonReader.context.config(features);\n\n        if (objectReader == null) {\n            objectReader = provider.getObjectReader(clazz, fieldBased);\n        }\n\n        T object = (T) objectReader.readObject(jsonReader, null, null, 0L);\n        if (!jsonReader.isEnd()) {\n            throw new JSONException(\"not support input \" + json);\n        }\n        return object;\n    }\n\n    /**\n     * @since 2.0.3\n     */\n    public <T> T getObject(int index, Function<JSONObject, T> creator) {\n        JSONObject object = getJSONObject(index);\n\n        if (object == null) {\n            return null;\n        }\n\n        return creator.apply(object);\n    }\n\n    /**\n     * Chained addition of elements\n     *\n     * <pre>\n     * JSONArray array = new JSONArray().fluentAdd(1).fluentAdd(2).fluentAdd(3);\n     * </pre>\n     *\n     * @param element element to be appended to this list\n     */\n    public JSONArray fluentAdd(Object element) {\n        add(element);\n        return this;\n    }\n\n    /**\n     * @since 2.0.3\n     */\n    public JSONArray fluentClear() {\n        clear();\n        return this;\n    }\n\n    /**\n     * @since 2.0.3\n     */\n    public JSONArray fluentRemove(int index) {\n        remove(index);\n        return this;\n    }\n\n    /**\n     * @since 2.0.3\n     */\n    public JSONArray fluentSet(int index, Object element) {\n        set(index, element);\n        return this;\n    }\n\n    /**\n     * @since 2.0.3\n     */\n    public JSONArray fluentRemove(Object o) {\n        remove(o);\n        return this;\n    }\n\n    /**\n     * @since 2.0.3\n     */\n    public JSONArray fluentRemoveAll(Collection<?> c) {\n        removeAll(c);\n        return this;\n    }\n\n    /**\n     * @since 2.0.3\n     */\n    public JSONArray fluentAddAll(Collection<?> c) {\n        addAll(c);\n        return this;\n    }\n\n    /**\n     * @since 2.0.3\n     */\n    public boolean isValid(JSONSchema schema) {\n        return schema\n                .validate(this)\n                .isSuccess();\n    }\n\n    @Override\n    public Object clone() {\n        return new JSONArray(this);\n    }\n\n    /**\n     * Pack multiple elements as {@link JSONArray}\n     *\n     * <pre>\n     * JSONArray array = JSONArray.of(1, 2, \"3\", 4F, 5L, 6D, true);\n     * </pre>\n     *\n     * @param items element set\n     */\n    public static JSONArray of(Object... items) {\n        return new JSONArray(items);\n    }\n\n    /**\n     * Pack an element as {@link JSONArray}\n     *\n     * <pre>\n     * JSONArray array = JSONArray.of(\"fastjson\");\n     * </pre>\n     *\n     * @param item target element\n     */\n    public static JSONArray of(Object item) {\n        JSONArray array = new JSONArray(1);\n        array.add(item);\n        return array;\n    }\n\n    /**\n     * Pack two elements as {@link JSONArray}\n     *\n     * <pre>\n     * JSONArray array = JSONArray.of(\"fastjson\", 2);\n     * </pre>\n     *\n     * @param first first element\n     * @param second second element\n     */\n    public static JSONArray of(Object first, Object second) {\n        JSONArray array = new JSONArray(2);\n        array.add(first);\n        array.add(second);\n        return array;\n    }\n\n    /**\n     * Pack three elements as {@link JSONArray}\n     *\n     * <pre>\n     * JSONArray array = JSONArray.of(\"fastjson\", 2, true);\n     * </pre>\n     *\n     * @param first first element\n     * @param second second element\n     * @param third third element\n     */\n    public static JSONArray of(Object first, Object second, Object third) {\n        JSONArray array = new JSONArray(3);\n        array.add(first);\n        array.add(second);\n        array.add(third);\n        return array;\n    }\n\n    /**\n     * Parse JSON {@link String} into {@link JSONArray}\n     *\n     * @param text the JSON {@link String} to be parsed\n     * @param features features to be enabled in parsing\n     */\n    public static JSONArray parseArray(String text, JSONReader.Feature... features) {\n        return JSON.parseArray(text, features);\n    }\n\n    /**\n     * Parse JSON {@link String} into {@link JSONArray}\n     *\n     * @param text the JSON {@link String} to be parsed\n     * @param features features to be enabled in parsing\n     * @since 2.0.13\n     */\n    public static JSONArray parse(String text, JSONReader.Feature... features) {\n        return JSON.parseArray(text, features);\n    }\n}\n",
            "file_name": "JSONArray.java",
            "human_label": "Converts the content in JSONWriter to a string.",
            "level": "self_contained",
            "lineno": "892",
            "name": "toString",
            "oracle_context": "{ \"apis\" : \"[of, write, setRootObject, getObjectWriter, JSONArray]\", \"classes\" : \"[JSONWriter, writer.context]\", \"vars\" : \"[Feature, context, arrayWriter]\" }",
            "package": "com.alibaba.fastjson2",
            "project": "fastjson2-main"
        },
        {
            "_id": "636767021a6d9265ec0178bf",
            "all_context": "{ \"class_level\" : \"import net.hasor.utils.BeanUtils;\\nimport net.hasor.utils.convert.Converter;\\nCharacterConverter();\\nCharacterConverter(Object defaultValue);\\ngetDefaultType();\\nconvertToType(Class type,Object value);\\nconvertToString(Object value);\\n\", \"repo_level\" : \"public interface BeanUtils {static Object getDefaultValue(Class returnType);\\nstatic Object[] getDefaultValue(Class<?>[] paramArray);\\nstatic Object invokeMethod(Object target,String methodName,Object objects);\\nstatic List<Field> findALLFields(Class target);\\nstatic List<Method> findALLMethods(Class target);\\nstatic List<Field> getFields(Class type);\\nstatic List<Method> getMethods(Class type);\\nstatic Field getField(String fieldName,Class type);\\nstatic Method getMethod(Class atClass,String name,Class<?>[] paramType);\\nstatic List<String> getPropertiesAndFields(Class target);\\nstatic List<String> getProperties(Class target);\\nstatic PropertyDescriptor[] getPropertyDescriptors(Class defineType);\\nstatic Method getReadMethod(String property,Class target);\\nstatic Method getWriteMethod(String property,Class target);\\nstatic boolean hasProperty(String propertyName,Class target);\\nstatic boolean hasField(String propertyName,Class target);\\nstatic boolean hasPropertyOrField(String name,Class target);\\nstatic boolean canReadProperty(String propertyName,Class target);\\nstatic boolean canReadPropertyOrField(String propertyName,Class target);\\nstatic boolean canWriteProperty(String propertyName,Class target);\\nstatic boolean canWriteField(String propertyName,Class target);\\nstatic boolean canWritePropertyOrField(String propertyName,Class target);\\nstatic boolean writeProperty(Object object,String attName,Object value);\\nstatic boolean writeField(Object object,String fieldName,Object value);\\nstatic boolean writePropertyOrField(Object object,String attName,Object value);\\nstatic Object readProperty(Object object,String attName);\\nstatic Object readField(Object object,String fieldName);\\nstatic Object readPropertyOrField(Object object,String attName);\\nstatic Class<?> getPropertyType(Class defineType,String attName);\\nstatic Class<?> getFieldType(Class defineType,String attName);\\nstatic Class<?> getPropertyOrFieldType(Class defineType,String attName);\\nstatic void copyProperties(Object dest,Object orig);\\nstatic void copyProperty(Object dest,Object orig,String propertyName);\\n }\\npublic interface Converter {public Object convert(Class type,Object value);\\n }\\n\" }",
            "class_name": "CharacterConverter",
            "code": "@Override protected Object convertToType(final Class<?> type,final Object value) throws Exception {\n  String string=value.toString();\n  if (string.length() == 0) {\n    return BeanUtils.getDefaultValue(type);\n  }\n else {\n    return string.charAt(0);\n  }\n}\n",
            "docstring": "/** \n * <p>Convert the input object into a java.lang.Character.</p>\n * @param type Data type to which this value should be converted.\n * @param value The input value to be converted.\n * @return The converted value.\n * @throws Exception if conversion cannot be performed successfully\n * @since 1.8.0\n */\n",
            "end_lineno": "94",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.convert.convert;\nimport net.hasor.utils.BeanUtils;\nimport net.hasor.utils.convert.Converter;\n\n/**\n * {@link Converter} implementaion that handles conversion\n * to and from <b>java.lang.Character</b> objects.\n * <p>\n * Can be configured to either return a <i>default value</i> or throw a\n * <code>ConversionException</code> if a conversion error occurs.\n *\n * @author Craig R. McClanahan\n * @version $Revision: 690380 $ $Date: 2008-08-29 21:04:38 +0100 (Fri, 29 Aug 2008) $\n * @since 1.3\n */\npublic final class CharacterConverter extends AbstractConverter {\n    /**\n     * Construct a <b>java.lang.Character</b> <i>Converter</i> that throws\n     * a <code>ConversionException</code> if an error occurs.\n     */\n    public CharacterConverter() {\n        super();\n    }\n\n    /**\n     * Construct a <b>java.lang.Character</b> <i>Converter</i> that returns\n     * a default value if an error occurs.\n     *\n     * @param defaultValue The default value to be returned\n     * if the value to be converted is missing or an error\n     * occurs converting the value.\n     */\n    public CharacterConverter(final Object defaultValue) {\n        super(defaultValue);\n    }\n\n    /**\n     * Return the default type this <code>Converter</code> handles.\n     *\n     * @return The default type this <code>Converter</code> handles.\n     * @since 1.8.0\n     */\n    @Override\n    protected Class<?> getDefaultType() {\n        return Character.class;\n    }\n\n    /**\n     * <p>Convert a java.lang.Class or object into a String.</p>\n     *\n     * @param value The input value to be converted\n     * @return the converted String value.\n     * @since 1.8.0\n     */\n    @Override\n    protected String convertToString(final Object value) {\n        String strValue = value.toString();\n        return strValue.length() == 0 ? \"\" : strValue.substring(0, 1);\n    }\n\n    /**\n     * <p>Convert the input object into a java.lang.Character.</p>\n     *\n     * @param type Data type to which this value should be converted.\n     * @param value The input value to be converted.\n     * @return The converted value.\n     * @throws Exception if conversion cannot be performed successfully\n     * @since 1.8.0\n     */\n    @Override\n    protected Object convertToType(final Class<?> type, final Object value) throws Exception {\n        String string = value.toString();\n        if (string.length() == 0) {\n            return BeanUtils.getDefaultValue(type);\n        } else {\n            return string.charAt(0);\n        }\n    }\n}\n",
            "file_name": "CharacterConverter.java",
            "human_label": "If the length of the value string is 0, the default type is returned. Otherwise, the element at the first position of the string is returned.",
            "level": "project_runnable",
            "lineno": "77",
            "name": "convertToType",
            "oracle_context": "{ \"apis\" : \"[toString, length, getDefaultValue, charAt]\", \"classes\" : \"[String]\", \"vars\" : \"[]\" }",
            "package": "net.hasor.utils.convert.convert",
            "project": "hasor-master"
        },
        {
            "_id": "6367670b1a6d9265ec017a0f",
            "all_context": "{ \"class_level\" : \"import net.hasor.core.Singleton;\\nimport net.hasor.dataql.UdfSourceAssembly;\\nimport net.hasor.utils.StringUtils;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nPattern linePattern;\\nPattern humpPattern;\\nstartsWithIgnoreCase(String str,String prefix);\\nendsWith(String str,String suffix);\\nendsWithIgnoreCase(String str,String suffix);\\n_startsWith(String str,String prefix,boolean ignoreCase);\\n_endsWith(String str,String suffix,boolean ignoreCase);\\nlineToHump(String str);\\nhumpToLine(String str);\\nfirstCharToUpperCase(String value);\\nfirstCharToLowerCase(String value);\\ntoUpperCase(String value);\\ntoLowerCase(String value);\\nindexOf(String str,String searchStr);\\nindexOfWithStart(String str,String searchStr,int startPos);\\nindexOfIgnoreCase(String str,String searchStr);\\nindexOfIgnoreCaseWithStart(String str,String searchStr,int startPos);\\nlastIndexOf(String str,String searchStr);\\nlastIndexOfWithStart(String str,String searchChar,int startPos);\\nlastIndexOfIgnoreCase(String str,String searchStr);\\nlastIndexOfIgnoreCaseWithStart(String str,String searchStr,int startPos);\\ncontains(String str,String searchStr);\\ncontainsIgnoreCase(String str,String searchStr);\\ncontainsAny(String str,List searchStrArray);\\ncontainsAnyIgnoreCase(String str,List searchStrArray);\\ntrim(String str);\\nsub(String str,int start,int end);\\nleft(String str,int len);\\nright(String str,int len);\\nalignRight(String str,String padChar,int len);\\nalignLeft(String str,String padChar,int len);\\nalignCenter(String str,String padChar,int len);\\ncompareString(String str1,String str2);\\ncompareStringIgnoreCase(String str1,String str2);\\nsplit(String str,String separatorChars);\\njoin(List array,String separator);\\nisEmpty(String str);\\nequalsIgnoreCase(String str1,String str2);\\nstartsWith(String str,String prefix);\\n\", \"repo_level\" : \"public interface UdfSourceAssembly {default Supplier<?> getSupplier(Class targetType,Finder finder);\\ndefault Predicate<Method> getPredicate(Class targetType);\\npublic Object[] allParams();\\ndefault Supplier<Map<String,Udf>> getUdfResource(Finder finder);\\npublic Class<? extends Annotation> annotationType();\\npublic String value();\\npublic Object call(Hints readOnly,Object values);\\npublic Object call(Hints readOnly,Object values);\\n }\\npublic interface StringUtils {static boolean isEmpty(String str);\\nstatic boolean isNotEmpty(String str);\\nstatic boolean isBlank(String str);\\nstatic boolean isNotBlank(String str);\\nstatic String trim(String str);\\nstatic String trimToNull(String str);\\nstatic String trimToEmpty(String str);\\nstatic String strip(String str);\\nstatic String stripToNull(String str);\\nstatic String stripToEmpty(String str);\\nstatic String strip(String str,String stripChars);\\nstatic String stripStart(String str,String stripChars);\\nstatic String stripEnd(String str,String stripChars);\\nstatic String[] stripAll(String[] strs);\\nstatic String[] stripAll(String[] strs,String stripChars);\\nstatic boolean equals(String str1,String str2);\\nstatic boolean equalsIgnoreCase(String str1,String str2);\\nstatic int indexOf(String str,char searchChar);\\nstatic int indexOf(String str,char searchChar,int startPos);\\nstatic int indexOf(String str,String searchStr);\\nstatic int ordinalIndexOf(String str,String searchStr,int ordinal);\\nstatic int indexOf(String str,String searchStr,int startPos);\\nstatic int indexOfIgnoreCase(String str,String searchStr);\\nstatic int indexOfIgnoreCase(String str,String searchStr,int startPos);\\nstatic int lastIndexOf(String str,char searchChar);\\nstatic int lastIndexOf(String str,char searchChar,int startPos);\\nstatic int lastIndexOf(String str,String searchStr);\\nstatic int lastOrdinalIndexOf(String str,String searchStr,int ordinal);\\nstatic int lastIndexOf(String str,String searchStr,int startPos);\\nstatic int lastIndexOfIgnoreCase(String str,String searchStr);\\nstatic int lastIndexOfIgnoreCase(String str,String searchStr,int startPos);\\nstatic boolean contains(String str,char searchChar);\\nstatic boolean contains(String str,String searchStr);\\nstatic boolean containsIgnoreCase(String str,String searchStr);\\nstatic int indexOfAny(String str,char[] searchChars);\\nstatic int indexOfAny(String str,String searchChars);\\nstatic boolean containsAny(String str,char[] searchChars);\\nstatic boolean containsAny(String str,String searchChars);\\nstatic int indexOfAnyBut(String str,char[] searchChars);\\nstatic int indexOfAnyBut(String str,String searchChars);\\nstatic boolean containsOnly(String str,char[] valid);\\nstatic boolean containsOnly(String str,String validChars);\\nstatic boolean containsNone(String str,char[] searchChars);\\nstatic boolean containsNone(String str,String invalidChars);\\nstatic int indexOfAny(String str,String[] searchStrs);\\nstatic int lastIndexOfAny(String str,String[] searchStrs);\\nstatic String substring(String str,int start);\\nstatic String substring(String str,int start,int end);\\nstatic String left(String str,int len);\\nstatic String right(String str,int len);\\nstatic String mid(String str,int pos,int len);\\nstatic String substringBefore(String str,String separator);\\nstatic String substringAfter(String str,String separator);\\nstatic String substringBeforeLast(String str,String separator);\\nstatic String substringAfterLast(String str,String separator);\\nstatic String substringBetween(String str,String tag);\\nstatic String substringBetween(String str,String open,String close);\\nstatic String[] substringsBetween(String str,String open,String close);\\nstatic String[] splitKeep(String str,char separatorChar);\\nstatic String[] splitKeep(String str,String separatorStr);\\nstatic String[] split(String str);\\nstatic String[] split(String str,char separatorChar);\\nstatic String[] split(String str,String separatorChars);\\nstatic String[] split(String str,String separatorChars,int max);\\nstatic String[] splitByWholeSeparator(String str,String separator);\\nstatic String[] splitByWholeSeparator(String str,String separator,int max);\\nstatic String[] splitByWholeSeparatorPreserveAllTokens(String str,String separator);\\nstatic String[] splitByWholeSeparatorPreserveAllTokens(String str,String separator,int max);\\nstatic String[] splitPreserveAllTokens(String str);\\nstatic String[] splitPreserveAllTokens(String str,char separatorChar);\\nstatic String[] splitPreserveAllTokens(String str,String separatorChars);\\nstatic String[] splitPreserveAllTokens(String str,String separatorChars,int max);\\nstatic String[] splitByCharacterType(String str);\\nstatic String[] splitByCharacterTypeCamelCase(String str);\\nstatic String join(Object[] array);\\nstatic String join(Object[] array,char separator);\\nstatic String join(Object[] array,char separator,int startIndex,int endIndex);\\nstatic String join(Object[] array,String separator);\\nstatic String join(Object[] array,String separator,int startIndex,int endIndex);\\nstatic String deleteWhitespace(String str);\\nstatic String removeStart(String str,String remove);\\nstatic String removeStartIgnoreCase(String str,String remove);\\nstatic String removeEnd(String str,String remove);\\nstatic String removeEndIgnoreCase(String str,String remove);\\nstatic String remove(String str,String remove);\\nstatic String remove(String str,char remove);\\nstatic String replaceOnce(String text,String searchString,String replacement);\\nstatic String replace(String text,String searchString,String replacement);\\nstatic String replace(String text,String searchString,String replacement,int max);\\nstatic String replaceEach(String text,String[] searchList,String[] replacementList);\\nstatic String replaceEachRepeatedly(String text,String[] searchList,String[] replacementList);\\nstatic String replaceChars(String str,char searchChar,char replaceChar);\\nstatic String replaceChars(String str,String searchChars,String replaceChars);\\nstatic String overlay(String str,String overlay,int start,int end);\\nstatic String chomp(String str);\\nstatic String chomp(String str,String separator);\\nstatic String chop(String str);\\nstatic String repeat(char character,int repeat);\\nstatic String repeat(String str,int repeat);\\nstatic String repeat(String str,String separator,int repeat);\\nstatic String rightPad(String str,int size);\\nstatic String rightPad(String str,int size,char padChar);\\nstatic String rightPad(String str,int size,String padStr);\\nstatic String leftPad(String str,int size);\\nstatic String leftPad(String str,int size,char padChar);\\nstatic String leftPad(String str,int size,String padStr);\\nstatic int length(String str);\\nstatic String center(String str,int size);\\nstatic String center(String str,int size,char padChar);\\nstatic String center(String str,int size,String padStr);\\nstatic String upperCase(String str);\\nstatic String upperCase(String str,Locale locale);\\nstatic String lowerCase(String str);\\nstatic String lowerCase(String str,Locale locale);\\nstatic String capitalize(String str);\\nstatic String uncapitalize(String str);\\nstatic String swapCase(String str);\\nstatic int countMatches(String str,String sub);\\nstatic boolean isAlpha(String str);\\nstatic boolean isAlphaSpace(String str);\\nstatic boolean isAlphanumeric(String str);\\nstatic boolean isAlphanumericSpace(String str);\\nstatic boolean isAsciiPrintable(String str);\\nstatic boolean isNumeric(String str);\\nstatic boolean isNumericSpace(String str);\\nstatic boolean isWhitespace(String str);\\nstatic boolean isAllLowerCase(String str);\\nstatic boolean isAllUpperCase(String str);\\nstatic String defaultString(String str);\\nstatic String defaultString(String str,String defaultStr);\\nstatic String defaultIfBlank(String str,String defaultStr);\\nstatic String defaultIfEmpty(String str,String defaultStr);\\nstatic String reverse(String str);\\nstatic String reverseDelimited(String str,char separatorChar);\\nstatic String abbreviate(String str,int maxWidth);\\nstatic String abbreviate(String str,int offset,int maxWidth);\\nstatic String abbreviateMiddle(String str,String middle,int length);\\nstatic String difference(String str1,String str2);\\nstatic int indexOfDifference(String str1,String str2);\\nstatic int indexOfDifference(String[] strs);\\nstatic String getCommonPrefix(String[] strs);\\nstatic int getLevenshteinDistance(String s,String t);\\nstatic boolean startsWith(String str,String prefix);\\nstatic boolean startsWithIgnoreCase(String str,String prefix);\\nstatic boolean startsWithAny(String string,String[] searchStrings);\\nstatic boolean endsWith(String str,String suffix);\\nstatic boolean endsWithIgnoreCase(String str,String suffix);\\nstatic String normalizeSpace(String str);\\nstatic boolean endsWithAny(String string,String[] searchStrings);\\nstatic String firstCharToUpperCase(String value);\\nstatic String firstCharToLowerCase(String value);\\nstatic boolean equalsBlankIgnoreCase(String str1,String str2);\\nstatic String quote(String input);\\nstatic void quote(Appendable buffer,String input);\\nstatic String toString(Object object);\\n }\\n\" }",
            "class_name": "StringUdfSource",
            "code": "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n  if (StringUtils.isEmpty(str) || searchStrArray == null || searchStrArray.isEmpty()) {\n    return false;\n  }\n  for (  String item : searchStrArray) {\n    if (containsIgnoreCase(str,item)) {\n      return true;\n    }\n  }\n  return false;\n}\n",
            "docstring": "/** \n * Case in-sensitive Checks if the String contains any character in the given set of string. \n */\n",
            "end_lineno": "222",
            "file_content": "/*\n * Copyright 2008-2009 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.dataql.fx.basic;\nimport net.hasor.core.Singleton;\nimport net.hasor.dataql.UdfSourceAssembly;\nimport net.hasor.utils.StringUtils;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n *  <code>import 'net.hasor.dataql.fx.basic.StringUdfSource' as string;</code>\n * @version : 2019-12-12\n */\n@Singleton\npublic class StringUdfSource implements UdfSourceAssembly {\n    // startsWith/endsWith\n    //-----------------------------------------------------------------------\n\n    /** Check if a String starts with a specified prefix. */\n    public static boolean startsWith(String str, String prefix) {\n        return _startsWith(str, prefix, false);\n    }\n\n    /** Case insensitive check if a String starts with a specified prefix. */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        return _startsWith(str, prefix, true);\n    }\n\n    /** Case insensitive check if a String ends with a specified suffix. */\n    public static boolean endsWith(String str, String suffix) {\n        return _endsWith(str, suffix, false);\n    }\n\n    /** Case insensitive check if a String ends with a specified suffix. */\n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        return _endsWith(str, suffix, true);\n    }\n\n    private static boolean _startsWith(String str, String prefix, boolean ignoreCase) {\n        if (str == null || prefix == null) {\n            return str == null && prefix == null;\n        }\n        if (prefix.length() > str.length()) {\n            return false;\n        }\n        return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n    }\n\n    private static boolean _endsWith(String str, String suffix, boolean ignoreCase) {\n        if (str == null || suffix == null) {\n            return str == null && suffix == null;\n        }\n        if (suffix.length() > str.length()) {\n            return false;\n        }\n        int strOffset = str.length() - suffix.length();\n        return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n    }\n\n    // Hump\n    //-----------------------------------------------------------------------\n    private static final Pattern linePattern = Pattern.compile(\"_(\\\\w)\");\n    private static final Pattern humpPattern = Pattern.compile(\"[A-Z]\");\n\n    /**  */\n    public static String lineToHump(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = str.toLowerCase();\n        Matcher matcher = linePattern.matcher(str);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            matcher.appendReplacement(sb, matcher.group(1).toUpperCase());\n        }\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n\n    /**  */\n    public static String humpToLine(String str) {\n        if (str == null) {\n            return null;\n        }\n        Matcher matcher = humpPattern.matcher(str);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            matcher.appendReplacement(sb, \"_\" + matcher.group(0).toLowerCase());\n        }\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n    // UpperCase/LowerCase\n    //-----------------------------------------------------------------------\n\n    /**  */\n    public static String firstCharToUpperCase(String value) {\n        return StringUtils.firstCharToUpperCase(value);\n    }\n\n    /**  */\n    public static String firstCharToLowerCase(String value) {\n        return StringUtils.firstCharToLowerCase(value);\n    }\n\n    /**  */\n    public static String toUpperCase(String value) {\n        return StringUtils.upperCase(value);\n    }\n\n    /**  */\n    public static String toLowerCase(String value) {\n        return StringUtils.lowerCase(value);\n    }\n    // IndexOf/lastIndexOf\n    //-----------------------------------------------------------------------\n\n    /** Finds the first index within a String, handling <code>null</code>. This method uses {@link String#indexOf(String)}. */\n    public static int indexOf(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchStr);\n    }\n\n    /** Finds the first index within a String from a start position, handling <code>null</code>. This method uses {@link String#indexOf(String, int)}. */\n    public static int indexOfWithStart(String str, String searchStr, int startPos) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchStr, startPos);\n    }\n\n    /** Case in-sensitive find of the first index within a String. */\n    public static int indexOfIgnoreCase(String str, String searchStr) {\n        return StringUtils.indexOfIgnoreCase(str, searchStr, 0);\n    }\n\n    /** Case in-sensitive find of the first index within a String from the specified position. */\n    public static int indexOfIgnoreCaseWithStart(String str, String searchStr, int startPos) {\n        return StringUtils.indexOfIgnoreCase(str, searchStr, startPos);\n    }\n\n    /** Finds the last index within a String, handling <code>null</code>. This method uses {@link String#lastIndexOf(String)}. */\n    public static int lastIndexOf(String str, String searchStr) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchStr);\n    }\n\n    /** Finds the last index within a String from a start position, handling <code>null</code>. This method uses {@link String#lastIndexOf(String, int)}. */\n    public static int lastIndexOfWithStart(String str, String searchChar, int startPos) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchChar, startPos);\n    }\n\n    /** Case in-sensitive find of the last index within a String from the specified position. */\n    public static int lastIndexOfIgnoreCase(String str, String searchStr) {\n        return StringUtils.lastIndexOfIgnoreCase(str, searchStr, 0);\n    }\n\n    /** Case in-sensitive find of the last index within a String from the specified position. */\n    public static int lastIndexOfIgnoreCaseWithStart(String str, String searchStr, int startPos) {\n        return StringUtils.lastIndexOfIgnoreCase(str, searchStr, startPos);\n    }\n    // Contains\n    //-----------------------------------------------------------------------\n\n    /** Checks if String contains a search String, handling <code>null</code>. This method uses {@link String#indexOf(String)}. */\n    public static boolean contains(String str, String searchStr) {\n        return StringUtils.contains(str, searchStr);\n    }\n\n    /** Checks if String contains a search String irrespective of case, handling <code>null</code>. Case-insensitivity is defined as by {@link String#equalsIgnoreCase(String)}. */\n    public static boolean containsIgnoreCase(String str, String searchStr) {\n        return StringUtils.containsIgnoreCase(str, searchStr);\n    }\n\n    /** Checks if the String contains any character in the given set of string. */\n    public static boolean containsAny(String str, List<String> searchStrArray) {\n        if (StringUtils.isEmpty(str) || searchStrArray == null || searchStrArray.isEmpty()) {\n            return false;\n        }\n        for (String item : searchStrArray) {\n            if (contains(str, item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /** Case in-sensitive Checks if the String contains any character in the given set of string. */\n    public static boolean containsAnyIgnoreCase(String str, List<String> searchStrArray) {\n        if (StringUtils.isEmpty(str) || searchStrArray == null || searchStrArray.isEmpty()) {\n            return false;\n        }\n        for (String item : searchStrArray) {\n            if (containsIgnoreCase(str, item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // trim/Sub/left/right\n    //-----------------------------------------------------------------------\n\n    /**  */\n    public static String trim(final String str) {\n        return str == null ? null : str.trim();\n    }\n\n    /** Gets a substring from the specified String avoiding exceptions. */\n    public static String sub(String str, int start, int end) {\n        return StringUtils.substring(str, start, end);\n    }\n\n    /** Gets the leftmost <code>len</code> characters of a String. */\n    public static String left(String str, int len) {\n        return StringUtils.left(str, len);\n    }\n\n    /** Gets the rightmost <code>len</code> characters of a String. */\n    public static String right(String str, int len) {\n        return StringUtils.right(str, len);\n    }\n    // align/pading\n    //-----------------------------------------------------------------------\n\n    /** padChar */\n    public static String alignRight(String str, String padChar, int len) {\n        if (str != null) {\n            if (str.length() > len) {\n                return str;\n            }\n        }\n        char pad = padChar.length() == 0 ? ' ' : padChar.charAt(0);\n        return StringUtils.rightPad(str, len, pad);\n    }\n\n    /** padChar */\n    public static String alignLeft(String str, String padChar, int len) {\n        if (str != null) {\n            if (str.length() > len) {\n                return str;\n            }\n        }\n        char pad = padChar.length() == 0 ? ' ' : padChar.charAt(0);\n        return StringUtils.leftPad(str, len, pad);\n    }\n\n    /** padChar */\n    public static String alignCenter(String str, String padChar, int len) {\n        if (str != null) {\n            if (str.length() > len) {\n                return str;\n            }\n        }\n        char pad = padChar.length() == 0 ? ' ' : padChar.charAt(0);\n        return StringUtils.center(str, len, pad);\n    }\n    // compare\n    //-----------------------------------------------------------------------\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * <p>\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let <i>k</i> be the smallest such index; then the string\n     * whose character at position <i>k</i> has the smaller value, as\n     * determined by using the &lt; operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * <blockquote><pre>\n     * this.charAt(k)-anotherString.charAt(k)\n     * </pre></blockquote>\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * <blockquote><pre>\n     * this.length()-anotherString.length()\n     * </pre></blockquote>\n     *\n     * @param   str1   the {@code String} to be compared.\n     * @param   str2   the {@code String} to be compared.\n     * @return the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public static int compareString(String str1, String str2) {\n        str1 = str1 == null ? \"\" : str1;\n        str2 = str2 == null ? \"\" : str2;\n        return str1.compareTo(str2);\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with normalized versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(character))} on\n     * each character.\n     * <p>\n     * Note that this method does <em>not</em> take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The java.text package provides <em>collators</em> to allow\n     * locale-sensitive ordering.\n     *\n     * @param   str1   the {@code String} to be compared.\n     * @param   str2   the {@code String} to be compared.\n     * @return a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator#compare(String, String)\n     * @since 1.2\n     */\n    public static int compareStringIgnoreCase(String str1, String str2) {\n        str1 = str1 == null ? \"\" : str1;\n        str2 = str2 == null ? \"\" : str2;\n        return str1.compareToIgnoreCase(str2);\n    }\n    // other\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Splits the provided text into an array, separators specified.\n     * This is an alternative to using StringTokenizer.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as one separator.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separatorChars splits on whitespace.</p>\n     *\n     * <pre>\n     * StringUtils.split(null, *)         = null\n     * StringUtils.split(\"\", *)           = []\n     * StringUtils.split(\"abc def\", null) = [\"abc\", \"def\"]\n     * StringUtils.split(\"abc def\", \" \")  = [\"abc\", \"def\"]\n     * StringUtils.split(\"abc  def\", \" \") = [\"abc\", \"def\"]\n     * StringUtils.split(\"ab:cd:ef\", \":\") = [\"ab\", \"cd\", \"ef\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separatorChars  the characters used as the delimiters, <code>null</code> splits on whitespace\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    public static List<String> split(String str, String separatorChars) {\n        return Arrays.asList(StringUtils.split(str, separatorChars));\n    }\n\n    /** Joins the elements of the provided array into a single String containing the provided list of elements. */\n    public static String join(List<Object> array, String separator) {\n        if (array == null) {\n            return null;\n        }\n        return StringUtils.join(array.toArray(), separator);\n    }\n\n    /** Checks if a String is empty (\"\") or null.*/\n    public static boolean isEmpty(String str) {\n        return str == null || str.length() == 0;\n    }\n\n    /**  */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n}\n",
            "file_name": "StringUdfSource.java",
            "human_label": "Check whether str contains elements in searchStrArray. If yes, true is returned. If no, false is returned.",
            "level": "project_runnable",
            "lineno": "211",
            "name": "containsAnyIgnoreCase",
            "oracle_context": "{ \"apis\" : \"[isEmpty, containsIgnoreCase]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
            "package": "net.hasor.dataql.fx.basic",
            "project": "hasor-master"
        },
        {
            "_id": "6367676b1a6d9265ec0181e2",
            "all_context": "{ \"class_level\" : \"import java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nimport java.util.Enumeration;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Properties;\\nEnumeration<E> enumeration;\\nCollections();\\nsize(Collection collection);\\nsize(Map map);\\nisEmpty(Map map);\\narrayToList(Object source);\\nmergeArrayIntoCollection(Object array,Collection collection);\\nmergePropertiesIntoMap(Properties props,Map map);\\ncontains(Iterator iterator,Object element);\\ncontains(Enumeration enumeration,Object element);\\ncontainsInstance(Collection collection,Object element);\\ncontainsAny(Collection source,Collection candidates);\\nfindFirstMatch(Collection source,Collection candidates);\\nfindValueOfType(Collection collection,Class type);\\nfindValueOfType(Collection collection,Class<?>[] types);\\nhasUniqueObject(Collection collection);\\nfindCommonElementType(Collection collection);\\ntoArray(Enumeration enumeration,A[] array);\\ntoIterator(Enumeration enumeration);\\nEnumerationIterator(Enumeration enumeration);\\nhasNext();\\nnext();\\nremove();\\nisEmpty(Collection collection);\\n\", \"repo_level\" : \"\" }",
            "class_name": "Collections",
            "code": "public static Object findFirstMatch(Collection source,Collection candidates){\n  if (isEmpty(source) || isEmpty(candidates)) {\n    return null;\n  }\n  for (  Object candidate : candidates) {\n    if (source.contains(candidate)) {\n      return candidate;\n    }\n  }\n  return null;\n}\n",
            "docstring": "/** \n * Return the first element in '<code>candidates</code>' that is contained in '<code>source</code>'. If no element in '<code>candidates</code>' is present in '<code>source</code>' returns <code>null</code>. Iteration order is {@link Collection} implementation specific.\n * @param source the source Collection\n * @param candidates the candidates to search for\n * @return the first present object, or <code>null</code> if not found\n */\n",
            "end_lineno": "222",
            "file_content": "/*\n * Copyright (C) 2014 jsonwebtoken.io\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.jsonwebtoken.lang;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\npublic final class Collections {\n\n    private Collections(){} //prevent instantiation\n\n    /**\n     * Return <code>true</code> if the supplied Collection is <code>null</code>\n     * or empty. Otherwise, return <code>false</code>.\n     * @param collection the Collection to check\n     * @return whether the given Collection is empty\n     */\n    public static boolean isEmpty(Collection collection) {\n        return (collection == null || collection.isEmpty());\n    }\n\n    /**\n     * Returns the collection's size or {@code 0} if the collection is {@code null}.\n     *\n     * @param collection the collection to check.\n     * @return the collection's size or {@code 0} if the collection is {@code null}.\n     * @since 0.9.2\n     */\n    public static int size(Collection collection) {\n        return collection == null ? 0 : collection.size();\n    }\n\n    /**\n     * Returns the map's size or {@code 0} if the map is {@code null}.\n     *\n     * @param map the map to check\n     * @return the map's size or {@code 0} if the map is {@code null}.\n     * @since 0.9.2\n     */\n    public static int size(Map map) {\n        return map == null ? 0 : map.size();\n    }\n\n    /**\n     * Return <code>true</code> if the supplied Map is <code>null</code>\n     * or empty. Otherwise, return <code>false</code>.\n     * @param map the Map to check\n     * @return whether the given Map is empty\n     */\n    public static boolean isEmpty(Map map) {\n        return (map == null || map.isEmpty());\n    }\n\n    /**\n     * Convert the supplied array into a List. A primitive array gets\n     * converted into a List of the appropriate wrapper type.\n     * <p>A <code>null</code> source value will be converted to an\n     * empty List.\n     * @param source the (potentially primitive) array\n     * @return the converted List result\n     * @see Objects#toObjectArray(Object)\n     */\n    public static List arrayToList(Object source) {\n        return Arrays.asList(Objects.toObjectArray(source));\n    }\n\n    /**\n     * Merge the given array into the given Collection.\n     * @param array the array to merge (may be <code>null</code>)\n     * @param collection the target Collection to merge the array into\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static void mergeArrayIntoCollection(Object array, Collection collection) {\n        if (collection == null) {\n            throw new IllegalArgumentException(\"Collection must not be null\");\n        }\n        Object[] arr = Objects.toObjectArray(array);\n        for (Object elem : arr) {\n            collection.add(elem);\n        }\n    }\n\n    /**\n     * Merge the given Properties instance into the given Map,\n     * copying all properties (key-value pairs) over.\n     * <p>Uses <code>Properties.propertyNames()</code> to even catch\n     * default properties linked into the original Properties instance.\n     * @param props the Properties instance to merge (may be <code>null</code>)\n     * @param map the target Map to merge the properties into\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static void mergePropertiesIntoMap(Properties props, Map map) {\n        if (map == null) {\n            throw new IllegalArgumentException(\"Map must not be null\");\n        }\n        if (props != null) {\n            for (Enumeration en = props.propertyNames(); en.hasMoreElements();) {\n                String key = (String) en.nextElement();\n                Object value = props.getProperty(key);\n                if (value == null) {\n                    // Potentially a non-String value...\n                    value = props.get(key);\n                }\n                map.put(key, value);\n            }\n        }\n    }\n\n\n    /**\n     * Check whether the given Iterator contains the given element.\n     * @param iterator the Iterator to check\n     * @param element the element to look for\n     * @return <code>true</code> if found, <code>false</code> else\n     */\n    public static boolean contains(Iterator iterator, Object element) {\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                Object candidate = iterator.next();\n                if (Objects.nullSafeEquals(candidate, element)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given Enumeration contains the given element.\n     * @param enumeration the Enumeration to check\n     * @param element the element to look for\n     * @return <code>true</code> if found, <code>false</code> else\n     */\n    public static boolean contains(Enumeration enumeration, Object element) {\n        if (enumeration != null) {\n            while (enumeration.hasMoreElements()) {\n                Object candidate = enumeration.nextElement();\n                if (Objects.nullSafeEquals(candidate, element)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given Collection contains the given element instance.\n     * <p>Enforces the given instance to be present, rather than returning\n     * <code>true</code> for an equal element as well.\n     * @param collection the Collection to check\n     * @param element the element to look for\n     * @return <code>true</code> if found, <code>false</code> else\n     */\n    public static boolean containsInstance(Collection collection, Object element) {\n        if (collection != null) {\n            for (Object candidate : collection) {\n                if (candidate == element) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return <code>true</code> if any element in '<code>candidates</code>' is\n     * contained in '<code>source</code>'; otherwise returns <code>false</code>.\n     * @param source the source Collection\n     * @param candidates the candidates to search for\n     * @return whether any of the candidates has been found\n     */\n    public static boolean containsAny(Collection source, Collection candidates) {\n        if (isEmpty(source) || isEmpty(candidates)) {\n            return false;\n        }\n        for (Object candidate : candidates) {\n            if (source.contains(candidate)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the first element in '<code>candidates</code>' that is contained in\n     * '<code>source</code>'. If no element in '<code>candidates</code>' is present in\n     * '<code>source</code>' returns <code>null</code>. Iteration order is\n     * {@link Collection} implementation specific.\n     * @param source the source Collection\n     * @param candidates the candidates to search for\n     * @return the first present object, or <code>null</code> if not found\n     */\n    public static Object findFirstMatch(Collection source, Collection candidates) {\n        if (isEmpty(source) || isEmpty(candidates)) {\n            return null;\n        }\n        for (Object candidate : candidates) {\n            if (source.contains(candidate)) {\n                return candidate;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Find a single value of the given type in the given Collection.\n     * @param collection the Collection to search\n     * @param type the type to look for\n     * @param <T> the generic type parameter for {@code type}\n     * @return a value of the given type found if there is a clear match,\n     * or <code>null</code> if none or more than one such value found\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T findValueOfType(Collection<?> collection, Class<T> type) {\n        if (isEmpty(collection)) {\n            return null;\n        }\n        T value = null;\n        for (Object element : collection) {\n            if (type == null || type.isInstance(element)) {\n                if (value != null) {\n                    // More than one value found... no clear single value.\n                    return null;\n                }\n                value = (T) element;\n            }\n        }\n        return value;\n    }\n\n    /**\n     * Find a single value of one of the given types in the given Collection:\n     * searching the Collection for a value of the first type, then\n     * searching for a value of the second type, etc.\n     * @param collection the collection to search\n     * @param types the types to look for, in prioritized order\n     * @return a value of one of the given types found if there is a clear match,\n     * or <code>null</code> if none or more than one such value found\n     */\n    public static Object findValueOfType(Collection<?> collection, Class<?>[] types) {\n        if (isEmpty(collection) || Objects.isEmpty(types)) {\n            return null;\n        }\n        for (Class<?> type : types) {\n            Object value = findValueOfType(collection, type);\n            if (value != null) {\n                return value;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Determine whether the given Collection only contains a single unique object.\n     * @param collection the Collection to check\n     * @return <code>true</code> if the collection contains a single reference or\n     * multiple references to the same instance, <code>false</code> else\n     */\n    public static boolean hasUniqueObject(Collection collection) {\n        if (isEmpty(collection)) {\n            return false;\n        }\n        boolean hasCandidate = false;\n        Object candidate = null;\n        for (Object elem : collection) {\n            if (!hasCandidate) {\n                hasCandidate = true;\n                candidate = elem;\n            }\n            else if (candidate != elem) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Find the common element type of the given Collection, if any.\n     * @param collection the Collection to check\n     * @return the common element type, or <code>null</code> if no clear\n     * common type has been found (or the collection was empty)\n     */\n    public static Class<?> findCommonElementType(Collection collection) {\n        if (isEmpty(collection)) {\n            return null;\n        }\n        Class<?> candidate = null;\n        for (Object val : collection) {\n            if (val != null) {\n                if (candidate == null) {\n                    candidate = val.getClass();\n                }\n                else if (candidate != val.getClass()) {\n                    return null;\n                }\n            }\n        }\n        return candidate;\n    }\n\n    /**\n     * Marshal the elements from the given enumeration into an array of the given type.\n     * Enumeration elements must be assignable to the type of the given array. The array\n     * returned will be a different instance than the array given.\n     * @param enumeration the collection to convert to an array\n     * @param array an array instance that matches the type of array to return\n     * @param <A> the element type of the array that will be created\n     * @param <E> the element type contained within the enumeration.\n     * @return a new array of type {@code A} that contains the elements in the specified {@code enumeration}.\n     */\n    public static <A,E extends A> A[] toArray(Enumeration<E> enumeration, A[] array) {\n        ArrayList<A> elements = new ArrayList<A>();\n        while (enumeration.hasMoreElements()) {\n            elements.add(enumeration.nextElement());\n        }\n        return elements.toArray(array);\n    }\n\n    /**\n     * Adapt an enumeration to an iterator.\n     * @param enumeration the enumeration\n     * @param <E> the type of elements in the enumeration\n     * @return the iterator\n     */\n    public static <E> Iterator<E> toIterator(Enumeration<E> enumeration) {\n        return new EnumerationIterator<E>(enumeration);\n    }\n\n    /**\n     * Iterator wrapping an Enumeration.\n     */\n    private static class EnumerationIterator<E> implements Iterator<E> {\n\n        private Enumeration<E> enumeration;\n\n        public EnumerationIterator(Enumeration<E> enumeration) {\n            this.enumeration = enumeration;\n        }\n\n        public boolean hasNext() {\n            return this.enumeration.hasMoreElements();\n        }\n\n        public E next() {\n            return this.enumeration.nextElement();\n        }\n\n        public void remove() throws UnsupportedOperationException {\n            throw new UnsupportedOperationException(\"Not supported\");\n        }\n    }\n}\n\n",
            "file_name": "Collections.java",
            "human_label": "Returns the first element in candidates that matches the source.",
            "level": "class_runnable",
            "lineno": "203",
            "name": "findFirstMatch",
            "oracle_context": "{ \"apis\" : \"[isEmpty, contains]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
            "package": "io.jsonwebtoken.lang",
            "project": "jjwt-master"
        },
        {
            "_id": "6367676b1a6d9265ec0181ee",
            "all_context": "{ \"class_level\" : \"import java.nio.charset.Charset;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nimport java.util.Enumeration;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Locale;\\nimport java.util.Properties;\\nimport java.util.Set;\\nimport java.util.StringTokenizer;\\nimport java.util.TreeSet;\\nString FOLDER_SEPARATOR;\\nString WINDOWS_FOLDER_SEPARATOR;\\nString TOP_PATH;\\nString CURRENT_PATH;\\nchar EXTENSION_SEPARATOR;\\nCharset UTF_8;\\nStrings();\\nhasLength(String str);\\nhasText(CharSequence str);\\nhasText(String str);\\ncontainsWhitespace(CharSequence str);\\ncontainsWhitespace(String str);\\ntrimWhitespace(String str);\\ntrimWhitespace(CharSequence str);\\nclean(String str);\\nclean(CharSequence str);\\ntrimAllWhitespace(String str);\\ntrimLeadingWhitespace(String str);\\ntrimTrailingWhitespace(String str);\\ntrimLeadingCharacter(String str,char leadingCharacter);\\ntrimTrailingCharacter(String str,char trailingCharacter);\\nstartsWithIgnoreCase(String str,String prefix);\\nendsWithIgnoreCase(String str,String suffix);\\nsubstringMatch(CharSequence str,int index,CharSequence substring);\\ncountOccurrencesOf(String str,String sub);\\nreplace(String inString,String oldPattern,String newPattern);\\ndelete(String inString,String pattern);\\ndeleteAny(String inString,String charsToDelete);\\nquote(String str);\\nquoteIfString(Object obj);\\nunqualify(String qualifiedName);\\nunqualify(String qualifiedName,char separator);\\ncapitalize(String str);\\nuncapitalize(String str);\\nchangeFirstCharacterCase(String str,boolean capitalize);\\ngetFilename(String path);\\ngetFilenameExtension(String path);\\nstripFilenameExtension(String path);\\napplyRelativePath(String path,String relativePath);\\ncleanPath(String path);\\npathEquals(String path1,String path2);\\nparseLocaleString(String localeString);\\nvalidateLocalePart(String localePart);\\ntoLanguageTag(Locale locale);\\naddStringToArray(String[] array,String str);\\nconcatenateStringArrays(String[] array1,String[] array2);\\nmergeStringArrays(String[] array1,String[] array2);\\nsortStringArray(String[] array);\\ntoStringArray(Collection collection);\\ntoStringArray(Enumeration enumeration);\\ntrimArrayElements(String[] array);\\nremoveDuplicateStrings(String[] array);\\nsplit(String toSplit,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter,String charsToDelete);\\ntokenizeToStringArray(String str,String delimiters);\\ntokenizeToStringArray(String str,String delimiters,boolean trimTokens,boolean ignoreEmptyTokens);\\ndelimitedListToStringArray(String str,String delimiter);\\ndelimitedListToStringArray(String str,String delimiter,String charsToDelete);\\ncommaDelimitedListToStringArray(String str);\\ncommaDelimitedListToSet(String str);\\ncollectionToDelimitedString(Collection coll,String delim,String prefix,String suffix);\\ncollectionToDelimitedString(Collection coll,String delim);\\ncollectionToCommaDelimitedString(Collection coll);\\narrayToDelimitedString(Object[] arr,String delim);\\narrayToCommaDelimitedString(Object[] arr);\\nhasLength(CharSequence str);\\n\", \"repo_level\" : \"\" }",
            "class_name": "Strings",
            "code": "public static String trimTrailingWhitespace(String str){\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb=new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n    sb.deleteCharAt(sb.length() - 1);\n  }\n  return sb.toString();\n}\n",
            "docstring": "/** \n * Trim trailing whitespace from the given String.\n * @param str the String to check\n * @return the trimmed String\n * @see java.lang.Character#isWhitespace\n */\n",
            "end_lineno": "253",
            "file_content": "/*\n * Copyright (C) 2014 jsonwebtoken.io\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.jsonwebtoken.lang;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic final class Strings {\n\n    private static final String FOLDER_SEPARATOR = \"/\";\n\n    private static final String WINDOWS_FOLDER_SEPARATOR = \"\\\\\";\n\n    private static final String TOP_PATH = \"..\";\n\n    private static final String CURRENT_PATH = \".\";\n\n    private static final char EXTENSION_SEPARATOR = '.';\n\n    public static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    private Strings(){} //prevent instantiation\n\n    //---------------------------------------------------------------------\n    // General convenience methods for working with Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Check that the given CharSequence is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a CharSequence that purely consists of whitespace.\n     * <pre>\n     * Strings.hasLength(null) = false\n     * Strings.hasLength(\"\") = false\n     * Strings.hasLength(\" \") = true\n     * Strings.hasLength(\"Hello\") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(CharSequence str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasLength(CharSequence)\n     */\n    public static boolean hasLength(String str) {\n        return hasLength((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <pre>\n     * Strings.hasText(null) = false\n     * Strings.hasText(\"\") = false\n     * Strings.hasText(\" \") = false\n     * Strings.hasText(\"12345\") = true\n     * Strings.hasText(\" 12345 \") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not <code>null</code>,\n     * its length is greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     * greater than 0, and it does not contain whitespace only\n     * @see #hasText(CharSequence)\n     */\n    public static boolean hasText(String str) {\n        return hasText((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence contains any whitespace characters.\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not empty and\n     * contains at least 1 whitespace character\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean containsWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String contains any whitespace characters.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not empty and\n     * contains at least 1 whitespace character\n     * @see #containsWhitespace(CharSequence)\n     */\n    public static boolean containsWhitespace(String str) {\n        return containsWhitespace((CharSequence) str);\n    }\n\n    /**\n     * Trim leading and trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimWhitespace(String str) {\n        return (String) trimWhitespace((CharSequence)str);\n    }\n    \n    \n    private static CharSequence trimWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        final int length = str.length();\n\n        int start = 0;\n\t\twhile (start < length && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        \n\t\tint end = length;\n        while (start < length && Character.isWhitespace(str.charAt(end - 1))) {\n            end--;\n        }\n        \n        return ((start > 0) || (end < length)) ? str.subSequence(start, end) : str;\n    }\n\n    public static String clean(String str) {\n    \tCharSequence result = clean((CharSequence) str);\n        \n        return result!=null?result.toString():null;\n    }\n    \n    public static CharSequence clean(CharSequence str) {\n        str = trimWhitespace(str);\n        if (!hasLength(str)) {\n            return null;\n        }\n        return str;\n    }\n\n    /**\n     * Trim <i>all</i> whitespace from the given String:\n     * leading, trailing, and intermediate characters.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimAllWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        int index = 0;\n        while (sb.length() > index) {\n            if (Character.isWhitespace(sb.charAt(index))) {\n                sb.deleteCharAt(index);\n            }\n            else {\n                index++;\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim leading whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimLeadingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimTrailingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied leading character from the given String.\n     * @param str the String to check\n     * @param leadingCharacter the leading character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimLeadingCharacter(String str, char leadingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied trailing character from the given String.\n     * @param str the String to check\n     * @param trailingCharacter the trailing character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimTrailingCharacter(String str, char trailingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n\n    /**\n     * Returns {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @param str the String to check\n     * @param prefix the prefix to look for\n     * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @param str the String to check\n     * @param suffix the suffix to look for\n     * @return {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @see java.lang.String#endsWith\n     */\n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        if (str == null || suffix == null) {\n            return false;\n        }\n        if (str.endsWith(suffix)) {\n            return true;\n        }\n        if (str.length() < suffix.length()) {\n            return false;\n        }\n\n        String lcStr = str.substring(str.length() - suffix.length()).toLowerCase();\n        String lcSuffix = suffix.toLowerCase();\n        return lcStr.equals(lcSuffix);\n    }\n\n    /**\n     * Returns {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     * @param str the original string (or StringBuilder)\n     * @param index the index in the original string to start matching against\n     * @param substring the substring to match at the given index\n     * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     */\n    public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n        for (int j = 0; j < substring.length(); j++) {\n            int i = index + j;\n            if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the number of occurrences the substring {@code sub} appears in string {@code str}.\n     * @param str string to search in. Return 0 if this is null.\n     * @param sub string to search for. Return 0 if this is null.\n     * @return the number of occurrences the substring {@code sub} appears in string {@code str}.\n     */\n    public static int countOccurrencesOf(String str, String sub) {\n        if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n            return 0;\n        }\n        int count = 0;\n        int pos = 0;\n        int idx;\n        while ((idx = str.indexOf(sub, pos)) != -1) {\n            ++count;\n            pos = idx + sub.length();\n        }\n        return count;\n    }\n\n    /**\n     * Replace all occurrences of a substring within a string with\n     * another string.\n     * @param inString String to examine\n     * @param oldPattern String to replace\n     * @param newPattern String to insert\n     * @return a String with the replacements\n     */\n    public static String replace(String inString, String oldPattern, String newPattern) {\n        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        int pos = 0; // our position in the old string\n        int index = inString.indexOf(oldPattern);\n        // the index of an occurrence we've found, or -1\n        int patLen = oldPattern.length();\n        while (index >= 0) {\n            sb.append(inString.substring(pos, index));\n            sb.append(newPattern);\n            pos = index + patLen;\n            index = inString.indexOf(oldPattern, pos);\n        }\n        sb.append(inString.substring(pos));\n        // remember to append any characters to the right of a match\n        return sb.toString();\n    }\n\n    /**\n     * Delete all occurrences of the given substring.\n     * @param inString the original String\n     * @param pattern the pattern to delete all occurrences of\n     * @return the resulting String\n     */\n    public static String delete(String inString, String pattern) {\n        return replace(inString, pattern, \"\");\n    }\n\n    /**\n     * Delete any character in a given String.\n     * @param inString the original String\n     * @param charsToDelete a set of characters to delete.\n     * E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n     * @return the resulting String\n     */\n    public static String deleteAny(String inString, String charsToDelete) {\n        if (!hasLength(inString) || !hasLength(charsToDelete)) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < inString.length(); i++) {\n            char c = inString.charAt(i);\n            if (charsToDelete.indexOf(c) == -1) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with formatted Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Quote the given String with single quotes.\n     * @param str the input String (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or <code>null</code> if the input was <code>null</code>\n     */\n    public static String quote(String str) {\n        return (str != null ? \"'\" + str + \"'\" : null);\n    }\n\n    /**\n     * Turn the given Object into a String with single quotes\n     * if it is a String; keeping the Object as-is else.\n     * @param obj the input Object (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or the input object as-is if not a String\n     */\n    public static Object quoteIfString(Object obj) {\n        return (obj instanceof String ? quote((String) obj) : obj);\n    }\n\n    /**\n     * Unqualify a string qualified by a '.' dot character. For example,\n     * \"this.name.is.qualified\", returns \"qualified\".\n     * @param qualifiedName the qualified name\n     * @return an unqualified string by stripping all previous text before (and including) the last period character.\n     */\n    public static String unqualify(String qualifiedName) {\n        return unqualify(qualifiedName, '.');\n    }\n\n    /**\n     * Unqualify a string qualified by a separator character. For example,\n     * \"this:name:is:qualified\" returns \"qualified\" if using a ':' separator.\n     * @param qualifiedName the qualified name\n     * @param separator the separator\n     * @return an unqualified string by stripping all previous text before and including the last {@code separator} character.\n     */\n    public static String unqualify(String qualifiedName, char separator) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);\n    }\n\n    /**\n     * Capitalize a <code>String</code>, changing the first letter to\n     * upper case as per {@link Character#toUpperCase(char)}.\n     * No other letters are changed.\n     * @param str the String to capitalize, may be <code>null</code>\n     * @return the capitalized String, <code>null</code> if null\n     */\n    public static String capitalize(String str) {\n        return changeFirstCharacterCase(str, true);\n    }\n\n    /**\n     * Uncapitalize a <code>String</code>, changing the first letter to\n     * lower case as per {@link Character#toLowerCase(char)}.\n     * No other letters are changed.\n     * @param str the String to uncapitalize, may be <code>null</code>\n     * @return the uncapitalized String, <code>null</code> if null\n     */\n    public static String uncapitalize(String str) {\n        return changeFirstCharacterCase(str, false);\n    }\n\n    private static String changeFirstCharacterCase(String str, boolean capitalize) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str.length());\n        if (capitalize) {\n            sb.append(Character.toUpperCase(str.charAt(0)));\n        }\n        else {\n            sb.append(Character.toLowerCase(str.charAt(0)));\n        }\n        sb.append(str.substring(1));\n        return sb.toString();\n    }\n\n    /**\n     * Extract the filename from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"myfile.txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename, or <code>null</code> if none\n     */\n    public static String getFilename(String path) {\n        if (path == null) {\n            return null;\n        }\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);\n    }\n\n    /**\n     * Extract the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename extension, or <code>null</code> if none\n     */\n    public static String getFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return null;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return null;\n        }\n        return path.substring(extIndex + 1);\n    }\n\n    /**\n     * Strip the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"mypath/myfile\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the path with stripped filename extension,\n     * or <code>null</code> if none\n     */\n    public static String stripFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return path;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return path;\n        }\n        return path.substring(0, extIndex);\n    }\n\n    /**\n     * Apply the given relative path to the given path,\n     * assuming standard Java folder separation (i.e. \"/\" separators).\n     * @param path the path to start from (usually a full file path)\n     * @param relativePath the relative path to apply\n     * (relative to the full file path above)\n     * @return the full file path that results from applying the relative path\n     */\n    public static String applyRelativePath(String path, String relativePath) {\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (separatorIndex != -1) {\n            String newPath = path.substring(0, separatorIndex);\n            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n                newPath += FOLDER_SEPARATOR;\n            }\n            return newPath + relativePath;\n        }\n        else {\n            return relativePath;\n        }\n    }\n\n    /**\n     * Normalize the path by suppressing sequences like \"path/..\" and\n     * inner simple dots.\n     * <p>The result is convenient for path comparison. For other uses,\n     * notice that Windows separators (\"\\\") are replaced by simple slashes.\n     * @param path the original path\n     * @return the normalized path\n     */\n    public static String cleanPath(String path) {\n        if (path == null) {\n            return null;\n        }\n        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);\n\n        // Strip prefix from path to analyze, to not treat it as part of the\n        // first path element. This is necessary to correctly parse paths like\n        // \"file:core/../core/io/Resource.class\", where the \"..\" should just\n        // strip the first \"core\" directory while keeping the \"file:\" prefix.\n        int prefixIndex = pathToUse.indexOf(\":\");\n        String prefix = \"\";\n        if (prefixIndex != -1) {\n            prefix = pathToUse.substring(0, prefixIndex + 1);\n            pathToUse = pathToUse.substring(prefixIndex + 1);\n        }\n        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {\n            prefix = prefix + FOLDER_SEPARATOR;\n            pathToUse = pathToUse.substring(1);\n        }\n\n        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);\n        List<String> pathElements = new LinkedList<String>();\n        int tops = 0;\n\n        for (int i = pathArray.length - 1; i >= 0; i--) {\n            String element = pathArray[i];\n            if (CURRENT_PATH.equals(element)) {\n                // Points to current directory - drop it.\n            }\n            else if (TOP_PATH.equals(element)) {\n                // Registering top path found.\n                tops++;\n            }\n            else {\n                if (tops > 0) {\n                    // Merging path element with element corresponding to top path.\n                    tops--;\n                }\n                else {\n                    // Normal path element found.\n                    pathElements.add(0, element);\n                }\n            }\n        }\n\n        // Remaining top paths need to be retained.\n        for (int i = 0; i < tops; i++) {\n            pathElements.add(0, TOP_PATH);\n        }\n\n        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);\n    }\n\n    /**\n     * Compare two paths after normalization of them.\n     * @param path1 first path for comparison\n     * @param path2 second path for comparison\n     * @return whether the two paths are equivalent after normalization\n     */\n    public static boolean pathEquals(String path1, String path2) {\n        return cleanPath(path1).equals(cleanPath(path2));\n    }\n\n    /**\n     * Parse the given <code>localeString</code> value into a {@link java.util.Locale}.\n     * <p>This is the inverse operation of {@link java.util.Locale#toString Locale's toString}.\n     * @param localeString the locale string, following <code>Locale's</code>\n     * <code>toString()</code> format (\"en\", \"en_UK\", etc);\n     * also accepts spaces as separators, as an alternative to underscores\n     * @return a corresponding <code>Locale</code> instance\n     */\n    public static Locale parseLocaleString(String localeString) {\n        String[] parts = tokenizeToStringArray(localeString, \"_ \", false, false);\n        String language = (parts.length > 0 ? parts[0] : \"\");\n        String country = (parts.length > 1 ? parts[1] : \"\");\n        validateLocalePart(language);\n        validateLocalePart(country);\n        String variant = \"\";\n        if (parts.length >= 2) {\n            // There is definitely a variant, and it is everything after the country\n            // code sans the separator between the country code and the variant.\n            int endIndexOfCountryCode = localeString.indexOf(country) + country.length();\n            // Strip off any leading '_' and whitespace, what's left is the variant.\n            variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));\n            if (variant.startsWith(\"_\")) {\n                variant = trimLeadingCharacter(variant, '_');\n            }\n        }\n        return (language.length() > 0 ? new Locale(language, country, variant) : null);\n    }\n\n    private static void validateLocalePart(String localePart) {\n        for (int i = 0; i < localePart.length(); i++) {\n            char ch = localePart.charAt(i);\n            if (ch != '_' && ch != ' ' && !Character.isLetterOrDigit(ch)) {\n                throw new IllegalArgumentException(\n                    \"Locale part \\\"\" + localePart + \"\\\" contains invalid characters\");\n            }\n        }\n    }\n\n    /**\n     * Determine the RFC 3066 compliant language tag,\n     * as used for the HTTP \"Accept-Language\" header.\n     * @param locale the Locale to transform to a language tag\n     * @return the RFC 3066 compliant language tag as String\n     */\n    public static String toLanguageTag(Locale locale) {\n        return locale.getLanguage() + (hasText(locale.getCountry()) ? \"-\" + locale.getCountry() : \"\");\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with String arrays\n    //---------------------------------------------------------------------\n\n    /**\n     * Append the given String to the given String array, returning a new array\n     * consisting of the input array contents plus the given String.\n     * @param array the array to append to (can be <code>null</code>)\n     * @param str the String to append\n     * @return the new array (never <code>null</code>)\n     */\n    public static String[] addStringToArray(String[] array, String str) {\n        if (Objects.isEmpty(array)) {\n            return new String[] {str};\n        }\n        String[] newArr = new String[array.length + 1];\n        System.arraycopy(array, 0, newArr, 0, array.length);\n        newArr[array.length] = str;\n        return newArr;\n    }\n\n    /**\n     * Concatenate the given String arrays into one,\n     * with overlapping array elements included twice.\n     * <p>The order of elements in the original arrays is preserved.\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        String[] newArr = new String[array1.length + array2.length];\n        System.arraycopy(array1, 0, newArr, 0, array1.length);\n        System.arraycopy(array2, 0, newArr, array1.length, array2.length);\n        return newArr;\n    }\n\n    /**\n     * Merge the given String arrays into one, with overlapping\n     * array elements only included once.\n     * <p>The order of elements in the original arrays is preserved\n     * (with the exception of overlapping elements, which are only\n     * included on their first occurrence).\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] mergeStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        List<String> result = new ArrayList<String>();\n        result.addAll(Arrays.asList(array1));\n        for (String str : array2) {\n            if (!result.contains(str)) {\n                result.add(str);\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Turn given source String array into sorted array.\n     * @param array the source array\n     * @return the sorted array (never <code>null</code>)\n     */\n    public static String[] sortStringArray(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        Arrays.sort(array);\n        return array;\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Collection was <code>null</code>)\n     */\n    public static String[] toStringArray(Collection<String> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new String[collection.size()]);\n    }\n\n    /**\n     * Copy the given Enumeration into a String array.\n     * The Enumeration must contain String elements only.\n     * @param enumeration the Enumeration to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Enumeration was <code>null</code>)\n     */\n    public static String[] toStringArray(Enumeration<String> enumeration) {\n        if (enumeration == null) {\n            return null;\n        }\n        List<String> list = java.util.Collections.list(enumeration);\n        return list.toArray(new String[list.size()]);\n    }\n\n    /**\n     * Trim the elements of the given String array,\n     * calling <code>String.trim()</code> on each of them.\n     * @param array the original String array\n     * @return the resulting array (of the same size) with trimmed elements\n     */\n    public static String[] trimArrayElements(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        String[] result = new String[array.length];\n        for (int i = 0; i < array.length; i++) {\n            String element = array[i];\n            result[i] = (element != null ? element.trim() : null);\n        }\n        return result;\n    }\n\n    /**\n     * Remove duplicate Strings from the given array.\n     * Also sorts the array, as it uses a TreeSet.\n     * @param array the String array\n     * @return an array without duplicates, in natural sort order\n     */\n    public static String[] removeDuplicateStrings(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return array;\n        }\n        Set<String> set = new TreeSet<String>();\n        for (String element : array) {\n            set.add(element);\n        }\n        return toStringArray(set);\n    }\n\n    /**\n     * Split a String at the first occurrence of the delimiter.\n     * Does not include the delimiter in the result.\n     * @param toSplit the string to split\n     * @param delimiter to split the string up with\n     * @return a two element array with index 0 being before the delimiter, and\n     * index 1 being after the delimiter (neither element includes the delimiter);\n     * or <code>null</code> if the delimiter wasn't found in the given input String\n     */\n    public static String[] split(String toSplit, String delimiter) {\n        if (!hasLength(toSplit) || !hasLength(delimiter)) {\n            return null;\n        }\n        int offset = toSplit.indexOf(delimiter);\n        if (offset < 0) {\n            return null;\n        }\n        String beforeDelimiter = toSplit.substring(0, offset);\n        String afterDelimiter = toSplit.substring(offset + delimiter.length());\n        return new String[] {beforeDelimiter, afterDelimiter};\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was null or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {\n        return splitArrayElementsIntoProperties(array, delimiter, null);\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @param charsToDelete one or more characters to remove from each element\n     * prior to attempting the split operation (typically the quotation mark\n     * symbol), or <code>null</code> if no removal should occur\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was <code>null</code> or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(\n        String[] array, String delimiter, String charsToDelete) {\n\n        if (Objects.isEmpty(array)) {\n            return null;\n        }\n        Properties result = new Properties();\n        for (String element : array) {\n            if (charsToDelete != null) {\n                element = deleteAny(element, charsToDelete);\n            }\n            String[] splittedElement = split(element, delimiter);\n            if (splittedElement == null) {\n                continue;\n            }\n            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n        }\n        return result;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter)\n     * @param trimTokens trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     * (only applies to tokens that are empty after trimming; StringTokenizer\n     * will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     * was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(\n        String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List<String> tokens = new ArrayList<String>();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter) {\n        return delimitedListToStringArray(str, delimiter, null);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @param charsToDelete a set of characters to delete. Useful for deleting unwanted\n     * line breaks: e.g. \"\\r\\n\\f\" will delete all new lines and line feeds in a String.\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {\n        if (str == null) {\n            return new String[0];\n        }\n        if (delimiter == null) {\n            return new String[] {str};\n        }\n        List<String> result = new ArrayList<String>();\n        if (\"\".equals(delimiter)) {\n            for (int i = 0; i < str.length(); i++) {\n                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));\n            }\n        }\n        else {\n            int pos = 0;\n            int delPos;\n            while ((delPos = str.indexOf(delimiter, pos)) != -1) {\n                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));\n                pos = delPos + delimiter.length();\n            }\n            if (str.length() > 0 && pos <= str.length()) {\n                // Add rest of String, but not in case of empty input.\n                result.add(deleteAny(str.substring(pos), charsToDelete));\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Convert a CSV list into an array of Strings.\n     * @param str the input String\n     * @return an array of Strings, or the empty array in case of empty input\n     */\n    public static String[] commaDelimitedListToStringArray(String str) {\n        return delimitedListToStringArray(str, \",\");\n    }\n\n    /**\n     * Convenience method to convert a CSV string list to a set.\n     * Note that this will suppress duplicates.\n     * @param str the input String\n     * @return a Set of String entries in the list\n     */\n    public static Set<String> commaDelimitedListToSet(String str) {\n        Set<String> set = new TreeSet<String>();\n        String[] tokens = commaDelimitedListToStringArray(str);\n        for (String token : tokens) {\n            set.add(token);\n        }\n        return set;\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @param prefix the String to start each element with\n     * @param suffix the String to end each element with\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {\n        if (Collections.isEmpty(coll)) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        Iterator<?> it = coll.iterator();\n        while (it.hasNext()) {\n            sb.append(prefix).append(it.next()).append(suffix);\n            if (it.hasNext()) {\n                sb.append(delim);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim) {\n        return collectionToDelimitedString(coll, delim, \"\", \"\");\n    }\n\n    /**\n     * Convenience method to return a Collection as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @return the delimited String\n     */\n    public static String collectionToCommaDelimitedString(Collection<?> coll) {\n        return collectionToDelimitedString(coll, \",\");\n    }\n\n    /**\n     * Convenience method to return a String array as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String arrayToDelimitedString(Object[] arr, String delim) {\n        if (Objects.isEmpty(arr)) {\n            return \"\";\n        }\n        if (arr.length == 1) {\n            return Objects.nullSafeToString(arr[0]);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < arr.length; i++) {\n            if (i > 0) {\n                sb.append(delim);\n            }\n            sb.append(arr[i]);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a String array as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @return the delimited String\n     */\n    public static String arrayToCommaDelimitedString(Object[] arr) {\n        return arrayToDelimitedString(arr, \",\");\n    }\n\n}\n\n",
            "file_name": "Strings.java",
            "human_label": "Trim the end space of the str.",
            "level": "class_runnable",
            "lineno": "238",
            "name": "trimTrailingWhitespace",
            "oracle_context": "{ \"apis\" : \"[hasLength, length, isWhitespace, charAt, deleteCharAt, toString]\", \"classes\" : \"[StringBuilder]\", \"vars\" : \"[]\" }",
            "package": "io.jsonwebtoken.lang",
            "project": "jjwt-master"
        },
        {
            "_id": "636767a31a6d9265ec018552",
            "all_context": "{ \"class_level\" : \"import java.io.DataInput;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.nio.ByteBuffer;\\nimport java.util.ArrayList;\\nimport java.util.List;\\nimport io.protostuff.StringSerializer.STRING;\\nimport static io.protostuff.WireFormat.TAG_TYPE_BITS;\\nimport static io.protostuff.WireFormat.TAG_TYPE_MASK;\\nimport static io.protostuff.WireFormat.WIRETYPE_END_GROUP;\\nimport static io.protostuff.WireFormat.WIRETYPE_LENGTH_DELIMITED;\\nimport static io.protostuff.WireFormat.WIRETYPE_TAIL_DELIMITER;\\nbyte[] buffer;\\nint bufferSize;\\nint bufferSizeAfterLimit;\\nint bufferPos;\\nInputStream input;\\nint lastTag;\\nint packedLimit;\\nint totalBytesRetired;\\nint currentLimit;\\nboolean decodeNestedMessageAsGroup;\\nint sizeLimit;\\nint DEFAULT_SIZE_LIMIT;\\nint DEFAULT_BUFFER_SIZE;\\nnewInstance(byte[] buf);\\nnewInstance(byte[] buf,int off,int len);\\nreadTag();\\ncheckLastTagWas(int value);\\nskipField(int tag);\\nskipMessage();\\nreadDouble();\\nreadFloat();\\nreadUInt64();\\nreadInt64();\\nreadInt32();\\nreadFixed64();\\nreadFixed32();\\nreadBool();\\nreadString();\\nreadBytes(ByteBuffer bb);\\nmergeObject(T value,Schema schema);\\nmergeObjectEncodedAsGroup(T value,Schema schema);\\nreadBytes();\\nreadUInt32();\\nreadEnum();\\nreadSFixed32();\\nreadSFixed64();\\nreadSInt32();\\nreadSInt64();\\nreadRawVarint32();\\nreadRawVarint32(InputStream input);\\nreadRawVarint32(InputStream input,int firstByte);\\nreadRawVarint32(DataInput input,byte firstByte);\\nreadRawVarint64();\\nreadRawLittleEndian32();\\nreadRawLittleEndian64();\\ndecodeZigZag32(int n);\\ndecodeZigZag64(long n);\\nCodedInput(byte[] buffer,int off,int len,boolean decodeNestedMessageAsGroup);\\nCodedInput(InputStream input,boolean decodeNestedMessageAsGroup);\\nCodedInput(InputStream input,byte[] buffer,boolean decodeNestedMessageAsGroup);\\nCodedInput(InputStream input,byte[] buffer,int offset,int limit,boolean decodeNestedMessageAsGroup);\\nsetSizeLimit(int limit);\\nresetSizeCounter();\\nreset();\\npushLimit(int byteLimit);\\nrecomputeBufferSizeAfterLimit();\\npopLimit(int oldLimit);\\ngetBytesUntilLimit();\\nisCurrentFieldPacked();\\nisAtEnd();\\ngetTotalBytesRead();\\nrefillBuffer(boolean mustSucceed);\\nreadRawByte();\\nreadRawBytes(int size);\\nskipRawBytes(int size);\\nreadFieldNumber(Schema schema);\\ncheckIfPackedField();\\nreadByteArray();\\nhandleUnknownField(int fieldNumber,Schema schema);\\ntransferByteRangeTo(Output output,boolean utf8String,int fieldNumber,boolean repeated);\\ngetLastTag();\\nreadByteBuffer();\\nnewInstance(InputStream input);\\n\", \"repo_level\" : \"\" }",
            "class_name": "CodedInput",
            "code": "@Override public String readString() throws IOException {\n  final int size=readRawVarint32();\n  if (size <= (bufferSize - bufferPos) && size > 0) {\n    final String result=STRING.deser(buffer,bufferPos,size);\n    bufferPos+=size;\n    return result;\n  }\n else {\n    return STRING.deser(readRawBytes(size));\n  }\n}\n",
            "docstring": "/** \n * Read a  {@code string} field value from the stream.\n */\n",
            "end_lineno": "292",
            "file_content": "//========================================================================\n//Copyright 2007-2009 David Yu dyuproject@gmail.com\n//------------------------------------------------------------------------\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at \n//http://www.apache.org/licenses/LICENSE-2.0\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//========================================================================\n\n// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// http://code.google.com/p/protobuf/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npackage io.protostuff;\n\nimport java.io.DataInput;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport io.protostuff.StringSerializer.STRING;\n\nimport static io.protostuff.WireFormat.TAG_TYPE_BITS;\nimport static io.protostuff.WireFormat.TAG_TYPE_MASK;\nimport static io.protostuff.WireFormat.WIRETYPE_END_GROUP;\nimport static io.protostuff.WireFormat.WIRETYPE_LENGTH_DELIMITED;\nimport static io.protostuff.WireFormat.WIRETYPE_TAIL_DELIMITER;\n\n/**\n * Reads and decodes protocol message fields.\n * <p>\n * This class contains two kinds of methods: methods that read specific protocol message constructs and field types\n * (e.g. {@link #readTag()} and {@link #readInt32()}) and methods that read low-level values (e.g.\n * {@link #readRawVarint32()} and {@link #readRawBytes}). If you are reading encoded protocol messages, you should use\n * the former methods, but if you are reading some other format of your own design, use the latter.\n *\n * @author kenton@google.com Kenton Varda\n * @author David Yu\n */\npublic final class CodedInput implements Input\n{\n    /**\n     * Create a new CodedInput wrapping the given InputStream.\n     */\n    public static CodedInput newInstance(final InputStream input)\n    {\n        return new CodedInput(input, false);\n    }\n\n    /**\n     * Create a new CodedInput wrapping the given byte array.\n     */\n    public static CodedInput newInstance(final byte[] buf)\n    {\n        return newInstance(buf, 0, buf.length);\n    }\n\n    /**\n     * Create a new CodedInput wrapping the given byte array slice.\n     */\n    public static CodedInput newInstance(final byte[] buf, final int off,\n            final int len)\n    {\n        return new CodedInput(buf, off, len, false);\n    }\n\n    // -----------------------------------------------------------------\n\n    /**\n     * Attempt to read a field tag, returning zero if we have reached EOF. Protocol message parsers use this to read\n     * tags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.\n     */\n    public int readTag() throws IOException\n    {\n        if (isAtEnd())\n        {\n            lastTag = 0;\n            return 0;\n        }\n\n        final int tag = readRawVarint32();\n        if (tag >>> TAG_TYPE_BITS == 0)\n        {\n            // If we actually read zero, that's not a valid tag.\n            throw ProtobufException.invalidTag();\n        }\n        lastTag = tag;\n        return tag;\n    }\n\n    /**\n     * Verifies that the last call to readTag() returned the given tag value. This is used to verify that a nested group\n     * ended with the correct end tag.\n     *\n     * @throws ProtobufException\n     *             {@code value} does not match the last tag.\n     */\n    public void checkLastTagWas(final int value)\n            throws ProtobufException\n    {\n        if (lastTag != value)\n        {\n            throw ProtobufException.invalidEndTag();\n        }\n    }\n\n    /**\n     * Reads and discards a single field, given its tag value.\n     *\n     * @return {@code false} if the tag is an endgroup tag, in which case nothing is skipped. Otherwise, returns\n     *         {@code true}.\n     */\n    public boolean skipField(final int tag) throws IOException\n    {\n        switch (WireFormat.getTagWireType(tag))\n        {\n            case WireFormat.WIRETYPE_VARINT:\n                readInt32();\n                return true;\n            case WireFormat.WIRETYPE_FIXED64:\n                readRawLittleEndian64();\n                return true;\n            case WireFormat.WIRETYPE_LENGTH_DELIMITED:\n                skipRawBytes(readRawVarint32());\n                return true;\n            case WireFormat.WIRETYPE_START_GROUP:\n                skipMessage();\n                checkLastTagWas(WireFormat.makeTag(WireFormat.getTagFieldNumber(tag),\n                        WireFormat.WIRETYPE_END_GROUP));\n                return true;\n            case WireFormat.WIRETYPE_END_GROUP:\n                return false;\n            case WireFormat.WIRETYPE_FIXED32:\n                readRawLittleEndian32();\n                return true;\n            default:\n                throw ProtobufException.invalidWireType();\n        }\n    }\n\n    /**\n     * Reads and discards an entire message. This will read either until EOF or until an endgroup tag, whichever comes\n     * first.\n     */\n    public void skipMessage() throws IOException\n    {\n        while (true)\n        {\n            final int tag = readTag();\n            if (tag == 0 || !skipField(tag))\n            {\n                return;\n            }\n        }\n    }\n\n    // -----------------------------------------------------------------\n\n    /**\n     * Read a {@code double} field value from the stream.\n     */\n    @Override\n    public double readDouble() throws IOException\n    {\n        checkIfPackedField();\n        return Double.longBitsToDouble(readRawLittleEndian64());\n    }\n\n    /**\n     * Read a {@code float} field value from the stream.\n     */\n    @Override\n    public float readFloat() throws IOException\n    {\n        checkIfPackedField();\n        return Float.intBitsToFloat(readRawLittleEndian32());\n    }\n\n    /**\n     * Read a {@code uint64} field value from the stream.\n     */\n    @Override\n    public long readUInt64() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint64();\n    }\n\n    /**\n     * Read an {@code int64} field value from the stream.\n     */\n    @Override\n    public long readInt64() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint64();\n    }\n\n    /**\n     * Read an {@code int32} field value from the stream.\n     */\n    @Override\n    public int readInt32() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint32();\n    }\n\n    /**\n     * Read a {@code fixed64} field value from the stream.\n     */\n    @Override\n    public long readFixed64() throws IOException\n    {\n        checkIfPackedField();\n        return readRawLittleEndian64();\n    }\n\n    /**\n     * Read a {@code fixed32} field value from the stream.\n     */\n    @Override\n    public int readFixed32() throws IOException\n    {\n        checkIfPackedField();\n        return readRawLittleEndian32();\n    }\n\n    /**\n     * Read a {@code bool} field value from the stream.\n     */\n    @Override\n    public boolean readBool() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint32() != 0;\n    }\n\n    /**\n     * Read a {@code string} field value from the stream.\n     */\n    @Override\n    public String readString() throws IOException\n    {\n        final int size = readRawVarint32();\n        if (size <= (bufferSize - bufferPos) && size > 0)\n        {\n            // Fast path: We already have the bytes in a contiguous buffer, so\n            // just copy directly from it.\n            final String result = STRING.deser(buffer, bufferPos, size);\n            bufferPos += size;\n            return result;\n        }\n        else\n        {\n            // Slow path: Build a byte array first then copy it.\n            return STRING.deser(readRawBytes(size));\n        }\n    }\n\n    /**\n     * Read a {@code string} field value from the stream into a ByteBuffer.\n     */\n    @Override\n    public void readBytes(final ByteBuffer bb) throws IOException\n    {\n        final int size = readRawVarint32();\n\n        if (size <= (bufferSize - bufferPos) && size > 0)\n        {\n            // Fast path: We already have the bytes in a contiguous buffer, so\n            // just copy directly from it.\n            bb.limit(size);\n            bb.put(buffer, bufferPos, size);\n            bufferPos += size;\n        }\n        else\n        {\n            // Slow path: Build a byte array first then copy it.\n            bb.put(readRawBytes(size));\n        }\n    }\n\n    @Override\n    public <T> T mergeObject(T value, final Schema<T> schema) throws IOException\n    {\n        if (decodeNestedMessageAsGroup)\n            return mergeObjectEncodedAsGroup(value, schema);\n\n        final int length = readRawVarint32();\n        // if (recursionDepth >= recursionLimit) {\n        // throw ProtobufException.recursionLimitExceeded();\n        // }\n        final int oldLimit = pushLimit(length);\n        // ++recursionDepth;\n\n        if (value == null)\n        {\n            value = schema.newMessage();\n        }\n        schema.mergeFrom(this, value);\n        if (!schema.isInitialized(value))\n        {\n            throw new UninitializedMessageException(value, schema);\n        }\n        checkLastTagWas(0);\n        // --recursionDepth;\n        popLimit(oldLimit);\n        return value;\n    }\n\n    /**\n     * Reads a message field value from the stream (using the {@code group} encoding).\n     */\n    private <T> T mergeObjectEncodedAsGroup(T value, final Schema<T> schema) throws IOException\n    {\n        // if (recursionDepth >= recursionLimit) {\n        // throw ProtobufException.recursionLimitExceeded();\n        // }\n        // ++recursionDepth;\n\n        if (value == null)\n        {\n            value = schema.newMessage();\n        }\n        schema.mergeFrom(this, value);\n        if (!schema.isInitialized(value))\n        {\n            throw new UninitializedMessageException(value, schema);\n        }\n        // handling is in #readFieldNumber\n        checkLastTagWas(0);\n        // --recursionDepth;\n        return value;\n    }\n\n    /*\n     * @ Reads a {@code group} field value from the stream and merges it into the given {@link UnknownFieldSet}.\n     * \n     * @deprecated UnknownFieldSet.Builder now implements MessageLite.Builder, so you can just call {@link #readGroup}.\n     */\n    /*\n     * @Deprecated public void readUnknownGroup(final int fieldNumber, final MessageLite.Builder builder) throws\n     * IOException { // We know that UnknownFieldSet will ignore any ExtensionRegistry so it // is safe to pass null\n     * here. (We can't call // ExtensionRegistry.getEmptyRegistry() because that would make this // class depend on\n     * ExtensionRegistry, which is not part of the lite // library.) readGroup(fieldNumber, builder, null); }\n     */\n\n    /**\n     * Read a {@code bytes} field value from the stream.\n     */\n    @Override\n    public ByteString readBytes() throws IOException\n    {\n        final int size = readRawVarint32();\n        if (size == 0)\n        {\n            return ByteString.EMPTY;\n        }\n\n        if (size <= (bufferSize - bufferPos) && size > 0)\n        {\n            // Fast path: We already have the bytes in a contiguous buffer, so\n            // just copy directly from it.\n            final ByteString result = ByteString.copyFrom(buffer, bufferPos, size);\n            bufferPos += size;\n            return result;\n        }\n        else\n        {\n            // Slow path: Build a byte array first then copy it.\n            // return ByteString.copyFrom(readRawBytes(size));\n            return ByteString.wrap(readRawBytes(size));\n        }\n    }\n\n    /**\n     * Read a {@code uint32} field value from the stream.\n     */\n    @Override\n    public int readUInt32() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint32();\n    }\n\n    /**\n     * Read an enum field value from the stream. Caller is responsible for converting the numeric value to an actual\n     * enum.\n     */\n    @Override\n    public int readEnum() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint32();\n    }\n\n    /**\n     * Read an {@code sfixed32} field value from the stream.\n     */\n    @Override\n    public int readSFixed32() throws IOException\n    {\n        checkIfPackedField();\n        return readRawLittleEndian32();\n    }\n\n    /**\n     * Read an {@code sfixed64} field value from the stream.\n     */\n    @Override\n    public long readSFixed64() throws IOException\n    {\n        checkIfPackedField();\n        return readRawLittleEndian64();\n    }\n\n    /**\n     * Read an {@code sint32} field value from the stream.\n     */\n    @Override\n    public int readSInt32() throws IOException\n    {\n        checkIfPackedField();\n        return decodeZigZag32(readRawVarint32());\n    }\n\n    /**\n     * Read an {@code sint64} field value from the stream.\n     */\n    @Override\n    public long readSInt64() throws IOException\n    {\n        checkIfPackedField();\n        return decodeZigZag64(readRawVarint64());\n    }\n\n    // =================================================================\n\n    /**\n     * Read a raw Varint from the stream. If larger than 32 bits, discard the upper bits.\n     */\n    public int readRawVarint32() throws IOException\n    {\n        byte tmp = readRawByte();\n        if (tmp >= 0)\n        {\n            return tmp;\n        }\n        int result = tmp & 0x7f;\n        if ((tmp = readRawByte()) >= 0)\n        {\n            result |= tmp << 7;\n        }\n        else\n        {\n            result |= (tmp & 0x7f) << 7;\n            if ((tmp = readRawByte()) >= 0)\n            {\n                result |= tmp << 14;\n            }\n            else\n            {\n                result |= (tmp & 0x7f) << 14;\n                if ((tmp = readRawByte()) >= 0)\n                {\n                    result |= tmp << 21;\n                }\n                else\n                {\n                    result |= (tmp & 0x7f) << 21;\n                    result |= (tmp = readRawByte()) << 28;\n                    if (tmp < 0)\n                    {\n                        // Discard upper 32 bits.\n                        for (int i = 0; i < 5; i++)\n                        {\n                            if (readRawByte() >= 0)\n                            {\n                                return result;\n                            }\n                        }\n                        throw ProtobufException.malformedVarint();\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Reads a varint from the input one byte at a time, so that it does not read any bytes after the end of the varint.\n     * If you simply wrapped the stream in a CodedInput and used {@link #readRawVarint32(InputStream)} then you would\n     * probably end up reading past the end of the varint since CodedInput buffers its input.\n     */\n    static int readRawVarint32(final InputStream input) throws IOException\n    {\n        final int firstByte = input.read();\n        if (firstByte == -1)\n        {\n            throw ProtobufException.truncatedMessage();\n        }\n\n        if ((firstByte & 0x80) == 0)\n        {\n            return firstByte;\n        }\n        return readRawVarint32(input, firstByte);\n    }\n\n    /**\n     * Reads a varint from the input one byte at a time, so that it does not read any bytes after the end of the varint.\n     * If you simply wrapped the stream in a CodedInput and used {@link #readRawVarint32(InputStream)} then you would\n     * probably end up reading past the end of the varint since CodedInput buffers its input.\n     */\n    static int readRawVarint32(final InputStream input, final int firstByte) throws IOException\n    {\n        int result = firstByte & 0x7f;\n        int offset = 7;\n        for (; offset < 32; offset += 7)\n        {\n            final int b = input.read();\n            if (b == -1)\n            {\n                throw ProtobufException.truncatedMessage();\n            }\n            result |= (b & 0x7f) << offset;\n            if ((b & 0x80) == 0)\n            {\n                return result;\n            }\n        }\n        // Keep reading up to 64 bits.\n        for (; offset < 64; offset += 7)\n        {\n            final int b = input.read();\n            if (b == -1)\n            {\n                throw ProtobufException.truncatedMessage();\n            }\n            if ((b & 0x80) == 0)\n            {\n                return result;\n            }\n        }\n        throw ProtobufException.malformedVarint();\n    }\n\n    /**\n     * Reads a varint from the input one byte at a time from a {@link DataInput}, so that it does not read any bytes\n     * after the end of the varint.\n     */\n    static int readRawVarint32(final DataInput input, final byte firstByte) throws IOException\n    {\n        int result = firstByte & 0x7f;\n        int offset = 7;\n        for (; offset < 32; offset += 7)\n        {\n            final byte b = input.readByte();\n            result |= (b & 0x7f) << offset;\n            if ((b & 0x80) == 0)\n            {\n                return result;\n            }\n        }\n        // Keep reading up to 64 bits.\n        for (; offset < 64; offset += 7)\n        {\n            final byte b = input.readByte();\n            if ((b & 0x80) == 0)\n            {\n                return result;\n            }\n        }\n        throw ProtobufException.malformedVarint();\n    }\n\n    /**\n     * Read a raw Varint from the stream.\n     */\n    public long readRawVarint64() throws IOException\n    {\n        int shift = 0;\n        long result = 0;\n        while (shift < 64)\n        {\n            final byte b = readRawByte();\n            result |= (long) (b & 0x7F) << shift;\n            if ((b & 0x80) == 0)\n            {\n                return result;\n            }\n            shift += 7;\n        }\n        throw ProtobufException.malformedVarint();\n    }\n\n    /**\n     * Read a 32-bit little-endian integer from the stream.\n     */\n    public int readRawLittleEndian32() throws IOException\n    {\n        final byte b1 = readRawByte();\n        final byte b2 = readRawByte();\n        final byte b3 = readRawByte();\n        final byte b4 = readRawByte();\n        return (((int) b1 & 0xff)) |\n                (((int) b2 & 0xff) << 8) |\n                (((int) b3 & 0xff) << 16) |\n                (((int) b4 & 0xff) << 24);\n    }\n\n    /**\n     * Read a 64-bit little-endian integer from the stream.\n     */\n    public long readRawLittleEndian64() throws IOException\n    {\n        final byte b1 = readRawByte();\n        final byte b2 = readRawByte();\n        final byte b3 = readRawByte();\n        final byte b4 = readRawByte();\n        final byte b5 = readRawByte();\n        final byte b6 = readRawByte();\n        final byte b7 = readRawByte();\n        final byte b8 = readRawByte();\n        return (((long) b1 & 0xff)) |\n                (((long) b2 & 0xff) << 8) |\n                (((long) b3 & 0xff) << 16) |\n                (((long) b4 & 0xff) << 24) |\n                (((long) b5 & 0xff) << 32) |\n                (((long) b6 & 0xff) << 40) |\n                (((long) b7 & 0xff) << 48) |\n                (((long) b8 & 0xff) << 56);\n    }\n\n    /**\n     * Decode a ZigZag-encoded 32-bit value. ZigZag encodes signed integers into values that can be efficiently encoded\n     * with varint. (Otherwise, negative values must be sign-extended to 64 bits to be varint encoded, thus always\n     * taking 10 bytes on the wire.)\n     *\n     * @param n\n     *            An unsigned 32-bit integer, stored in a signed int because Java has no explicit unsigned support.\n     * @return A signed 32-bit integer.\n     */\n    public static int decodeZigZag32(final int n)\n    {\n        return (n >>> 1) ^ -(n & 1);\n    }\n\n    /**\n     * Decode a ZigZag-encoded 64-bit value. ZigZag encodes signed integers into values that can be efficiently encoded\n     * with varint. (Otherwise, negative values must be sign-extended to 64 bits to be varint encoded, thus always\n     * taking 10 bytes on the wire.)\n     *\n     * @param n\n     *            An unsigned 64-bit integer, stored in a signed int because Java has no explicit unsigned support.\n     * @return A signed 64-bit integer.\n     */\n    public static long decodeZigZag64(final long n)\n    {\n        return (n >>> 1) ^ -(n & 1);\n    }\n\n    // -----------------------------------------------------------------\n\n    private final byte[] buffer;\n    private int bufferSize;\n    private int bufferSizeAfterLimit;\n    private int bufferPos;\n    private final InputStream input;\n    private int lastTag;\n    private int packedLimit = 0;\n\n    /**\n     * The total number of bytes read before the current buffer. The total bytes read up to the current position can be\n     * computed as {@code totalBytesRetired + bufferPos}. This value may be negative if reading started in the middle of\n     * the current buffer (e.g. if the constructor that takes a byte array and an offset was used).\n     */\n    private int totalBytesRetired;\n\n    /**\n     * The absolute position of the end of the current message.\n     */\n    private int currentLimit = Integer.MAX_VALUE;\n\n    // ** See setRecursionLimit() */\n    // private int recursionDepth;\n    // private int recursionLimit = DEFAULT_RECURSION_LIMIT;\n\n    /**\n     * If true, the nested messages are group-encoded\n     */\n    public final boolean decodeNestedMessageAsGroup;\n\n    /**\n     * See setSizeLimit()\n     */\n    private int sizeLimit = DEFAULT_SIZE_LIMIT;\n\n    // static final int DEFAULT_RECURSION_LIMIT = 64;\n    static final int DEFAULT_SIZE_LIMIT = 64 << 20; // 64MB\n    static final int DEFAULT_BUFFER_SIZE = 4096;\n\n    public CodedInput(final byte[] buffer, final int off, final int len,\n            boolean decodeNestedMessageAsGroup)\n    {\n        this.buffer = buffer;\n        bufferSize = off + len;\n        bufferPos = off;\n        totalBytesRetired = -off;\n        input = null;\n        this.decodeNestedMessageAsGroup = decodeNestedMessageAsGroup;\n    }\n\n    public CodedInput(final InputStream input, boolean decodeNestedMessageAsGroup)\n    {\n        this(input, new byte[DEFAULT_BUFFER_SIZE], 0, 0, decodeNestedMessageAsGroup);\n    }\n\n    public CodedInput(final InputStream input, byte[] buffer,\n            boolean decodeNestedMessageAsGroup)\n    {\n        this(input, buffer, 0, 0, decodeNestedMessageAsGroup);\n    }\n\n    public CodedInput(final InputStream input, byte[] buffer, int offset, int limit,\n            boolean decodeNestedMessageAsGroup)\n    {\n        this.buffer = buffer;\n        bufferSize = limit;\n        bufferPos = offset;\n        totalBytesRetired = -offset;\n        this.input = input;\n        this.decodeNestedMessageAsGroup = decodeNestedMessageAsGroup;\n    }\n\n    /*\n     * Set the maximum message recursion depth. In order to prevent malicious messages from causing stack overflows,\n     * {@code CodedInput} limits how deeply messages may be nested. The default limit is 64.\n     * \n     * @return the old limit.\n     * \n     * public int setRecursionLimit(final int limit) { if (limit < 0) { throw new IllegalArgumentException(\n     * \"Recursion limit cannot be negative: \" + limit); } final int oldLimit = recursionLimit; recursionLimit = limit;\n     * return oldLimit; }\n     */\n\n    /**\n     * Set the maximum message size. In order to prevent malicious messages from exhausting memory or causing integer\n     * overflows, {@code CodedInput} limits how large a message may be. The default limit is 64MB. You should set this\n     * limit as small as you can without harming your app's functionality. Note that size limits only apply when reading\n     * from an {@code InputStream}, not when constructed around a raw byte array.\n     * <p>\n     * If you want to read several messages from a single CodedInput, you could call {@link #resetSizeCounter()} after\n     * each one to avoid hitting the size limit.\n     *\n     * @return the old limit.\n     */\n    public int setSizeLimit(final int limit)\n    {\n        if (limit < 0)\n        {\n            throw new IllegalArgumentException(\n                    \"Size limit cannot be negative: \" + limit);\n        }\n        final int oldLimit = sizeLimit;\n        sizeLimit = limit;\n        return oldLimit;\n    }\n\n    /**\n     * Resets the current size counter to zero (see {@link #setSizeLimit(int)}). The field {@code totalBytesRetired}\n     * will be negative if the initial position was not zero.\n     */\n    public void resetSizeCounter()\n    {\n        totalBytesRetired = -bufferPos;\n    }\n\n    /**\n     * Resets the buffer position and limit to re-use this CodedInput object.\n     */\n    public void reset()\n    {\n        this.bufferSize = 0;\n        this.bufferPos = 0;\n        this.bufferSizeAfterLimit = 0;\n        this.currentLimit = Integer.MAX_VALUE;\n        this.lastTag = 0;\n        this.packedLimit = 0;\n        this.sizeLimit = DEFAULT_SIZE_LIMIT;\n        resetSizeCounter();\n    }\n\n    /**\n     * Note that {@code pushLimit()} does NOT affect how many bytes the {@code CodedInputStream} reads from an\n     * underlying {@code InputStream} when refreshing its buffer. If you need to prevent reading past a certain point in\n     * the underlying {@code InputStream} (e.g. because you expect it to contain more data after the end of the message\n     * which you need to handle differently) then you must place a wrapper around your {@code InputStream} which limits\n     * the amount of data that can be read from it.\n     *\n     * @return the old limit.\n     */\n    public int pushLimit(int byteLimit) throws ProtobufException\n    {\n        if (byteLimit < 0)\n        {\n            throw ProtobufException.negativeSize();\n        }\n        byteLimit += totalBytesRetired + bufferPos;\n        final int oldLimit = currentLimit;\n        if (byteLimit > oldLimit)\n        {\n            throw ProtobufException.truncatedMessage();\n        }\n        currentLimit = byteLimit;\n\n        recomputeBufferSizeAfterLimit();\n\n        return oldLimit;\n    }\n\n    private void recomputeBufferSizeAfterLimit()\n    {\n        bufferSize += bufferSizeAfterLimit;\n        final int bufferEnd = totalBytesRetired + bufferSize;\n        if (bufferEnd > currentLimit)\n        {\n            // Limit is in current buffer.\n            bufferSizeAfterLimit = bufferEnd - currentLimit;\n            bufferSize -= bufferSizeAfterLimit;\n        }\n        else\n        {\n            bufferSizeAfterLimit = 0;\n        }\n    }\n\n    /**\n     * Discards the current limit, returning to the previous limit.\n     *\n     * @param oldLimit\n     *            The old limit, as returned by {@code pushLimit}.\n     */\n    public void popLimit(final int oldLimit)\n    {\n        currentLimit = oldLimit;\n        recomputeBufferSizeAfterLimit();\n    }\n\n    /**\n     * Returns the number of bytes to be read before the current limit. If no limit is set, returns -1.\n     */\n    public int getBytesUntilLimit()\n    {\n        if (currentLimit == Integer.MAX_VALUE)\n        {\n            return -1;\n        }\n\n        final int currentAbsolutePosition = totalBytesRetired + bufferPos;\n        return currentLimit - currentAbsolutePosition;\n    }\n\n    /**\n     * Return true if currently reading packed field\n     */\n    public boolean isCurrentFieldPacked()\n    {\n        return packedLimit != 0 && packedLimit != getTotalBytesRead();\n    }\n\n    /**\n     * Returns true if the stream has reached the end of the input. This is the case if either the end of the underlying\n     * input source has been reached or if the stream has reached a limit created using {@link #pushLimit(int)}.\n     */\n    public boolean isAtEnd() throws IOException\n    {\n        return bufferPos == bufferSize && !refillBuffer(false);\n    }\n\n    /**\n     * The total bytes read up to the current position. Calling {@link #resetSizeCounter()} resets this value to zero.\n     */\n    public int getTotalBytesRead()\n    {\n        return totalBytesRetired + bufferPos;\n    }\n\n    /**\n     * Called with {@code this.buffer} is empty to read more bytes from the input. If {@code mustSucceed} is true,\n     * refillBuffer() guarantees that either there will be at least one byte in the buffer when it returns or it will\n     * throw an exception. If {@code mustSucceed} is false, refillBuffer() returns false if no more bytes were\n     * available.\n     */\n    private boolean refillBuffer(final boolean mustSucceed) throws IOException\n    {\n        if (bufferPos < bufferSize)\n        {\n            throw new IllegalStateException(\n                    \"refillBuffer() called when buffer wasn't empty.\");\n        }\n\n        if (totalBytesRetired + bufferSize == currentLimit)\n        {\n            // Oops, we hit a limit.\n            if (mustSucceed)\n            {\n                throw ProtobufException.truncatedMessage();\n            }\n            else\n            {\n                return false;\n            }\n        }\n\n        totalBytesRetired += bufferSize;\n\n        bufferPos = 0;\n        bufferSize = (input == null) ? -1 : input.read(buffer);\n        if (bufferSize == 0 || bufferSize < -1)\n        {\n            throw new IllegalStateException(\n                    \"InputStream#read(byte[]) returned invalid result: \" + bufferSize +\n                            \"\\nThe InputStream implementation is buggy.\");\n        }\n        if (bufferSize == -1)\n        {\n            bufferSize = 0;\n            if (mustSucceed)\n            {\n                throw ProtobufException.truncatedMessage();\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else\n        {\n            recomputeBufferSizeAfterLimit();\n            final int totalBytesRead =\n                    totalBytesRetired + bufferSize + bufferSizeAfterLimit;\n            if (totalBytesRead > sizeLimit || totalBytesRead < 0)\n            {\n                throw ProtobufException.sizeLimitExceeded();\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Read one byte from the input.\n     *\n     * @throws ProtobufException\n     *             The end of the stream or the current limit was reached.\n     */\n    public byte readRawByte() throws IOException\n    {\n        if (bufferPos == bufferSize)\n        {\n            refillBuffer(true);\n        }\n        return buffer[bufferPos++];\n    }\n\n    /**\n     * Read a fixed size of bytes from the input.\n     *\n     * @throws ProtobufException\n     *             The end of the stream or the current limit was reached.\n     */\n    public byte[] readRawBytes(final int size) throws IOException\n    {\n        if (size < 0)\n        {\n            throw ProtobufException.negativeSize();\n        }\n\n        if (totalBytesRetired + bufferPos + size > currentLimit)\n        {\n            // Read to the end of the stream anyway.\n            skipRawBytes(currentLimit - totalBytesRetired - bufferPos);\n            // Then fail.\n            throw ProtobufException.truncatedMessage();\n        }\n\n        if (size <= bufferSize - bufferPos)\n        {\n            // We have all the bytes we need already.\n            final byte[] bytes = new byte[size];\n            System.arraycopy(buffer, bufferPos, bytes, 0, size);\n            bufferPos += size;\n            return bytes;\n        }\n        else if (size < buffer.length)\n        {\n            // Reading more bytes than are in the buffer, but not an excessive number\n            // of bytes. We can safely allocate the resulting array ahead of time.\n\n            // First copy what we have.\n            final byte[] bytes = new byte[size];\n            int pos = bufferSize - bufferPos;\n            System.arraycopy(buffer, bufferPos, bytes, 0, pos);\n            bufferPos = bufferSize;\n\n            // We want to use refillBuffer() and then copy from the buffer into our\n            // byte array rather than reading directly into our byte array because\n            // the input may be unbuffered.\n            refillBuffer(true);\n\n            while (size - pos > bufferSize)\n            {\n                System.arraycopy(buffer, 0, bytes, pos, bufferSize);\n                pos += bufferSize;\n                bufferPos = bufferSize;\n                refillBuffer(true);\n            }\n\n            System.arraycopy(buffer, 0, bytes, pos, size - pos);\n            bufferPos = size - pos;\n\n            return bytes;\n        }\n        else\n        {\n            // The size is very large. For security reasons, we can't allocate the\n            // entire byte array yet. The size comes directly from the input, so a\n            // maliciously-crafted message could provide a bogus very large size in\n            // order to trick the app into allocating a lot of memory. We avoid this\n            // by allocating and reading only a small chunk at a time, so that the\n            // malicious message must actually *be* extremely large to cause\n            // problems. Meanwhile, we limit the allowed size of a message elsewhere.\n\n            // Remember the buffer markers since we'll have to copy the bytes out of\n            // it later.\n            final int originalBufferPos = bufferPos;\n            final int originalBufferSize = bufferSize;\n\n            // Mark the current buffer consumed.\n            totalBytesRetired += bufferSize;\n            bufferPos = 0;\n            bufferSize = 0;\n\n            // Read all the rest of the bytes we need.\n            int sizeLeft = size - (originalBufferSize - originalBufferPos);\n            final List<byte[]> chunks = new ArrayList<byte[]>();\n\n            while (sizeLeft > 0)\n            {\n                final byte[] chunk = new byte[Math.min(sizeLeft, buffer.length)];\n                int pos = 0;\n                while (pos < chunk.length)\n                {\n                    final int n = (input == null) ? -1 :\n                            input.read(chunk, pos, chunk.length - pos);\n                    if (n == -1)\n                    {\n                        throw ProtobufException.truncatedMessage();\n                    }\n                    totalBytesRetired += n;\n                    pos += n;\n                }\n                sizeLeft -= chunk.length;\n                chunks.add(chunk);\n            }\n\n            // OK, got everything. Now concatenate it all into one buffer.\n            final byte[] bytes = new byte[size];\n\n            // Start by copying the leftover bytes from this.buffer.\n            int pos = originalBufferSize - originalBufferPos;\n            System.arraycopy(buffer, originalBufferPos, bytes, 0, pos);\n\n            // And now all the chunks.\n            for (final byte[] chunk : chunks)\n            {\n                System.arraycopy(chunk, 0, bytes, pos, chunk.length);\n                pos += chunk.length;\n            }\n\n            // Done.\n            return bytes;\n        }\n    }\n\n    /**\n     * Reads and discards {@code size} bytes.\n     *\n     * @throws ProtobufException\n     *             The end of the stream or the current limit was reached.\n     */\n    public void skipRawBytes(final int size) throws IOException\n    {\n        if (size < 0)\n        {\n            throw ProtobufException.negativeSize();\n        }\n\n        if (totalBytesRetired + bufferPos + size > currentLimit)\n        {\n            // Read to the end of the stream anyway.\n            skipRawBytes(currentLimit - totalBytesRetired - bufferPos);\n            // Then fail.\n            throw ProtobufException.truncatedMessage();\n        }\n\n        if (size <= bufferSize - bufferPos)\n        {\n            // We have all the bytes we need already.\n            bufferPos += size;\n        }\n        else\n        {\n            // Skipping more bytes than are in the buffer. First skip what we have.\n            int pos = bufferSize - bufferPos;\n            bufferPos = bufferSize;\n\n            // Keep refilling the buffer until we get to the point we wanted to skip\n            // to. This has the side effect of ensuring the limits are updated\n            // correctly.\n            refillBuffer(true);\n            while (size - pos > bufferSize)\n            {\n                pos += bufferSize;\n                bufferPos = bufferSize;\n                refillBuffer(true);\n            }\n\n            bufferPos = size - pos;\n        }\n    }\n\n    // START EXTRA\n    @Override\n    public <T> int readFieldNumber(Schema<T> schema) throws IOException\n    {\n        if (isAtEnd())\n        {\n            lastTag = 0;\n            return 0;\n        }\n\n        // are we reading packed field?\n        if (isCurrentFieldPacked())\n        {\n            if (packedLimit < getTotalBytesRead())\n                throw ProtobufException.misreportedSize();\n\n            // Return field number while reading packed field\n            return lastTag >>> TAG_TYPE_BITS;\n        }\n\n        packedLimit = 0;\n        final int tag = readRawVarint32();\n        final int fieldNumber = tag >>> TAG_TYPE_BITS;\n        if (fieldNumber == 0)\n        {\n            if (decodeNestedMessageAsGroup && WIRETYPE_TAIL_DELIMITER == (tag & TAG_TYPE_MASK))\n            {\n                // protostuff's tail delimiter for streaming\n                // 2 options: length-delimited or tail-delimited.\n                lastTag = 0;\n                return 0;\n            }\n            // If we actually read zero, that's not a valid tag.\n            throw ProtobufException.invalidTag();\n        }\n        if (decodeNestedMessageAsGroup && WIRETYPE_END_GROUP == (tag & TAG_TYPE_MASK))\n        {\n            lastTag = 0;\n            return 0;\n        }\n\n        lastTag = tag;\n        return fieldNumber;\n    }\n\n    /**\n     * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that\n     * packed fields are being read.\n     *\n     * @throws IOException\n     */\n    private void checkIfPackedField() throws IOException\n    {\n        // Do we have the start of a packed field?\n        if (packedLimit == 0 && WireFormat.getTagWireType(lastTag) == WIRETYPE_LENGTH_DELIMITED)\n        {\n            final int length = readRawVarint32();\n            if (length < 0)\n                throw ProtobufException.negativeSize();\n\n            this.packedLimit = getTotalBytesRead() + length;\n        }\n    }\n\n    @Override\n    public byte[] readByteArray() throws IOException\n    {\n        final int size = readRawVarint32();\n        if (size <= (bufferSize - bufferPos) && size > 0)\n        {\n            // Fast path: We already have the bytes in a contiguous buffer, so\n            // just copy directly from it.\n            final byte[] copy = new byte[size];\n            System.arraycopy(buffer, bufferPos, copy, 0, size);\n            bufferPos += size;\n            return copy;\n        }\n        else\n        {\n            // Slow path: Build a byte array first then copy it.\n            return readRawBytes(size);\n        }\n    }\n\n    @Override\n    public <T> void handleUnknownField(int fieldNumber, Schema<T> schema) throws IOException\n    {\n        skipField(lastTag);\n    }\n\n    @Override\n    public void transferByteRangeTo(Output output, boolean utf8String, int fieldNumber,\n            boolean repeated) throws IOException\n    {\n        final int size = readRawVarint32();\n        if (size <= (bufferSize - bufferPos) && size > 0)\n        {\n            // Fast path: We already have the bytes in a contiguous buffer\n            output.writeByteRange(utf8String, fieldNumber, buffer, bufferPos, size, repeated);\n            bufferPos += size;\n        }\n        else\n        {\n            // Slow path: Build a byte array first then copy it.\n            output.writeByteRange(utf8String, fieldNumber, readRawBytes(size), 0, size, repeated);\n        }\n    }\n\n    /**\n     * Returns the last tag.\n     */\n    public int getLastTag()\n    {\n        return lastTag;\n    }\n\n    /**\n     * Reads a byte array/ByteBuffer value.\n     */\n    @Override\n    public ByteBuffer readByteBuffer() throws IOException\n    {\n        return ByteBuffer.wrap(readByteArray());\n    }\n\n    // END EXTRA\n}\n",
            "file_name": "CodedInput.java",
            "human_label": "Read string from a buffer.",
            "level": "project_runnable",
            "lineno": "272",
            "name": "readString",
            "oracle_context": "{ \"apis\" : \"[readRawVarint32, deser, readRawBytes]\", \"classes\" : \"[String]\", \"vars\" : \"[bufferSize, bufferPos, buffer]\" }",
            "package": "io.protostuff",
            "project": "protostuff-master"
        },
        {
            "_id": "6367667d1a6d9265ec017401",
            "all_context": "{ \"class_level\" : \"import java.io.IOException;\\nimport java.io.StringWriter;\\nimport java.io.Writer;\\nimport java.util.Locale;\\nStringEscapeUtils();\\nescapeJava(Writer out,String str);\\nescapeJavaScript(String str);\\nescapeJavaScript(Writer out,String str);\\nescapeJavaStyleString(String str,boolean escapeSingleQuotes,boolean escapeForwardSlash);\\nescapeJavaStyleString(Writer out,String str,boolean escapeSingleQuote,boolean escapeForwardSlash);\\nhex(char ch);\\nunescapeJava(String str);\\nunescapeJava(Writer out,String str);\\nunescapeJavaScript(String str);\\nunescapeJavaScript(Writer out,String str);\\nescapeJava(String str);\\n\", \"repo_level\" : \"\" }",
            "class_name": "StringEscapeUtils",
            "code": "public static String unescapeJava(String str) throws Exception {\n  if (str == null) {\n    return null;\n  }\n  StringWriter writer=new StringWriter(str.length());\n  unescapeJava(writer,str);\n  return writer.toString();\n}\n",
            "docstring": "/** \n * <p>Unescapes any Java literals found in the <code>String</code>. For example, it will turn a sequence of <code>'\\'</code> and <code>'n'</code> into a newline character, unless the <code>'\\'</code> is preceded by another <code>'\\'</code>.</p>\n * @param str the <code>String</code> to unescape, may be null\n * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n */\n",
            "end_lineno": "300",
            "file_content": "/*\n* Licensed to the Apache Software Foundation (ASF) under one or more\n* contributor license agreements.  See the NOTICE file distributed with\n* this work for additional information regarding copyright ownership.\n* The ASF licenses this file to You under the Apache License, Version 2.0\n* (the \"License\"); you may not use this file except in compliance with\n* the License.  You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n* Modified from original form by Tim Fox\n*/\n/*\n * Copyright 2021 Async-IO.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.atmosphere.util;\n\n\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.util.Locale;\n\n/**\n *\n * Adapted from Apache Commons code\n *\n *\n * <p>Escapes and unescapes <code>String</code>s for\n * Java, Java Script, HTML, XML, and SQL.</p>\n * <p/>\n * <p>#ThreadSafe#</p>\n *\n * @author Apache Software Foundation\n * @author Apache Jakarta Turbine\n * @author Purple Technology\n * @author <a href=\"mailto:alex@purpletech.com\">Alexander Day Chaffee</a>\n * @author Antony Riley\n * @author Helge Tesgaard\n * @author <a href=\"sean@boohai.com\">Sean Brown</a>\n * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n * @author Phil Steitz\n * @author Pete Gieser\n * @version $Id: StringEscapeUtils.java 1057072 2011-01-10 01:55:57Z niallp $\n * @since 2.0\n */\npublic class StringEscapeUtils {\n\n  /**\n   * <p><code>StringEscapeUtils</code> instances should NOT be constructed in\n   * standard programming.</p>\n   * <p/>\n   * <p>Instead, the class should be used as:\n   * <pre>StringEscapeUtils.escapeJava(\"foo\");</pre></p>\n   * <p/>\n   * <p>This constructor is public to permit tools that require a JavaBean\n   * instance to operate.</p>\n   */\n  public StringEscapeUtils() {\n    super();\n  }\n\n  // Java and JavaScript\n  //--------------------------------------------------------------------------\n\n  /**\n   * <p>Escapes the characters in a <code>String</code> using Java String rules.</p>\n   * <p/>\n   * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n   * <p/>\n   * <p>So a tab becomes the characters <code>'\\\\'</code> and\n   * <code>'t'</code>.</p>\n   * <p/>\n   * <p>The only difference between Java strings and JavaScript strings\n   * is that in JavaScript, a single quote must be escaped.</p>\n   * <p/>\n   * <p>Example:\n   * <pre>\n   * input string: He didn't say, \"Stop!\"\n   * output string: He didn't say, \\\"Stop!\\\"\n   * </pre>\n   * </p>\n   *\n   * @param str String to escape values in, may be null\n   * @return String with escaped values, <code>null</code> if null string input\n   */\n  public static String escapeJava(String str) throws Exception {\n    return escapeJavaStyleString(str, false, false);\n  }\n\n  /**\n   * <p>Escapes the characters in a <code>String</code> using Java String rules to\n   * a <code>Writer</code>.</p>\n   * <p/>\n   * <p>A <code>null</code> string input has no effect.</p>\n   *\n   * @param out Writer to write escaped string into\n   * @param str String to escape values in, may be null\n   * @throws IllegalArgumentException if the Writer is <code>null</code>\n   * @throws IOException              if error occurs on underlying Writer\n   * @see #escapeJava(java.lang.String)\n   */\n  public static void escapeJava(Writer out, String str) throws IOException {\n    escapeJavaStyleString(out, str, false, false);\n  }\n\n  /**\n   * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n   * <p>Escapes any values it finds into their JavaScript String form.\n   * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n   * <p/>\n   * <p>So a tab becomes the characters <code>'\\\\'</code> and\n   * <code>'t'</code>.</p>\n   * <p/>\n   * <p>The only difference between Java strings and JavaScript strings\n   * is that in JavaScript, a single quote must be escaped.</p>\n   * <p/>\n   * <p>Example:\n   * <pre>\n   * input string: He didn't say, \"Stop!\"\n   * output string: He didn\\'t say, \\\"Stop!\\\"\n   * </pre>\n   * </p>\n   *\n   * @param str String to escape values in, may be null\n   * @return String with escaped values, <code>null</code> if null string input\n   */\n  public static String escapeJavaScript(String str) throws Exception {\n    return escapeJavaStyleString(str, true, true);\n  }\n\n  /**\n   * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n   * to a <code>Writer</code>.</p>\n   * <p/>\n   * <p>A <code>null</code> string input has no effect.</p>\n   *\n   * @param out Writer to write escaped string into\n   * @param str String to escape values in, may be null\n   * @throws IllegalArgumentException if the Writer is <code>null</code>\n   * @throws IOException              if error occurs on underlying Writer\n   * @see #escapeJavaScript(java.lang.String)\n   */\n  public static void escapeJavaScript(Writer out, String str) throws Exception {\n    escapeJavaStyleString(out, str, true, true);\n  }\n\n  /**\n   * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n   *\n   * @param str                String to escape values in, may be null\n   * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n   * @param escapeForwardSlash TODO\n   * @return the escaped string\n   */\n  private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash)\n      throws Exception {\n    if (str == null) {\n      return null;\n    }\n    StringWriter writer = new StringWriter(str.length() * 2);\n    escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);\n    return writer.toString();\n  }\n\n  /**\n   * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n   *\n   * @param out                write to receieve the escaped string\n   * @param str                String to escape values in, may be null\n   * @param escapeSingleQuote  escapes single quotes if <code>true</code>\n   * @param escapeForwardSlash TODO\n   * @throws IOException if an IOException occurs\n   */\n  private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,\n                                            boolean escapeForwardSlash) throws IOException {\n    if (out == null) {\n      throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (str == null) {\n      return;\n    }\n    int sz;\n    sz = str.length();\n    for (int i = 0; i < sz; i++) {\n      char ch = str.charAt(i);\n\n      // handle unicode\n      if (ch > 0xfff) {\n        out.write(\"\\\\u\" + hex(ch));\n      } else if (ch > 0xff) {\n        out.write(\"\\\\u0\" + hex(ch));\n      } else if (ch > 0x7f) {\n        out.write(\"\\\\u00\" + hex(ch));\n      } else if (ch < 32) {\n        switch (ch) {\n          case '\\b':\n            out.write('\\\\');\n            out.write('b');\n            break;\n          case '\\n':\n            out.write('\\\\');\n            out.write('n');\n            break;\n          case '\\t':\n            out.write('\\\\');\n            out.write('t');\n            break;\n          case '\\f':\n            out.write('\\\\');\n            out.write('f');\n            break;\n          case '\\r':\n            out.write('\\\\');\n            out.write('r');\n            break;\n          default:\n            if (ch > 0xf) {\n              out.write(\"\\\\u00\" + hex(ch));\n            } else {\n              out.write(\"\\\\u000\" + hex(ch));\n            }\n            break;\n        }\n      } else {\n        switch (ch) {\n          case '\\'':\n            if (escapeSingleQuote) {\n              out.write('\\\\');\n            }\n            out.write('\\'');\n            break;\n          case '\"':\n            out.write('\\\\');\n            out.write('\"');\n            break;\n          case '\\\\':\n            out.write('\\\\');\n            out.write('\\\\');\n            break;\n          case '/':\n            if (escapeForwardSlash) {\n              out.write('\\\\');\n            }\n            out.write('/');\n            break;\n          default:\n            out.write(ch);\n            break;\n        }\n      }\n    }\n  }\n\n  /**\n   * <p>Returns an upper case hexadecimal <code>String</code> for the given\n   * character.</p>\n   *\n   * @param ch The character to convert.\n   * @return An upper case hexadecimal <code>String</code>\n   */\n  private static String hex(char ch) {\n    return Integer.toHexString(ch).toUpperCase(Locale.ENGLISH);\n  }\n\n  /**\n   * <p>Unescapes any Java literals found in the <code>String</code>.\n   * For example, it will turn a sequence of <code>'\\'</code> and\n   * <code>'n'</code> into a newline character, unless the <code>'\\'</code>\n   * is preceded by another <code>'\\'</code>.</p>\n   *\n   * @param str the <code>String</code> to unescape, may be null\n   * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n   */\n  public static String unescapeJava(String str) throws Exception {\n    if (str == null) {\n      return null;\n    }\n    StringWriter writer = new StringWriter(str.length());\n    unescapeJava(writer, str);\n    return writer.toString();\n  }\n\n  /**\n   * <p>Unescapes any Java literals found in the <code>String</code> to a\n   * <code>Writer</code>.</p>\n   * <p/>\n   * <p>For example, it will turn a sequence of <code>'\\'</code> and\n   * <code>'n'</code> into a newline character, unless the <code>'\\'</code>\n   * is preceded by another <code>'\\'</code>.</p>\n   * <p/>\n   * <p>A <code>null</code> string input has no effect.</p>\n   *\n   * @param out the <code>Writer</code> used to output unescaped characters\n   * @param str the <code>String</code> to unescape, may be null\n   * @throws IllegalArgumentException if the Writer is <code>null</code>\n   * @throws IOException              if error occurs on underlying Writer\n   */\n  public static void unescapeJava(Writer out, String str) throws Exception {\n    if (out == null) {\n      throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (str == null) {\n      return;\n    }\n    int sz = str.length();\n    StringBuilder unicode = new StringBuilder();\n    boolean hadSlash = false;\n    boolean inUnicode = false;\n    for (int i = 0; i < sz; i++) {\n      char ch = str.charAt(i);\n      if (inUnicode) {\n        // if in unicode, then we're reading unicode\n        // values in somehow\n        unicode.append(ch);\n        if (unicode.length() == 4) {\n          // unicode now contains the four hex digits\n          // which represents our unicode character\n          int value = Integer.parseInt(unicode.toString(), 16);\n          out.write((char) value);\n          unicode.setLength(0);\n          inUnicode = false;\n          hadSlash = false;\n        }\n        continue;\n      }\n      if (hadSlash) {\n        // handle an escaped value\n        hadSlash = false;\n        switch (ch) {\n          case '\\\\':\n            out.write('\\\\');\n            break;\n          case '\\'':\n            out.write('\\'');\n            break;\n          case '\\\"':\n            out.write('\"');\n            break;\n          case 'r':\n            out.write('\\r');\n            break;\n          case 'f':\n            out.write('\\f');\n            break;\n          case 't':\n            out.write('\\t');\n            break;\n          case 'n':\n            out.write('\\n');\n            break;\n          case 'b':\n            out.write('\\b');\n            break;\n          case 'u': {\n            // uh-oh, we're in unicode country....\n            inUnicode = true;\n            break;\n          }\n          default:\n            out.write(ch);\n            break;\n        }\n        continue;\n      } else if (ch == '\\\\') {\n        hadSlash = true;\n        continue;\n      }\n      out.write(ch);\n    }\n    if (hadSlash) {\n      // then we're in the weird case of a \\ at the end of the\n      // string, let's output it anyway.\n      out.write('\\\\');\n    }\n  }\n\n  /**\n   * <p>Unescapes any JavaScript literals found in the <code>String</code>.</p>\n   * <p/>\n   * <p>For example, it will turn a sequence of <code>'\\'</code> and <code>'n'</code>\n   * into a newline character, unless the <code>'\\'</code> is preceded by another\n   * <code>'\\'</code>.</p>\n   *\n   * @param str the <code>String</code> to unescape, may be null\n   * @return A new unescaped <code>String</code>, <code>null</code> if null string input\n   * @see #unescapeJava(String)\n   */\n  public static String unescapeJavaScript(String str) throws Exception {\n    return unescapeJava(str);\n  }\n\n  /**\n   * <p>Unescapes any JavaScript literals found in the <code>String</code> to a\n   * <code>Writer</code>.</p>\n   * <p/>\n   * <p>For example, it will turn a sequence of <code>'\\'</code> and <code>'n'</code>\n   * into a newline character, unless the <code>'\\'</code> is preceded by another\n   * <code>'\\'</code>.</p>\n   * <p/>\n   * <p>A <code>null</code> string input has no effect.</p>\n   *\n   * @param out the <code>Writer</code> used to output unescaped characters\n   * @param str the <code>String</code> to unescape, may be null\n   * @throws IllegalArgumentException if the Writer is <code>null</code>\n   * @throws IOException              if error occurs on underlying Writer\n   * @see #unescapeJava(Writer, String)\n   */\n  public static void unescapeJavaScript(Writer out, String str) throws Exception {\n    unescapeJava(out, str);\n  }\n\n}\n\n\n\n\n\n",
            "file_name": "StringEscapeUtils.java",
            "human_label": "Unescapes Java that found in the String.",
            "level": "slib_runnable",
            "lineno": "284",
            "name": "unescapeJava",
            "oracle_context": "{ \"apis\" : \"[length, toString]\", \"classes\" : \"[StringWriter]\", \"vars\" : \"[]\" }",
            "package": "org.atmosphere.util",
            "project": "atmosphere-atmosphere-2.7.x"
        },
        {
            "_id": "636766f01a6d9265ec01763e",
            "all_context": "{ \"class_level\" : \"import java.io.ByteArrayOutputStream;\\nimport java.io.IOException;\\nimport java.io.UnsupportedEncodingException;\\nimport java.util.HashMap;\\nimport java.util.Locale;\\nimport java.util.Map;\\nString US_ASCII_CHARSET;\\nString BASE64_ENCODING_MARKER;\\nString QUOTEDPRINTABLE_ENCODING_MARKER;\\nString ENCODED_TOKEN_MARKER;\\nString ENCODED_TOKEN_FINISHER;\\nString LINEAR_WHITESPACE;\\nMap<String,String> MIME2JAVA;\\nMimeUtility();\\ndecodeWord(String word);\\njavaCharset(String charset);\\ndecodeText(String text);\\n\", \"repo_level\" : \"\" }",
            "class_name": "MimeUtility",
            "code": "private static String javaCharset(String charset){\n  if (charset == null) {\n    return null;\n  }\n  String mappedCharset=MIME2JAVA.get(charset.toLowerCase(Locale.ENGLISH));\n  if (mappedCharset == null) {\n    return charset;\n  }\n  return mappedCharset;\n}\n",
            "docstring": "/** \n * Translate a MIME standard character set name into the Java equivalent.\n * @param charset The MIME standard name.\n * @return The Java equivalent for this name.\n */\n",
            "end_lineno": "248",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.web.upload.util;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\n/**\n * Utility class to decode MIME texts.\n * @since 1.3\n */\npublic final class MimeUtility {\n    /**\n     * The {@code US-ASCII} charset identifier constant.\n     */\n    private static final String              US_ASCII_CHARSET                = \"US-ASCII\";\n    /**\n     * The marker to indicate text is encoded with BASE64 algorithm.\n     */\n    private static final String              BASE64_ENCODING_MARKER          = \"B\";\n    /**\n     * The marker to indicate text is encoded with QuotedPrintable algorithm.\n     */\n    private static final String              QUOTEDPRINTABLE_ENCODING_MARKER = \"Q\";\n    /**\n     * If the text contains any encoded tokens, those tokens will be marked with \"=?\".\n     */\n    private static final String              ENCODED_TOKEN_MARKER            = \"=?\";\n    /**\n     * If the text contains any encoded tokens, those tokens will terminate with \"=?\".\n     */\n    private static final String              ENCODED_TOKEN_FINISHER          = \"?=\";\n    /**\n     * The linear whitespace chars sequence.\n     */\n    private static final String              LINEAR_WHITESPACE               = \" \\t\\r\\n\";\n    /**\n     * Mappings between MIME and Java charset.\n     */\n    private static final Map<String, String> MIME2JAVA                       = new HashMap<String, String>();\n\n    static {\n        MIME2JAVA.put(\"iso-2022-cn\", \"ISO2022CN\");\n        MIME2JAVA.put(\"iso-2022-kr\", \"ISO2022KR\");\n        MIME2JAVA.put(\"utf-8\", \"UTF8\");\n        MIME2JAVA.put(\"utf8\", \"UTF8\");\n        MIME2JAVA.put(\"ja_jp.iso2022-7\", \"ISO2022JP\");\n        MIME2JAVA.put(\"ja_jp.eucjp\", \"EUCJIS\");\n        MIME2JAVA.put(\"euc-kr\", \"KSC5601\");\n        MIME2JAVA.put(\"euckr\", \"KSC5601\");\n        MIME2JAVA.put(\"us-ascii\", \"ISO-8859-1\");\n        MIME2JAVA.put(\"x-us-ascii\", \"ISO-8859-1\");\n    }\n\n    /**\n     * Hidden constructor, this class must not be instantiated.\n     */\n    private MimeUtility() {\n        // do nothing\n    }\n\n    /**\n     * Decode a string of text obtained from a mail header into\n     * its proper form.  The text generally will consist of a\n     * string of tokens, some of which may be encoded using\n     * base64 encoding.\n     *\n     * @param text   The text to decode.\n     *\n     * @return The decoded text string.\n     * @throws UnsupportedEncodingException if the detected encoding in the input text is not supported.\n     */\n    public static String decodeText(String text) throws UnsupportedEncodingException {\n        // if the text contains any encoded tokens, those tokens will be marked with \"=?\".  If the\n        // source string doesn't contain that sequent, no decoding is required.\n        if (text.indexOf(ENCODED_TOKEN_MARKER) < 0) {\n            return text;\n        }\n        int offset = 0;\n        int endOffset = text.length();\n        int startWhiteSpace = -1;\n        int endWhiteSpace = -1;\n        StringBuilder decodedText = new StringBuilder(text.length());\n        boolean previousTokenEncoded = false;\n        while (offset < endOffset) {\n            char ch = text.charAt(offset);\n            // is this a whitespace character?\n            if (LINEAR_WHITESPACE.indexOf(ch) != -1) { // whitespace found\n                startWhiteSpace = offset;\n                while (offset < endOffset) {\n                    // step over the white space characters.\n                    ch = text.charAt(offset);\n                    if (LINEAR_WHITESPACE.indexOf(ch) != -1) { // whitespace found\n                        offset++;\n                    } else {\n                        // record the location of the first non lwsp and drop down to process the\n                        // token characters.\n                        endWhiteSpace = offset;\n                        break;\n                    }\n                }\n            } else {\n                // we have a word token.  We need to scan over the word and then try to parse it.\n                int wordStart = offset;\n                while (offset < endOffset) {\n                    // step over the non white space characters.\n                    ch = text.charAt(offset);\n                    if (LINEAR_WHITESPACE.indexOf(ch) == -1) { // not white space\n                        offset++;\n                    } else {\n                        break;\n                    }\n                    //NB:  Trailing whitespace on these header strings will just be discarded.\n                }\n                // pull out the word token.\n                String word = text.substring(wordStart, offset);\n                // is the token encoded?  decode the word\n                if (word.startsWith(ENCODED_TOKEN_MARKER)) {\n                    try {\n                        // if this gives a parsing failure, treat it like a non-encoded word.\n                        String decodedWord = decodeWord(word);\n                        // are any whitespace characters significant?  Append 'em if we've got 'em.\n                        if (!previousTokenEncoded && startWhiteSpace != -1) {\n                            decodedText.append(text.substring(startWhiteSpace, endWhiteSpace));\n                            startWhiteSpace = -1;\n                        }\n                        // this is definitely a decoded token.\n                        previousTokenEncoded = true;\n                        // and add this to the text.\n                        decodedText.append(decodedWord);\n                        // we continue parsing from here...we allow parsing errors to fall through\n                        // and get handled as normal text.\n                        continue;\n                    } catch (IllegalArgumentException e) {\n                        // just ignore it, skip to next word\n                    }\n                }\n                // this is a normal token, so it doesn't matter what the previous token was.  Add the white space\n                // if we have it.\n                if (startWhiteSpace != -1) {\n                    decodedText.append(text.substring(startWhiteSpace, endWhiteSpace));\n                    startWhiteSpace = -1;\n                }\n                // this is not a decoded token.\n                previousTokenEncoded = false;\n                decodedText.append(word);\n            }\n        }\n        return decodedText.toString();\n    }\n\n    /**\n     * Parse a string using the RFC 2047 rules for an \"encoded-word\"\n     * type.  This encoding has the syntax:\n     *\n     * encoded-word = \"=?\" charset \"?\" encoding \"?\" encoded-text \"?=\"\n     *\n     * @param word   The possibly encoded word value.\n     *\n     * @return The decoded word.\n     * @throws UnsupportedEncodingException\n     */\n    private static String decodeWord(String word) throws UnsupportedEncodingException {\n        // encoded words start with the characters \"=?\".  If this not an encoded word, we throw a\n        // ParseException for the caller.\n        if (!word.startsWith(ENCODED_TOKEN_MARKER)) {\n            throw new UnsupportedEncodingException(\"Invalid RFC 2047 encoded-word: \" + word);\n        }\n        int charsetPos = word.indexOf('?', 2);\n        if (charsetPos == -1) {\n            throw new UnsupportedEncodingException(\"Missing charset in RFC 2047 encoded-word: \" + word);\n        }\n        // pull out the character set information (this is the MIME name at this point).\n        String charset = word.substring(2, charsetPos).toLowerCase();\n        // now pull out the encoding token the same way.\n        int encodingPos = word.indexOf('?', charsetPos + 1);\n        if (encodingPos == -1) {\n            throw new UnsupportedEncodingException(\"Missing encoding in RFC 2047 encoded-word: \" + word);\n        }\n        String encoding = word.substring(charsetPos + 1, encodingPos);\n        // and finally the encoded text.\n        int encodedTextPos = word.indexOf(ENCODED_TOKEN_FINISHER, encodingPos + 1);\n        if (encodedTextPos == -1) {\n            throw new UnsupportedEncodingException(\"Missing encoded text in RFC 2047 encoded-word: \" + word);\n        }\n        String encodedText = word.substring(encodingPos + 1, encodedTextPos);\n        // seems a bit silly to encode a null string, but easy to deal with.\n        if (encodedText.length() == 0) {\n            return \"\";\n        }\n        try {\n            // the decoder writes directly to an output stream.\n            ByteArrayOutputStream out = new ByteArrayOutputStream(encodedText.length());\n            byte[] encodedData = encodedText.getBytes(US_ASCII_CHARSET);\n            // Base64 encoded?\n            if (encoding.equals(BASE64_ENCODING_MARKER)) {\n                Base64Decoder.decode(encodedData, out);\n            } else if (encoding.equals(QUOTEDPRINTABLE_ENCODING_MARKER)) { // maybe quoted printable.\n                QuotedPrintableDecoder.decode(encodedData, out);\n            } else {\n                throw new UnsupportedEncodingException(\"Unknown RFC 2047 encoding: \" + encoding);\n            }\n            // get the decoded byte data and convert into a string.\n            byte[] decodedData = out.toByteArray();\n            return new String(decodedData, javaCharset(charset));\n        } catch (IOException e) {\n            throw new UnsupportedEncodingException(\"Invalid RFC 2047 encoding\");\n        }\n    }\n\n    /**\n     * Translate a MIME standard character set name into the Java\n     * equivalent.\n     *\n     * @param charset The MIME standard name.\n     *\n     * @return The Java equivalent for this name.\n     */\n    private static String javaCharset(String charset) {\n        // nothing in, nothing out.\n        if (charset == null) {\n            return null;\n        }\n        String mappedCharset = MIME2JAVA.get(charset.toLowerCase(Locale.ENGLISH));\n        // if there is no mapping, then the original name is used.  Many of the MIME character set\n        // names map directly back into Java.  The reverse isn't necessarily true.\n        if (mappedCharset == null) {\n            return charset;\n        }\n        return mappedCharset;\n    }\n}\n",
            "file_name": "MimeUtility.java",
            "human_label": "Translate a MIME standard charset name into the Java equivalent.",
            "level": "class_runnable",
            "lineno": "228",
            "name": "javaCharset",
            "oracle_context": "{ \"apis\" : \"[get, toLowerCase]\", \"classes\" : \"[String, Locale]\", \"vars\" : \"[ENGLISH, MIME2JAVA]\" }",
            "package": "net.hasor.web.upload.util",
            "project": "hasor-master"
        },
        {
            "_id": "6367676a1a6d9265ec0181bf",
            "all_context": "{ \"class_level\" : \"import java.nio.charset.Charset;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nimport java.util.Enumeration;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Locale;\\nimport java.util.Properties;\\nimport java.util.Set;\\nimport java.util.StringTokenizer;\\nimport java.util.TreeSet;\\nString FOLDER_SEPARATOR;\\nString WINDOWS_FOLDER_SEPARATOR;\\nString TOP_PATH;\\nString CURRENT_PATH;\\nchar EXTENSION_SEPARATOR;\\nCharset UTF_8;\\nStrings();\\nhasLength(String str);\\nhasText(CharSequence str);\\nhasText(String str);\\ncontainsWhitespace(CharSequence str);\\ncontainsWhitespace(String str);\\ntrimWhitespace(String str);\\ntrimWhitespace(CharSequence str);\\nclean(String str);\\nclean(CharSequence str);\\ntrimAllWhitespace(String str);\\ntrimLeadingWhitespace(String str);\\ntrimTrailingWhitespace(String str);\\ntrimLeadingCharacter(String str,char leadingCharacter);\\ntrimTrailingCharacter(String str,char trailingCharacter);\\nstartsWithIgnoreCase(String str,String prefix);\\nendsWithIgnoreCase(String str,String suffix);\\nsubstringMatch(CharSequence str,int index,CharSequence substring);\\ncountOccurrencesOf(String str,String sub);\\nreplace(String inString,String oldPattern,String newPattern);\\ndelete(String inString,String pattern);\\ndeleteAny(String inString,String charsToDelete);\\nquote(String str);\\nquoteIfString(Object obj);\\nunqualify(String qualifiedName);\\nunqualify(String qualifiedName,char separator);\\ncapitalize(String str);\\nuncapitalize(String str);\\nchangeFirstCharacterCase(String str,boolean capitalize);\\ngetFilename(String path);\\ngetFilenameExtension(String path);\\nstripFilenameExtension(String path);\\napplyRelativePath(String path,String relativePath);\\ncleanPath(String path);\\npathEquals(String path1,String path2);\\nparseLocaleString(String localeString);\\nvalidateLocalePart(String localePart);\\ntoLanguageTag(Locale locale);\\naddStringToArray(String[] array,String str);\\nconcatenateStringArrays(String[] array1,String[] array2);\\nmergeStringArrays(String[] array1,String[] array2);\\nsortStringArray(String[] array);\\ntoStringArray(Collection collection);\\ntoStringArray(Enumeration enumeration);\\ntrimArrayElements(String[] array);\\nremoveDuplicateStrings(String[] array);\\nsplit(String toSplit,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter,String charsToDelete);\\ntokenizeToStringArray(String str,String delimiters);\\ntokenizeToStringArray(String str,String delimiters,boolean trimTokens,boolean ignoreEmptyTokens);\\ndelimitedListToStringArray(String str,String delimiter);\\ndelimitedListToStringArray(String str,String delimiter,String charsToDelete);\\ncommaDelimitedListToStringArray(String str);\\ncommaDelimitedListToSet(String str);\\ncollectionToDelimitedString(Collection coll,String delim,String prefix,String suffix);\\ncollectionToDelimitedString(Collection coll,String delim);\\ncollectionToCommaDelimitedString(Collection coll);\\narrayToDelimitedString(Object[] arr,String delim);\\narrayToCommaDelimitedString(Object[] arr);\\nhasLength(CharSequence str);\\n\", \"repo_level\" : \"\" }",
            "class_name": "Strings",
            "code": "public static Object quoteIfString(Object obj){\n  return (obj instanceof String ? quote((String)obj) : obj);\n}\n",
            "docstring": "/** \n * Turn the given Object into a String with single quotes if it is a String; keeping the Object as-is else.\n * @param obj the input Object (e.g. \"myString\")\n * @return the quoted String (e.g. \"'myString'\"),or the input object as-is if not a String\n */\n",
            "end_lineno": "455",
            "file_content": "/*\n * Copyright (C) 2014 jsonwebtoken.io\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.jsonwebtoken.lang;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic final class Strings {\n\n    private static final String FOLDER_SEPARATOR = \"/\";\n\n    private static final String WINDOWS_FOLDER_SEPARATOR = \"\\\\\";\n\n    private static final String TOP_PATH = \"..\";\n\n    private static final String CURRENT_PATH = \".\";\n\n    private static final char EXTENSION_SEPARATOR = '.';\n\n    public static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    private Strings(){} //prevent instantiation\n\n    //---------------------------------------------------------------------\n    // General convenience methods for working with Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Check that the given CharSequence is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a CharSequence that purely consists of whitespace.\n     * <pre>\n     * Strings.hasLength(null) = false\n     * Strings.hasLength(\"\") = false\n     * Strings.hasLength(\" \") = true\n     * Strings.hasLength(\"Hello\") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(CharSequence str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasLength(CharSequence)\n     */\n    public static boolean hasLength(String str) {\n        return hasLength((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <pre>\n     * Strings.hasText(null) = false\n     * Strings.hasText(\"\") = false\n     * Strings.hasText(\" \") = false\n     * Strings.hasText(\"12345\") = true\n     * Strings.hasText(\" 12345 \") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not <code>null</code>,\n     * its length is greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     * greater than 0, and it does not contain whitespace only\n     * @see #hasText(CharSequence)\n     */\n    public static boolean hasText(String str) {\n        return hasText((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence contains any whitespace characters.\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not empty and\n     * contains at least 1 whitespace character\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean containsWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String contains any whitespace characters.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not empty and\n     * contains at least 1 whitespace character\n     * @see #containsWhitespace(CharSequence)\n     */\n    public static boolean containsWhitespace(String str) {\n        return containsWhitespace((CharSequence) str);\n    }\n\n    /**\n     * Trim leading and trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimWhitespace(String str) {\n        return (String) trimWhitespace((CharSequence)str);\n    }\n    \n    \n    private static CharSequence trimWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        final int length = str.length();\n\n        int start = 0;\n\t\twhile (start < length && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        \n\t\tint end = length;\n        while (start < length && Character.isWhitespace(str.charAt(end - 1))) {\n            end--;\n        }\n        \n        return ((start > 0) || (end < length)) ? str.subSequence(start, end) : str;\n    }\n\n    public static String clean(String str) {\n    \tCharSequence result = clean((CharSequence) str);\n        \n        return result!=null?result.toString():null;\n    }\n    \n    public static CharSequence clean(CharSequence str) {\n        str = trimWhitespace(str);\n        if (!hasLength(str)) {\n            return null;\n        }\n        return str;\n    }\n\n    /**\n     * Trim <i>all</i> whitespace from the given String:\n     * leading, trailing, and intermediate characters.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimAllWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        int index = 0;\n        while (sb.length() > index) {\n            if (Character.isWhitespace(sb.charAt(index))) {\n                sb.deleteCharAt(index);\n            }\n            else {\n                index++;\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim leading whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimLeadingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimTrailingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied leading character from the given String.\n     * @param str the String to check\n     * @param leadingCharacter the leading character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimLeadingCharacter(String str, char leadingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied trailing character from the given String.\n     * @param str the String to check\n     * @param trailingCharacter the trailing character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimTrailingCharacter(String str, char trailingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n\n    /**\n     * Returns {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @param str the String to check\n     * @param prefix the prefix to look for\n     * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @param str the String to check\n     * @param suffix the suffix to look for\n     * @return {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @see java.lang.String#endsWith\n     */\n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        if (str == null || suffix == null) {\n            return false;\n        }\n        if (str.endsWith(suffix)) {\n            return true;\n        }\n        if (str.length() < suffix.length()) {\n            return false;\n        }\n\n        String lcStr = str.substring(str.length() - suffix.length()).toLowerCase();\n        String lcSuffix = suffix.toLowerCase();\n        return lcStr.equals(lcSuffix);\n    }\n\n    /**\n     * Returns {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     * @param str the original string (or StringBuilder)\n     * @param index the index in the original string to start matching against\n     * @param substring the substring to match at the given index\n     * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     */\n    public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n        for (int j = 0; j < substring.length(); j++) {\n            int i = index + j;\n            if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the number of occurrences the substring {@code sub} appears in string {@code str}.\n     * @param str string to search in. Return 0 if this is null.\n     * @param sub string to search for. Return 0 if this is null.\n     * @return the number of occurrences the substring {@code sub} appears in string {@code str}.\n     */\n    public static int countOccurrencesOf(String str, String sub) {\n        if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n            return 0;\n        }\n        int count = 0;\n        int pos = 0;\n        int idx;\n        while ((idx = str.indexOf(sub, pos)) != -1) {\n            ++count;\n            pos = idx + sub.length();\n        }\n        return count;\n    }\n\n    /**\n     * Replace all occurrences of a substring within a string with\n     * another string.\n     * @param inString String to examine\n     * @param oldPattern String to replace\n     * @param newPattern String to insert\n     * @return a String with the replacements\n     */\n    public static String replace(String inString, String oldPattern, String newPattern) {\n        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        int pos = 0; // our position in the old string\n        int index = inString.indexOf(oldPattern);\n        // the index of an occurrence we've found, or -1\n        int patLen = oldPattern.length();\n        while (index >= 0) {\n            sb.append(inString.substring(pos, index));\n            sb.append(newPattern);\n            pos = index + patLen;\n            index = inString.indexOf(oldPattern, pos);\n        }\n        sb.append(inString.substring(pos));\n        // remember to append any characters to the right of a match\n        return sb.toString();\n    }\n\n    /**\n     * Delete all occurrences of the given substring.\n     * @param inString the original String\n     * @param pattern the pattern to delete all occurrences of\n     * @return the resulting String\n     */\n    public static String delete(String inString, String pattern) {\n        return replace(inString, pattern, \"\");\n    }\n\n    /**\n     * Delete any character in a given String.\n     * @param inString the original String\n     * @param charsToDelete a set of characters to delete.\n     * E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n     * @return the resulting String\n     */\n    public static String deleteAny(String inString, String charsToDelete) {\n        if (!hasLength(inString) || !hasLength(charsToDelete)) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < inString.length(); i++) {\n            char c = inString.charAt(i);\n            if (charsToDelete.indexOf(c) == -1) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with formatted Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Quote the given String with single quotes.\n     * @param str the input String (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or <code>null</code> if the input was <code>null</code>\n     */\n    public static String quote(String str) {\n        return (str != null ? \"'\" + str + \"'\" : null);\n    }\n\n    /**\n     * Turn the given Object into a String with single quotes\n     * if it is a String; keeping the Object as-is else.\n     * @param obj the input Object (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or the input object as-is if not a String\n     */\n    public static Object quoteIfString(Object obj) {\n        return (obj instanceof String ? quote((String) obj) : obj);\n    }\n\n    /**\n     * Unqualify a string qualified by a '.' dot character. For example,\n     * \"this.name.is.qualified\", returns \"qualified\".\n     * @param qualifiedName the qualified name\n     * @return an unqualified string by stripping all previous text before (and including) the last period character.\n     */\n    public static String unqualify(String qualifiedName) {\n        return unqualify(qualifiedName, '.');\n    }\n\n    /**\n     * Unqualify a string qualified by a separator character. For example,\n     * \"this:name:is:qualified\" returns \"qualified\" if using a ':' separator.\n     * @param qualifiedName the qualified name\n     * @param separator the separator\n     * @return an unqualified string by stripping all previous text before and including the last {@code separator} character.\n     */\n    public static String unqualify(String qualifiedName, char separator) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);\n    }\n\n    /**\n     * Capitalize a <code>String</code>, changing the first letter to\n     * upper case as per {@link Character#toUpperCase(char)}.\n     * No other letters are changed.\n     * @param str the String to capitalize, may be <code>null</code>\n     * @return the capitalized String, <code>null</code> if null\n     */\n    public static String capitalize(String str) {\n        return changeFirstCharacterCase(str, true);\n    }\n\n    /**\n     * Uncapitalize a <code>String</code>, changing the first letter to\n     * lower case as per {@link Character#toLowerCase(char)}.\n     * No other letters are changed.\n     * @param str the String to uncapitalize, may be <code>null</code>\n     * @return the uncapitalized String, <code>null</code> if null\n     */\n    public static String uncapitalize(String str) {\n        return changeFirstCharacterCase(str, false);\n    }\n\n    private static String changeFirstCharacterCase(String str, boolean capitalize) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str.length());\n        if (capitalize) {\n            sb.append(Character.toUpperCase(str.charAt(0)));\n        }\n        else {\n            sb.append(Character.toLowerCase(str.charAt(0)));\n        }\n        sb.append(str.substring(1));\n        return sb.toString();\n    }\n\n    /**\n     * Extract the filename from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"myfile.txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename, or <code>null</code> if none\n     */\n    public static String getFilename(String path) {\n        if (path == null) {\n            return null;\n        }\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);\n    }\n\n    /**\n     * Extract the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename extension, or <code>null</code> if none\n     */\n    public static String getFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return null;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return null;\n        }\n        return path.substring(extIndex + 1);\n    }\n\n    /**\n     * Strip the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"mypath/myfile\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the path with stripped filename extension,\n     * or <code>null</code> if none\n     */\n    public static String stripFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return path;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return path;\n        }\n        return path.substring(0, extIndex);\n    }\n\n    /**\n     * Apply the given relative path to the given path,\n     * assuming standard Java folder separation (i.e. \"/\" separators).\n     * @param path the path to start from (usually a full file path)\n     * @param relativePath the relative path to apply\n     * (relative to the full file path above)\n     * @return the full file path that results from applying the relative path\n     */\n    public static String applyRelativePath(String path, String relativePath) {\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (separatorIndex != -1) {\n            String newPath = path.substring(0, separatorIndex);\n            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n                newPath += FOLDER_SEPARATOR;\n            }\n            return newPath + relativePath;\n        }\n        else {\n            return relativePath;\n        }\n    }\n\n    /**\n     * Normalize the path by suppressing sequences like \"path/..\" and\n     * inner simple dots.\n     * <p>The result is convenient for path comparison. For other uses,\n     * notice that Windows separators (\"\\\") are replaced by simple slashes.\n     * @param path the original path\n     * @return the normalized path\n     */\n    public static String cleanPath(String path) {\n        if (path == null) {\n            return null;\n        }\n        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);\n\n        // Strip prefix from path to analyze, to not treat it as part of the\n        // first path element. This is necessary to correctly parse paths like\n        // \"file:core/../core/io/Resource.class\", where the \"..\" should just\n        // strip the first \"core\" directory while keeping the \"file:\" prefix.\n        int prefixIndex = pathToUse.indexOf(\":\");\n        String prefix = \"\";\n        if (prefixIndex != -1) {\n            prefix = pathToUse.substring(0, prefixIndex + 1);\n            pathToUse = pathToUse.substring(prefixIndex + 1);\n        }\n        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {\n            prefix = prefix + FOLDER_SEPARATOR;\n            pathToUse = pathToUse.substring(1);\n        }\n\n        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);\n        List<String> pathElements = new LinkedList<String>();\n        int tops = 0;\n\n        for (int i = pathArray.length - 1; i >= 0; i--) {\n            String element = pathArray[i];\n            if (CURRENT_PATH.equals(element)) {\n                // Points to current directory - drop it.\n            }\n            else if (TOP_PATH.equals(element)) {\n                // Registering top path found.\n                tops++;\n            }\n            else {\n                if (tops > 0) {\n                    // Merging path element with element corresponding to top path.\n                    tops--;\n                }\n                else {\n                    // Normal path element found.\n                    pathElements.add(0, element);\n                }\n            }\n        }\n\n        // Remaining top paths need to be retained.\n        for (int i = 0; i < tops; i++) {\n            pathElements.add(0, TOP_PATH);\n        }\n\n        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);\n    }\n\n    /**\n     * Compare two paths after normalization of them.\n     * @param path1 first path for comparison\n     * @param path2 second path for comparison\n     * @return whether the two paths are equivalent after normalization\n     */\n    public static boolean pathEquals(String path1, String path2) {\n        return cleanPath(path1).equals(cleanPath(path2));\n    }\n\n    /**\n     * Parse the given <code>localeString</code> value into a {@link java.util.Locale}.\n     * <p>This is the inverse operation of {@link java.util.Locale#toString Locale's toString}.\n     * @param localeString the locale string, following <code>Locale's</code>\n     * <code>toString()</code> format (\"en\", \"en_UK\", etc);\n     * also accepts spaces as separators, as an alternative to underscores\n     * @return a corresponding <code>Locale</code> instance\n     */\n    public static Locale parseLocaleString(String localeString) {\n        String[] parts = tokenizeToStringArray(localeString, \"_ \", false, false);\n        String language = (parts.length > 0 ? parts[0] : \"\");\n        String country = (parts.length > 1 ? parts[1] : \"\");\n        validateLocalePart(language);\n        validateLocalePart(country);\n        String variant = \"\";\n        if (parts.length >= 2) {\n            // There is definitely a variant, and it is everything after the country\n            // code sans the separator between the country code and the variant.\n            int endIndexOfCountryCode = localeString.indexOf(country) + country.length();\n            // Strip off any leading '_' and whitespace, what's left is the variant.\n            variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));\n            if (variant.startsWith(\"_\")) {\n                variant = trimLeadingCharacter(variant, '_');\n            }\n        }\n        return (language.length() > 0 ? new Locale(language, country, variant) : null);\n    }\n\n    private static void validateLocalePart(String localePart) {\n        for (int i = 0; i < localePart.length(); i++) {\n            char ch = localePart.charAt(i);\n            if (ch != '_' && ch != ' ' && !Character.isLetterOrDigit(ch)) {\n                throw new IllegalArgumentException(\n                    \"Locale part \\\"\" + localePart + \"\\\" contains invalid characters\");\n            }\n        }\n    }\n\n    /**\n     * Determine the RFC 3066 compliant language tag,\n     * as used for the HTTP \"Accept-Language\" header.\n     * @param locale the Locale to transform to a language tag\n     * @return the RFC 3066 compliant language tag as String\n     */\n    public static String toLanguageTag(Locale locale) {\n        return locale.getLanguage() + (hasText(locale.getCountry()) ? \"-\" + locale.getCountry() : \"\");\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with String arrays\n    //---------------------------------------------------------------------\n\n    /**\n     * Append the given String to the given String array, returning a new array\n     * consisting of the input array contents plus the given String.\n     * @param array the array to append to (can be <code>null</code>)\n     * @param str the String to append\n     * @return the new array (never <code>null</code>)\n     */\n    public static String[] addStringToArray(String[] array, String str) {\n        if (Objects.isEmpty(array)) {\n            return new String[] {str};\n        }\n        String[] newArr = new String[array.length + 1];\n        System.arraycopy(array, 0, newArr, 0, array.length);\n        newArr[array.length] = str;\n        return newArr;\n    }\n\n    /**\n     * Concatenate the given String arrays into one,\n     * with overlapping array elements included twice.\n     * <p>The order of elements in the original arrays is preserved.\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        String[] newArr = new String[array1.length + array2.length];\n        System.arraycopy(array1, 0, newArr, 0, array1.length);\n        System.arraycopy(array2, 0, newArr, array1.length, array2.length);\n        return newArr;\n    }\n\n    /**\n     * Merge the given String arrays into one, with overlapping\n     * array elements only included once.\n     * <p>The order of elements in the original arrays is preserved\n     * (with the exception of overlapping elements, which are only\n     * included on their first occurrence).\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] mergeStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        List<String> result = new ArrayList<String>();\n        result.addAll(Arrays.asList(array1));\n        for (String str : array2) {\n            if (!result.contains(str)) {\n                result.add(str);\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Turn given source String array into sorted array.\n     * @param array the source array\n     * @return the sorted array (never <code>null</code>)\n     */\n    public static String[] sortStringArray(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        Arrays.sort(array);\n        return array;\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Collection was <code>null</code>)\n     */\n    public static String[] toStringArray(Collection<String> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new String[collection.size()]);\n    }\n\n    /**\n     * Copy the given Enumeration into a String array.\n     * The Enumeration must contain String elements only.\n     * @param enumeration the Enumeration to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Enumeration was <code>null</code>)\n     */\n    public static String[] toStringArray(Enumeration<String> enumeration) {\n        if (enumeration == null) {\n            return null;\n        }\n        List<String> list = java.util.Collections.list(enumeration);\n        return list.toArray(new String[list.size()]);\n    }\n\n    /**\n     * Trim the elements of the given String array,\n     * calling <code>String.trim()</code> on each of them.\n     * @param array the original String array\n     * @return the resulting array (of the same size) with trimmed elements\n     */\n    public static String[] trimArrayElements(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        String[] result = new String[array.length];\n        for (int i = 0; i < array.length; i++) {\n            String element = array[i];\n            result[i] = (element != null ? element.trim() : null);\n        }\n        return result;\n    }\n\n    /**\n     * Remove duplicate Strings from the given array.\n     * Also sorts the array, as it uses a TreeSet.\n     * @param array the String array\n     * @return an array without duplicates, in natural sort order\n     */\n    public static String[] removeDuplicateStrings(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return array;\n        }\n        Set<String> set = new TreeSet<String>();\n        for (String element : array) {\n            set.add(element);\n        }\n        return toStringArray(set);\n    }\n\n    /**\n     * Split a String at the first occurrence of the delimiter.\n     * Does not include the delimiter in the result.\n     * @param toSplit the string to split\n     * @param delimiter to split the string up with\n     * @return a two element array with index 0 being before the delimiter, and\n     * index 1 being after the delimiter (neither element includes the delimiter);\n     * or <code>null</code> if the delimiter wasn't found in the given input String\n     */\n    public static String[] split(String toSplit, String delimiter) {\n        if (!hasLength(toSplit) || !hasLength(delimiter)) {\n            return null;\n        }\n        int offset = toSplit.indexOf(delimiter);\n        if (offset < 0) {\n            return null;\n        }\n        String beforeDelimiter = toSplit.substring(0, offset);\n        String afterDelimiter = toSplit.substring(offset + delimiter.length());\n        return new String[] {beforeDelimiter, afterDelimiter};\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was null or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {\n        return splitArrayElementsIntoProperties(array, delimiter, null);\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @param charsToDelete one or more characters to remove from each element\n     * prior to attempting the split operation (typically the quotation mark\n     * symbol), or <code>null</code> if no removal should occur\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was <code>null</code> or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(\n        String[] array, String delimiter, String charsToDelete) {\n\n        if (Objects.isEmpty(array)) {\n            return null;\n        }\n        Properties result = new Properties();\n        for (String element : array) {\n            if (charsToDelete != null) {\n                element = deleteAny(element, charsToDelete);\n            }\n            String[] splittedElement = split(element, delimiter);\n            if (splittedElement == null) {\n                continue;\n            }\n            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n        }\n        return result;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter)\n     * @param trimTokens trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     * (only applies to tokens that are empty after trimming; StringTokenizer\n     * will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     * was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(\n        String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List<String> tokens = new ArrayList<String>();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter) {\n        return delimitedListToStringArray(str, delimiter, null);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @param charsToDelete a set of characters to delete. Useful for deleting unwanted\n     * line breaks: e.g. \"\\r\\n\\f\" will delete all new lines and line feeds in a String.\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {\n        if (str == null) {\n            return new String[0];\n        }\n        if (delimiter == null) {\n            return new String[] {str};\n        }\n        List<String> result = new ArrayList<String>();\n        if (\"\".equals(delimiter)) {\n            for (int i = 0; i < str.length(); i++) {\n                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));\n            }\n        }\n        else {\n            int pos = 0;\n            int delPos;\n            while ((delPos = str.indexOf(delimiter, pos)) != -1) {\n                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));\n                pos = delPos + delimiter.length();\n            }\n            if (str.length() > 0 && pos <= str.length()) {\n                // Add rest of String, but not in case of empty input.\n                result.add(deleteAny(str.substring(pos), charsToDelete));\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Convert a CSV list into an array of Strings.\n     * @param str the input String\n     * @return an array of Strings, or the empty array in case of empty input\n     */\n    public static String[] commaDelimitedListToStringArray(String str) {\n        return delimitedListToStringArray(str, \",\");\n    }\n\n    /**\n     * Convenience method to convert a CSV string list to a set.\n     * Note that this will suppress duplicates.\n     * @param str the input String\n     * @return a Set of String entries in the list\n     */\n    public static Set<String> commaDelimitedListToSet(String str) {\n        Set<String> set = new TreeSet<String>();\n        String[] tokens = commaDelimitedListToStringArray(str);\n        for (String token : tokens) {\n            set.add(token);\n        }\n        return set;\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @param prefix the String to start each element with\n     * @param suffix the String to end each element with\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {\n        if (Collections.isEmpty(coll)) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        Iterator<?> it = coll.iterator();\n        while (it.hasNext()) {\n            sb.append(prefix).append(it.next()).append(suffix);\n            if (it.hasNext()) {\n                sb.append(delim);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim) {\n        return collectionToDelimitedString(coll, delim, \"\", \"\");\n    }\n\n    /**\n     * Convenience method to return a Collection as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @return the delimited String\n     */\n    public static String collectionToCommaDelimitedString(Collection<?> coll) {\n        return collectionToDelimitedString(coll, \",\");\n    }\n\n    /**\n     * Convenience method to return a String array as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String arrayToDelimitedString(Object[] arr, String delim) {\n        if (Objects.isEmpty(arr)) {\n            return \"\";\n        }\n        if (arr.length == 1) {\n            return Objects.nullSafeToString(arr[0]);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < arr.length; i++) {\n            if (i > 0) {\n                sb.append(delim);\n            }\n            sb.append(arr[i]);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a String array as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @return the delimited String\n     */\n    public static String arrayToCommaDelimitedString(Object[] arr) {\n        return arrayToDelimitedString(arr, \",\");\n    }\n\n}\n\n",
            "file_name": "Strings.java",
            "human_label": "Check whether an obj variable is of the String type.",
            "level": "class_runnable",
            "lineno": "446",
            "name": "quoteIfString",
            "oracle_context": "{ \"apis\" : \"[quote]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
            "package": "io.jsonwebtoken.lang",
            "project": "jjwt-master"
        },
        {
            "_id": "636767501a6d9265ec017e86",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.alg.util.*;\\nimport java.util.*;\\nimport java.util.function.*;\\nListNodeImpl<E> head;\\nint size;\\nint nextIndex;\\nListNodeImpl<E> next;\\nListNodeImpl<E> last;\\nint expectedModCount;\\nV value;\\nDoublyLinkedList<V> list;\\nListNodeImpl<V> next;\\nListNodeImpl<V> prev;\\ntail();\\nsize();\\nclear();\\naddListNode(ListNodeImpl node);\\nmoveAllListNodes(DoublyLinkedList list);\\nremoveListNode(ListNodeImpl node);\\nlink(ListNodeImpl predecessor,ListNodeImpl successor);\\nlinkBefore(ListNodeImpl node,ListNodeImpl successor);\\nlinkLast(ListNodeImpl node);\\nlinkListIntoThisBefore(int index,DoublyLinkedList list);\\nunlink(ListNodeImpl node);\\naddNode(int index,ListNode node);\\naddNodeFirst(ListNode node);\\naddNodeLast(ListNode node);\\naddNodeBefore(ListNode node,ListNode successor);\\ngetFirstNode();\\ngetLastNode();\\ngetNode(int index);\\ngetNodeAt(int index);\\nindexOfNode(ListNode node);\\ncontainsNode(ListNode node);\\nremoveNode(ListNode node);\\nnodeOf(Object element);\\nlastNodeOf(Object element);\\nsearchNode(Supplier first,UnaryOperator next,Object element);\\naddElementFirst(E element);\\naddElementLast(E element);\\naddElementBeforeNode(ListNode successor,E element);\\nadd(int index,E element);\\nget(int index);\\nremove(int index);\\naddFirst(E e);\\naddLast(E e);\\nofferFirst(E e);\\nofferLast(E e);\\nremoveFirst();\\nremoveLast();\\npollFirst();\\npollLast();\\ngetFirst();\\ngetLast();\\npeekFirst();\\npeekLast();\\nremoveFirstOccurrence(Object o);\\nremoveLastOccurrence(Object o);\\noffer(E e);\\nremove();\\npoll();\\nelement();\\npeek();\\npush(E e);\\npop();\\ninvert();\\nmoveFrom(int index,DoublyLinkedList movedList);\\nappend(DoublyLinkedList movedList);\\nprepend(DoublyLinkedList movedList);\\ncircularIterator(E firstElement);\\nreverseCircularIterator(E firstElement);\\ndescendingIterator();\\niterator();\\nlistIterator();\\nlistIterator(int index);\\nlistIterator(E element);\\nnext();\\nnextNode();\\nprevious();\\npreviousNode();\\nListNodeIteratorImpl(int startIndex);\\nListNodeIteratorImpl(int startIndex,ListNodeImpl startNode);\\nhasNext();\\nhasPrevious();\\nnextIndex();\\npreviousIndex();\\nadd(E e);\\nset(E e);\\ncheckForComodification();\\nreverseIterator(ListNodeIterator listIterator);\\ngetValue();\\ngetNext();\\ngetPrev();\\nListNodeImpl(V value);\\ntoString();\\nisEmpty();\\n\", \"repo_level\" : \"\" }",
            "class_name": "DoublyLinkedList",
            "code": "@Override public ListNode<E> previousNode(){\n  checkForComodification();\n  if (!hasPrevious()) {\n    throw new NoSuchElementException();\n  }\n  last=next=next.prev;\n  nextIndex--;\n  return last;\n}\n",
            "docstring": "/** \n * {@inheritDoc}\n */\n",
            "end_lineno": "1237",
            "file_content": "/*\n * (C) Copyright 2018-2021, by Timofey Chudakov and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.util;\n\nimport org.jgrapht.alg.util.*;\n\nimport java.util.*;\nimport java.util.function.*;\n\n/**\n * {@code DoublyLinkedList} implements a doubly linked {@link List} data structure, that exposes its\n * {@link ListNode ListNodes} where the data is stored in.\n * <p>\n * An element holding {@code ListNode} can be removed or added to a {@code DoublyLinkedList} in\n * constant time O(1). Other methods that operate on {@code ListNodes} directly also have constant\n * runtime. This is also the case for methods that operate on the first(head) and last(tail) node or\n * element. Random access methods have a runtime O(n) that is linearly dependent on the size of the\n * {@code DoublyLinkedList}.\n * </p>\n * <p>\n * A {@code DoublyLinkedList} supports {@code null} elements but does not support\n * {@code null ListNodes}. This class is not thread safe and needs to be synchronized externally if\n * modified by concurrent threads.\n * </p>\n * <p>\n * The iterators over this list have a <i>fail-fast</i> behavior meaning that they throw a\n * {@link ConcurrentModificationException} after they detect a structural modification of the list,\n * that they're not responsible for.\n * </p>\n * <p>\n * This class is similar to {@link LinkedList}. The general difference is that the {@code ListNodes}\n * of this {@code List} are accessible and can be removed or added directly. To ensure the integrity\n * of the {@code List} nodes of this List have a reference to the List they belong to. This\n * increases the memory occupied by this list implementation compared to {@code LinkedList} for the\n * same elements. Instances of {@code LinkedList.Node} have three references each (the element, next\n * and previous), instances of {@code DoublyLinkedList.ListNode} have four (the element, next,\n * previous and the list).\n * </p>\n *\n * @param <E> the list element type\n * @author Timofey Chudakov\n * @author Hannes Wellmann\n */\npublic class DoublyLinkedList<E>\n    extends\n    AbstractSequentialList<E>\n    implements\n    Deque<E>\n{\n    /** The first element of the list, {@code null} if this list is empty. */\n    private ListNodeImpl<E> head = null;\n    private int size;\n\n    private ListNodeImpl<E> tail()\n    {\n        return head.prev;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isEmpty()\n    {\n        return head == null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int size()\n    {\n        return size;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void clear()\n    {\n        if (!isEmpty()) {\n            ListNodeImpl<E> node = head;\n            do {\n                ListNodeImpl<E> next = node.next;\n                boolean removed = removeListNode(node); // clears all links of removed node\n                assert removed;\n                node = next;\n            } while (node != head);\n\n            head = null;\n            assert size == 0;\n        }\n    }\n\n    // internal modification methods\n\n    /**\n     * Adds the given {@link ListNode} to this {@code List}.\n     * <p>\n     * Sets the {@code list} reference of {@code node} to this list, increases this lists\n     * {@code size} and {@code modcount} by one.\n     * </p>\n     * \n     * @param node the node to add to this list\n     * @throws IllegalArgumentException if {@code node} is already contained in this or another\n     *         {@code DoublyLinkedList}\n     */\n    private void addListNode(ListNodeImpl<E> node)\n    { // call this before any modification of this list is done\n        if (node.list != null) {\n            String list = (node.list == this) ? \"this\" : \"other\";\n            throw new IllegalArgumentException(\n                \"Node <\" + node + \"> already contained in \" + list + \" list\");\n        }\n        node.list = this;\n        size++;\n        modCount++;\n    }\n\n    /**\n     * Atomically moves all {@link ListNode ListNodes} from {@code list} to this list as if each\n     * node was removed with {@link #removeListNode(ListNodeImpl)} from {@code list} and\n     * subsequently added to this list by {@link #addListNode(ListNodeImpl)}.\n     */\n    private void moveAllListNodes(DoublyLinkedList<E> list)\n    { // call this before any modification of this list is done\n\n        for (ListNodeIteratorImpl it = list.new ListNodeIteratorImpl(0); it.hasNext();) {\n            ListNodeImpl<E> node = it.nextNode();\n            assert node.list == list;\n            node.list = this;\n        }\n        size += list.size;\n        list.size = 0;\n        modCount++;\n        list.modCount++;\n    }\n\n    /**\n     * Removes the given {@link ListNode} from this {@code List}, if it is contained in this\n     * {@code List}.\n     * <p>\n     * If {@code node} is contained in this list, sets the {@code list}, {@code next} and\n     * {@code prev} reference of {@code node} to {@code null} decreases this list's {@code size} and\n     * increases the {@code modcount} by one.\n     * </p>\n     * \n     * @param node the node to remove from this list\n     * @return true if {@code node} was removed from this list, else false\n     */\n    private boolean removeListNode(ListNodeImpl<E> node)\n    { // call this before any modification of this list is done\n        if (node.list == this) {\n\n            node.list = null;\n            node.next = null;\n            node.prev = null;\n\n            size--;\n            modCount++;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Establishes the links between the given {@link ListNodeImpl nodes} in such a way that the\n     * {@code predecessor} is linked before the {@code successor}.\n     * \n     * @param predecessor the first node linked before the other\n     * @param successor the second node linked after the other\n     */\n    private void link(ListNodeImpl<E> predecessor, ListNodeImpl<E> successor)\n    {\n        predecessor.next = successor;\n        successor.prev = predecessor;\n    }\n\n    /** Insert non null {@code node} before non null {@code successor} into the list. */\n    private void linkBefore(ListNodeImpl<E> node, ListNodeImpl<E> successor)\n    {\n        addListNode(node);\n        link(successor.prev, node);\n        link(node, successor);\n    }\n\n    /** Insert non null {@code node} as last node into the list. */\n    private void linkLast(ListNodeImpl<E> node)\n    {\n        if (isEmpty()) { // node will be the first and only one\n            addListNode(node);\n            link(node, node); // self link\n            head = node;\n        } else {\n            linkBefore(node, head);\n        }\n    }\n\n    /** Insert non null {@code list} before node at {@code index} into the list. */\n    private void linkListIntoThisBefore(int index, DoublyLinkedList<E> list)\n    {\n        int previousSize = size;\n        moveAllListNodes(list);\n\n        // link list's node into this list\n        if (previousSize == 0) {\n            head = list.head; // head and tail already linked together\n        } else {\n            ListNodeImpl<E> refNode = (index == previousSize) ? head : getNodeAt(index);\n\n            ListNodeImpl<E> listTail = list.tail();\n            link(refNode.prev, list.head); // changes list.tail()\n            link(listTail, refNode);\n\n            if (index == 0) {\n                head = list.head;\n            }\n        }\n        // clear list but do not call list.clear(), since their nodes are still used\n        list.head = null;\n    }\n\n    /** Remove the non null {@code node} from the list. */\n    private boolean unlink(ListNodeImpl<E> node)\n    {\n        ListNodeImpl<E> prev = node.prev;\n        ListNodeImpl<E> next = node.next;\n        if (removeListNode(node)) { // clears prev and next of node\n            if (size == 0) {\n                head = null;\n            } else {\n                // list is circular, don't have to worry about null values\n                link(prev, next);\n\n                if (head == node) {\n                    head = next;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // ----------------------------------------------------------------------------\n    // public modification and access methods\n\n    // ListNode methods:\n    // Base methods to access, add and remove nodes to/from this list.\n    // Used by all public methods if possible\n\n    /**\n     * Inserts the specified {@link ListNode node} at the specified position in this list.\n     * <p>\n     * This method has a linear runtime complexity O(n) that depends linearly on the distance of the\n     * index to the nearest end. Adding {@code node} as first or last takes only constant time O(1).\n     * </p>\n     * \n     * @param index index at which the specified {@code node} is to be inserted\n     * @param node the node to add\n     * @throws IndexOutOfBoundsException if the index is out of range\n     *         ({@code index < 0 || index > size()})\n     * @throws IllegalArgumentException if {@code node} is already part of this or another\n     *         {@code DoublyLinkedList}\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public void addNode(int index, ListNode<E> node)\n    {\n        ListNodeImpl<E> nodeImpl = (ListNodeImpl<E>) node;\n        if (index == size) { // also true if this is empty\n            linkLast(nodeImpl);\n        } else {\n            ListNodeImpl<E> successor = index == 0 ? head : getNodeAt(index);\n            linkBefore(nodeImpl, successor);\n            if (head == successor) {\n                head = nodeImpl;\n            }\n        }\n    }\n\n    /**\n     * Inserts the specified {@link ListNode node} at the front of this list.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @param node the node to add\n     * @throws IllegalArgumentException if {@code node} is already part of this or another\n     *         {@code DoublyLinkedList}\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public void addNodeFirst(ListNode<E> node)\n    {\n        addNode(0, node);\n    }\n\n    /**\n     * Inserts the specified {@link ListNode node} at the end of this list.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @param node the node to add\n     * @throws IllegalArgumentException if {@code node} is already part of this or another\n     *         {@code DoublyLinkedList}\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public void addNodeLast(ListNode<E> node)\n    {\n        addNode(size, node);\n    }\n\n    /**\n     * Inserts the specified {@link ListNode node} before the specified {@code successor} in this\n     * list.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @param node the node to add\n     * @param successor {@code ListNode} before which the {@code node} is inserted\n     * @throws IllegalArgumentException if {@code node} is already contained in this or another\n     *         {@code DoublyLinkedList} or {@code successor} is not contained in this list\n     * @throws NullPointerException if {@code successor} or {@code node} is {@code null}\n     */\n    public void addNodeBefore(ListNode<E> node, ListNode<E> successor)\n    {\n        ListNodeImpl<E> successorImpl = (ListNodeImpl<E>) successor;\n        ListNodeImpl<E> nodeImpl = (ListNodeImpl<E>) node;\n\n        if (successorImpl.list != this) {\n            throw new IllegalArgumentException(\"Node <\" + successorImpl + \"> not in this list\");\n        }\n        linkBefore(nodeImpl, successorImpl);\n        if (head == successorImpl) {\n            head = nodeImpl;\n        }\n    }\n\n    /**\n     * Returns the first {@link ListNode node} of this list.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @return the first {@code ListNode} of this list\n     * @throws NoSuchElementException if this list is empty\n     */\n    public ListNode<E> getFirstNode()\n    {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        return head;\n    }\n\n    /**\n     * Returns the last {@link ListNode node} of this list.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @return the last {@code ListNode} of this list\n     * @throws NoSuchElementException if this list is empty\n     */\n    public ListNode<E> getLastNode()\n    {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        return tail();\n    }\n\n    /**\n     * Returns the {@link ListNode node} at the specified position in this list.\n     * <p>\n     * This method has linear runtime complexity O(n).\n     * </p>\n     * \n     * @param index index of the {@code ListNode} to return\n     * @return the {@code ListNode} at the specified position in this list\n     * @throws IndexOutOfBoundsException if the index is out of range\n     *         ({@code index < 0 || index >= size()})\n     */\n    public ListNode<E> getNode(int index)\n    {\n        return getNodeAt(index);\n    }\n\n    /**\n     * Returns the {@link ListNodeImpl node} at the specified position in this list.\n     * \n     * @param index index of the {@code ListNodeImpl} to return\n     * @return the {@code ListNode} at the specified position in this list\n     * @throws IndexOutOfBoundsException if the index is out of range\n     *         ({@code index < 0 || index >= size()})\n     */\n    private ListNodeImpl<E> getNodeAt(int index)\n    {\n        if (index < 0 || size <= index) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index);\n        }\n        ListNodeImpl<E> node;\n        if (index < size / 2) {\n            node = head;\n            for (int i = 0; i < index; i++) {\n                node = node.next;\n            }\n        } else {\n            node = tail();\n            for (int i = size - 1; index < i; i--) {\n                node = node.prev;\n            }\n        }\n        return node;\n    }\n\n    /**\n     * Returns the index of the specified {@link ListNode node} in this list, or -1 if this list\n     * does not contain the {@code node}.\n     * <p>\n     * More formally, returns the index {@code i} such that {@code node == getNode(i)}, or -1 if\n     * there is no such index. Because a {@code ListNode} is contained in at most one list exactly\n     * once, the returned index (if not -1) is the only occurrence of that {@code node}.\n     * </p>\n     * <p>\n     * This method has linear runtime complexity O(n) to find {@code node} but returns in constant\n     * time O(1) if {@code node} is not {@link #containsNode(ListNode) contained} in this list.\n     * </p>\n     * \n     * @param node the node to search for\n     * @return the index of the specified {@code node} in this list, or -1 if this list does not\n     *         contain {@code node}\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public int indexOfNode(ListNode<E> node)\n    {\n        if (!containsNode(node)) {\n            return -1;\n        }\n        ListNodeImpl<E> current = head;\n        for (int i = 0; i < size; i++) {\n            if (current == node) {\n                return i;\n            }\n            current = current.next;\n        }\n        // should never happen:\n        throw new IllegalStateException(\"Node contained in list not found: \" + node);\n    }\n\n    /**\n     * Returns true if this {@code DoublyLinkedList} contains the specified {@link ListNode}.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @param node the node whose presence in this {@code DoublyLinkedList} is to be tested\n     * @return true if this {@code DoublyLinkedList} contains the {@link ListNode}\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public boolean containsNode(ListNode<E> node)\n    {\n        return ((ListNodeImpl<E>) node).list == this;\n    }\n\n    /**\n     * Removes the {@link ListNode node} from this list. Returns true if {@code node} was in this\n     * list and is now removed. If {@code node} is not contained in this list, the list is left\n     * unchanged.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     *\n     * @param node the node to remove from this list\n     * @return true if node was removed from this list\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public boolean removeNode(ListNode<E> node)\n    {\n        return unlink((ListNodeImpl<E>) node);\n    }\n\n    /**\n     * Returns the first {@link ListNode node} holding the specified {@code element} in this list.\n     * More formally, returns the first {@code ListNode} such that\n     * {@code Objects.equals(element, node.getValue())}, or {@code null} if there is no such node.\n     * <p>\n     * This method has linear runtime complexity O(n).\n     * </p>\n     * \n     * @param element the element whose {@code ListNode} is to return\n     * @return the first {@code ListNode} holding the {@code element} or null if no node was found\n     */\n    public ListNode<E> nodeOf(Object element)\n    {\n        return searchNode(() -> head, n -> n.next, element).getFirst();\n    }\n\n    /**\n     * Returns the last {@link ListNode node} holding the specified {@code element} in this list.\n     * More formally, returns the last {@code ListNode} such that\n     * {@code Objects.equals(element, node.getValue())}, or {@code null} if there is no such node.\n     * <p>\n     * This method has linear runtime complexity O(n).\n     * </p>\n     * \n     * @param element the element whose {@code ListNode} is to return\n     * @return the last {@code ListNode} holding the {@code element} or null if no node was found\n     */\n    public ListNode<E> lastNodeOf(Object element)\n    {\n        return searchNode(this::tail, n -> n.prev, element).getFirst();\n    }\n\n    /**\n     * Returns a {@link Pair} of the first encountered {@link ListNode} in this list, whose\n     * {@code value} is equal to the given {@code element}, and its index. Or if this list does not\n     * contain such node a Pair of {@code null} and {@code -1};\n     * <p>\n     * The search starts at the node supplied by {@code first} and advances in the direction induced\n     * by the specified {@code next} operator.\n     * </p>\n     * \n     * @param first supplier of the first node to check if this list is not empty\n     * @param next {@code Function} to get from the current node the next node to check\n     * @param element the element for that the first node with equal value is searched.\n     * @return a {@link Pair} of the first encountered {@code ListNode} holding a {@code value}\n     *         equal to {@code element} and its index, or if no such node was found a\n     *         {@code Pair.of(null, -1)}\n     */\n    private Pair<ListNodeImpl<E>, Integer> searchNode(\n        Supplier<ListNodeImpl<E>> first, UnaryOperator<ListNodeImpl<E>> next, Object element)\n    {\n        if (!isEmpty()) {\n            int index = 0;\n            ListNodeImpl<E> firstNode = first.get();\n            ListNodeImpl<E> node = firstNode;\n            do {\n                if (Objects.equals(node.value, element)) {\n                    return Pair.of(node, index);\n                }\n                index++;\n                node = next.apply(node);\n            } while (node != firstNode);\n        }\n        return Pair.of(null, -1);\n    }\n\n    /**\n     * Inserts the specified element at the front of this list. Returns the {@link ListNode}\n     * allocated to store the {@code value}. The returned {@code ListNode} is the new head of the\n     * list.\n     * <p>\n     * This method is equivalent to {@link #addFirst(Object)} but returns the allocated\n     * {@code ListNode}.\n     * </p>\n     * \n     * @param element the element to add\n     * @return the {@code ListNode} allocated to store the {@code value}\n     */\n    public ListNode<E> addElementFirst(E element)\n    {\n        ListNode<E> node = new ListNodeImpl<>(element);\n        addNode(0, node);\n        return node;\n    }\n\n    /**\n     * Inserts the specified element at the end of this list. Returns the {@link ListNode} allocated\n     * to store the {@code value}. The returned {@code ListNode} is the new tail of the list.\n     * <p>\n     * This method is equivalent to {@link #addLast(Object)} but returns the allocated\n     * {@code ListNode}.\n     * </p>\n     * \n     * @param element the element to add\n     * @return the {@code ListNode} allocated to store the {@code value}\n     */\n    public ListNode<E> addElementLast(E element)\n    {\n        ListNode<E> node = new ListNodeImpl<>(element);\n        addNode(size, node);\n        return node;\n    }\n\n    /**\n     * Inserts the specified element before the specified {@link ListNode successor} in this list.\n     * Returns the {@code ListNode} allocated to store the {@code value}.\n     *\n     * @param successor {@code ListNode} before which the node holding {@code value} is inserted\n     * @param element the element to add\n     * @return the {@code ListNode} allocated to store the {@code value}\n     * @throws IllegalArgumentException if {@code successor} is not contained in this list\n     * @throws NullPointerException if {@code successor} is {@code null}\n     */\n    public ListNode<E> addElementBeforeNode(ListNode<E> successor, E element)\n    {\n        ListNode<E> node = new ListNodeImpl<>(element);\n        addNodeBefore(node, successor);\n        return node;\n    }\n\n    // List methods (shortcut for most commonly used methods to avoid iterator creation)\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void add(int index, E element)\n    {\n        if (index == size) { // also true if this is empty\n            addElementLast(element);\n        } else {\n            addElementBeforeNode(getNode(index), element);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E get(int index)\n    {\n        return getNodeAt(index).value;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E remove(int index)\n    {\n        ListNode<E> node = getNode(index);\n        removeNode(node);\n        return node.getValue();\n    }\n\n    // Deque methods\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void addFirst(E e)\n    {\n        addElementFirst(e);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void addLast(E e)\n    {\n        addElementLast(e);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean offerFirst(E e)\n    {\n        addElementFirst(e);\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean offerLast(E e)\n    {\n        addElementLast(e);\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E removeFirst()\n    {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n\n        ListNode<E> node = head;\n        removeNode(node); // changes head\n        return node.getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E removeLast()\n    {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n\n        ListNode<E> node = tail();\n        removeNode(node); // changes tail\n        return node.getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E pollFirst()\n    {\n        if (isEmpty()) {\n            return null;\n        }\n        ListNode<E> node = head;\n        removeNode(node); // changes head\n        return node.getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E pollLast()\n    {\n        if (isEmpty()) {\n            return null;\n        }\n        ListNode<E> node = tail();\n        removeNode(node); // changes tail()\n        return node.getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E getFirst()\n    {\n        return getFirstNode().getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E getLast()\n    {\n        return getLastNode().getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E peekFirst()\n    {\n        return isEmpty() ? null : getFirst();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E peekLast()\n    {\n        return isEmpty() ? null : getLast();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean removeFirstOccurrence(Object o)\n    {\n        ListNode<E> node = nodeOf(o);\n        if (node != null) {\n            removeNode(node);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean removeLastOccurrence(Object o)\n    {\n        ListNode<E> node = lastNodeOf(o);\n        if (node != null) {\n            removeNode(node);\n            return true;\n        }\n        return false;\n    }\n\n    // Queue methods\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean offer(E e)\n    {\n        return offerLast(e);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E remove()\n    {\n        return removeFirst();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E poll()\n    {\n        return pollFirst();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E element()\n    {\n        return getFirst();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E peek()\n    {\n        return peekFirst();\n    }\n\n    // Stack methods\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void push(E e)\n    {\n        addFirst(e);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E pop()\n    {\n        return removeFirst();\n    }\n\n    // special bulk methods\n\n    /**\n     * Inverts the list. For instance, calling this method on the list $(a,b,c,\\dots,x,y,z)$ will\n     * result in the list $(z,y,x,\\dots,c,b,a)$. This method does only pointer manipulation, meaning\n     * that all the list nodes allocated for the previously added elements are valid after this\n     * method finishes.\n     */\n    public void invert()\n    {\n        if (size < 2) {\n            return;\n        }\n        ListNodeImpl<E> newHead = tail();\n        ListNodeImpl<E> current = head;\n        do {\n            ListNodeImpl<E> next = current.next;\n\n            current.next = current.prev;\n            current.prev = next;\n\n            current = next;\n        } while (current != head);\n        head = newHead;\n        ++modCount;\n    }\n\n    /**\n     * Moves all {@link ListNode ListNodes} of the given {@code sourceList} to this list and inserts\n     * them all before the node previously at the given position. All the {@code nodes} of\n     * {@code movedList} are moved to this list. When this method terminates this list contains all\n     * nodes of {@code movedList} and {@code movedList} is empty.\n     *\n     * @param index index of the first element of {@code list} in this {@code list} after it was\n     *        added\n     * @param movedList the {@code DoublyLinkedList} to move to this one\n     * @throws NullPointerException if {@code movedList} is {@code null}\n     */\n    public void moveFrom(int index, DoublyLinkedList<E> movedList)\n    {\n        linkListIntoThisBefore(index, movedList);\n    }\n\n    /**\n     * Appends the {@code movedList} to the end of this list. All the elements from\n     * {@code movedList} are transferred to this list, i.e. the {@code list} is empty after calling\n     * this method.\n     *\n     * @param movedList the {@code DoublyLinkedList} to append to this one\n     * @throws NullPointerException if {@code movedList} is {@code null}\n     */\n    public void append(DoublyLinkedList<E> movedList)\n    {\n        moveFrom(size, movedList);\n    }\n\n    /**\n     * Prepends the {@code movedList} to the beginning of this list. All the elements from\n     * {@code movedList} are transferred to this list, i.e. the {@code movedList} is empty after\n     * calling this method.\n     *\n     * @param movedList the {@code DoublyLinkedList} to prepend to this one\n     * @throws NullPointerException if {@code movedList} is {@code null}\n     */\n    public void prepend(DoublyLinkedList<E> movedList)\n    {\n        moveFrom(0, movedList);\n    }\n\n    // ----------------------------------------------------------------------------\n    // (List)Iterators\n\n    /**\n     * Returns a {@link NodeIterator} that starts at the first {@link ListNode} of this list that is\n     * equal to the specified {@code firstElement}, iterates in forward direction over the end of\n     * this list until the first node.\n     * <p>\n     * The first call to {@link NodeIterator#nextNode()} returns the first {@code node} that holds a\n     * value such that {@code Objects.equals(node.getValue, firstElement)} returns {@code true}. The\n     * returned {@code NodeIterator} iterates in forward direction returning the respective next\n     * element in subsequent calls to {@code next(Node)}. The returned iterator ignores the actual\n     * bounds of this {@code DoublyLinkedList} and iterates until the node before the first one is\n     * reached. Its {@link NodeIterator#hasNext() hasNext()} returns {@code false} if the next node\n     * would be the first one.\n     * </p>\n     * \n     * @param firstElement the element equal to the first {@code next()}\n     * @return a circular {@code NodeIterator} iterating forward from {@code firstElement}\n     */\n    public NodeIterator<E> circularIterator(E firstElement)\n    {\n        ListNodeImpl<E> startNode = (ListNodeImpl<E>) nodeOf(firstElement);\n        if (startNode == null) {\n            throw new NoSuchElementException();\n        }\n        return new ListNodeIteratorImpl(0, startNode);\n    }\n\n    /**\n     * Returns a {@link NodeIterator} that starts at the first {@link ListNode} of this list that is\n     * equal to the specified {@code firstElement}, iterates in reverse direction over the end of\n     * this list until the first node.\n     * <p>\n     * The first call to {@link NodeIterator#nextNode()} returns the first {@code node} that holds a\n     * value such that {@code Objects.equals(node.getValue, firstElement)} returns {@code true}. The\n     * returned {@code NodeIterator} iterates in reverse direction returning the respective previous\n     * element in subsequent calls to {@code next(Node)}. The returned iterator ignores the actual\n     * bounds of this {@code DoublyLinkedList} and iterates until the node before the first one is\n     * reached. Its {@link NodeIterator#hasNext() hasNext()} returns {@code false} if the next node\n     * would be the first one.\n     * </p>\n     * \n     * @param firstElement the element equal to the first {@code next()}\n     * @return a circular {@code NodeIterator} iterating backwards from {@code firstElement}\n     */\n    public NodeIterator<E> reverseCircularIterator(E firstElement)\n    {\n        ListNodeImpl<E> startNode = (ListNodeImpl<E>) nodeOf(firstElement);\n        if (startNode == null) {\n            throw new NoSuchElementException();\n        }\n        return reverseIterator(new ListNodeIteratorImpl(size, startNode.next));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public NodeIterator<E> descendingIterator()\n    {\n        return reverseIterator(listIterator(size));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public NodeIterator<E> iterator()\n    {\n        return listIterator();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public ListNodeIterator<E> listIterator()\n    {\n        return listIterator(0);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public ListNodeIterator<E> listIterator(int index)\n    {\n        return new ListNodeIteratorImpl(index);\n    }\n\n    /**\n     * Returns a {@link ListNodeIterator} over the elements in this list (in proper sequence)\n     * starting with the first {@link ListNode} whose value is equal to the specified\n     * {@code element}.\n     *\n     * @param element the first element to be returned from the list iterator (by a call to the\n     *        {@code next} method)\n     * @return a list iterator over the elements in this list (in proper sequence)\n     * @throws NoSuchElementException if {@code element} is not in the list\n     */\n    public ListNodeIterator<E> listIterator(E element)\n    {\n        Pair<ListNodeImpl<E>, Integer> startPair = searchNode(() -> head, n -> n.next, element);\n        ListNodeImpl<E> startNode = startPair.getFirst();\n        int startIndex = startPair.getSecond();\n        if (startNode == null) {\n            throw new NoSuchElementException();\n        }\n        return new ListNodeIteratorImpl(startIndex, startNode);\n    }\n\n    /**\n     * An extension of the {@link Iterator} interface for {@link DoublyLinkedList DoublyLinkedLists}\n     * exposing their {@link ListNode ListNodes}.\n     *\n     * @param <E> the list element type\n     */\n    public interface NodeIterator<E>\n        extends\n        Iterator<E>\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        default E next()\n        {\n            return nextNode().getValue();\n        }\n\n        /**\n         * Returns the next {@link ListNode} in the list and advances the cursor position.\n         *\n         * @return the next {@code ListNode}\n         * @see ListIterator#next()\n         */\n        ListNode<E> nextNode();\n\n    }\n\n    /**\n     * An extension of the {@link ListIterator} interface for {@link DoublyLinkedList\n     * DoublyLinkedLists} exposing their {@link ListNode ListNodes}.\n     *\n     * @param <E> the list element type\n     */\n    public interface ListNodeIterator<E>\n        extends\n        ListIterator<E>,\n        NodeIterator<E>\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        default E next()\n        {\n            return nextNode().getValue();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        default E previous()\n        {\n            return previousNode().getValue();\n        }\n\n        /**\n         * Returns the previous {@link ListNode} in the list and moves the cursor position\n         * backwards.\n         *\n         * @return the previous {@code ListNode}\n         * @see ListIterator#previous()\n         */\n        ListNode<E> previousNode();\n\n    }\n\n    /**\n     * An implementation of the {@link DoublyLinkedList.ListNodeIterator} interface.\n     */\n    private class ListNodeIteratorImpl\n        implements\n        ListNodeIterator<E>\n    {\n        /** Index in this list of the ListNode returned next. */\n        private int nextIndex;\n        /** ListNode this iterator will return next. Null if this list is empty. */\n        private ListNodeImpl<E> next;\n        /** ListNode this iterator returned last. */\n        private ListNodeImpl<E> last = null;\n\n        /**\n         * The number of modifications the list have had at the moment when this iterator was\n         * created\n         */\n        private int expectedModCount = modCount;\n\n        private ListNodeIteratorImpl(int startIndex)\n        {\n            this.nextIndex = startIndex;\n            if (startIndex == size) {\n                this.next = isEmpty() ? null : head;\n            } else {\n                this.next = getNodeAt(startIndex);\n            }\n        }\n\n        private ListNodeIteratorImpl(int startIndex, ListNodeImpl<E> startNode)\n        {\n            this.nextIndex = startIndex;\n            this.next = startNode;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean hasNext()\n        {\n            return nextIndex < size;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean hasPrevious()\n        {\n            return nextIndex > 0;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int nextIndex()\n        {\n            return nextIndex;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int previousIndex()\n        {\n            return nextIndex - 1;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public ListNodeImpl<E> nextNode()\n        {\n            checkForComodification();\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n\n            last = next;\n            next = next.next;\n            nextIndex++;\n            return last;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public ListNode<E> previousNode()\n        {\n            checkForComodification();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException();\n            }\n\n            last = next = next.prev;\n            nextIndex--;\n            return last;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void add(E e)\n        {\n            checkForComodification();\n\n            if (nextIndex == size) {\n                addElementLast(e); // sets head to new node of e if was empty\n                if (size == 1) { // was empty\n                    next = head; // jump over head threshold, so cursor is at the end\n                }\n            } else {\n                addElementBeforeNode(next, e);\n            }\n            last = null;\n            nextIndex++;\n            expectedModCount++;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void set(E e)\n        {\n            if (last == null) {\n                throw new IllegalStateException();\n            }\n            checkForComodification();\n            // replace node returned last with a new node holding e\n\n            ListNode<E> nextNode = last.next;\n            boolean wasLast = last == tail();\n            removeNode(last);\n            if (wasLast) { // or the sole node\n                last = (ListNodeImpl<E>) addElementLast(e);\n            } else {\n                last = (ListNodeImpl<E>) addElementBeforeNode(nextNode, e);\n            }\n            expectedModCount += 2; // because of unlink and add\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void remove()\n        {\n            if (last == null) {\n                throw new IllegalStateException();\n            }\n            checkForComodification();\n\n            ListNodeImpl<E> lastsNext = last.next;\n            removeNode(last);\n            if (next == last) { // previousNode() called before\n                // removed element after cursor (which would have been next)\n                next = lastsNext;\n            } else { // nextNode() called before\n                // removed element before cursor (next is unaffected but the index decreases)\n                nextIndex--;\n            }\n            last = null;\n            expectedModCount++;\n        }\n\n        /**\n         * Verifies that the list structure hasn't been changed since the iteration started\n         */\n        private void checkForComodification()\n        {\n            if (expectedModCount != modCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n    }\n\n    /**\n     * Returns a {@link NodeIterator} that iterates in reverse order, assuming the cursor of the\n     * specified {@link ListNodeIterator} is behind the tail of the list.\n     */\n    private static <E> NodeIterator<E> reverseIterator(ListNodeIterator<E> listIterator)\n    {\n        return new NodeIterator<E>()\n        {\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public boolean hasNext()\n            {\n                return listIterator.hasPrevious();\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public ListNode<E> nextNode()\n            {\n                return listIterator.previousNode();\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public void remove()\n            {\n                listIterator.remove();\n            }\n        };\n    }\n\n    /**\n     * Container for the elements stored in a {@link DoublyLinkedList}.\n     * <p>\n     * A {@link ListNode} is either contained exactly once in exactly one {@code DoublyLinkedList}\n     * or contained in no {@code DoublyLinkedList}.\n     * </p>\n     * \n     * @param <V> the type of the element stored in this node\n     */\n    public interface ListNode<V>\n    {\n        /**\n         * Returns the immutable value this {@code ListNode} contains.\n         *\n         * @return the value this list node contains\n         */\n        V getValue();\n\n        /**\n         * Returns the next node in the list structure with respect to this node\n         *\n         * @return the next node in the list structure with respect to this node\n         */\n        ListNode<V> getNext();\n\n        /**\n         * Returns the previous node in the list structure with respect to this node\n         *\n         * @return the previous node in the list structure with respect to this node\n         */\n        ListNode<V> getPrev();\n    }\n\n    /**\n     * The default {@link ListNode} implementation that enables checks and enforcement of a single\n     * container list policy.\n     */\n    private static class ListNodeImpl<V>\n        implements\n        ListNode<V>\n    {\n        private final V value;\n        private DoublyLinkedList<V> list = null;\n        private ListNodeImpl<V> next = null;\n        private ListNodeImpl<V> prev = null;\n\n        /**\n         * Creates new list node\n         *\n         * @param value the value this list node stores\n         */\n        ListNodeImpl(V value)\n        {\n            this.value = value;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            if (list == null) {\n                return \" - \" + value + \" - \"; // not in a list\n            } else {\n                return prev.value + \" -> \" + value + \" -> \" + next.value;\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public V getValue()\n        {\n            return value;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public ListNodeImpl<V> getNext()\n        {\n            return next;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public ListNodeImpl<V> getPrev()\n        {\n            return prev;\n        }\n    }\n}\n",
            "file_name": "DoublyLinkedList.java",
            "human_label": "Returns the previous ListNode.",
            "level": "class_runnable",
            "lineno": "1223",
            "name": "previousNode",
            "oracle_context": "{ \"apis\" : \"[checkForComodification, hasPrevious, next, nextIndex]\", \"classes\" : \"[next]\", \"vars\" : \"[prev, last, next, nextIndex]\" }",
            "package": "org.jgrapht.util",
            "project": "jgrapht-master"
        },
        {
            "_id": "636767611a6d9265ec018116",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.*;\\nimport org.jgrapht.alg.connectivity.*;\\nimport org.jgrapht.alg.interfaces.*;\\nimport org.jgrapht.graph.*;\\nimport java.util.*;\\nimport java.util.function.*;\\nimport java.util.stream.*;\\nGraph<V,E> network;\\nSet<V> oddVertices;\\nGusfieldGomoryHuCutTree<V,E> gusfieldGomoryHuCutTreeAlgorithm;\\nSimpleWeightedGraph<V,DefaultWeightedEdge> gomoryHuTree;\\ndouble minimumCutWeight;\\nSet<V> sourcePartitionMinimumCut;\\nPadbergRaoOddMinimumCutset(Graph network);\\nPadbergRaoOddMinimumCutset(Graph network,double epsilon);\\nPadbergRaoOddMinimumCutset(Graph network,MinimumSTCutAlgorithm minimumSTCutAlgorithm);\\ncalculateMinCutWithoutTreeCompression();\\ncalculateMinCutWithTreeCompression();\\nsplitCluster(Set cluster,Queue queue);\\nintersection(Set set1,Set set2);\\nisOddVertexSet(Set vertices,Set oddVertices);\\ngetSourcePartition();\\ngetSinkPartition();\\ngetCutEdges();\\ncalculateMinCut(Set oddVertices,boolean useTreeCompression);\\n\", \"repo_level\" : \"\" }",
            "class_name": "PadbergRaoOddMinimumCutset",
            "code": "private Set<V> intersection(Set<V> set1,Set<V> set2){\n  Set<V> a;\n  Set<V> b;\n  if (set1.size() <= set2.size()) {\n    a=set1;\n    b=set2;\n  }\n else {\n    a=set2;\n    b=set1;\n  }\n  return a.stream().filter(b::contains).collect(Collectors.toSet());\n}\n",
            "docstring": "/** \n * Efficient way to compute the intersection between two sets\n * @param set1 set $1$\n * @param set2 set $2$\n * @return intersection of set $1$ and $2$\n */\n",
            "end_lineno": "278",
            "file_content": "/*\n * (C) Copyright 2016-2021, by Joris Kinable and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.alg.flow;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.connectivity.*;\nimport org.jgrapht.alg.interfaces.*;\nimport org.jgrapht.graph.*;\n\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\n\n/**\n * Implementation of the algorithm by Padberg and Rao to compute Odd Minimum Cut-Sets. Let $G=(V,E)$\n * be an undirected, simple weighted graph, where all edge weights are positive. Let $T \\subset V$\n * with $|T|$ even, be a set of vertices that are labelled <i>odd</i>. A cut-set $(U:V-U)$ is called\n * odd if $|T \\cap U|$ is an odd number. Let $c(U:V-U)$ be the weight of the cut, that is, the sum\n * of weights of the edges which have exactly one endpoint in $U$ and one endpoint in $V-U$. The\n * problem of finding an odd minimum cut-set in $G$ is stated as follows: Find $W \\subseteq V$ such\n * that $c(W:V-W)=min(c(U:V-U)|U \\subseteq V, |T \\cap U|$ is odd).\n *\n * <p>\n * The algorithm has been published in: Padberg, M. Rao, M. Odd Minimum Cut-Sets and b-Matchings.\n * Mathematics of Operations Research, 7(1), p67-80, 1982. A more concise description is published\n * in: Letchford, A. Reinelt, G. Theis, D. Odd minimum cut-sets and b-matchings revisited. SIAM\n * Journal of Discrete Mathematics, 22(4), p1480-1487, 2008.\n *\n * <p>\n * The runtime complexity of this algorithm is dominated by the runtime complexity of the algorithm\n * used to compute A Gomory-Hu tree on graph $G$. Consequently, the runtime complexity of this class\n * is $O(V^4)$.\n *\n * <p>\n * This class does not support changes to the underlying graph. The behavior of this class is\n * undefined when the graph is modified after instantiating this class.\n *\n * @param <V> the graph vertex type\n * @param <E> the graph edge type\n *\n * @author Joris Kinable\n */\npublic class PadbergRaoOddMinimumCutset<V, E>\n{\n\n    /* Input graph */\n    private final Graph<V, E> network;\n    /* Set of vertices which are labeled 'odd' (set T in the paper) */\n    private Set<V> oddVertices;\n    /* Algorithm used to calculate the Gomory-Hu Cut-tree */\n    private final GusfieldGomoryHuCutTree<V, E> gusfieldGomoryHuCutTreeAlgorithm;\n    /* The Gomory-Hu tree */\n    private SimpleWeightedGraph<V, DefaultWeightedEdge> gomoryHuTree;\n\n    /* Weight of the minimum odd cut-set */\n    private double minimumCutWeight = Double.MAX_VALUE;\n    /* Source partition constituting the minimum odd cut-set */\n    private Set<V> sourcePartitionMinimumCut;\n\n    /**\n     * Creates a new instance of the PadbergRaoOddMinimumCutset algorithm.\n     *\n     * @param network input graph\n     */\n    public PadbergRaoOddMinimumCutset(Graph<V, E> network)\n    {\n        this(network, MaximumFlowAlgorithmBase.DEFAULT_EPSILON);\n    }\n\n    /**\n     * Creates a new instance of the PadbergRaoOddMinimumCutset algorithm.\n     *\n     * @param network input graph\n     * @param epsilon tolerance\n     */\n    public PadbergRaoOddMinimumCutset(Graph<V, E> network, double epsilon)\n    {\n        this(network, new PushRelabelMFImpl<>(network, epsilon));\n    }\n\n    /**\n     * Creates a new instance of the PadbergRaoOddMinimumCutset algorithm.\n     *\n     * @param network input graph\n     * @param minimumSTCutAlgorithm algorithm used to calculate the Gomory-Hu tree\n     */\n    public PadbergRaoOddMinimumCutset(\n        Graph<V, E> network, MinimumSTCutAlgorithm<V, E> minimumSTCutAlgorithm)\n    {\n        this.network = GraphTests.requireUndirected(network);\n        gusfieldGomoryHuCutTreeAlgorithm =\n            new GusfieldGomoryHuCutTree<>(network, minimumSTCutAlgorithm);\n    }\n\n    /**\n     * Calculates the minimum odd cut. The implementation follows Algorithm 1 in the paper Odd\n     * minimum cut sets and b-matchings revisited by Adam Letchford, Gerhard Reinelt and Dirk Theis.\n     * The original algorithm runs on a compressed Gomory-Hu tree: a cut-tree with the odd vertices\n     * as terminal vertices. This tree has $|T|-1$ edges as opposed to $|V|-1$ for a Gomory-Hu tree\n     * defined on the input graph $G$. This compression step can however be skipped. If you want to\n     * run the original algorithm in the paper, set the parameter <code>useTreeCompression</code> to\n     * true. Alternatively, experiment which setting of this parameter produces the fastest results.\n     * Both settings are guaranteed to find the optimal cut. Experiments on random graphs showed\n     * that setting <code>useTreeCompression</code> to false was on average a bit faster.\n     *\n     * @param oddVertices Set of vertices which are labeled 'odd'. Note that the number of vertices\n     *        in this set must be even!\n     * @param useTreeCompression parameter indicating whether tree compression should be used\n     *        (recommended: false).\n     * @return weight of the minimum odd cut.\n     */\n    public double calculateMinCut(Set<V> oddVertices, boolean useTreeCompression)\n    {\n        minimumCutWeight = Double.MAX_VALUE;\n        this.oddVertices = oddVertices;\n\n        if (oddVertices.size() % 2 == 1)\n            throw new IllegalArgumentException(\"There needs to be an even number of odd vertices\");\n        assert network.vertexSet().containsAll(oddVertices); // All odd vertices must be contained\n        // in the graph\n        // all edge weights must be non-negative\n        assert network.edgeSet().stream().noneMatch(e -> network.getEdgeWeight(e) < 0);\n\n        gomoryHuTree = gusfieldGomoryHuCutTreeAlgorithm.getGomoryHuTree();\n\n        if (useTreeCompression)\n            return calculateMinCutWithTreeCompression();\n        else\n            return calculateMinCutWithoutTreeCompression();\n    }\n\n    /**\n     * Modified implementation of the algorithm proposed in Odd Minimum Cut-sets and b-matchings by\n     * Padberg and Rao. The optimal cut is directly computed on the Gomory-Hu tree computed for\n     * graph $G$. This approach iterates efficiently over all possible cuts of the graph (there are\n     * $|V|$ such cuts).\n     *\n     * @return weight of the minimum odd cut.\n     */\n    private double calculateMinCutWithoutTreeCompression()\n    {\n        Set<DefaultWeightedEdge> edges = new LinkedHashSet<>(gomoryHuTree.edgeSet());\n        for (DefaultWeightedEdge edge : edges) {\n            V source = gomoryHuTree.getEdgeSource(edge);\n            V target = gomoryHuTree.getEdgeTarget(edge);\n            double edgeWeight = gomoryHuTree.getEdgeWeight(edge);\n\n            if (edgeWeight >= minimumCutWeight)\n                continue;\n\n            gomoryHuTree.removeEdge(edge); // Temporarily remove edge\n            Set<V> sourcePartition =\n                new ConnectivityInspector<>(gomoryHuTree).connectedSetOf(source);\n            if (PadbergRaoOddMinimumCutset.isOddVertexSet(sourcePartition, oddVertices)) { // If the\n                                                                                           // source\n                                                                                           // partition\n                                                                                           // forms\n                                                                                           // an odd\n                                                                                           // cutset,\n                                                                                           // check\n                                                                                           // whether\n                                                                                           // the\n                                                                                           // cut\n                                                                                           // isn't\n                                                                                           // better\n                                                                                           // than\n                                                                                           // the\n                                                                                           // one we\n                                                                                           // already\n                                                                                           // found.\n                minimumCutWeight = edgeWeight;\n                sourcePartitionMinimumCut = sourcePartition;\n            }\n            gomoryHuTree.addEdge(source, target, edge); // Place edge back\n        }\n        return minimumCutWeight;\n    }\n\n    /**\n     * Implementation of the algorithm proposed in Odd Minimum Cut-sets and b-matchings by Padberg\n     * and Rao. The algorithm evaluates at most $|T|$ cuts in the Gomory-Hu tree.\n     *\n     * @return weight of the minimum odd cut.\n     */\n    private double calculateMinCutWithTreeCompression()\n    {\n        Queue<Set<V>> queue = new ArrayDeque<>();\n        queue.add(oddVertices);\n\n        // Keep splitting the clusters until each resulting cluster containes exactly one vertex.\n        while (!queue.isEmpty()) {\n            Set<V> nextCluster = queue.poll();\n            this.splitCluster(nextCluster, queue);\n        }\n\n        return minimumCutWeight;\n    }\n\n    /**\n     * Takes a set of odd vertices with cardinality $2$ or more, and splits them into $2$ new\n     * non-empty sets.\n     * \n     * @param cluster group of odd vertices\n     * @param queue clusters with cardinality $2$ or more\n     */\n    private void splitCluster(Set<V> cluster, Queue<Set<V>> queue)\n    {\n        assert cluster.size() >= 2;\n\n        // Choose 2 random odd nodes\n        Iterator<V> iterator = cluster.iterator();\n        V oddNode1 = iterator.next();\n        V oddNode2 = iterator.next();\n\n        // Calculate the minimum cut separating these two nodes.\n        double cutWeight = gusfieldGomoryHuCutTreeAlgorithm.calculateMinCut(oddNode1, oddNode2);\n        Set<V> sourcePartition = null;\n\n        if (cutWeight < minimumCutWeight) {\n            sourcePartition = gusfieldGomoryHuCutTreeAlgorithm.getSourcePartition();\n            if (PadbergRaoOddMinimumCutset.isOddVertexSet(sourcePartition, oddVertices)) {\n                this.minimumCutWeight = cutWeight;\n                this.sourcePartitionMinimumCut = sourcePartition;\n            }\n        }\n\n        if (cluster.size() == 2)\n            return;\n\n        if (sourcePartition == null)\n            sourcePartition = gusfieldGomoryHuCutTreeAlgorithm.getSourcePartition();\n\n        Set<V> split1 = this.intersection(cluster, sourcePartition);\n        Set<V> split2 = new HashSet<>(cluster);\n        split2.removeAll(split1);\n\n        if (split1.size() > 1)\n            queue.add(split1);\n        if (split2.size() > 1)\n            queue.add(split2);\n    }\n\n    /**\n     * Efficient way to compute the intersection between two sets\n     * \n     * @param set1 set $1$\n     * @param set2 set $2$\n     * @return intersection of set $1$ and $2$\n     */\n    private Set<V> intersection(Set<V> set1, Set<V> set2)\n    {\n        Set<V> a;\n        Set<V> b;\n        if (set1.size() <= set2.size()) {\n            a = set1;\n            b = set2;\n        } else {\n            a = set2;\n            b = set1;\n        }\n\n        return a.stream().filter(b::contains).collect(Collectors.toSet());\n    }\n\n    /**\n     * Convenience method which test whether the given set contains an odd number of odd-labeled\n     * nodes.\n     *\n     * @param <V> vertex type\n     * @param vertices input set\n     * @param oddVertices subset of vertices which are labeled odd\n     * @return true if the given set contains an odd number of odd-labeled nodes.\n     */\n    public static <V> boolean isOddVertexSet(Set<V> vertices, Set<V> oddVertices)\n    {\n        if (vertices.size() < oddVertices.size())\n            return vertices.stream().filter(oddVertices::contains).count() % 2 == 1;\n        else\n            return oddVertices.stream().filter(vertices::contains).count() % 2 == 1;\n    }\n\n    /**\n     * Returns partition $W$ of the cut obtained after the last invocation of\n     * {@link #calculateMinCut(Set, boolean)}\n     *\n     * @return partition $W$\n     */\n    public Set<V> getSourcePartition()\n    {\n        return sourcePartitionMinimumCut;\n    }\n\n    /**\n     * Returns partition $V-W$ of the cut obtained after the last invocation of\n     * {@link #calculateMinCut(Set, boolean)}\n     *\n     * @return partition $V-W$\n     */\n    public Set<V> getSinkPartition()\n    {\n        Set<V> sinkPartition = new LinkedHashSet<>(network.vertexSet());\n        sinkPartition.removeAll(sourcePartitionMinimumCut);\n        return sinkPartition;\n    }\n\n    /**\n     * Returns the set of edges which run from the source partition to the sink partition, in the\n     * $s-t$ cut obtained after the last invocation of {@link #calculateMinCut(Set, boolean)}\n     *\n     * @return set of edges which have one endpoint in the source partition and one endpoint in the\n     *         sink partition.\n     */\n    public Set<E> getCutEdges()\n    {\n        Predicate<E> predicate = e -> sourcePartitionMinimumCut.contains(network.getEdgeSource(e))\n            ^ sourcePartitionMinimumCut.contains(network.getEdgeTarget(e));\n        return network\n            .edgeSet().stream().filter(predicate)\n            .collect(Collectors.toCollection(LinkedHashSet::new));\n    }\n\n}\n",
            "file_name": "PadbergRaoOddMinimumCutset.java",
            "human_label": "Return the intersection between two sets.",
            "level": "slib_runnable",
            "lineno": "258",
            "name": "intersection",
            "oracle_context": "{ \"apis\" : \"[size, collect, filter, stream, toSet]\", \"classes\" : \"[Set<V>]\", \"vars\" : \"[]\" }",
            "package": "org.jgrapht.alg.flow",
            "project": "jgrapht-master"
        },
        {
            "_id": "636766f71a6d9265ec017730",
            "all_context": "{ \"class_level\" : \"import net.hasor.utils.ArrayUtils;\\nimport net.hasor.utils.ClassUtils;\\nimport java.lang.reflect.AccessibleObject;\\nimport java.lang.reflect.Field;\\nimport java.lang.reflect.Modifier;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nboolean appendStatics;\\nboolean appendTransients;\\nString[] excludeFieldNames;\\nClass<?> upToClass;\\ntoString(Object object,ToStringStyle style);\\ntoString(Object object,ToStringStyle style,boolean outputTransients);\\ntoString(Object object,ToStringStyle style,boolean outputTransients,boolean outputStatics);\\ntoString(Object object,ToStringStyle style,boolean outputTransients,boolean outputStatics,Class reflectUpToClass);\\ntoStringExclude(Object object,String excludeFieldName);\\ntoStringExclude(Object object,Collection excludeFieldNames);\\ntoNoNullStringArray(Collection collection);\\ntoNoNullStringArray(Object[] array);\\ntoStringExclude(Object object,String[] excludeFieldNames);\\nReflectionToStringBuilder(Object object);\\nReflectionToStringBuilder(Object object,ToStringStyle style);\\nReflectionToStringBuilder(Object object,ToStringStyle style,StringBuffer buffer);\\nReflectionToStringBuilder(Object object,ToStringStyle style,StringBuffer buffer,Class reflectUpToClass,boolean outputTransients,boolean outputStatics);\\naccept(Field field);\\nappendFieldsIn(Class clazz);\\ngetExcludeFieldNames();\\ngetUpToClass();\\ngetValue(Field field);\\nisAppendStatics();\\nisAppendTransients();\\nreflectionAppendArray(Object array);\\nsetAppendStatics(boolean appendStatics);\\nsetAppendTransients(boolean appendTransients);\\nsetExcludeFieldNames(String[] excludeFieldNamesParam);\\nsetUpToClass(Class clazz);\\ntoString();\\ntoString(Object object);\\n\", \"repo_level\" : \"public interface ArrayUtils {static Map toMap(Object[] array);\\nstatic Object[] clone(Object[] array);\\nstatic long[] clone(long[] array);\\nstatic int[] clone(int[] array);\\nstatic short[] clone(short[] array);\\nstatic char[] clone(char[] array);\\nstatic byte[] clone(byte[] array);\\nstatic double[] clone(double[] array);\\nstatic float[] clone(float[] array);\\nstatic boolean[] clone(boolean[] array);\\nstatic String[] clone(String[] array);\\nstatic Object[] nullToEmpty(Object[] array);\\nstatic String[] nullToEmpty(String[] array);\\nstatic long[] nullToEmpty(long[] array);\\nstatic int[] nullToEmpty(int[] array);\\nstatic short[] nullToEmpty(short[] array);\\nstatic char[] nullToEmpty(char[] array);\\nstatic byte[] nullToEmpty(byte[] array);\\nstatic double[] nullToEmpty(double[] array);\\nstatic float[] nullToEmpty(float[] array);\\nstatic boolean[] nullToEmpty(boolean[] array);\\nstatic Long[] nullToEmpty(Long[] array);\\nstatic Integer[] nullToEmpty(Integer[] array);\\nstatic Short[] nullToEmpty(Short[] array);\\nstatic Character[] nullToEmpty(Character[] array);\\nstatic Byte[] nullToEmpty(Byte[] array);\\nstatic Double[] nullToEmpty(Double[] array);\\nstatic Float[] nullToEmpty(Float[] array);\\nstatic Boolean[] nullToEmpty(Boolean[] array);\\nstatic Object[] subarray(Object[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic long[] subarray(long[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic int[] subarray(int[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic short[] subarray(short[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic char[] subarray(char[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic byte[] subarray(byte[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic double[] subarray(double[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic float[] subarray(float[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic boolean[] subarray(boolean[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic boolean isSameLength(Object[] array1,Object[] array2);\\nstatic boolean isSameLength(long[] array1,long[] array2);\\nstatic boolean isSameLength(int[] array1,int[] array2);\\nstatic boolean isSameLength(short[] array1,short[] array2);\\nstatic boolean isSameLength(char[] array1,char[] array2);\\nstatic boolean isSameLength(byte[] array1,byte[] array2);\\nstatic boolean isSameLength(double[] array1,double[] array2);\\nstatic boolean isSameLength(float[] array1,float[] array2);\\nstatic boolean isSameLength(boolean[] array1,boolean[] array2);\\nstatic int getLength(Object array);\\nstatic boolean isSameType(Object array1,Object array2);\\nstatic void reverse(Object[] array);\\nstatic void reverse(long[] array);\\nstatic void reverse(int[] array);\\nstatic void reverse(short[] array);\\nstatic void reverse(char[] array);\\nstatic void reverse(byte[] array);\\nstatic void reverse(double[] array);\\nstatic void reverse(float[] array);\\nstatic void reverse(boolean[] array);\\nstatic int indexOf(Object[] array,Object objectToFind);\\nstatic int indexOf(Object[] array,Object objectToFind,int startIndex);\\nstatic int lastIndexOf(Object[] array,Object objectToFind);\\nstatic int lastIndexOf(Object[] array,Object objectToFind,int startIndex);\\nstatic boolean contains(Object[] array,Object objectToFind);\\nstatic int indexOf(long[] array,long valueToFind);\\nstatic int indexOf(long[] array,long valueToFind,int startIndex);\\nstatic int lastIndexOf(long[] array,long valueToFind);\\nstatic int lastIndexOf(long[] array,long valueToFind,int startIndex);\\nstatic boolean contains(long[] array,long valueToFind);\\nstatic int indexOf(int[] array,int valueToFind);\\nstatic int indexOf(int[] array,int valueToFind,int startIndex);\\nstatic int lastIndexOf(int[] array,int valueToFind);\\nstatic int lastIndexOf(int[] array,int valueToFind,int startIndex);\\nstatic boolean contains(int[] array,int valueToFind);\\nstatic int indexOf(short[] array,short valueToFind);\\nstatic int indexOf(short[] array,short valueToFind,int startIndex);\\nstatic int lastIndexOf(short[] array,short valueToFind);\\nstatic int lastIndexOf(short[] array,short valueToFind,int startIndex);\\nstatic boolean contains(short[] array,short valueToFind);\\nstatic int indexOf(char[] array,char valueToFind);\\nstatic int indexOf(char[] array,char valueToFind,int startIndex);\\nstatic int lastIndexOf(char[] array,char valueToFind);\\nstatic int lastIndexOf(char[] array,char valueToFind,int startIndex);\\nstatic boolean contains(char[] array,char valueToFind);\\nstatic int indexOf(byte[] array,byte valueToFind);\\nstatic int indexOf(byte[] array,byte valueToFind,int startIndex);\\nstatic int lastIndexOf(byte[] array,byte valueToFind);\\nstatic int lastIndexOf(byte[] array,byte valueToFind,int startIndex);\\nstatic boolean contains(byte[] array,byte valueToFind);\\nstatic int indexOf(double[] array,double valueToFind);\\nstatic int indexOf(double[] array,double valueToFind,double tolerance);\\nstatic int indexOf(double[] array,double valueToFind,int startIndex);\\nstatic int indexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\nstatic int lastIndexOf(double[] array,double valueToFind);\\nstatic int lastIndexOf(double[] array,double valueToFind,double tolerance);\\nstatic int lastIndexOf(double[] array,double valueToFind,int startIndex);\\nstatic int lastIndexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\nstatic boolean contains(double[] array,double valueToFind);\\nstatic boolean contains(double[] array,double valueToFind,double tolerance);\\nstatic int indexOf(float[] array,float valueToFind);\\nstatic int indexOf(float[] array,float valueToFind,int startIndex);\\nstatic int lastIndexOf(float[] array,float valueToFind);\\nstatic int lastIndexOf(float[] array,float valueToFind,int startIndex);\\nstatic boolean contains(float[] array,float valueToFind);\\nstatic int indexOf(boolean[] array,boolean valueToFind);\\nstatic int indexOf(boolean[] array,boolean valueToFind,int startIndex);\\nstatic int lastIndexOf(boolean[] array,boolean valueToFind);\\nstatic int lastIndexOf(boolean[] array,boolean valueToFind,int startIndex);\\nstatic boolean contains(boolean[] array,boolean valueToFind);\\nstatic char[] toPrimitive(Character[] array);\\nstatic char[] toPrimitive(Character[] array,char valueForNull);\\nstatic Character[] toObject(char[] array);\\nstatic long[] toPrimitive(Long[] array);\\nstatic long[] toPrimitive(Long[] array,long valueForNull);\\nstatic Long[] toObject(long[] array);\\nstatic int[] toPrimitive(Integer[] array);\\nstatic int[] toPrimitive(Integer[] array,int valueForNull);\\nstatic Integer[] toObject(int[] array);\\nstatic short[] toPrimitive(Short[] array);\\nstatic short[] toPrimitive(Short[] array,short valueForNull);\\nstatic Short[] toObject(short[] array);\\nstatic byte[] toPrimitive(Byte[] array);\\nstatic byte[] toPrimitive(Byte[] array,byte valueForNull);\\nstatic Byte[] toObject(byte[] array);\\nstatic double[] toPrimitive(Double[] array);\\nstatic double[] toPrimitive(Double[] array,double valueForNull);\\nstatic Double[] toObject(double[] array);\\nstatic float[] toPrimitive(Float[] array);\\nstatic float[] toPrimitive(Float[] array,float valueForNull);\\nstatic Float[] toObject(float[] array);\\nstatic boolean[] toPrimitive(Boolean[] array);\\nstatic boolean[] toPrimitive(Boolean[] array,boolean valueForNull);\\nstatic Boolean[] toObject(boolean[] array);\\nstatic boolean isEmpty(Object[] array);\\nstatic boolean isEmpty(long[] array);\\nstatic boolean isEmpty(int[] array);\\nstatic boolean isEmpty(short[] array);\\nstatic boolean isEmpty(char[] array);\\nstatic boolean isEmpty(byte[] array);\\nstatic boolean isEmpty(double[] array);\\nstatic boolean isEmpty(float[] array);\\nstatic boolean isEmpty(boolean[] array);\\nstatic boolean isNotEmpty(Object[] array);\\nstatic boolean isNotEmpty(long[] array);\\nstatic boolean isNotEmpty(int[] array);\\nstatic boolean isNotEmpty(short[] array);\\nstatic boolean isNotEmpty(char[] array);\\nstatic boolean isNotEmpty(byte[] array);\\nstatic boolean isNotEmpty(double[] array);\\nstatic boolean isNotEmpty(float[] array);\\nstatic boolean isNotEmpty(boolean[] array);\\nstatic Object[] addAll(Object[] array1,Object[] array2);\\nstatic boolean[] addAll(boolean[] array1,boolean[] array2);\\nstatic char[] addAll(char[] array1,char[] array2);\\nstatic byte[] addAll(byte[] array1,byte[] array2);\\nstatic short[] addAll(short[] array1,short[] array2);\\nstatic int[] addAll(int[] array1,int[] array2);\\nstatic long[] addAll(long[] array1,long[] array2);\\nstatic float[] addAll(float[] array1,float[] array2);\\nstatic double[] addAll(double[] array1,double[] array2);\\nstatic String[] addAll(String[] array1,String[] array2);\\nstatic T[] add(T[] array,T element);\\nstatic boolean[] add(boolean[] array,boolean element);\\nstatic byte[] add(byte[] array,byte element);\\nstatic char[] add(char[] array,char element);\\nstatic double[] add(double[] array,double element);\\nstatic float[] add(float[] array,float element);\\nstatic int[] add(int[] array,int element);\\nstatic long[] add(long[] array,long element);\\nstatic short[] add(short[] array,short element);\\nstatic Object[] add(Object[] array,int index,Object element);\\nstatic boolean[] add(boolean[] array,int index,boolean element);\\nstatic char[] add(char[] array,int index,char element);\\nstatic byte[] add(byte[] array,int index,byte element);\\nstatic short[] add(short[] array,int index,short element);\\nstatic int[] add(int[] array,int index,int element);\\nstatic long[] add(long[] array,int index,long element);\\nstatic float[] add(float[] array,int index,float element);\\nstatic double[] add(double[] array,int index,double element);\\nstatic Object[] remove(Object[] array,int index);\\nstatic Object[] removeElement(Object[] array,Object element);\\nstatic boolean[] remove(boolean[] array,int index);\\nstatic boolean[] removeElement(boolean[] array,boolean element);\\nstatic byte[] remove(byte[] array,int index);\\nstatic byte[] removeElement(byte[] array,byte element);\\nstatic char[] remove(char[] array,int index);\\nstatic char[] removeElement(char[] array,char element);\\nstatic double[] remove(double[] array,int index);\\nstatic double[] removeElement(double[] array,double element);\\nstatic float[] remove(float[] array,int index);\\nstatic float[] removeElement(float[] array,float element);\\nstatic int[] remove(int[] array,int index);\\nstatic int[] removeElement(int[] array,int element);\\nstatic long[] remove(long[] array,int index);\\nstatic long[] removeElement(long[] array,long element);\\nstatic short[] remove(short[] array,int index);\\nstatic short[] removeElement(short[] array,short element);\\nstatic Object[] clearNull(Object[] arr);\\n }\\npublic interface ClassUtils {static String getShortClassName(Object object,String valueIfNull);\\nstatic String getShortClassName(Class cls);\\nstatic String getShortClassName(String className);\\nstatic String getPackageName(Object object,String valueIfNull);\\nstatic String getPackageName(Class cls);\\nstatic String getPackageName(String className);\\nstatic List<Class<?>> getAllSuperclasses(Class cls);\\nstatic List<Class<?>> getAllInterfaces(Class cls);\\nstatic List<Class<?>> convertClassNamesToClasses(List classNames);\\nstatic List<String> convertClassesToClassNames(List classes);\\nstatic boolean isAssignable(Class<?>[] classArray,Class<?>[] toClassArray);\\nstatic boolean isAssignable(Class<?>[] classArray,Class<?>[] toClassArray,boolean autoboxing);\\nstatic boolean isAssignable(Class cls,Class toClass);\\nstatic boolean isAssignable(Class cls,Class toClass,boolean autoboxing);\\nstatic Class<?> primitiveToWrapper(Class cls);\\nstatic Class<?>[] primitivesToWrappers(Class<?>[] classes);\\nstatic Class<?> wrapperToPrimitive(Class cls);\\nstatic Class<?>[] wrappersToPrimitives(Class<?>[] classes);\\nstatic boolean isInnerClass(Class cls);\\nstatic Class<?> getClass(ClassLoader classLoader,String className,boolean initialize);\\nstatic Class<?> getClass(ClassLoader classLoader,String className);\\nstatic Class<?> getClass(String className);\\nstatic Class<?> getClass(String className,boolean initialize);\\nstatic Method getPublicMethod(Class cls,String methodName,Class parameterTypes);\\nstatic Class<?>[] toClass(Object[] array);\\nstatic String getShortCanonicalName(Object object,String valueIfNull);\\nstatic String getShortCanonicalName(Class cls);\\nstatic String getShortCanonicalName(String canonicalName);\\nstatic String getPackageCanonicalName(Object object,String valueIfNull);\\nstatic String getPackageCanonicalName(Class cls);\\nstatic String getPackageCanonicalName(String canonicalName);\\nstatic ClassLoader getClassLoader(ClassLoader classLoader);\\nstatic boolean isLangClass(Class target);\\nstatic String getDescName(Class type);\\nstatic String getDescNameWithOutModifiers(Method method);\\nstatic String getDescName(Method method);\\nstatic Class<?> getSuperClassGenricType(Class clazz,int index);\\nstatic T newInstance(Class clazz);\\n }\\n\" }",
            "class_name": "ReflectionToStringBuilder",
            "code": "static String[] toNoNullStringArray(Collection<?> collection){\n  if (collection == null) {\n    return ArrayUtils.EMPTY_STRING_ARRAY;\n  }\n  return toNoNullStringArray(collection.toArray());\n}\n",
            "docstring": "/** \n * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code> entries. Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element is <code>null</code>.\n * @param collection The collection to convert\n * @return A new array of Strings.\n */\n",
            "end_lineno": "326",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.builder;\nimport net.hasor.utils.ArrayUtils;\nimport net.hasor.utils.ClassUtils;\n\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\n/**\n * <p>\n * Assists in implementing {@link Object#toString()} methods using reflection.\n * </p>\n *\n * <p>\n * This class uses reflection to determine the fields to append. Because these fields are usually private, the class\n * uses {@link java.lang.reflect.AccessibleObject#setAccessible(java.lang.reflect.AccessibleObject[], boolean)} to\n * change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions are\n * set up correctly.\n * </p>\n *\n * <p>\n * A typical invocation for this method would look like:\n * </p>\n *\n * <pre>\n * public String toString() {\n *   return ReflectionToStringBuilder.toString(this);\n * }</pre>\n *\n *\n *\n * <p>\n * You can also use the builder to debug 3rd party objects:\n * </p>\n *\n * <pre>\n * System.out.println(\"An object: \" + ReflectionToStringBuilder.toString(anObject));</pre>\n *\n *\n *\n * <p>\n * A subclass can control field output by overriding the methods:\n * <ul>\n * <li>{@link #accept(java.lang.reflect.Field)}</li>\n * <li>{@link #getValue(java.lang.reflect.Field)}</li>\n * </ul>\n * </p>\n * <p>\n * For example, this method does <i>not</i> include the <code>password</code> field in the returned\n * <code>String</code>:\n * </p>\n *\n * <pre>\n * public String toString() {\n *     return (new ReflectionToStringBuilder(this) {\n *         protected boolean accept(Field f) {\n *             return super.accept(f) && !f.getName().equals(\"password\");\n *         }\n *     }).toString();\n * }</pre>\n *\n *\n *\n * <p>\n * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the\n * constructor.\n * </p>\n *\n * @author Apache Software Foundation\n * @author Gary Gregory\n * @author Pete Gieser\n * @since 2.0\n * @version $Id: ReflectionToStringBuilder.java 905636 2010-02-02 14:03:32Z niallp $\n */\npublic class ReflectionToStringBuilder extends ToStringBuilder {\n    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }\n\n    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object or <code>ToStringStyle</code> is <code>null</code>\n     */\n    public static String toString(Object object, ToStringStyle style) {\n        return toString(object, style, false, false, null);\n    }\n\n    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     *\n     * <p>\n     * Static fields will not be included. Superclass fields will be appended.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\n        return toString(object, style, outputTransients, false, null);\n    }\n\n    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     *\n     * <p>\n     * Static fields will not be included. Superclass fields will be appended.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include transient fields\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\n        return toString(object, style, outputTransients, outputStatics, null);\n    }\n\n    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     *\n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics, Class<?> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics).toString();\n    }\n\n    /**\n     * Builds a String for a toString method excluding the given field name.\n     *\n     * @param object\n     *            The object to \"toString\".\n     * @param excludeFieldName\n     *            The field name to exclude\n     * @return The toString value.\n     */\n    public static String toStringExclude(Object object, final String excludeFieldName) {\n        return toStringExclude(object, new String[] { excludeFieldName });\n    }\n\n    /**\n     * Builds a String for a toString method excluding the given field names.\n     *\n     * @param object\n     *            The object to \"toString\".\n     * @param excludeFieldNames\n     *            The field names to exclude. Null excludes nothing.\n     * @return The toString value.\n     */\n    public static String toStringExclude(Object object, Collection<?> /*String*/ excludeFieldNames) {\n        return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\n    }\n\n    /**\n     * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code>\n     * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element \n     * is <code>null</code>.\n     *\n     * @param collection\n     *            The collection to convert\n     * @return A new array of Strings.\n     */\n    static String[] toNoNullStringArray(Collection<?> collection) {\n        if (collection == null) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        return toNoNullStringArray(collection.toArray());\n    }\n\n    /**\n     * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists\n     * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}\n     * if an array element is <code>null</code>.\n     *\n     * @param array\n     *            The array to check\n     * @return The given array or a new array without null.\n     */\n    static String[] toNoNullStringArray(Object[] array) {\n        ArrayList<String> list = new ArrayList<String>(array.length);\n        for (int i = 0; i < array.length; i++) {\n            Object e = array[i];\n            if (e != null) {\n                list.add(e.toString());\n            }\n        }\n        return (String[]) list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Builds a String for a toString method excluding the given field names.\n     *\n     * @param object\n     *            The object to \"toString\".\n     * @param excludeFieldNames\n     *            The field names to exclude\n     * @return The toString value.\n     */\n    public static String toStringExclude(Object object, String[] excludeFieldNames) {\n        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\n    }\n\n    /**\n     * Whether or not to append static fields.\n     */\n    private boolean  appendStatics    = false;\n    /**\n     * Whether or not to append transient fields.\n     */\n    private boolean  appendTransients = false;\n    /**\n     * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\n     */\n    private String[] excludeFieldNames;\n    /**\n     * The last super class to stop appending fields for.\n     */\n    private Class<?> upToClass        = null;\n\n    /**\n     * <p>\n     * Constructor.\n     * </p>\n     *\n     * <p>\n     * This constructor outputs using the default style set with <code>setDefaultStyle</code>.\n     * </p>\n     *\n     * @param object\n     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the Object passed in is <code>null</code>\n     */\n    public ReflectionToStringBuilder(Object object) {\n        super(object);\n    }\n\n    /**\n     * <p>\n     * Constructor.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default style is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the Object passed in is <code>null</code>\n     */\n    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\n        super(object, style);\n    }\n\n    /**\n     * <p>\n     * Constructor.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default style is used.\n     * </p>\n     *\n     * <p>\n     * If the buffer is <code>null</code>, a new one is created.\n     * </p>\n     *\n     * @param object\n     *            the Object to build a <code>toString</code> for\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param buffer\n     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the Object passed in is <code>null</code>\n     */\n    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n        super(object, style, buffer);\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param object\n     *            the Object to build a <code>toString</code> for\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param buffer\n     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @since 2.1\n     */\n    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer, Class<?> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\n        super(object, style, buffer);\n        this.setUpToClass(reflectUpToClass);\n        this.setAppendTransients(outputTransients);\n        this.setAppendStatics(outputStatics);\n    }\n\n    /**\n     * Returns whether or not to append the given <code>Field</code>.\n     * <ul>\n     * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\n     * <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\n     * <li>Inner class fields are not appened.</li>\n     * </ul>\n     *\n     * @param field The Field to test.\n     * @return Whether or not to append the given <code>Field</code>.\n     */\n    protected boolean accept(Field field) {\n        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n            // Reject field from inner class.\n            return false;\n        }\n        if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n            // Reject transient fields.\n            return false;\n        }\n        if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n            // Reject static fields.\n            return false;\n        }\n        if (this.getExcludeFieldNames() != null && Arrays.binarySearch(this.getExcludeFieldNames(), field.getName()) >= 0) {\n            // Reject fields from the getExcludeFieldNames list.\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     *\n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     *\n     * @param clazz The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length; i++) {\n            Field field = fields[i];\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }\n\n    /**\n     * @return Returns the excludeFieldNames.\n     */\n    public String[] getExcludeFieldNames() {\n        return this.excludeFieldNames;\n    }\n\n    /**\n     * <p>\n     * Gets the last super class to stop appending fields for.\n     * </p>\n     *\n     * @return The last super class to stop appending fields for.\n     */\n    public Class<?> getUpToClass() {\n        return this.upToClass;\n    }\n\n    /**\n     * <p>\n     * Calls <code>java.lang.reflect.Field.get(Object)</code>.\n     * </p>\n     *\n     * @param field The Field to query.\n     * @return The Object from the given Field.\n     *\n     * @throws IllegalArgumentException see {@link java.lang.reflect.Field#get(Object)}\n     * @throws IllegalAccessException see {@link java.lang.reflect.Field#get(Object)}\n     * @see java.lang.reflect.Field#get(Object)\n     */\n    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\n        return field.get(this.getObject());\n    }\n\n    /**\n     * <p>\n     * Gets whether or not to append static fields.\n     * </p>\n     *\n     * @return Whether or not to append static fields.\n     * @since 2.1\n     */\n    public boolean isAppendStatics() {\n        return this.appendStatics;\n    }\n\n    /**\n     * <p>\n     * Gets whether or not to append transient fields.\n     * </p>\n     *\n     * @return Whether or not to append transient fields.\n     */\n    public boolean isAppendTransients() {\n        return this.appendTransients;\n    }\n\n    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     *\n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }\n\n    /**\n     * <p>\n     * Sets whether or not to append static fields.\n     * </p>\n     *\n     * @param appendStatics\n     *            Whether or not to append static fields.\n     * @since 2.1\n     */\n    public void setAppendStatics(boolean appendStatics) {\n        this.appendStatics = appendStatics;\n    }\n\n    /**\n     * <p>\n     * Sets whether or not to append transient fields.\n     * </p>\n     *\n     * @param appendTransients Whether or not to append transient fields.\n     */\n    public void setAppendTransients(boolean appendTransients) {\n        this.appendTransients = appendTransients;\n    }\n\n    /**\n     * Sets the field names to exclude.\n     *\n     * @param excludeFieldNamesParam\n     *            The excludeFieldNames to excluding from toString or <code>null</code>.\n     * @return <code>this</code>\n     */\n    public ReflectionToStringBuilder setExcludeFieldNames(String[] excludeFieldNamesParam) {\n        if (excludeFieldNamesParam == null) {\n            this.excludeFieldNames = null;\n        } else {\n            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\n            Arrays.sort(this.excludeFieldNames);\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Sets the last super class to stop appending fields for.\n     * </p>\n     *\n     * @param clazz\n     *            The last super class to stop appending fields for.\n     */\n    public void setUpToClass(Class<?> clazz) {\n        if (clazz != null) {\n            Object object = getObject();\n            if (object != null && clazz.isInstance(object) == false) {\n                throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n            }\n        }\n        this.upToClass = clazz;\n    }\n\n    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     *\n     * @return the built string\n     */\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }\n}\n",
            "file_name": "ReflectionToStringBuilder.java",
            "human_label": "If collection is null, convert collection to EMPTY_STRING_ARRAY. Otherwise, convert collection to an array of strings and return the array. ???",
            "level": "project_runnable",
            "lineno": "312",
            "name": "toNoNullStringArray",
            "oracle_context": "{ \"apis\" : \"[toArray]\", \"classes\" : \"[ArrayUtils]\", \"vars\" : \"[EMPTY_STRING_ARRAY]\" }",
            "package": "net.hasor.utils.builder",
            "project": "hasor-master"
        },
        {
            "_id": "636766821a6d9265ec0174b3",
            "all_context": "{ \"class_level\" : \"import org.atmosphere.cache.BroadcastMessage;\\nimport org.atmosphere.cache.CacheMessage;\\nimport org.atmosphere.cpr.BroadcastFilter.BroadcastAction;\\nimport org.atmosphere.lifecycle.LifecycleHandler;\\nimport org.atmosphere.pool.PoolableBroadcasterFactory;\\nimport org.atmosphere.util.Utils;\\nimport org.slf4j.Logger;\\nimport org.slf4j.LoggerFactory;\\nimport java.io.IOException;\\nimport java.net.URI;\\nimport java.util.ArrayList;\\nimport java.util.Collection;\\nimport java.util.Collections;\\nimport java.util.HashMap;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Set;\\nimport java.util.UUID;\\nimport java.util.concurrent.BlockingQueue;\\nimport java.util.concurrent.Callable;\\nimport java.util.concurrent.ConcurrentHashMap;\\nimport java.util.concurrent.ConcurrentLinkedQueue;\\nimport java.util.concurrent.Future;\\nimport java.util.concurrent.LinkedBlockingQueue;\\nimport java.util.concurrent.RejectedExecutionException;\\nimport java.util.concurrent.TimeUnit;\\nimport java.util.concurrent.atomic.AtomicBoolean;\\nimport java.util.concurrent.atomic.AtomicInteger;\\nimport java.util.concurrent.atomic.AtomicLong;\\nimport static org.atmosphere.cpr.ApplicationConfig.BACKWARD_COMPATIBLE_WEBSOCKET_BEHAVIOR;\\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_CACHE_STRATEGY;\\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_SHAREABLE_LISTENERS;\\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_WAIT_TIME;\\nimport static org.atmosphere.cpr.ApplicationConfig.CACHE_MESSAGE_ON_IO_FLUSH_EXCEPTION;\\nimport static org.atmosphere.cpr.ApplicationConfig.MAX_INACTIVE;\\nimport static org.atmosphere.cpr.ApplicationConfig.OUT_OF_ORDER_BROADCAST;\\nimport static org.atmosphere.cpr.ApplicationConfig.SUSPENDED_ATMOSPHERE_RESOURCE_UUID;\\nimport static org.atmosphere.cpr.ApplicationConfig.WRITE_TIMEOUT;\\nimport static org.atmosphere.cpr.BroadcasterLifeCyclePolicy.ATMOSPHERE_RESOURCE_POLICY.NEVER;\\nimport static org.atmosphere.cpr.FrameworkConfig.INJECTED_ATMOSPHERE_RESOURCE;\\nint POLLING_DEFAULT;\\nString CACHED;\\nLogger logger;\\nString DESTROYED;\\nList<AtmosphereResourceEventListener> EMPTY_LISTENERS;\\nConcurrentLinkedQueue<AtmosphereResource> resources;\\nBroadcasterConfig bc;\\nBlockingQueue<Deliver> messages;\\nCollection<BroadcasterListener> broadcasterListeners;\\nAtomicBoolean started;\\nAtomicBoolean initialized;\\nAtomicBoolean destroyed;\\nSCOPE scope;\\nString name;\\nConcurrentLinkedQueue<Deliver> delayedBroadcast;\\nConcurrentLinkedQueue<Deliver> broadcastOnResume;\\nConcurrentLinkedQueue<BroadcasterLifeCyclePolicyListener> lifeCycleListeners;\\nConcurrentHashMap<String,WriteQueue> writeQueues;\\nWriteQueue uniqueWriteQueue;\\nAtomicInteger dispatchThread;\\nFuture<?>[] notifierFuture;\\nFuture<?>[] asyncWriteFuture;\\nPOLICY policy;\\nAtomicLong maxSuspendResource;\\nAtomicBoolean requestScoped;\\nAtomicBoolean recentActivity;\\nBroadcasterLifeCyclePolicy lifeCyclePolicy;\\nURI uri;\\nAtmosphereConfig config;\\nObject[] awaitBarrier;\\nAtomicBoolean outOfOrderBroadcastSupported;\\nint writeTimeoutInSecond;\\nint waitTime;\\nboolean backwardCompatible;\\nLifecycleHandler lifecycleHandler;\\nFuture<?> currentLifecycleTask;\\nboolean cacheOnIOFlushException;\\nboolean sharedListeners;\\nboolean candidateForPoolable;\\nString usingTokenIdForAttribute;\\nBlockingQueue<AsyncWriteToken> queue;\\nAtomicBoolean monitored;\\nString uuid;\\nAtmosphereResource r;\\nAtmosphereResourceEvent e;\\nAtomicBoolean completed;\\nAtomicBoolean executed;\\nThread ioThread;\\nAtmosphereResource resource;\\nObject msg;\\nBroadcasterFuture future;\\nObject originalMessage;\\nCacheMessage cache;\\nAtomicInteger count;\\nDefaultBroadcaster();\\ninitialize(String name,URI uri,AtmosphereConfig config);\\ninitialize(String name,AtmosphereConfig config);\\ndestroy();\\ngetAtmosphereResources();\\nsetScope(SCOPE scope);\\ngetScope();\\nsetID(String id);\\nrename(String id);\\ngetID();\\nresumeAll();\\nreleaseExternalResources();\\nsetBroadcasterLifeCyclePolicy(BroadcasterLifeCyclePolicy lifeCyclePolicy);\\ngetBroadcasterLifeCyclePolicy();\\naddBroadcasterLifeCyclePolicyListener(BroadcasterLifeCyclePolicyListener b);\\nremoveBroadcasterLifeCyclePolicyListener(BroadcasterLifeCyclePolicyListener b);\\nisDestroyed();\\nawaitAndBroadcast(Object t,long time,TimeUnit timeUnit);\\naddBroadcasterListener(BroadcasterListener b);\\nremoveBroadcasterListener(BroadcasterListener b);\\ngetBroadcastHandler();\\nrun();\\ngetAsyncWriteHandler(WriteQueue writeQueue);\\nstart();\\nspawnReactor();\\nkillReactiveThreads();\\nreactiveThreadsCount();\\npush(Deliver deliver);\\ndeliverPush(Deliver deliver,boolean rec);\\nendBroadcast(Deliver deliver,AtmosphereResource r,CacheMessage cacheMsg,boolean deliverMessage);\\nqueueWriteIO(AtmosphereResource r,Deliver deliver,AtomicInteger count);\\nexecuteBlockingWrite(AtmosphereResource r,Deliver deliver,AtomicInteger count);\\nWriteQueue(String uuid);\\nasString();\\nperRequestFilter(AtmosphereResource r,Deliver msg);\\ncallable(Object msg);\\nexecuteAsyncWrite(AsyncWriteToken token);\\ncacheMessageOnIOException(Throwable cause);\\ncheckCachedAndPush(AtmosphereResource r,AtmosphereResourceEvent e);\\nretrieveTrackedBroadcast(AtmosphereResource r,AtmosphereResourceEvent e);\\ninvokeOnStateChange(AtmosphereResource r,AtmosphereResourceEvent e);\\nprepareInvokeOnStateChange(AtmosphereResource r,AtmosphereResourceEvent e);\\nWriteOperation(AtmosphereResource r,AtmosphereResourceEvent e,Thread ioThread);\\ncall();\\ninterrupt();\\nonException(Throwable t,AtmosphereResource ar);\\nonException(Throwable t,AtmosphereResource ar,boolean notifyAndCache);\\ncacheLostMessage(AtmosphereResource r,boolean force);\\ncacheLostMessage(AtmosphereResource r,AsyncWriteToken token);\\ncacheLostMessage(AtmosphereResource r,AsyncWriteToken token,boolean force);\\nsetSuspendPolicy(long maxSuspendResource,POLICY policy);\\nbroadcast(Object msg);\\nfutureDone(Object msg);\\ndispatchMessages(Deliver e);\\nfilter(Object msg);\\nbroadcast(Object msg,AtmosphereResource r);\\nbroadcastOnResume(Object msg);\\nbroadcastOnResume(AtmosphereResource r);\\nbroadcast(Object msg,Set subset);\\naddAtmosphereResource(AtmosphereResource r);\\ncacheAndSuspend(AtmosphereResource r);\\nnotifyAndAdd(AtmosphereResource r);\\nisAtmosphereResourceValid(AtmosphereResource r);\\nentryDone(BroadcasterFuture f);\\nnotifyBroadcastListener();\\nnotifyOnAddAtmosphereResourceListener(AtmosphereResource r);\\nnotifyOnRemoveAtmosphereResourceListener(AtmosphereResource r);\\nnotifyOnMessage(Deliver deliver);\\nremoveAtmosphereResource(AtmosphereResource r);\\nremoveAtmosphereResource(AtmosphereResource r,boolean executeDone);\\nsetBroadcasterConfig(BroadcasterConfig bc);\\ngetBroadcasterConfig();\\ndelayBroadcast(Object o);\\ndelayBroadcast(Object o,long delay,TimeUnit t);\\nscheduleFixedBroadcast(Object o,long period,TimeUnit t);\\nscheduleFixedBroadcast(Object o,long waitFor,long period,TimeUnit t);\\ntoString();\\nAsyncWriteToken(AtmosphereResource resource,Object msg,BroadcasterFuture future,Object originalMessage,AtomicInteger count);\\nAsyncWriteToken(AtmosphereResource resource,Object msg,BroadcasterFuture future,Object originalMessage,CacheMessage cache,AtomicInteger count);\\nlastBroadcasted();\\ntranslateTimeUnit(long period,TimeUnit tu);\\nnotifyOnPreDestroy();\\nbroadcasterListeners();\\nlifeCyclePolicy();\\nlifeCycleListeners();\\nmessages();\\nwriteQueues();\\npolicy();\\noutOfOrderBroadcastSupported();\\nrecentActivity();\\nlifecycleHandler();\\nlifecycleHandler(LifecycleHandler lifecycleHandler);\\ncurrentLifecycleTask();\\ncurrentLifecycleTask(Future currentLifecycleTask);\\ncreateBroadcasterConfig(AtmosphereConfig config);\\n\", \"repo_level\" : \"public interface BroadcastMessage {public String id();\\npublic Object message();\\n }\\npublic interface CacheMessage {public Object getMessage();\\npublic String getId();\\npublic String toString();\\npublic long getCreateTime();\\npublic String uuid();\\n }\\npublic interface LifecycleHandler {public LifecycleHandler on(DefaultBroadcaster broadcaster);\\npublic void run();\\n void destroy(boolean resume);\\npublic LifecycleHandler offIfEmpty(DefaultBroadcaster broadcaster);\\npublic LifecycleHandler off(DefaultBroadcaster broadcaster);\\nprotected void notifyIdleListener(DefaultBroadcaster broadcaster);\\nprotected void notifyDestroyListener(DefaultBroadcaster broadcaster);\\nprotected void notifyEmptyListener(DefaultBroadcaster broadcaster);\\n }\\npublic interface PoolableBroadcasterFactory {protected void configure(String broadcasterLifeCyclePolicy);\\npublic Broadcaster get();\\npublic boolean add(Broadcaster b,Object id);\\npublic boolean remove(Broadcaster b,Object id);\\npublic T lookup(Class c,Object id,boolean createIfNull,boolean unique);\\npublic void removeAllAtmosphereResource(AtmosphereResource r);\\npublic boolean remove(Object id);\\npublic Collection<Broadcaster> lookupAll();\\npublic Broadcaster createBroadcaster();\\npublic PoolableBroadcasterFactory trackPooledBroadcaster(boolean trackPooledBroadcaster);\\npublic boolean trackPooledBroadcaster();\\npublic PoolableProvider<? extends Broadcaster,?> poolableProvider();\\npublic PoolableBroadcasterFactory poolableProvider(PoolableProvider poolableProvider);\\n }\\npublic interface Utils {static boolean webSocketEnabled(HttpServletRequest request);\\nstatic boolean rawWebSocket(HttpServletRequest request);\\nstatic boolean firefoxWebSocketEnabled(HttpServletRequest request);\\nstatic boolean twoConnectionsTransport(TRANSPORT t);\\nstatic boolean webSocketQueryStringPresentOrNull(HttpServletRequest request);\\nstatic boolean resumableTransport(TRANSPORT t);\\nstatic boolean pollableTransport(TRANSPORT t);\\nstatic boolean pushMessage(TRANSPORT t);\\nstatic boolean atmosphereProtocol(AtmosphereRequest r);\\nstatic boolean webSocketMessage(AtmosphereResource r);\\nstatic boolean properProtocol(HttpServletRequest request);\\nstatic AtmosphereResource websocketResource(AtmosphereResource r);\\nstatic boolean closeMessage(HttpServletRequest request);\\nstatic Object invoke(Object proxiedInstance,Method m,Object o);\\nstatic void inject(AtmosphereResource r);\\nstatic void inject(Object object,Class clazz,AtmosphereResource r);\\nstatic void inject(Object object,Class clazz,AtmosphereConfig config);\\nstatic Set<Field> getInheritedPrivateFields(Class type);\\nstatic Set<Method> getInheritedPrivateMethod(Class type);\\nstatic boolean requestScopedInjection(AtmosphereConfig config,AtmosphereHandler h);\\nstatic boolean requestScopedInjection(AtmosphereConfig config,Object o);\\nstatic void destroyMeteor(AtmosphereRequest req);\\nstatic String pathInfo(AtmosphereRequest request);\\nstatic boolean isRunningTest();\\nstatic boolean isUnderJDK11AndUp();\\n }\\n\" }",
            "class_name": "DefaultBroadcaster",
            "code": "protected Object filter(Object msg){\n  BroadcastAction a=bc.filter(msg);\n  if (a.action() == BroadcastAction.ACTION.ABORT || msg == null)   return null;\n else   return a.message();\n}\n",
            "docstring": "/** \n * Invoke the  {@link BroadcastFilter}\n * @param msg\n * @return\n */\n",
            "end_lineno": "1244",
            "file_content": "/*\n * Copyright 2008-2022 Async-IO.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage org.atmosphere.cpr;\n\nimport org.atmosphere.cache.BroadcastMessage;\nimport org.atmosphere.cache.CacheMessage;\nimport org.atmosphere.cpr.BroadcastFilter.BroadcastAction;\nimport org.atmosphere.lifecycle.LifecycleHandler;\nimport org.atmosphere.pool.PoolableBroadcasterFactory;\nimport org.atmosphere.util.Utils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport static org.atmosphere.cpr.ApplicationConfig.BACKWARD_COMPATIBLE_WEBSOCKET_BEHAVIOR;\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_CACHE_STRATEGY;\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_SHAREABLE_LISTENERS;\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_WAIT_TIME;\nimport static org.atmosphere.cpr.ApplicationConfig.CACHE_MESSAGE_ON_IO_FLUSH_EXCEPTION;\nimport static org.atmosphere.cpr.ApplicationConfig.MAX_INACTIVE;\nimport static org.atmosphere.cpr.ApplicationConfig.OUT_OF_ORDER_BROADCAST;\nimport static org.atmosphere.cpr.ApplicationConfig.SUSPENDED_ATMOSPHERE_RESOURCE_UUID;\nimport static org.atmosphere.cpr.ApplicationConfig.WRITE_TIMEOUT;\nimport static org.atmosphere.cpr.BroadcasterLifeCyclePolicy.ATMOSPHERE_RESOURCE_POLICY.NEVER;\nimport static org.atmosphere.cpr.FrameworkConfig.INJECTED_ATMOSPHERE_RESOURCE;\n\n/**\n * The default {@link Broadcaster} implementation.\n * <p/>\n * Broadcast messages to suspended responses using the caller's Thread.\n * This basic {@link Broadcaster} use an {@link java.util.concurrent.ExecutorService}\n * to broadcast messages, hence the broadcast operation is asynchronous. Make sure\n * you block on {@link #broadcast(Object)}.get()} if you need synchronous operations.\n *\n * @author Jeanfrancois Arcand\n */\npublic class DefaultBroadcaster implements Broadcaster {\n    public static final int POLLING_DEFAULT = 100;\n    public static final String CACHED = DefaultBroadcaster.class.getName() + \".messagesCached\";\n\n    private static final Logger logger = LoggerFactory.getLogger(DefaultBroadcaster.class);\n    private static final String DESTROYED = \"This Broadcaster has been destroyed and cannot be used {} by invoking {}\";\n    private static final List<AtmosphereResourceEventListener> EMPTY_LISTENERS = new ArrayList<>();\n\n    protected final ConcurrentLinkedQueue<AtmosphereResource> resources =\n            new ConcurrentLinkedQueue<>();\n    protected BroadcasterConfig bc;\n    protected final BlockingQueue<Deliver> messages = new LinkedBlockingQueue<>();\n    protected Collection<BroadcasterListener> broadcasterListeners;\n\n    protected final AtomicBoolean started = new AtomicBoolean(false);\n    protected final AtomicBoolean initialized = new AtomicBoolean(false);\n    protected final AtomicBoolean destroyed = new AtomicBoolean(false);\n\n    protected SCOPE scope = SCOPE.APPLICATION;\n    protected String name = DefaultBroadcaster.class.getSimpleName();\n    protected final ConcurrentLinkedQueue<Deliver> delayedBroadcast = new ConcurrentLinkedQueue<>();\n    protected final ConcurrentLinkedQueue<Deliver> broadcastOnResume = new ConcurrentLinkedQueue<>();\n    protected final ConcurrentLinkedQueue<BroadcasterLifeCyclePolicyListener> lifeCycleListeners = new ConcurrentLinkedQueue<>();\n    protected final ConcurrentHashMap<String, WriteQueue> writeQueues = new ConcurrentHashMap<>();\n    protected final WriteQueue uniqueWriteQueue = new WriteQueue(\"-1\");\n    protected final AtomicInteger dispatchThread = new AtomicInteger();\n\n    protected Future<?>[] notifierFuture;\n    protected Future<?>[] asyncWriteFuture;\n\n    private POLICY policy = POLICY.FIFO;\n    private final AtomicLong maxSuspendResource = new AtomicLong(-1);\n    private final AtomicBoolean requestScoped = new AtomicBoolean(false);\n    private final AtomicBoolean recentActivity = new AtomicBoolean(false);\n    private BroadcasterLifeCyclePolicy lifeCyclePolicy = new BroadcasterLifeCyclePolicy.Builder()\n            .policy(NEVER).build();\n    protected URI uri;\n    protected AtmosphereConfig config;\n    private final Object[] awaitBarrier = new Object[0];\n    private final AtomicBoolean outOfOrderBroadcastSupported = new AtomicBoolean(false);\n    protected int writeTimeoutInSecond = -1;\n    protected int waitTime = POLLING_DEFAULT;\n    private boolean backwardCompatible;\n    private LifecycleHandler lifecycleHandler;\n    private Future<?> currentLifecycleTask;\n    private boolean cacheOnIOFlushException = true;\n    protected boolean sharedListeners;\n    protected boolean candidateForPoolable;\n    protected final String usingTokenIdForAttribute = UUID.randomUUID().toString();\n\n    public DefaultBroadcaster() {\n    }\n\n    public Broadcaster initialize(String name, URI uri, AtmosphereConfig config) {\n        this.name = name;\n        this.uri = uri;\n        this.config = config;\n\n        bc = createBroadcasterConfig(config);\n        String s = config.getInitParameter(BROADCASTER_CACHE_STRATEGY);\n        if (s != null) {\n            logger.warn(\"{} is no longer supported. Use BroadcastInterceptor instead. By default the original message will be cached.\", BROADCASTER_CACHE_STRATEGY);\n        }\n        s = config.getInitParameter(OUT_OF_ORDER_BROADCAST);\n        if (s != null) {\n            outOfOrderBroadcastSupported.set(Boolean.parseBoolean(s));\n        }\n\n        s = config.getInitParameter(BROADCASTER_WAIT_TIME);\n        if (s != null) {\n            waitTime = Integer.parseInt(s);\n        }\n\n        s = config.getInitParameter(WRITE_TIMEOUT);\n        if (s != null) {\n            writeTimeoutInSecond = Integer.parseInt(s);\n        }\n        if (outOfOrderBroadcastSupported.get()) {\n            logger.trace(\"{} supports Out Of Order Broadcast: {}\", name, outOfOrderBroadcastSupported.get());\n        }\n        initialized.set(true);\n        backwardCompatible = Boolean.parseBoolean(config.getInitParameter(BACKWARD_COMPATIBLE_WEBSOCKET_BEHAVIOR));\n        cacheOnIOFlushException = config.getInitParameter(CACHE_MESSAGE_ON_IO_FLUSH_EXCEPTION, true);\n        sharedListeners = config.getInitParameter(BROADCASTER_SHAREABLE_LISTENERS, false);\n\n        if (sharedListeners) {\n            broadcasterListeners = config.getBroadcasterFactory().broadcasterListeners();\n        } else {\n            broadcasterListeners = new ConcurrentLinkedQueue<>();\n        }\n\n        candidateForPoolable = PoolableBroadcasterFactory.class.isAssignableFrom(config.getBroadcasterFactory().getClass());\n\n        return this;\n    }\n\n    public Broadcaster initialize(String name, AtmosphereConfig config) {\n        return initialize(name, URI.create(\"http://localhost\"), config);\n    }\n\n    /**\n     * Create {@link BroadcasterConfig}.\n     *\n     * @param config the {@link AtmosphereConfig}\n     * @return an instance of {@link BroadcasterConfig}\n     */\n    protected BroadcasterConfig createBroadcasterConfig(AtmosphereConfig config) {\n        return new BroadcasterConfig(config.framework().broadcasterFilters, config, getID()).init();\n    }\n\n    @Override\n    public synchronized void destroy() {\n        try {\n            logger.trace(\"Broadcaster {} will be pooled: {}\", getID(), candidateForPoolable);\n            if (!candidateForPoolable) {\n                if (notifyOnPreDestroy()) return;\n\n                logger.trace(\"Broadcaster {} is being destroyed and cannot be re-used. Policy was {}\", getID(), policy);\n                logger.trace(\"Broadcaster {} is being destroyed and cannot be re-used. Resources are {}\", getID(), resources);\n                \n                if (destroyed.getAndSet(true)) return;\n\n                started.set(false);\n\n                releaseExternalResources();\n                killReactiveThreads();\n\n                if (bc != null) {\n                    bc.destroy();\n                }\n                lifeCycleListeners.clear();\n                delayedBroadcast.clear();\n                if (!sharedListeners) {\n                    broadcasterListeners.clear();\n                }\n            }\n\n            resources.clear();\n            broadcastOnResume.clear();\n            messages.clear();\n            writeQueues.clear();\n\n            if (config.getBroadcasterFactory() != null) {\n                config.getBroadcasterFactory().remove(this, this.getID());\n            }\n        } catch (Throwable t) {\n            logger.error(\"Unexpected exception during Broadcaster destroy {}\", getID(), t);\n        }\n    }\n\n    @Override\n    public Collection<AtmosphereResource> getAtmosphereResources() {\n        return Collections.unmodifiableCollection(resources);\n    }\n\n    @Override\n    public void setScope(SCOPE scope) {\n        if (destroyed.get()) {\n            logger.debug(DESTROYED, getID(), \"setScope\");\n            return;\n        }\n\n        this.scope = scope;\n        if (scope != SCOPE.REQUEST) {\n            return;\n        }\n\n        logger.debug(\"Changing broadcaster scope for {}. This broadcaster will be destroyed.\", getID());\n        synchronized (resources) {\n            try {\n                // Next, we need to create a new broadcaster per resource.\n                for (AtmosphereResource resource : resources) {\n                    Broadcaster b = config.getBroadcasterFactory()\n                            .get(getClass(), getClass().getSimpleName() + \"/\" + config.uuidProvider().generateUuid());\n\n                    /**\n                     * REQUEST_SCOPE means one BroadcasterCache per Broadcaster,\n                     */\n                    if (DefaultBroadcaster.class.isAssignableFrom(this.getClass())) {\n                        BroadcasterCache cache = config.framework().newClassInstance(BroadcasterCache.class, bc.getBroadcasterCache().getClass());\n                        cache.configure(config);\n                        b.getBroadcasterConfig().setBroadcasterCache(cache);\n                    }\n\n                    resource.setBroadcaster(b);\n                    b.setScope(SCOPE.REQUEST);\n                    if (resource.getAtmosphereResourceEvent().isSuspended()) {\n                        b.addAtmosphereResource(resource);\n                    }\n                    logger.debug(\"Resource {} not using broadcaster {}\", resource, b.getID());\n                }\n\n                // Do not destroy because this is a new Broadcaster\n                if (resources.isEmpty()) {\n                    return;\n                }\n\n                destroy();\n            } catch (Exception e) {\n                logger.error(\"Failed to set request scope for current resources\", e);\n            }\n        }\n    }\n\n    @Override\n    public SCOPE getScope() {\n        return scope;\n    }\n\n    @Override\n    public synchronized void setID(String id) {\n        if (id == null) {\n            id = getClass().getSimpleName() + \"/\" + config.uuidProvider().generateUuid();\n        }\n\n        if (config.getBroadcasterFactory() == null)\n            return; // we are shutdown or destroyed, but someone still reference\n\n        Broadcaster b = config.getBroadcasterFactory().lookup(this.getClass(), id);\n        if (b != null && b.getScope() == SCOPE.REQUEST) {\n            throw new IllegalStateException(\"Broadcaster ID already assigned to SCOPE.REQUEST. Cannot change the id\");\n        } else if (b != null) {\n            return;\n        }\n\n        config.getBroadcasterFactory().remove(this, name);\n        this.name = id;\n        config.getBroadcasterFactory().add(this, name);\n\n        bc.broadcasterID(name);\n    }\n\n    /**\n     * Rename this Broadcaster without invoking it's associated {@link org.atmosphere.cpr.BroadcasterFactory}. This\n     * method must be carefully used as it could easily create memory leak as the Broadcaster won't be removed\n     * from its {@link org.atmosphere.cpr.BroadcasterFactory}.\n     *\n     * @param id the new name\n     * @return this;\n     */\n    public Broadcaster rename(String id) {\n        this.name = id;\n        return this;\n    }\n\n    @Override\n    public String getID() {\n        return name;\n    }\n\n    @Override\n    public void resumeAll() {\n        synchronized (resources) {\n            for (AtmosphereResource r : resources) {\n                try {\n                    r.resume();\n                } catch (Throwable t) {\n                    logger.trace(\"resumeAll\", t);\n                } finally {\n                    removeAtmosphereResource(r);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void releaseExternalResources() {\n    }\n\n    @Override\n    public void setBroadcasterLifeCyclePolicy(final BroadcasterLifeCyclePolicy lifeCyclePolicy) {\n        this.lifeCyclePolicy = lifeCyclePolicy;\n        if (lifecycleHandler != null) lifecycleHandler.on(this);\n    }\n\n    @Override\n    public BroadcasterLifeCyclePolicy getBroadcasterLifeCyclePolicy() {\n        return lifeCyclePolicy;\n    }\n\n    @Override\n    public void addBroadcasterLifeCyclePolicyListener(BroadcasterLifeCyclePolicyListener b) {\n        lifeCycleListeners.add(b);\n    }\n\n    @Override\n    public void removeBroadcasterLifeCyclePolicyListener(BroadcasterLifeCyclePolicyListener b) {\n        lifeCycleListeners.remove(b);\n    }\n\n    @Override\n    public boolean isDestroyed() {\n        return destroyed.get();\n    }\n\n    @Override\n    public Future<Object> awaitAndBroadcast(Object t, long time, TimeUnit timeUnit) {\n        if (resources.isEmpty()) {\n            synchronized (awaitBarrier) {\n                try {\n                    logger.trace(\"Awaiting for AtmosphereResource for {} {}\", time, timeUnit);\n                    awaitBarrier.wait(translateTimeUnit(time, timeUnit));\n                } catch (Throwable e) {\n                    logger.warn(\"awaitAndBroadcast\", e);\n                    return null;\n                }\n            }\n        }\n        return broadcast(t);\n    }\n\n    @Override\n    public Broadcaster addBroadcasterListener(BroadcasterListener b) {\n        if (!sharedListeners && !broadcasterListeners.contains(b)) {\n            broadcasterListeners.add(b);\n        }\n        return this;\n    }\n\n    @Override\n    public Broadcaster removeBroadcasterListener(BroadcasterListener b) {\n        if (!sharedListeners) broadcasterListeners.remove(b);\n        return this;\n    }\n\n    protected Runnable getBroadcastHandler() {\n        return new Runnable() {\n            public void run() {\n                while (!isDestroyed()) {\n                    Deliver msg = null;\n                    try {\n                        msg = messages.poll(waitTime, TimeUnit.MILLISECONDS);\n                        if (msg == null) {\n                            dispatchThread.decrementAndGet();\n                            return;\n                        }\n                    } catch (InterruptedException ex) {\n                        logger.trace(\"{} got interrupted for Broadcaster {}\", Thread.currentThread().getName(), getID());\n                        logger.trace(\"\", ex);\n                        dispatchThread.decrementAndGet();\n                        return;\n                    } finally {\n                        if (outOfOrderBroadcastSupported.get()) {\n                            bc.getExecutorService().submit(this);\n                        }\n                    }\n\n                    try {\n                        logger.trace(\"{} is about to broadcast {}\", getID(), msg);\n                        push(msg);\n                    } catch (Throwable ex) {\n                        if (!started.get() || destroyed.get()) {\n                            logger.trace(\"Failed to submit broadcast handler runnable on shutdown for Broadcaster {}\", getID(), ex);\n                            dispatchThread.decrementAndGet();\n                            return;\n                        } else {\n                            logger.warn(\"This message {} will be lost\", msg);\n                            logger.warn(\"Failed to submit broadcast handler runnable to for Broadcaster\" + getID(), ex);\n                        }\n                    } finally {\n                        if (outOfOrderBroadcastSupported.get()) {\n                            dispatchThread.decrementAndGet();\n                            return;\n                        }\n                    }\n                }\n            }\n        };\n    }\n\n    protected Runnable getAsyncWriteHandler(final WriteQueue writeQueue) {\n        return new Runnable() {\n            public void run() {\n                while (!isDestroyed()) {\n                    AsyncWriteToken token;\n                    try {\n                        token = writeQueue.queue.poll(waitTime, TimeUnit.MILLISECONDS);\n                        if (token == null && !outOfOrderBroadcastSupported.get()) {\n                            synchronized (writeQueue) {\n                                if (writeQueue.queue.isEmpty()) {\n                                    writeQueue.monitored.set(false);\n                                    writeQueues.remove(writeQueue.uuid);\n                                    return;\n                                }\n                            }\n                        } else if (token == null) {\n                            return;\n                        }\n                    } catch (InterruptedException ex) {\n                        logger.trace(\"{} got interrupted for Broadcaster {}\", Thread.currentThread().getName(), getID());\n                        logger.trace(\"\", ex);\n                        return;\n                    } finally {\n                        if (!bc.getAsyncWriteService().isShutdown() && outOfOrderBroadcastSupported.get()) {\n                            bc.getAsyncWriteService().submit(this);\n                        }\n                    }\n\n                    // Shield us from https://github.com/Atmosphere/atmosphere/issues/1187\n                    if (token != null) {\n                        synchronized (token.resource) {\n                            try {\n                                logger.trace(\"About to write to {}\", token.resource);\n                                executeAsyncWrite(token);\n                            } catch (Throwable ex) {\n                                if (!started.get() || destroyed.get()) {\n                                    logger.trace(\"Failed to execute a write operation. Broadcaster is destroyed or not yet started for Broadcaster {}\", getID(), ex);\n                                    return;\n                                } else {\n                                    try {\n                                        logger.warn(\"This message {} will be lost for AtmosphereResource {}, adding it to the BroadcasterCache\",\n                                                token.originalMessage, token.resource != null ? token.resource.uuid() : \"null\");\n                                        cacheLostMessage(token.resource, token, true);\n                                    } finally {\n                                        removeAtmosphereResource(token.resource, false);\n                                        logger.warn(\"Failed to execute a write operation for Broadcaster \" + getID(), ex);\n                                    }\n                                }\n                            } finally {\n                                if (!bc.getAsyncWriteService().isShutdown() && outOfOrderBroadcastSupported.get()) {\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n    }\n\n    protected void start() {\n        if (!initialized.get()) {\n            logger.warn(\"Broadcaster {} not initialized\", getID());\n        }\n\n        if (!started.getAndSet(true)) {\n            bc.getBroadcasterCache().start();\n\n            // Only start if we know a child haven't started them.\n            if (notifierFuture == null && asyncWriteFuture == null) {\n                spawnReactor();\n            }\n        }\n    }\n\n    protected void spawnReactor() {\n        killReactiveThreads();\n\n        int threads = outOfOrderBroadcastSupported.get() ? reactiveThreadsCount() : 1;\n        notifierFuture = new Future<?>[threads];\n\n        if (outOfOrderBroadcastSupported.get()) {\n            asyncWriteFuture = new Future<?>[threads];\n            for (int i = 0; i < threads; i++) {\n                notifierFuture[i] = bc.getExecutorService().submit(getBroadcastHandler());\n                asyncWriteFuture[i] = bc.getAsyncWriteService().submit(getAsyncWriteHandler(uniqueWriteQueue));\n            }\n        } else {\n            notifierFuture[0] = bc.getExecutorService().submit(getBroadcastHandler());\n        }\n        dispatchThread.set(threads);\n    }\n\n    protected void killReactiveThreads() {\n        if (notifierFuture != null) {\n            for (Future<?> f : notifierFuture) {\n                if (f != null)\n                    f.cancel(false);\n            }\n        }\n\n        if (asyncWriteFuture != null) {\n            for (Future<?> f : asyncWriteFuture) {\n                if (f != null)\n                    f.cancel(false);\n            }\n        }\n    }\n\n    /**\n     * Return the default number of reactive threads that will be waiting for work when a broadcast operation\n     * is executed.\n     *\n     * @return the default number of reactive threads\n     */\n    protected int reactiveThreadsCount() {\n        return Runtime.getRuntime().availableProcessors() * 2;\n    }\n\n    protected void push(Deliver deliver) {\n        if (destroyed.get()) {\n            return;\n        }\n\n        deliverPush(deliver, true);\n    }\n\n    protected void deliverPush(Deliver deliver, boolean rec) {\n        recentActivity.set(true);\n\n        Object prevMessage = deliver.message;\n        if (rec && !delayedBroadcast.isEmpty()) {\n            Iterator<Deliver> i = delayedBroadcast.iterator();\n            StringBuilder b = new StringBuilder();\n            while (i.hasNext()) {\n                Deliver e = i.next();\n                e.future.cancel(true);\n                try {\n                    // Append so we do a single flush\n                    if (e.message instanceof String\n                            && deliver.message instanceof String) {\n                        b.append(e.message);\n                    } else {\n                        deliverPush(e, false);\n                    }\n                } finally {\n                    i.remove();\n                }\n            }\n\n            if (b.length() > 0) {\n                deliver.message = b.append(deliver.message).toString();\n            }\n        }\n\n        Object finalMsg = callable(deliver.message);\n        if (finalMsg == null) {\n            logger.error(\"Callable exception. Please catch all exceptions from your callable. Message {} will be lost and all AtmosphereResource \" +\n                    \"associated with this Broadcaster resumed.\", deliver.message);\n            entryDone(deliver.future);\n            switch (deliver.type) {\n                case ALL:\n                    synchronized (resources) {\n                        for (AtmosphereResource r : resources) {\n                            if (Utils.resumableTransport(r.transport()))\n                                try {\n                                    r.resume();\n                                } catch (Throwable t) {\n                                    logger.trace(\"resumeAll\", t);\n                                }\n                        }\n                    }\n                    break;\n                case RESOURCE:\n                    deliver.resource.resume();\n                    break;\n                case SET:\n                    for (AtmosphereResource r : deliver.resources) {\n                        r.resume();\n                    }\n                    break;\n            }\n            return;\n        }\n\n        Object prevM = deliver.originalMessage;\n        deliver.originalMessage = (deliver.originalMessage != deliver.message ? callable(deliver.originalMessage) : finalMsg);\n\n        if (deliver.originalMessage == null) {\n            logger.trace(\"Broadcasted message was null {}\", prevM);\n            entryDone(deliver.future);\n            return;\n        }\n\n        deliver.message = finalMsg;\n\n        Map<String, CacheMessage> cacheForSet = deliver.type == Deliver.TYPE.SET ? new HashMap<>() : null;\n        // We cache first, and if the broadcast succeed, we will remove it.\n        switch (deliver.type) {\n            case ALL:\n                deliver.cache = bc.getBroadcasterCache().addToCache(getID(), BroadcasterCache.NULL, new BroadcastMessage(deliver.originalMessage));\n                break;\n            case RESOURCE:\n                deliver.cache = bc.getBroadcasterCache().addToCache(getID(), deliver.resource.uuid(), new BroadcastMessage(deliver.originalMessage));\n                break;\n            case SET:\n                for (AtmosphereResource r : deliver.resources) {\n                    cacheForSet.put(r.uuid(), bc.getBroadcasterCache().addToCache(getID(), r.uuid(), new BroadcastMessage(deliver.originalMessage)));\n                }\n                break;\n        }\n\n        notifyOnMessage(deliver);\n        if (resources.isEmpty()) {\n            logger.trace(\"No resource available for {} and message {}\", getID(), finalMsg);\n            entryDone(deliver.future);\n            if (cacheForSet != null) {\n                cacheForSet.clear();\n            }\n            return;\n        }\n\n        try {\n            if (logger.isTraceEnabled()) {\n                for (AtmosphereResource r : resources) {\n                    logger.trace(\"AtmosphereResource {} available for {}\", r.uuid(), deliver.message);\n                }\n            }\n\n            boolean hasFilters = bc.hasPerRequestFilters();\n            Object beforeProcessingMessage = deliver.message;\n            switch (deliver.type) {\n                case ALL:\n                    AtomicInteger count = new AtomicInteger(resources.size());\n\n                    for (AtmosphereResource r : resources) {\n                        deliver.message = beforeProcessingMessage;\n                        boolean deliverMessage = perRequestFilter(r, deliver);\n\n                        if (endBroadcast(deliver, r, deliver.cache, deliverMessage)) continue;\n\n                        if (deliver.writeLocally) {\n                            queueWriteIO(r, hasFilters ? new Deliver(r, deliver) : deliver, count);\n                        }\n                    }\n                    break;\n                case RESOURCE:\n                    boolean deliverMessage = perRequestFilter(deliver.resource, deliver);\n\n                    if (endBroadcast(deliver, deliver.resource, deliver.cache,  deliverMessage)) return;\n\n                    if (deliver.writeLocally) {\n                        queueWriteIO(deliver.resource, deliver, new AtomicInteger(1));\n                    }\n                    break;\n                case SET:\n                    count = new AtomicInteger(deliver.resources.size());\n\n                    for (AtmosphereResource r : deliver.resources) {\n                        deliver.message = beforeProcessingMessage;\n                        deliverMessage = perRequestFilter(r, deliver);\n\n                        CacheMessage cacheMsg = cacheForSet.remove(r.uuid());\n\n                        if (endBroadcast(deliver, r, cacheMsg, deliverMessage)) continue;\n\n                        if (deliver.writeLocally) {\n                            queueWriteIO(r, new Deliver(r, deliver, cacheMsg), count);\n                        }\n                    }\n                    break;\n            }\n\n            deliver.message = prevMessage;\n        } catch (InterruptedException ex) {\n            logger.debug(ex.getMessage(), ex);\n            if (cacheForSet != null) {\n                cacheForSet.clear();\n            }\n        }\n    }\n\n    protected boolean endBroadcast(Deliver deliver, AtmosphereResource r, CacheMessage cacheMsg, boolean deliverMessage) {\n        if (!deliverMessage || deliver.message == null) {\n            logger.debug(\"Skipping broadcast delivery {} for resource {} \", deliver.message, deliver.resource != null ? deliver.resource.uuid() : \"null\");\n            bc.getBroadcasterCache().clearCache(getID(), r.uuid(), cacheMsg);\n            entryDone(deliver.future);\n\n            return true;\n        }\n        return false;\n    }\n\n    protected void queueWriteIO(AtmosphereResource r, Deliver deliver, AtomicInteger count) throws InterruptedException {\n        if (deliver.async) {\n            // The onStateChange/onRequest may change the isResumed value, hence we need to make sure only one thread flip\n            // the switch to garantee the Entry will be cached in the order it was broadcasted.\n            // Without synchronizing we may end up with a out of order BroadcasterCache queue.\n            if (!bc.getBroadcasterCache().getClass().equals(BroadcasterCache.DEFAULT.getClass())) {\n                if (r.isResumed() || r.isCancelled()) {\n                    logger.trace(\"AtmosphereResource {} has been resumed or cancelled, unable to Broadcast message {}\", r.uuid(), deliver.message);\n\n                    /*\n                     * https://github.com/Atmosphere/atmosphere/issues/1886\n                     * Before caching the message, double check if the client has reconnected, and if true, send the\n                     * cached message.\n                     */\n                    AtmosphereResource r2 = config.resourcesFactory().find(r.uuid());\n                    logger.trace(\"Found an AtmosphereResource {} in state {}\", r2, r.isSuspended());\n                    if (r2 != null && r2.isSuspended() && r.hashCode() != r2.hashCode()) {\n                        // Prevent other Broadcast to happens\n                        removeAtmosphereResource(r2);\n                        checkCachedAndPush(r2, r2.getAtmosphereResourceEvent());\n                    }\n                    return;\n                }\n            }\n\n            AsyncWriteToken w = new AsyncWriteToken(r, deliver.message, deliver.future, deliver.originalMessage, deliver.cache, count);\n            if (!outOfOrderBroadcastSupported.get()) {\n                WriteQueue writeQueue = writeQueues.get(r.uuid());\n                if (writeQueue == null) {\n                    writeQueue = new WriteQueue(r.uuid());\n                    writeQueues.put(r.uuid(), writeQueue);\n                }\n\n                writeQueue.queue.put(w);\n                synchronized (writeQueue) {\n                    if (!writeQueue.monitored.getAndSet(true)) {\n                        logger.trace(\"Broadcaster {} is about to queueWriteIO for AtmosphereResource {}\", name, r.uuid());\n                        bc.getAsyncWriteService().submit(getAsyncWriteHandler(writeQueue));\n                    }\n                }\n            } else {\n                uniqueWriteQueue.queue.offer(w);\n            }\n        } else {\n            executeBlockingWrite(r, deliver, count);\n        }\n    }\n\n    protected void executeBlockingWrite(AtmosphereResource r, Deliver deliver, AtomicInteger count) throws InterruptedException {\n        // We deliver using the calling thread.\n        synchronized (r) {\n            executeAsyncWrite(new AsyncWriteToken(r, deliver.message, deliver.future, deliver.originalMessage, deliver.cache, count));\n        }\n    }\n\n    public final static class WriteQueue {\n        final BlockingQueue<AsyncWriteToken> queue = new LinkedBlockingQueue<>();\n        final AtomicBoolean monitored = new AtomicBoolean();\n        final String uuid;\n\n        private WriteQueue(String uuid) {\n            this.uuid = uuid;\n        }\n\n        public List<String> asString() {\n            List<String> l = new ArrayList<>();\n            for (AsyncWriteToken w : queue) {\n                l.add(w.toString());\n            }\n            return l;\n        }\n    }\n\n    protected boolean perRequestFilter(AtmosphereResource r, Deliver msg) {\n        // A broadcaster#broadcast(msg,Set) may contains null value.\n        if (r == null) {\n            logger.trace(\"Null AtmosphereResource passed inside a Set\");\n            return false;\n        }\n\n        if (bc.hasPerRequestFilters()) {\n            BroadcastAction a = bc.filter(r, msg.message, msg.originalMessage);\n            if (a.action() == BroadcastAction.ACTION.ABORT) {\n                return false;\n            }\n            msg.message = a.message();\n        }\n        return true;\n    }\n\n    private Object callable(Object msg) {\n        if (Callable.class.isAssignableFrom(msg.getClass())) {\n            try {\n                return ((Callable) msg).call();\n            } catch (Exception e) {\n                logger.warn(\"Callable exception\", e);\n                return null;\n            }\n        }\n        return msg;\n    }\n\n    protected void executeAsyncWrite(final AsyncWriteToken token) {\n        boolean notifyListeners = true;\n        boolean lostCandidate = false;\n\n        if (token.resource == null) throw new NullPointerException();\n\n        final AtmosphereResourceEventImpl event = (AtmosphereResourceEventImpl) token.resource.getAtmosphereResourceEvent();\n        final AtmosphereResourceImpl r = (AtmosphereResourceImpl) token.resource;\n        final boolean willBeResumed = Utils.resumableTransport(r.transport());\n        List<AtmosphereResourceEventListener> listeners = willBeResumed ? new ArrayList<>() : EMPTY_LISTENERS;\n        final AtmosphereRequest request = r.getRequest(false);\n        try {\n\n            event.setMessage(token.msg);\n\n            // Make sure we cache the message in case the AtmosphereResource has been cancelled, resumed or the client disconnected.\n            if (!isAtmosphereResourceValid(r)) {\n                logger.trace(\"AtmosphereResource {} state is invalid for Broadcaster {}. Message will be cached\", r.uuid(), name);\n                removeAtmosphereResource(r, false);\n                return;\n            }\n\n            bc.getBroadcasterCache().clearCache(getID(), r.uuid(), token.cache);\n            try {\n                request.setAttribute(getID(), token.future);\n                request.setAttribute(MAX_INACTIVE, System.currentTimeMillis());\n                request.setAttribute(usingTokenIdForAttribute, token);\n\n                if (willBeResumed && !r.atmosphereResourceEventListener().isEmpty()) {\n                    listeners.addAll(r.atmosphereResourceEventListener());\n                }\n                prepareInvokeOnStateChange(r, event);\n            } catch (Throwable t) {\n                logger.debug(\"Invalid AtmosphereResource state {}. The connection has been remotely\" +\n                        \" closed and message {} will be added to the configured BroadcasterCache for later retrieval\", r.uuid(), event.getMessage());\n                logger.trace(\"If you are using Tomcat 7.0.22 and lower, you're most probably hitting http://is.gd/NqicFT\");\n                logger.trace(\"ApplicationConfig.CACHE_MESSAGE_ON_IO_FLUSH_EXCEPTION {}\", cacheOnIOFlushException, t);\n\n                lostCandidate = cacheOnIOFlushException ? cacheOnIOFlushException : cacheMessageOnIOException(t);\n                // The Request/Response associated with the AtmosphereResource has already been written and commited\n                removeAtmosphereResource(r, false);\n                r.removeFromAllBroadcasters();\n                event.setCancelled(true);\n                event.setThrowable(t);\n                r.setIsInScope(false);\n                return;\n            }\n        } finally {\n            if (notifyListeners) {\n                // Long Polling listener will be cleared when the resume() is called.\n                if (willBeResumed) {\n                    event.setMessage(token.msg);\n                    for (AtmosphereResourceEventListener e : listeners) {\n                        e.onBroadcast(event);\n                    }\n                    // Listener wil be called later\n                } else if (!event.isResumedOnTimeout()) {\n                    r.notifyListeners();\n                }\n            }\n\n            if (token.lastBroadcasted()) {\n                notifyBroadcastListener();\n            }\n\n            if (token.future != null) token.future.done();\n\n            if (lostCandidate) {\n                cacheLostMessage(r, token, true);\n            }\n\n            try {\n                request.removeAttribute(getID());\n                request.removeAttribute(usingTokenIdForAttribute);\n            } catch (NullPointerException ex) {\n                logger.trace(\"NPE after the message has been written for {}\", r.uuid());\n            }\n            token.destroy();\n        }\n    }\n\n    protected boolean cacheMessageOnIOException(Throwable cause) {\n        for (StackTraceElement element : cause.getStackTrace()) {\n            if (element.getMethodName().equals(\"flush\") || element.getMethodName().equals(\"flushBuffer\")) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    protected boolean checkCachedAndPush(final AtmosphereResource r, final AtmosphereResourceEvent e) {\n        boolean cache = retrieveTrackedBroadcast(r, e);\n\n        if (!cache) return false;\n\n        if (!((List) e.getMessage()).isEmpty()) {\n            logger.debug(\"Sending cached message {} to {}\", e.getMessage(), r.uuid());\n\n            List<Object> cacheMessages = (List) e.getMessage();\n            BroadcasterFuture<Object> f = new BroadcasterFuture<>(e.getMessage(), 1);\n            LinkedList<Object> filteredMessage = new LinkedList<>();\n            LinkedList<Object> filteredMessageClone = null;\n            Deliver deliver;\n            Object newMessage;\n            for (Object o : cacheMessages) {\n                newMessage = filter(o);\n                if (newMessage == null) {\n                    continue;\n                }\n\n                deliver = new Deliver(newMessage, r, f, o);\n                // Can be aborted by a Filter\n                if (!perRequestFilter(r, deliver)) {\n                    continue;\n                }\n\n                if (deliver.message != null) {\n                    filteredMessage.addLast(deliver.message);\n                }\n            }\n\n            if (filteredMessage.isEmpty()) {\n                return false;\n            }\n            e.setMessage(filteredMessage);\n\n            final boolean willBeResumed = Utils.resumableTransport(r.transport());\n\n            if (willBeResumed) {\n                filteredMessageClone = (LinkedList<Object>) filteredMessage.clone();\n            }\n\n            List<AtmosphereResourceEventListener> listeners = willBeResumed ? new ArrayList<>() : EMPTY_LISTENERS;\n            AtmosphereResourceImpl rImpl = (AtmosphereResourceImpl) r;\n            if (willBeResumed && !rImpl.atmosphereResourceEventListener().isEmpty()) {\n                listeners.addAll(rImpl.atmosphereResourceEventListener());\n            }\n\n            // Must make sure execute only one thread\n            synchronized (rImpl) {\n                try {\n                    rImpl.getRequest().setAttribute(CACHED, \"true\");\n                    prepareInvokeOnStateChange(r, e);\n                } catch (Throwable t) {\n                    // An exception occurred\n                    logger.error(\"Unable to write cached message {} for {}\", e.getMessage(), r.uuid());\n                    logger.error(\"\", t);\n                    for (Object o : cacheMessages) {\n                        bc.getBroadcasterCache().addToCache(getID(), r.uuid(), new BroadcastMessage(o));\n                    }\n                    return true;\n                }\n\n                // If long-polling or JSONP is used we need to set the messages for the event again, because onResume() have cleared them\n                if (willBeResumed) {\n                    e.setMessage(filteredMessageClone);\n                }\n\n                for (AtmosphereResourceEventListener l : willBeResumed ? listeners : rImpl.atmosphereResourceEventListener()) {\n                    l.onBroadcast(e);\n                }\n\n                switch (r.transport()) {\n                    case UNDEFINED:\n                    case JSONP:\n                    case AJAX:\n                    case LONG_POLLING:\n                        return true;\n                    case SSE:\n                        break;\n                    default:\n                        try {\n                            r.getResponse().flushBuffer();\n                        } catch (IOException ioe) {\n                            logger.trace(\"\", ioe);\n                            ((AtmosphereResourceImpl) r)._destroy();\n                        }\n                        break;\n                }\n            }\n        }\n        return false;\n    }\n\n    protected boolean retrieveTrackedBroadcast(final AtmosphereResource r, final AtmosphereResourceEvent e) {\n        logger.trace(\"Checking cached message for {}\", r.uuid());\n        List<?> missedMsg = bc.getBroadcasterCache().retrieveFromCache(getID(), r.uuid());\n        if (missedMsg != null && !missedMsg.isEmpty()) {\n            e.setMessage(missedMsg);\n            return true;\n        }\n        return false;\n    }\n\n    protected void invokeOnStateChange(final AtmosphereResource r, final AtmosphereResourceEvent e) {\n        try {\n            logger.trace(\"{} is broadcasting to {}\", name, r.uuid());\n            r.getAtmosphereHandler().onStateChange(e);\n        } catch (Throwable t) {\n            if (!InterruptedException.class.isAssignableFrom(t.getClass())) {\n                onException(t, r);\n            }\n        }\n    }\n\n    protected void prepareInvokeOnStateChange(final AtmosphereResource r, final AtmosphereResourceEvent e) {\n        if (writeTimeoutInSecond != -1) {\n            logger.trace(\"Registering Write timeout {} for {}\", writeTimeoutInSecond, r.uuid());\n            WriteOperation w = new WriteOperation(r, e, Thread.currentThread());\n            bc.getScheduledExecutorService().schedule(w, writeTimeoutInSecond, TimeUnit.MILLISECONDS);\n\n            try {\n                w.call();\n            } catch (Exception ex) {\n                logger.warn(\"\", ex);\n            }\n        } else {\n            invokeOnStateChange(r, e);\n        }\n    }\n\n    final class WriteOperation implements Callable<Object> {\n\n        private final AtmosphereResource r;\n        private final AtmosphereResourceEvent e;\n        private final AtomicBoolean completed = new AtomicBoolean();\n        private final AtomicBoolean executed = new AtomicBoolean();\n        private final Thread ioThread;\n\n        private WriteOperation(AtmosphereResource r, AtmosphereResourceEvent e, Thread ioThread) {\n            this.r = r;\n            this.e = e;\n            this.ioThread = ioThread;\n        }\n\n        @Override\n        public Object call() throws Exception {\n            if (!completed.getAndSet(true)) {\n                invokeOnStateChange(r, e);\n                logger.trace(\"Cancelling Write timeout {} for {}\", writeTimeoutInSecond, r.uuid());\n                executed.set(true);\n            } else if (!executed.get()) {\n                // https://github.com/Atmosphere/atmosphere/issues/902\n                try {\n                    ioThread.interrupt();\n                } catch (Throwable t) {\n                    // Swallow, this is already enough embarrassing\n                    logger.trace(\"I/O failure, unable to interrupt the thread\", t);\n                }\n\n                logger.trace(\"Honoring Write timeout {} for {}\", writeTimeoutInSecond, r.uuid());\n                onException(new IOException(\"Unable to write after \" + writeTimeoutInSecond), r);\n                ((AtmosphereResourceImpl) r).cancel();\n            }\n            return null;\n        }\n\n        public void interrupt() {\n        }\n    }\n\n    public void onException(Throwable t, final AtmosphereResource ar) {\n        onException(t, ar, true);\n    }\n\n    public void onException(Throwable t, final AtmosphereResource ar, boolean notifyAndCache) {\n        final AtmosphereResourceImpl r = AtmosphereResourceImpl.class.cast(ar);\n\n        logger.trace(\"I/O Exception (or related) during execution of the write operation for \" +\n                        \"AtmosphereResource {} and Broadcaster {}. Message will be cached {}\",\n                ar.uuid(), getID(), String.valueOf(notifyAndCache), t);\n\n        // Remove to prevent other broadcast to re-use it.\n        removeAtmosphereResource(r);\n\n        if (notifyAndCache) {\n            final AtmosphereResourceEventImpl event = r.getAtmosphereResourceEvent();\n            event.setThrowable(t);\n\n            r.notifyListeners(event);\n            r.removeEventListeners();\n        }\n\n        if (notifyAndCache) {\n            cacheLostMessage(r, (AsyncWriteToken) r.getRequest(false).getAttribute(usingTokenIdForAttribute), notifyAndCache);\n        }\n\n        /*\n         * Make sure we resume the connection on every IOException.\n         */\n        if (bc != null && bc.getAsyncWriteService() != null) {\n            bc.getAsyncWriteService().execute(() -> {\n                try {\n                    logger.trace(\"Forcing connection close {}\", ar.uuid());\n                    r.resume();\n                    r.close();\n                } catch (Throwable t1) {\n                    logger.trace(\"Was unable to resume a corrupted AtmosphereResource {}\", r);\n                    logger.trace(\"Cause\", t1);\n                }\n            });\n        } else {\n            r.resume();\n        }\n    }\n\n    /**\n     * Cache the message because an unexpected exception occurred.\n     *\n     * @param r {@link AtmosphereResource}\n     */\n    public void cacheLostMessage(AtmosphereResource r, boolean force) {\n        AtmosphereRequest request = ((AtmosphereResourceImpl) r).getRequest(false);\n        try {\n            cacheLostMessage(r, (AsyncWriteToken) request.getAttribute(usingTokenIdForAttribute), force);\n        } finally {\n            request.removeAttribute(usingTokenIdForAttribute);\n        }\n    }\n\n    /**\n     * Cache the message because an unexpected exception occurred.\n     *\n     * @param r {@link AtmosphereResource}\n     */\n    public void cacheLostMessage(AtmosphereResource r, AsyncWriteToken token) {\n        cacheLostMessage(r, token, false);\n    }\n\n    /**\n     * Cache the message because an unexpected exception occurred.\n     *\n     * @param r {@link AtmosphereResource}\n     */\n    public void cacheLostMessage(AtmosphereResource r, AsyncWriteToken token, boolean force) {\n        if (!force) {\n            return;\n        }\n\n        try {\n            if (token != null && token.originalMessage != null) {\n                bc.getBroadcasterCache().addToCache(getID(), r != null ? r.uuid() : BroadcasterCache.NULL,\n                        new BroadcastMessage(String.valueOf(token.future.hashCode()), token.originalMessage));\n                logger.trace(\"Lost message cached {}\", token.originalMessage);\n            }\n        } catch (Throwable t2) {\n            logger.error(\"Unable to cache message {} for AtmosphereResource {}\", token.originalMessage, r != null ? r.uuid() : \"\");\n            logger.error(\"Unable to cache message\", t2);\n        }\n    }\n\n    @Override\n    public void setSuspendPolicy(long maxSuspendResource, POLICY policy) {\n        this.maxSuspendResource.set(maxSuspendResource);\n        this.policy = policy;\n    }\n\n    @Override\n    public Future<Object> broadcast(Object msg) {\n\n        if (destroyed.get()) {\n            logger.debug(DESTROYED, getID(), \"broadcast(T msg)\");\n            return futureDone(msg);\n        }\n\n        start();\n        Object newMsg = filter(msg);\n        if (newMsg == null) {\n            logger.debug(\"Broadcast Interrupted {}\", msg);\n            return futureDone(msg);\n        }\n\n        int callee = resources.isEmpty() ? 1 : resources.size();\n\n        BroadcasterFuture<Object> f = new BroadcasterFuture<>(newMsg, callee);\n        dispatchMessages(new Deliver(newMsg, f, msg));\n        return f;\n    }\n\n    protected BroadcasterFuture<Object> futureDone(Object msg) {\n        notifyBroadcastListener();\n        return (new BroadcasterFuture<>(msg)).done();\n    }\n\n    protected void dispatchMessages(Deliver e) {\n        messages.offer(e);\n\n        if (dispatchThread.get() == 0) {\n            dispatchThread.incrementAndGet();\n            getBroadcasterConfig().getExecutorService().submit(getBroadcastHandler());\n        }\n    }\n\n    /**\n     * Invoke the {@link BroadcastFilter}\n     *\n     * @param msg\n     * @return\n     */\n    protected Object filter(Object msg) {\n        BroadcastAction a = bc.filter(msg);\n        if (a.action() == BroadcastAction.ACTION.ABORT || msg == null)\n            return null;\n        else\n            return a.message();\n    }\n\n    @Override\n    public Future<Object> broadcast(Object msg, AtmosphereResource r) {\n\n        if (destroyed.get()) {\n            logger.debug(DESTROYED, getID(), \"broadcast(T msg, AtmosphereResource r\");\n            return futureDone(msg);\n        }\n\n        start();\n        Object newMsg = filter(msg);\n        if (newMsg == null) return futureDone(msg);\n\n        BroadcasterFuture<Object> f = new BroadcasterFuture<>(newMsg, 1);\n        dispatchMessages(new Deliver(newMsg, r, f, msg));\n        return f;\n    }\n\n    @Override\n    public Future<Object> broadcastOnResume(Object msg) {\n\n        if (destroyed.get()) {\n            logger.debug(DESTROYED, getID(), \"broadcastOnResume(T msg)\");\n            return futureDone(msg);\n        }\n\n        start();\n        Object newMsg = filter(msg);\n        if (newMsg == null) return futureDone(msg);\n\n        BroadcasterFuture<Object> f = new BroadcasterFuture<>(newMsg, resources.size());\n        broadcastOnResume.offer(new Deliver(newMsg, f, msg));\n        return f;\n    }\n\n    protected void broadcastOnResume(AtmosphereResource r) {\n        for (Deliver e : broadcastOnResume) {\n            e.async = false;\n            push(new Deliver(r, e));\n        }\n\n        if (resources.isEmpty()) {\n            broadcastOnResume.clear();\n        }\n    }\n\n    @Override\n    public Future<Object> broadcast(Object msg, Set<AtmosphereResource> subset) {\n\n        if (destroyed.get()) {\n            logger.debug(DESTROYED, getID(), \"broadcast(T msg, Set<AtmosphereResource> subset)\");\n            return futureDone(msg);\n        }\n\n        start();\n        Object newMsg = filter(msg);\n        if (newMsg == null) return futureDone(msg);\n\n        BroadcasterFuture<Object> f = new BroadcasterFuture<>(null, newMsg, subset.size());\n        dispatchMessages(new Deliver(newMsg, subset, f, msg));\n        return f;\n    }\n\n    @Override\n    public Broadcaster addAtmosphereResource(AtmosphereResource r) {\n        try {\n            if (destroyed.get()) {\n                logger.debug(DESTROYED, getID(), \"addAtmosphereResource(AtmosphereResource r\");\n                return this;\n            }\n\n            start();\n            if (scope == SCOPE.REQUEST && requestScoped.getAndSet(true)) {\n                throw new IllegalStateException(\"Broadcaster \" + this\n                        + \" cannot be used as its scope is set to REQUEST\");\n            }\n\n            // To avoid excessive synchronization, we allow resources.size() to get larger that maxSuspendResource\n            if (maxSuspendResource.get() > 0 && resources.size() >= maxSuspendResource.get()) {\n                // Resume the first in.\n                if (policy == POLICY.FIFO) {\n                    // TODO handle null return from poll()\n                    AtmosphereResource resource = resources.poll();\n                    try {\n                        logger.warn(\"Too many resource. Forcing resume of {} \", resource.uuid());\n                        resource.resume();\n                    } catch (Throwable t) {\n                        logger.warn(\"failed to resume resource {} \", resource, t);\n                    }\n                } else if (policy == POLICY.REJECT) {\n                    throw new RejectedExecutionException(String.format(\"Maximum suspended AtmosphereResources %s\", maxSuspendResource));\n                }\n            }\n\n            if (!r.isSuspended()) {\n                logger.warn(\"AtmosphereResource {} is not suspended. If cached messages exists, this may cause unexpected situation. Suspend first\", r.uuid());\n            }\n\n            if (!backwardCompatible && resources.contains(r)) {\n                boolean duplicate = r.transport() != AtmosphereResource.TRANSPORT.WEBSOCKET\n                        || ((AtmosphereResourceImpl) r).getRequest(false).getAttribute(INJECTED_ATMOSPHERE_RESOURCE) != null;\n\n                if (duplicate) {\n                    AtmosphereResourceImpl dup = (AtmosphereResourceImpl) config.resourcesFactory().find(r.uuid());\n                    if (dup != null && dup != r ) {\n                        if ( ! dup.isPendingClose() ) {\n                            logger.debug(\"Duplicate resource {}. Could be caused by a dead connection not detected by your server. \" +\n                                    \"Replacing the old one with the fresh one {}\", r.uuid(), r.transport());\n                        } else {\n                            logger.debug(\"Not yet closed resource still active {}\", r.uuid());\n                        }\n                        dup.dirtyClose();\n                    } else {\n                        logger.debug(\"Duplicate resource {}\", r.uuid());\n                        return this;\n                    }\n                } else {\n                    logger.debug(\"Duplicate resource {}\", r.uuid());\n                    return this;\n                }\n            }\n\n            // Only synchronize if we have a valid BroadcasterCache\n            if (!bc.getBroadcasterCache().getClass().equals(BroadcasterCache.DEFAULT.getClass())) {\n                // In case we are adding messages to the cache, we need to make sure the operation is done before.\n                synchronized (resources) {\n                    cacheAndSuspend(r);\n                }\n            } else {\n                cacheAndSuspend(r);\n            }\n        } finally {\n            // OK reset\n            if (!resources.isEmpty()) {\n                synchronized (awaitBarrier) {\n                    awaitBarrier.notifyAll();\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Look in the cache to see if there are messages available, and take the appropriate actions.\n     *\n     * @param r AtmosphereResource\n     */\n    protected void cacheAndSuspend(AtmosphereResource r) {\n        // In case the connection is closed, for whatever reason\n        if (!isAtmosphereResourceValid(r)) {\n            logger.debug(\"Unable to add AtmosphereResource {}\", r.uuid());\n            return;\n        }\n\n        boolean wasResumed = checkCachedAndPush(r, r.getAtmosphereResourceEvent());\n        if (!wasResumed && isAtmosphereResourceValid(r)) {\n            logger.trace(\"Associating AtmosphereResource {} with Broadcaster {}\", r.uuid(), getID());\n\n            String parentUUID = r.transport().equals(AtmosphereResource.TRANSPORT.WEBSOCKET) ?\n                    (String) ((AtmosphereResourceImpl) r).getRequest(false).getAttribute(SUSPENDED_ATMOSPHERE_RESOURCE_UUID) :\n                    null;\n            if (!backwardCompatible && parentUUID != null) {\n                AtmosphereResource p = config.resourcesFactory().find(parentUUID);\n                if (p != null && !resources.contains(p)) {\n                    notifyAndAdd(p);\n                } else if (p == null) {\n                    notifyAndAdd(r);\n                } else {\n                    logger.trace(\"AtmosphereResource {} was already mapped to {}\", r.uuid(), parentUUID);\n                }\n            } else {\n                notifyAndAdd(r);\n            }\n        } else if (!wasResumed) {\n            logger.debug(\"Unable to add AtmosphereResource {} to {}\", r.uuid(), name);\n        }\n    }\n\n    protected void notifyAndAdd(AtmosphereResource r) {\n        resources.add(r);\n        r.addBroadcaster(this);\n        notifyOnAddAtmosphereResourceListener(r);\n    }\n\n    private boolean isAtmosphereResourceValid(AtmosphereResource r) {\n        return !r.isResumed()\n                && !r.isCancelled()\n                && ((AtmosphereResourceImpl) r).isInScope();\n    }\n\n    protected void entryDone(final BroadcasterFuture<?> f) {\n        notifyBroadcastListener();\n        if (f != null) f.done();\n    }\n\n    protected void notifyBroadcastListener() {\n        for (BroadcasterListener b : broadcasterListeners) {\n            try {\n                b.onComplete(this);\n            } catch (Exception ex) {\n                logger.warn(\"\", ex);\n            }\n        }\n    }\n\n    protected void notifyOnAddAtmosphereResourceListener(AtmosphereResource r) {\n        for (BroadcasterListener b : broadcasterListeners) {\n            try {\n                b.onAddAtmosphereResource(this, r);\n            } catch (Exception ex) {\n                logger.warn(\"\", ex);\n            }\n        }\n    }\n\n    protected void notifyOnRemoveAtmosphereResourceListener(AtmosphereResource r) {\n        for (BroadcasterListener b : broadcasterListeners) {\n            try {\n                b.onRemoveAtmosphereResource(this, r);\n            } catch (Exception ex) {\n                logger.warn(\"\", ex);\n            }\n        }\n    }\n\n    protected void notifyOnMessage(Deliver deliver) {\n        for (BroadcasterListener b : broadcasterListeners) {\n            try {\n                b.onMessage(this, deliver);\n            } catch (Exception ex) {\n                logger.warn(\"\", ex);\n            }\n        }\n    }\n\n    @Override\n    public Broadcaster removeAtmosphereResource(AtmosphereResource r) {\n        return removeAtmosphereResource(r, true);\n    }\n\n    protected Broadcaster removeAtmosphereResource(AtmosphereResource r, boolean executeDone) {\n        if (destroyed.get()) {\n            logger.debug(DESTROYED, getID(), \"removeAtmosphereResource(AtmosphereResource r)\");\n            return this;\n        }\n\n        boolean removed = resources.remove(r);\n        if (removed) {\n            if (r.isSuspended()) {\n                logger.trace(\"Excluded from {} : {}\", getID(), r.uuid());\n                bc.getBroadcasterCache().excludeFromCache(getID(), r);\n            }\n            notifyOnRemoveAtmosphereResourceListener(r);\n        } else {\n            logger.trace(\"Unable to remove {} from {}\", r.uuid(), getID());\n        }\n        r.removeBroadcaster(this);\n\n        if (!removed) return this;\n\n        logger.trace(\"Removing AtmosphereResource {} for Broadcaster {}\", r.uuid(), name);\n        writeQueues.remove(r.uuid());\n\n        // Here we need to make sure we aren't in the process of broadcasting and unlock the Future.\n        if (executeDone) {\n            AtmosphereResourceImpl aImpl = (AtmosphereResourceImpl) r;\n            BroadcasterFuture<?> f = (BroadcasterFuture<?>) aImpl.getRequest(false).getAttribute(getID());\n            if (f != null && !f.isDone() && !f.isCancelled()) {\n                aImpl.getRequest(false).removeAttribute(getID());\n                entryDone(f);\n            }\n        }\n\n        return this;\n    }\n\n    @Override\n    public void setBroadcasterConfig(BroadcasterConfig bc) {\n        this.bc = bc;\n    }\n\n    @Override\n    public BroadcasterConfig getBroadcasterConfig() {\n        return bc;\n    }\n\n    @Override\n    public Future<Object> delayBroadcast(Object o) {\n        return delayBroadcast(o, 0, null);\n    }\n\n    @Override\n    public Future<Object> delayBroadcast(final Object o, long delay, TimeUnit t) {\n\n        if (destroyed.get()) {\n            logger.debug(DESTROYED, getID(), \"delayBroadcast(final T o, long delay, TimeUnit t)\");\n            return null;\n        }\n\n        start();\n        final Object msg = filter(o);\n        if (msg == null) return null;\n\n        final BroadcasterFuture<Object> future = new BroadcasterFuture<>(msg);\n        final Deliver e = new Deliver(msg, future, o);\n        Future<Object> f;\n        if (delay > 0) {\n            f = bc.getScheduledExecutorService().schedule(() -> {\n                delayedBroadcast.remove(e);\n                if (Callable.class.isAssignableFrom(o.getClass())) {\n                    try {\n                        Object r = ((Callable) o).call();\n                        final Object msg1 = filter(r);\n                        if (msg1 != null) {\n                            Deliver deliver = new Deliver(msg1, future, r);\n                            push(deliver);\n                        }\n                        return msg1;\n                    } catch (Exception e1) {\n                        logger.error(\"delayBroadcast\", e);\n                    }\n                }\n\n                final Object msg1 = filter(o);\n                final Deliver e12 = new Deliver(msg1, future, o);\n                push(e12);\n                return msg1;\n            }, delay, t);\n\n            e.future = new BroadcasterFuture<>(f, msg);\n        }\n        delayedBroadcast.offer(e);\n        return future;\n    }\n\n    @Override\n    public Future<Object> scheduleFixedBroadcast(final Object o, long period, TimeUnit t) {\n        return scheduleFixedBroadcast(o, 0, period, t);\n    }\n\n    @Override\n    public Future<Object> scheduleFixedBroadcast(final Object o, long waitFor, long period, TimeUnit t) {\n\n        if (destroyed.get()) {\n            logger.debug(DESTROYED, getID(), \"scheduleFixedBroadcast(final Object o, long waitFor, long period, TimeUnit t)\");\n            return null;\n        }\n\n        start();\n        if (period == 0 || t == null) {\n            return null;\n        }\n\n        final Object msg = filter(o);\n        if (msg == null) return null;\n\n        final BroadcasterFuture<Object> f = new BroadcasterFuture<Object>(msg);\n\n        return (Future<Object>) bc.getScheduledExecutorService().scheduleWithFixedDelay(() -> {\n            if (Callable.class.isAssignableFrom(o.getClass())) {\n                try {\n                    Object r = Callable.class.cast(o).call();\n                    final Object msg1 = filter(r);\n                    if (msg1 != null) {\n                        Deliver deliver = new Deliver(msg1, f, r);\n                        push(deliver);\n                    }\n                    return;\n                } catch (Exception e) {\n                    logger.error(\"\", e);\n                }\n            }\n            final Object msg1 = filter(o);\n            final Deliver e = new Deliver(msg1, f, o);\n            push(e);\n        }, waitFor, period, t);\n    }\n\n    @Override\n    public String toString() {\n        return \"\\n\\tName: \" + name +\n                \"\\n\\tAtmosphereResource: \" + resources.size() +\n                \"\\n\\tBroadcasterCache \" + bc.getBroadcasterCache();\n    }\n\n    protected final static class AsyncWriteToken {\n\n        AtmosphereResource resource;\n        Object msg;\n        BroadcasterFuture future;\n        Object originalMessage;\n        CacheMessage cache;\n        AtomicInteger count;\n\n        public AsyncWriteToken(AtmosphereResource resource, Object msg, BroadcasterFuture future, Object originalMessage, AtomicInteger count) {\n            this.resource = resource;\n            this.msg = msg;\n            this.future = future;\n            this.originalMessage = originalMessage;\n            this.count = count;\n        }\n\n        public AsyncWriteToken(AtmosphereResource resource, Object msg, BroadcasterFuture future, Object originalMessage, CacheMessage cache, AtomicInteger count) {\n            this.resource = resource;\n            this.msg = msg;\n            this.future = future;\n            this.originalMessage = originalMessage;\n            this.cache = cache;\n            this.count = count;\n        }\n\n        public void destroy() {\n            this.resource = null;\n            this.msg = null;\n            this.future = null;\n            this.originalMessage = null;\n        }\n\n        public boolean lastBroadcasted() {\n            return count.decrementAndGet() == 0;\n        }\n\n        @Override\n        public String toString() {\n            return \"AsyncWriteToken{\" +\n                    \"resource=\" + resource +\n                    \", msg=\" + msg +\n                    \", future=\" + future +\n                    '}';\n        }\n    }\n\n    private long translateTimeUnit(long period, TimeUnit tu) {\n        if (period == -1) return period;\n\n        switch (tu) {\n            case SECONDS:\n                return TimeUnit.MILLISECONDS.convert(period, TimeUnit.SECONDS);\n            case MINUTES:\n                return TimeUnit.MILLISECONDS.convert(period, TimeUnit.MINUTES);\n            case HOURS:\n                return TimeUnit.MILLISECONDS.convert(period, TimeUnit.HOURS);\n            case DAYS:\n                return TimeUnit.MILLISECONDS.convert(period, TimeUnit.DAYS);\n            case MILLISECONDS:\n                return period;\n            case MICROSECONDS:\n                return TimeUnit.MILLISECONDS.convert(period, TimeUnit.MICROSECONDS);\n            case NANOSECONDS:\n                return TimeUnit.MILLISECONDS.convert(period, TimeUnit.NANOSECONDS);\n        }\n        return period;\n    }\n\n    boolean notifyOnPreDestroy() {\n        for (BroadcasterListener b : broadcasterListeners) {\n            try {\n                b.onPreDestroy(this);\n            } catch (RuntimeException ex) {\n                if (BroadcasterListener.BroadcastListenerException.class.isAssignableFrom(ex.getClass())) {\n                    logger.trace(\"onPreDestroy\", ex);\n                    return true;\n                }\n                logger.warn(\"onPreDestroy\", ex);\n            }\n        }\n        return false;\n    }\n\n    public Collection<BroadcasterListener> broadcasterListeners() {\n        return broadcasterListeners;\n    }\n\n    public BroadcasterLifeCyclePolicy lifeCyclePolicy() {\n        return lifeCyclePolicy;\n    }\n\n    public ConcurrentLinkedQueue<BroadcasterLifeCyclePolicyListener> lifeCycleListeners() {\n        return lifeCycleListeners;\n    }\n\n    public BlockingQueue<Deliver> messages() {\n        return messages;\n    }\n\n    public ConcurrentHashMap<String, WriteQueue> writeQueues() {\n        return writeQueues;\n    }\n\n    public POLICY policy() {\n        return policy;\n    }\n\n    public boolean outOfOrderBroadcastSupported() {\n        return outOfOrderBroadcastSupported.get();\n    }\n\n    public AtomicBoolean recentActivity() {\n        return recentActivity;\n    }\n\n    public LifecycleHandler lifecycleHandler() {\n        return lifecycleHandler;\n    }\n\n    public DefaultBroadcaster lifecycleHandler(LifecycleHandler lifecycleHandler) {\n        this.lifecycleHandler = lifecycleHandler;\n        return this;\n    }\n\n    public Future<?> currentLifecycleTask() {\n        return currentLifecycleTask;\n    }\n\n    public DefaultBroadcaster currentLifecycleTask(Future<?> currentLifecycleTask) {\n        this.currentLifecycleTask = currentLifecycleTask;\n        return this;\n    }\n}\n",
            "file_name": "DefaultBroadcaster.java",
            "human_label": "Filter and return null for the null and abort message in BroadcastAction, return the action message otherwise. ",
            "level": "project_runnable",
            "lineno": "1232",
            "name": "filter",
            "oracle_context": "{ \"apis\" : \"[action, message]\", \"classes\" : \"[BroadcastAction, BroadcastAction.ACTION]\", \"vars\" : \"[ABORT, ACTION, bc]\" }",
            "package": "org.atmosphere.cpr",
            "project": "atmosphere-atmosphere-2.7.x"
        },
        {
            "_id": "6367677e1a6d9265ec018314",
            "all_context": "{ \"class_level\" : \"import java.awt.Component;\\nimport java.awt.event.ActionEvent;\\nimport java.awt.event.ActionListener;\\nimport java.awt.event.MouseAdapter;\\nimport java.awt.event.MouseEvent;\\nimport java.util.ArrayList;\\nimport java.util.Enumeration;\\nimport javax.swing.JCheckBox;\\nimport javax.swing.JMenuItem;\\nimport javax.swing.JOptionPane;\\nimport javax.swing.JPopupMenu;\\nimport javax.swing.JTree;\\nimport javax.swing.tree.TreePath;\\nCategoryNodeEditorRenderer _renderer;\\nCategoryNode _lastEditedNode;\\nJCheckBox _checkBox;\\nCategoryExplorerModel _categoryModel;\\nJTree _tree;\\nCategoryNodeEditor(CategoryExplorerModel model);\\nactionPerformed(ActionEvent e);\\nmousePressed(MouseEvent e);\\ngetTreeCellEditorComponent(JTree tree,Object value,boolean selected,boolean expanded,boolean leaf,int row);\\ngetCellEditorValue();\\ncreatePropertiesMenuItem(CategoryNode node);\\nshowPropertiesDialog(CategoryNode node);\\ngetDisplayedProperties(CategoryNode node);\\nshowPopup(CategoryNode node,int x,int y);\\ncreateSelectDescendantsMenuItem(CategoryNode node);\\ncreateUnselectDescendantsMenuItem(CategoryNode node);\\ncreateExpandMenuItem(CategoryNode node);\\ncreateCollapseMenuItem(CategoryNode node);\\nexpandDescendants(CategoryNode node);\\ncollapseDescendants(CategoryNode node);\\nremoveUnusedNodes();\\nexpand(CategoryNode node);\\ngetTreePath(CategoryNode node);\\ncollapse(CategoryNode node);\\ncreateRemoveMenuItem();\\n\", \"repo_level\" : \"\" }",
            "class_name": "CategoryNodeEditor",
            "code": "protected int removeUnusedNodes(){\n  int count=0;\n  CategoryNode root=_categoryModel.getRootCategoryNode();\n  Enumeration enumeration=root.depthFirstEnumeration();\n  while (enumeration.hasMoreElements()) {\n    CategoryNode node=(CategoryNode)enumeration.nextElement();\n    if (node.isLeaf() && node.getNumberOfContainedRecords() == 0 && node.getParent() != null) {\n      _categoryModel.removeNodeFromParent(node);\n      count++;\n    }\n  }\n  return count;\n}\n",
            "docstring": "/** \n * Removes any inactive nodes from the Category tree.\n */\n",
            "end_lineno": "269",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.log4j.lf5.viewer.categoryexplorer;\n\nimport java.awt.Component;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\n\nimport javax.swing.JCheckBox;\nimport javax.swing.JMenuItem;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPopupMenu;\nimport javax.swing.JTree;\nimport javax.swing.tree.TreePath;\n\n/**\n * CategoryNodeEditor\n *\n * @author Michael J. Sikorsky\n * @author Robert Shaw\n */\n\n// Contributed by ThoughtWorks Inc.\n\npublic class CategoryNodeEditor extends CategoryAbstractCellEditor {\n  //--------------------------------------------------------------------------\n  //   Constants:\n  //--------------------------------------------------------------------------\n\n  //--------------------------------------------------------------------------\n  //   Protected Variables:\n  //--------------------------------------------------------------------------\n  protected CategoryNodeEditorRenderer _renderer;\n  protected CategoryNode _lastEditedNode;\n  protected JCheckBox _checkBox;\n  protected CategoryExplorerModel _categoryModel;\n  protected JTree _tree;\n\n  //--------------------------------------------------------------------------\n  //   Private Variables:\n  //--------------------------------------------------------------------------\n\n  //--------------------------------------------------------------------------\n  //   Constructors:\n  //--------------------------------------------------------------------------\n\n  public CategoryNodeEditor(CategoryExplorerModel model) {\n    _renderer = new CategoryNodeEditorRenderer();\n    _checkBox = _renderer.getCheckBox();\n    _categoryModel = model;\n\n    _checkBox.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        _categoryModel.update(_lastEditedNode, _checkBox.isSelected());\n        stopCellEditing();\n      }\n    });\n\n    _renderer.addMouseListener(new MouseAdapter() {\n      public void mousePressed(MouseEvent e) {\n        if ((e.getModifiers() & MouseEvent.BUTTON3_MASK) != 0) {\n          showPopup(_lastEditedNode, e.getX(), e.getY());\n        }\n        stopCellEditing();\n      }\n    });\n  }\n\n  //--------------------------------------------------------------------------\n  //   Public Methods:\n  //--------------------------------------------------------------------------\n\n  public Component getTreeCellEditorComponent(JTree tree, Object value,\n      boolean selected, boolean expanded,\n      boolean leaf, int row) {\n    _lastEditedNode = (CategoryNode) value;\n    _tree = tree;\n\n    return _renderer.getTreeCellRendererComponent(tree,\n        value, selected, expanded,\n        leaf, row, true);\n    // hasFocus ignored\n  }\n\n  public Object getCellEditorValue() {\n    return _lastEditedNode.getUserObject();\n  }\n  //--------------------------------------------------------------------------\n  //   Protected Methods:\n  //--------------------------------------------------------------------------\n\n  protected JMenuItem createPropertiesMenuItem(final CategoryNode node) {\n    JMenuItem result = new JMenuItem(\"Properties\");\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        showPropertiesDialog(node);\n      }\n    });\n    return result;\n  }\n\n  protected void showPropertiesDialog(CategoryNode node) {\n    JOptionPane.showMessageDialog(\n        _tree,\n        getDisplayedProperties(node),\n        \"Category Properties: \" + node.getTitle(),\n        JOptionPane.PLAIN_MESSAGE\n    );\n  }\n\n  protected Object getDisplayedProperties(CategoryNode node) {\n    ArrayList result = new ArrayList();\n    result.add(\"Category: \" + node.getTitle());\n    if (node.hasFatalRecords()) {\n      result.add(\"Contains at least one fatal LogRecord.\");\n    }\n    if (node.hasFatalChildren()) {\n      result.add(\"Contains descendants with a fatal LogRecord.\");\n    }\n    result.add(\"LogRecords in this category alone: \" +\n        node.getNumberOfContainedRecords());\n    result.add(\"LogRecords in descendant categories: \" +\n        node.getNumberOfRecordsFromChildren());\n    result.add(\"LogRecords in this category including descendants: \" +\n        node.getTotalNumberOfRecords());\n    return result.toArray();\n  }\n\n  protected void showPopup(CategoryNode node, int x, int y) {\n    JPopupMenu popup = new JPopupMenu();\n    popup.setSize(150, 400);\n    //\n    // Configure the Popup\n    //\n    if (node.getParent() == null) {\n      popup.add(createRemoveMenuItem());\n      popup.addSeparator();\n    }\n    popup.add(createSelectDescendantsMenuItem(node));\n    popup.add(createUnselectDescendantsMenuItem(node));\n    popup.addSeparator();\n    popup.add(createExpandMenuItem(node));\n    popup.add(createCollapseMenuItem(node));\n    popup.addSeparator();\n    popup.add(createPropertiesMenuItem(node));\n    popup.show(_renderer, x, y);\n  }\n\n  protected JMenuItem createSelectDescendantsMenuItem(final CategoryNode node) {\n    JMenuItem selectDescendants =\n        new JMenuItem(\"Select All Descendant Categories\");\n    selectDescendants.addActionListener(\n        new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            _categoryModel.setDescendantSelection(node, true);\n          }\n        }\n    );\n    return selectDescendants;\n  }\n\n  protected JMenuItem createUnselectDescendantsMenuItem(final CategoryNode node) {\n    JMenuItem unselectDescendants =\n        new JMenuItem(\"Deselect All Descendant Categories\");\n    unselectDescendants.addActionListener(\n\n        new ActionListener() {\n          public void actionPerformed(ActionEvent e) {\n            _categoryModel.setDescendantSelection(node, false);\n          }\n        }\n\n    );\n    return unselectDescendants;\n  }\n\n  protected JMenuItem createExpandMenuItem(final CategoryNode node) {\n    JMenuItem result = new JMenuItem(\"Expand All Descendant Categories\");\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        expandDescendants(node);\n      }\n    });\n    return result;\n  }\n\n  protected JMenuItem createCollapseMenuItem(final CategoryNode node) {\n    JMenuItem result = new JMenuItem(\"Collapse All Descendant Categories\");\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        collapseDescendants(node);\n      }\n    });\n    return result;\n  }\n\n  /**\n   * This featured was moved from the LogBrokerMonitor class\n   * to the CategoryNodeExplorer so that the Category tree\n   * could be pruned from the Category Explorer popup menu.\n   * This menu option only appears when a user right clicks on\n   * the Category parent node.\n   *\n   * See removeUnusedNodes()\n   */\n  protected JMenuItem createRemoveMenuItem() {\n    JMenuItem result = new JMenuItem(\"Remove All Empty Categories\");\n    result.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        while (removeUnusedNodes() > 0) ;\n      }\n    });\n    return result;\n  }\n\n  protected void expandDescendants(CategoryNode node) {\n    Enumeration descendants = node.depthFirstEnumeration();\n    CategoryNode current;\n    while (descendants.hasMoreElements()) {\n      current = (CategoryNode) descendants.nextElement();\n      expand(current);\n    }\n  }\n\n  protected void collapseDescendants(CategoryNode node) {\n    Enumeration descendants = node.depthFirstEnumeration();\n    CategoryNode current;\n    while (descendants.hasMoreElements()) {\n      current = (CategoryNode) descendants.nextElement();\n      collapse(current);\n    }\n  }\n\n  /**\n   * Removes any inactive nodes from the Category tree.\n   */\n  protected int removeUnusedNodes() {\n    int count = 0;\n    CategoryNode root = _categoryModel.getRootCategoryNode();\n    Enumeration enumeration = root.depthFirstEnumeration();\n    while (enumeration.hasMoreElements()) {\n      CategoryNode node = (CategoryNode) enumeration.nextElement();\n      if (node.isLeaf() && node.getNumberOfContainedRecords() == 0\n          && node.getParent() != null) {\n        _categoryModel.removeNodeFromParent(node);\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  protected void expand(CategoryNode node) {\n    _tree.expandPath(getTreePath(node));\n  }\n\n  protected TreePath getTreePath(CategoryNode node) {\n    return new TreePath(node.getPath());\n  }\n\n  protected void collapse(CategoryNode node) {\n    _tree.collapsePath(getTreePath(node));\n  }\n\n  //-----------------------------------------------------------------------\n  //   Private Methods:\n  //--------------------------------------------------------------------------\n\n  //--------------------------------------------------------------------------\n  //   Nested Top-Level Classes or Interfaces:\n  //--------------------------------------------------------------------------\n\n}\n",
            "file_name": "CategoryNodeEditor.java",
            "human_label": "Remove any inactive nodes from the Category tree and return the number of removed nodes.",
            "level": "project_runnable",
            "lineno": "252",
            "name": "removeUnusedNodes",
            "oracle_context": "{ \"apis\" : \"[getRootCategoryNode, depthFirstEnumeration, hasMoreElements, nextElement, isLeaf, getNumberOfContainedRecords, getParent, removeNodeFromParent]\", \"classes\" : \"[CategoryNode, Enumeration]\", \"vars\" : \"[_categoryModel]\" }",
            "package": "org.apache.log4j.lf5.viewer.categoryexplorer",
            "project": "logging-log4j1-main"
        },
        {
            "_id": "6367676a1a6d9265ec0181cd",
            "all_context": "{ \"class_level\" : \"import java.nio.charset.Charset;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nimport java.util.Enumeration;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Locale;\\nimport java.util.Properties;\\nimport java.util.Set;\\nimport java.util.StringTokenizer;\\nimport java.util.TreeSet;\\nString FOLDER_SEPARATOR;\\nString WINDOWS_FOLDER_SEPARATOR;\\nString TOP_PATH;\\nString CURRENT_PATH;\\nchar EXTENSION_SEPARATOR;\\nCharset UTF_8;\\nStrings();\\nhasLength(String str);\\nhasText(CharSequence str);\\nhasText(String str);\\ncontainsWhitespace(CharSequence str);\\ncontainsWhitespace(String str);\\ntrimWhitespace(String str);\\ntrimWhitespace(CharSequence str);\\nclean(String str);\\nclean(CharSequence str);\\ntrimAllWhitespace(String str);\\ntrimLeadingWhitespace(String str);\\ntrimTrailingWhitespace(String str);\\ntrimLeadingCharacter(String str,char leadingCharacter);\\ntrimTrailingCharacter(String str,char trailingCharacter);\\nstartsWithIgnoreCase(String str,String prefix);\\nendsWithIgnoreCase(String str,String suffix);\\nsubstringMatch(CharSequence str,int index,CharSequence substring);\\ncountOccurrencesOf(String str,String sub);\\nreplace(String inString,String oldPattern,String newPattern);\\ndelete(String inString,String pattern);\\ndeleteAny(String inString,String charsToDelete);\\nquote(String str);\\nquoteIfString(Object obj);\\nunqualify(String qualifiedName);\\nunqualify(String qualifiedName,char separator);\\ncapitalize(String str);\\nuncapitalize(String str);\\nchangeFirstCharacterCase(String str,boolean capitalize);\\ngetFilename(String path);\\ngetFilenameExtension(String path);\\nstripFilenameExtension(String path);\\napplyRelativePath(String path,String relativePath);\\ncleanPath(String path);\\npathEquals(String path1,String path2);\\nparseLocaleString(String localeString);\\nvalidateLocalePart(String localePart);\\ntoLanguageTag(Locale locale);\\naddStringToArray(String[] array,String str);\\nconcatenateStringArrays(String[] array1,String[] array2);\\nmergeStringArrays(String[] array1,String[] array2);\\nsortStringArray(String[] array);\\ntoStringArray(Collection collection);\\ntoStringArray(Enumeration enumeration);\\ntrimArrayElements(String[] array);\\nremoveDuplicateStrings(String[] array);\\nsplit(String toSplit,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter,String charsToDelete);\\ntokenizeToStringArray(String str,String delimiters);\\ntokenizeToStringArray(String str,String delimiters,boolean trimTokens,boolean ignoreEmptyTokens);\\ndelimitedListToStringArray(String str,String delimiter);\\ndelimitedListToStringArray(String str,String delimiter,String charsToDelete);\\ncommaDelimitedListToStringArray(String str);\\ncommaDelimitedListToSet(String str);\\ncollectionToDelimitedString(Collection coll,String delim,String prefix,String suffix);\\ncollectionToDelimitedString(Collection coll,String delim);\\ncollectionToCommaDelimitedString(Collection coll);\\narrayToDelimitedString(Object[] arr,String delim);\\narrayToCommaDelimitedString(Object[] arr);\\nhasLength(CharSequence str);\\n\", \"repo_level\" : \"\" }",
            "class_name": "Strings",
            "code": "public static String trimLeadingWhitespace(String str){\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb=new StringBuilder(str);\n  while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}\n",
            "docstring": "/** \n * Trim leading whitespace from the given String.\n * @param str the String to check\n * @return the trimmed String\n * @see java.lang.Character#isWhitespace\n */\n",
            "end_lineno": "236",
            "file_content": "/*\n * Copyright (C) 2014 jsonwebtoken.io\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.jsonwebtoken.lang;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic final class Strings {\n\n    private static final String FOLDER_SEPARATOR = \"/\";\n\n    private static final String WINDOWS_FOLDER_SEPARATOR = \"\\\\\";\n\n    private static final String TOP_PATH = \"..\";\n\n    private static final String CURRENT_PATH = \".\";\n\n    private static final char EXTENSION_SEPARATOR = '.';\n\n    public static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    private Strings(){} //prevent instantiation\n\n    //---------------------------------------------------------------------\n    // General convenience methods for working with Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Check that the given CharSequence is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a CharSequence that purely consists of whitespace.\n     * <pre>\n     * Strings.hasLength(null) = false\n     * Strings.hasLength(\"\") = false\n     * Strings.hasLength(\" \") = true\n     * Strings.hasLength(\"Hello\") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(CharSequence str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasLength(CharSequence)\n     */\n    public static boolean hasLength(String str) {\n        return hasLength((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <pre>\n     * Strings.hasText(null) = false\n     * Strings.hasText(\"\") = false\n     * Strings.hasText(\" \") = false\n     * Strings.hasText(\"12345\") = true\n     * Strings.hasText(\" 12345 \") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not <code>null</code>,\n     * its length is greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     * greater than 0, and it does not contain whitespace only\n     * @see #hasText(CharSequence)\n     */\n    public static boolean hasText(String str) {\n        return hasText((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence contains any whitespace characters.\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not empty and\n     * contains at least 1 whitespace character\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean containsWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String contains any whitespace characters.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not empty and\n     * contains at least 1 whitespace character\n     * @see #containsWhitespace(CharSequence)\n     */\n    public static boolean containsWhitespace(String str) {\n        return containsWhitespace((CharSequence) str);\n    }\n\n    /**\n     * Trim leading and trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimWhitespace(String str) {\n        return (String) trimWhitespace((CharSequence)str);\n    }\n    \n    \n    private static CharSequence trimWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        final int length = str.length();\n\n        int start = 0;\n\t\twhile (start < length && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        \n\t\tint end = length;\n        while (start < length && Character.isWhitespace(str.charAt(end - 1))) {\n            end--;\n        }\n        \n        return ((start > 0) || (end < length)) ? str.subSequence(start, end) : str;\n    }\n\n    public static String clean(String str) {\n    \tCharSequence result = clean((CharSequence) str);\n        \n        return result!=null?result.toString():null;\n    }\n    \n    public static CharSequence clean(CharSequence str) {\n        str = trimWhitespace(str);\n        if (!hasLength(str)) {\n            return null;\n        }\n        return str;\n    }\n\n    /**\n     * Trim <i>all</i> whitespace from the given String:\n     * leading, trailing, and intermediate characters.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimAllWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        int index = 0;\n        while (sb.length() > index) {\n            if (Character.isWhitespace(sb.charAt(index))) {\n                sb.deleteCharAt(index);\n            }\n            else {\n                index++;\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim leading whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimLeadingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimTrailingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied leading character from the given String.\n     * @param str the String to check\n     * @param leadingCharacter the leading character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimLeadingCharacter(String str, char leadingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied trailing character from the given String.\n     * @param str the String to check\n     * @param trailingCharacter the trailing character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimTrailingCharacter(String str, char trailingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n\n    /**\n     * Returns {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @param str the String to check\n     * @param prefix the prefix to look for\n     * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @param str the String to check\n     * @param suffix the suffix to look for\n     * @return {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @see java.lang.String#endsWith\n     */\n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        if (str == null || suffix == null) {\n            return false;\n        }\n        if (str.endsWith(suffix)) {\n            return true;\n        }\n        if (str.length() < suffix.length()) {\n            return false;\n        }\n\n        String lcStr = str.substring(str.length() - suffix.length()).toLowerCase();\n        String lcSuffix = suffix.toLowerCase();\n        return lcStr.equals(lcSuffix);\n    }\n\n    /**\n     * Returns {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     * @param str the original string (or StringBuilder)\n     * @param index the index in the original string to start matching against\n     * @param substring the substring to match at the given index\n     * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     */\n    public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n        for (int j = 0; j < substring.length(); j++) {\n            int i = index + j;\n            if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the number of occurrences the substring {@code sub} appears in string {@code str}.\n     * @param str string to search in. Return 0 if this is null.\n     * @param sub string to search for. Return 0 if this is null.\n     * @return the number of occurrences the substring {@code sub} appears in string {@code str}.\n     */\n    public static int countOccurrencesOf(String str, String sub) {\n        if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n            return 0;\n        }\n        int count = 0;\n        int pos = 0;\n        int idx;\n        while ((idx = str.indexOf(sub, pos)) != -1) {\n            ++count;\n            pos = idx + sub.length();\n        }\n        return count;\n    }\n\n    /**\n     * Replace all occurrences of a substring within a string with\n     * another string.\n     * @param inString String to examine\n     * @param oldPattern String to replace\n     * @param newPattern String to insert\n     * @return a String with the replacements\n     */\n    public static String replace(String inString, String oldPattern, String newPattern) {\n        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        int pos = 0; // our position in the old string\n        int index = inString.indexOf(oldPattern);\n        // the index of an occurrence we've found, or -1\n        int patLen = oldPattern.length();\n        while (index >= 0) {\n            sb.append(inString.substring(pos, index));\n            sb.append(newPattern);\n            pos = index + patLen;\n            index = inString.indexOf(oldPattern, pos);\n        }\n        sb.append(inString.substring(pos));\n        // remember to append any characters to the right of a match\n        return sb.toString();\n    }\n\n    /**\n     * Delete all occurrences of the given substring.\n     * @param inString the original String\n     * @param pattern the pattern to delete all occurrences of\n     * @return the resulting String\n     */\n    public static String delete(String inString, String pattern) {\n        return replace(inString, pattern, \"\");\n    }\n\n    /**\n     * Delete any character in a given String.\n     * @param inString the original String\n     * @param charsToDelete a set of characters to delete.\n     * E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n     * @return the resulting String\n     */\n    public static String deleteAny(String inString, String charsToDelete) {\n        if (!hasLength(inString) || !hasLength(charsToDelete)) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < inString.length(); i++) {\n            char c = inString.charAt(i);\n            if (charsToDelete.indexOf(c) == -1) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with formatted Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Quote the given String with single quotes.\n     * @param str the input String (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or <code>null</code> if the input was <code>null</code>\n     */\n    public static String quote(String str) {\n        return (str != null ? \"'\" + str + \"'\" : null);\n    }\n\n    /**\n     * Turn the given Object into a String with single quotes\n     * if it is a String; keeping the Object as-is else.\n     * @param obj the input Object (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or the input object as-is if not a String\n     */\n    public static Object quoteIfString(Object obj) {\n        return (obj instanceof String ? quote((String) obj) : obj);\n    }\n\n    /**\n     * Unqualify a string qualified by a '.' dot character. For example,\n     * \"this.name.is.qualified\", returns \"qualified\".\n     * @param qualifiedName the qualified name\n     * @return an unqualified string by stripping all previous text before (and including) the last period character.\n     */\n    public static String unqualify(String qualifiedName) {\n        return unqualify(qualifiedName, '.');\n    }\n\n    /**\n     * Unqualify a string qualified by a separator character. For example,\n     * \"this:name:is:qualified\" returns \"qualified\" if using a ':' separator.\n     * @param qualifiedName the qualified name\n     * @param separator the separator\n     * @return an unqualified string by stripping all previous text before and including the last {@code separator} character.\n     */\n    public static String unqualify(String qualifiedName, char separator) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);\n    }\n\n    /**\n     * Capitalize a <code>String</code>, changing the first letter to\n     * upper case as per {@link Character#toUpperCase(char)}.\n     * No other letters are changed.\n     * @param str the String to capitalize, may be <code>null</code>\n     * @return the capitalized String, <code>null</code> if null\n     */\n    public static String capitalize(String str) {\n        return changeFirstCharacterCase(str, true);\n    }\n\n    /**\n     * Uncapitalize a <code>String</code>, changing the first letter to\n     * lower case as per {@link Character#toLowerCase(char)}.\n     * No other letters are changed.\n     * @param str the String to uncapitalize, may be <code>null</code>\n     * @return the uncapitalized String, <code>null</code> if null\n     */\n    public static String uncapitalize(String str) {\n        return changeFirstCharacterCase(str, false);\n    }\n\n    private static String changeFirstCharacterCase(String str, boolean capitalize) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str.length());\n        if (capitalize) {\n            sb.append(Character.toUpperCase(str.charAt(0)));\n        }\n        else {\n            sb.append(Character.toLowerCase(str.charAt(0)));\n        }\n        sb.append(str.substring(1));\n        return sb.toString();\n    }\n\n    /**\n     * Extract the filename from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"myfile.txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename, or <code>null</code> if none\n     */\n    public static String getFilename(String path) {\n        if (path == null) {\n            return null;\n        }\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);\n    }\n\n    /**\n     * Extract the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename extension, or <code>null</code> if none\n     */\n    public static String getFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return null;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return null;\n        }\n        return path.substring(extIndex + 1);\n    }\n\n    /**\n     * Strip the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"mypath/myfile\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the path with stripped filename extension,\n     * or <code>null</code> if none\n     */\n    public static String stripFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return path;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return path;\n        }\n        return path.substring(0, extIndex);\n    }\n\n    /**\n     * Apply the given relative path to the given path,\n     * assuming standard Java folder separation (i.e. \"/\" separators).\n     * @param path the path to start from (usually a full file path)\n     * @param relativePath the relative path to apply\n     * (relative to the full file path above)\n     * @return the full file path that results from applying the relative path\n     */\n    public static String applyRelativePath(String path, String relativePath) {\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (separatorIndex != -1) {\n            String newPath = path.substring(0, separatorIndex);\n            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n                newPath += FOLDER_SEPARATOR;\n            }\n            return newPath + relativePath;\n        }\n        else {\n            return relativePath;\n        }\n    }\n\n    /**\n     * Normalize the path by suppressing sequences like \"path/..\" and\n     * inner simple dots.\n     * <p>The result is convenient for path comparison. For other uses,\n     * notice that Windows separators (\"\\\") are replaced by simple slashes.\n     * @param path the original path\n     * @return the normalized path\n     */\n    public static String cleanPath(String path) {\n        if (path == null) {\n            return null;\n        }\n        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);\n\n        // Strip prefix from path to analyze, to not treat it as part of the\n        // first path element. This is necessary to correctly parse paths like\n        // \"file:core/../core/io/Resource.class\", where the \"..\" should just\n        // strip the first \"core\" directory while keeping the \"file:\" prefix.\n        int prefixIndex = pathToUse.indexOf(\":\");\n        String prefix = \"\";\n        if (prefixIndex != -1) {\n            prefix = pathToUse.substring(0, prefixIndex + 1);\n            pathToUse = pathToUse.substring(prefixIndex + 1);\n        }\n        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {\n            prefix = prefix + FOLDER_SEPARATOR;\n            pathToUse = pathToUse.substring(1);\n        }\n\n        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);\n        List<String> pathElements = new LinkedList<String>();\n        int tops = 0;\n\n        for (int i = pathArray.length - 1; i >= 0; i--) {\n            String element = pathArray[i];\n            if (CURRENT_PATH.equals(element)) {\n                // Points to current directory - drop it.\n            }\n            else if (TOP_PATH.equals(element)) {\n                // Registering top path found.\n                tops++;\n            }\n            else {\n                if (tops > 0) {\n                    // Merging path element with element corresponding to top path.\n                    tops--;\n                }\n                else {\n                    // Normal path element found.\n                    pathElements.add(0, element);\n                }\n            }\n        }\n\n        // Remaining top paths need to be retained.\n        for (int i = 0; i < tops; i++) {\n            pathElements.add(0, TOP_PATH);\n        }\n\n        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);\n    }\n\n    /**\n     * Compare two paths after normalization of them.\n     * @param path1 first path for comparison\n     * @param path2 second path for comparison\n     * @return whether the two paths are equivalent after normalization\n     */\n    public static boolean pathEquals(String path1, String path2) {\n        return cleanPath(path1).equals(cleanPath(path2));\n    }\n\n    /**\n     * Parse the given <code>localeString</code> value into a {@link java.util.Locale}.\n     * <p>This is the inverse operation of {@link java.util.Locale#toString Locale's toString}.\n     * @param localeString the locale string, following <code>Locale's</code>\n     * <code>toString()</code> format (\"en\", \"en_UK\", etc);\n     * also accepts spaces as separators, as an alternative to underscores\n     * @return a corresponding <code>Locale</code> instance\n     */\n    public static Locale parseLocaleString(String localeString) {\n        String[] parts = tokenizeToStringArray(localeString, \"_ \", false, false);\n        String language = (parts.length > 0 ? parts[0] : \"\");\n        String country = (parts.length > 1 ? parts[1] : \"\");\n        validateLocalePart(language);\n        validateLocalePart(country);\n        String variant = \"\";\n        if (parts.length >= 2) {\n            // There is definitely a variant, and it is everything after the country\n            // code sans the separator between the country code and the variant.\n            int endIndexOfCountryCode = localeString.indexOf(country) + country.length();\n            // Strip off any leading '_' and whitespace, what's left is the variant.\n            variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));\n            if (variant.startsWith(\"_\")) {\n                variant = trimLeadingCharacter(variant, '_');\n            }\n        }\n        return (language.length() > 0 ? new Locale(language, country, variant) : null);\n    }\n\n    private static void validateLocalePart(String localePart) {\n        for (int i = 0; i < localePart.length(); i++) {\n            char ch = localePart.charAt(i);\n            if (ch != '_' && ch != ' ' && !Character.isLetterOrDigit(ch)) {\n                throw new IllegalArgumentException(\n                    \"Locale part \\\"\" + localePart + \"\\\" contains invalid characters\");\n            }\n        }\n    }\n\n    /**\n     * Determine the RFC 3066 compliant language tag,\n     * as used for the HTTP \"Accept-Language\" header.\n     * @param locale the Locale to transform to a language tag\n     * @return the RFC 3066 compliant language tag as String\n     */\n    public static String toLanguageTag(Locale locale) {\n        return locale.getLanguage() + (hasText(locale.getCountry()) ? \"-\" + locale.getCountry() : \"\");\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with String arrays\n    //---------------------------------------------------------------------\n\n    /**\n     * Append the given String to the given String array, returning a new array\n     * consisting of the input array contents plus the given String.\n     * @param array the array to append to (can be <code>null</code>)\n     * @param str the String to append\n     * @return the new array (never <code>null</code>)\n     */\n    public static String[] addStringToArray(String[] array, String str) {\n        if (Objects.isEmpty(array)) {\n            return new String[] {str};\n        }\n        String[] newArr = new String[array.length + 1];\n        System.arraycopy(array, 0, newArr, 0, array.length);\n        newArr[array.length] = str;\n        return newArr;\n    }\n\n    /**\n     * Concatenate the given String arrays into one,\n     * with overlapping array elements included twice.\n     * <p>The order of elements in the original arrays is preserved.\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        String[] newArr = new String[array1.length + array2.length];\n        System.arraycopy(array1, 0, newArr, 0, array1.length);\n        System.arraycopy(array2, 0, newArr, array1.length, array2.length);\n        return newArr;\n    }\n\n    /**\n     * Merge the given String arrays into one, with overlapping\n     * array elements only included once.\n     * <p>The order of elements in the original arrays is preserved\n     * (with the exception of overlapping elements, which are only\n     * included on their first occurrence).\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] mergeStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        List<String> result = new ArrayList<String>();\n        result.addAll(Arrays.asList(array1));\n        for (String str : array2) {\n            if (!result.contains(str)) {\n                result.add(str);\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Turn given source String array into sorted array.\n     * @param array the source array\n     * @return the sorted array (never <code>null</code>)\n     */\n    public static String[] sortStringArray(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        Arrays.sort(array);\n        return array;\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Collection was <code>null</code>)\n     */\n    public static String[] toStringArray(Collection<String> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new String[collection.size()]);\n    }\n\n    /**\n     * Copy the given Enumeration into a String array.\n     * The Enumeration must contain String elements only.\n     * @param enumeration the Enumeration to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Enumeration was <code>null</code>)\n     */\n    public static String[] toStringArray(Enumeration<String> enumeration) {\n        if (enumeration == null) {\n            return null;\n        }\n        List<String> list = java.util.Collections.list(enumeration);\n        return list.toArray(new String[list.size()]);\n    }\n\n    /**\n     * Trim the elements of the given String array,\n     * calling <code>String.trim()</code> on each of them.\n     * @param array the original String array\n     * @return the resulting array (of the same size) with trimmed elements\n     */\n    public static String[] trimArrayElements(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        String[] result = new String[array.length];\n        for (int i = 0; i < array.length; i++) {\n            String element = array[i];\n            result[i] = (element != null ? element.trim() : null);\n        }\n        return result;\n    }\n\n    /**\n     * Remove duplicate Strings from the given array.\n     * Also sorts the array, as it uses a TreeSet.\n     * @param array the String array\n     * @return an array without duplicates, in natural sort order\n     */\n    public static String[] removeDuplicateStrings(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return array;\n        }\n        Set<String> set = new TreeSet<String>();\n        for (String element : array) {\n            set.add(element);\n        }\n        return toStringArray(set);\n    }\n\n    /**\n     * Split a String at the first occurrence of the delimiter.\n     * Does not include the delimiter in the result.\n     * @param toSplit the string to split\n     * @param delimiter to split the string up with\n     * @return a two element array with index 0 being before the delimiter, and\n     * index 1 being after the delimiter (neither element includes the delimiter);\n     * or <code>null</code> if the delimiter wasn't found in the given input String\n     */\n    public static String[] split(String toSplit, String delimiter) {\n        if (!hasLength(toSplit) || !hasLength(delimiter)) {\n            return null;\n        }\n        int offset = toSplit.indexOf(delimiter);\n        if (offset < 0) {\n            return null;\n        }\n        String beforeDelimiter = toSplit.substring(0, offset);\n        String afterDelimiter = toSplit.substring(offset + delimiter.length());\n        return new String[] {beforeDelimiter, afterDelimiter};\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was null or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {\n        return splitArrayElementsIntoProperties(array, delimiter, null);\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @param charsToDelete one or more characters to remove from each element\n     * prior to attempting the split operation (typically the quotation mark\n     * symbol), or <code>null</code> if no removal should occur\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was <code>null</code> or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(\n        String[] array, String delimiter, String charsToDelete) {\n\n        if (Objects.isEmpty(array)) {\n            return null;\n        }\n        Properties result = new Properties();\n        for (String element : array) {\n            if (charsToDelete != null) {\n                element = deleteAny(element, charsToDelete);\n            }\n            String[] splittedElement = split(element, delimiter);\n            if (splittedElement == null) {\n                continue;\n            }\n            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n        }\n        return result;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter)\n     * @param trimTokens trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     * (only applies to tokens that are empty after trimming; StringTokenizer\n     * will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     * was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(\n        String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List<String> tokens = new ArrayList<String>();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter) {\n        return delimitedListToStringArray(str, delimiter, null);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @param charsToDelete a set of characters to delete. Useful for deleting unwanted\n     * line breaks: e.g. \"\\r\\n\\f\" will delete all new lines and line feeds in a String.\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {\n        if (str == null) {\n            return new String[0];\n        }\n        if (delimiter == null) {\n            return new String[] {str};\n        }\n        List<String> result = new ArrayList<String>();\n        if (\"\".equals(delimiter)) {\n            for (int i = 0; i < str.length(); i++) {\n                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));\n            }\n        }\n        else {\n            int pos = 0;\n            int delPos;\n            while ((delPos = str.indexOf(delimiter, pos)) != -1) {\n                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));\n                pos = delPos + delimiter.length();\n            }\n            if (str.length() > 0 && pos <= str.length()) {\n                // Add rest of String, but not in case of empty input.\n                result.add(deleteAny(str.substring(pos), charsToDelete));\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Convert a CSV list into an array of Strings.\n     * @param str the input String\n     * @return an array of Strings, or the empty array in case of empty input\n     */\n    public static String[] commaDelimitedListToStringArray(String str) {\n        return delimitedListToStringArray(str, \",\");\n    }\n\n    /**\n     * Convenience method to convert a CSV string list to a set.\n     * Note that this will suppress duplicates.\n     * @param str the input String\n     * @return a Set of String entries in the list\n     */\n    public static Set<String> commaDelimitedListToSet(String str) {\n        Set<String> set = new TreeSet<String>();\n        String[] tokens = commaDelimitedListToStringArray(str);\n        for (String token : tokens) {\n            set.add(token);\n        }\n        return set;\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @param prefix the String to start each element with\n     * @param suffix the String to end each element with\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {\n        if (Collections.isEmpty(coll)) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        Iterator<?> it = coll.iterator();\n        while (it.hasNext()) {\n            sb.append(prefix).append(it.next()).append(suffix);\n            if (it.hasNext()) {\n                sb.append(delim);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim) {\n        return collectionToDelimitedString(coll, delim, \"\", \"\");\n    }\n\n    /**\n     * Convenience method to return a Collection as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @return the delimited String\n     */\n    public static String collectionToCommaDelimitedString(Collection<?> coll) {\n        return collectionToDelimitedString(coll, \",\");\n    }\n\n    /**\n     * Convenience method to return a String array as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String arrayToDelimitedString(Object[] arr, String delim) {\n        if (Objects.isEmpty(arr)) {\n            return \"\";\n        }\n        if (arr.length == 1) {\n            return Objects.nullSafeToString(arr[0]);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < arr.length; i++) {\n            if (i > 0) {\n                sb.append(delim);\n            }\n            sb.append(arr[i]);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a String array as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @return the delimited String\n     */\n    public static String arrayToCommaDelimitedString(Object[] arr) {\n        return arrayToDelimitedString(arr, \",\");\n    }\n\n}\n\n",
            "file_name": "Strings.java",
            "human_label": "Trim the leading whitespaces in a string.",
            "level": "class_runnable",
            "lineno": "221",
            "name": "trimLeadingWhitespace",
            "oracle_context": "{ \"apis\" : \"[hasLength, length, isWhitespace, charAt, deleteCharAt, toString]\", \"classes\" : \"[StringBuilder]\", \"vars\" : \"[]\" }",
            "package": "io.jsonwebtoken.lang",
            "project": "jjwt-master"
        },
        {
            "_id": "636766fe1a6d9265ec01782a",
            "all_context": "{ \"class_level\" : \"import java.io.ByteArrayOutputStream;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nint SKIP_CODE;\\nint SKIP_DEBUG;\\nint SKIP_FRAMES;\\nint EXPAND_FRAMES;\\nint EXPAND_ASM_INSNS;\\nint INPUT_STREAM_DATA_CHUNK_SIZE;\\nbyte[] b;\\nbyte[] classFileBuffer;\\nint[] cpInfoOffsets;\\nString[] constantUtf8Values;\\nConstantDynamic[] constantDynamicValues;\\nint[] bootstrapMethodOffsets;\\nint maxStringLength;\\nint header;\\nClassReader(byte[] classFile);\\nClassReader(byte[] classFileBuffer,int classFileOffset,int classFileLength);\\nClassReader(byte[] classFileBuffer,int classFileOffset,boolean checkClassVersion);\\nClassReader(InputStream inputStream);\\nClassReader(String className);\\ngetAccess();\\ngetClassName();\\ngetSuperName();\\ngetInterfaces();\\naccept(ClassVisitor classVisitor,int parsingOptions);\\naccept(ClassVisitor classVisitor,Attribute[] attributePrototypes,int parsingOptions);\\nreadModuleAttributes(ClassVisitor classVisitor,Context context,int moduleOffset,int modulePackagesOffset,String moduleMainClass);\\nreadRecordComponent(ClassVisitor classVisitor,Context context,int recordComponentOffset);\\nreadField(ClassVisitor classVisitor,Context context,int fieldInfoOffset);\\nreadMethod(ClassVisitor classVisitor,Context context,int methodInfoOffset);\\nreadCode(MethodVisitor methodVisitor,Context context,int codeOffset);\\nreadLabel(int bytecodeOffset,Label[] labels);\\ncreateLabel(int bytecodeOffset,Label[] labels);\\ncreateDebugLabel(int bytecodeOffset,Label[] labels);\\nreadTypeAnnotations(MethodVisitor methodVisitor,Context context,int runtimeTypeAnnotationsOffset,boolean visible);\\ngetTypeAnnotationBytecodeOffset(int[] typeAnnotationOffsets,int typeAnnotationIndex);\\nreadTypeAnnotationTarget(Context context,int typeAnnotationOffset);\\nreadParameterAnnotations(MethodVisitor methodVisitor,Context context,int runtimeParameterAnnotationsOffset,boolean visible);\\nreadElementValues(AnnotationVisitor annotationVisitor,int annotationOffset,boolean named,char[] charBuffer);\\nreadElementValue(AnnotationVisitor annotationVisitor,int elementValueOffset,String elementName,char[] charBuffer);\\ncomputeImplicitFrame(Context context);\\nreadStackMapFrame(int stackMapFrameOffset,boolean compressed,boolean expand,Context context);\\nreadVerificationTypeInfo(int verificationTypeInfoOffset,Object[] frame,int index,char[] charBuffer,Label[] labels);\\ngetFirstAttributeOffset();\\nreadBootstrapMethodsAttribute(int maxStringLength);\\nreadAttribute(Attribute[] attributePrototypes,String type,int offset,int length,char[] charBuffer,int codeAttributeOffset,Label[] labels);\\ngetItemCount();\\ngetItem(int constantPoolEntryIndex);\\ngetMaxStringLength();\\nreadByte(int offset);\\nreadUnsignedShort(int offset);\\nreadShort(int offset);\\nreadInt(int offset);\\nreadLong(int offset);\\nreadUTF8(int offset,char[] charBuffer);\\nreadUtf(int constantPoolEntryIndex,char[] charBuffer);\\nreadUtf(int utfOffset,int utfLength,char[] charBuffer);\\nreadStringish(int offset,char[] charBuffer);\\nreadClass(int offset,char[] charBuffer);\\nreadModule(int offset,char[] charBuffer);\\nreadPackage(int offset,char[] charBuffer);\\nreadConstantDynamic(int constantPoolEntryIndex,char[] charBuffer);\\nreadConst(int constantPoolEntryIndex,char[] charBuffer);\\nreadStream(InputStream inputStream,boolean close);\\n\", \"repo_level\" : \"\" }",
            "class_name": "ClassReader",
            "code": "final String readUtf(final int constantPoolEntryIndex,final char[] charBuffer){\n  String value=constantUtf8Values[constantPoolEntryIndex];\n  if (value != null) {\n    return value;\n  }\n  int cpInfoOffset=cpInfoOffsets[constantPoolEntryIndex];\n  return constantUtf8Values[constantPoolEntryIndex]=readUtf(cpInfoOffset + 2,readUnsignedShort(cpInfoOffset),charBuffer);\n}\n",
            "docstring": "/** \n * Reads a CONSTANT_Utf8 constant pool entry in  {@link #classFileBuffer}.\n * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pooltable.\n * @param charBuffer the buffer to be used to read the string. This buffer must be sufficientlylarge. It is not automatically resized.\n * @return the String corresponding to the specified CONSTANT_Utf8 entry.\n */\n",
            "end_lineno": "3172",
            "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage net.hasor.utils.asm;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * A parser to make a {@link ClassVisitor} visit a ClassFile structure, as defined in the Java\n * Virtual Machine Specification (JVMS). This class parses the ClassFile content and calls the\n * appropriate visit methods of a given {@link ClassVisitor} for each field, method and bytecode\n * instruction encountered.\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html\">JVMS 4</a>\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic class ClassReader {\n    /**\n     * A flag to skip the Code attributes. If this flag is set the Code attributes are neither parsed\n     * nor visited.\n     */\n    public static final  int               SKIP_CODE                    = 1;\n    /**\n     * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable,\n     * LocalVariableTypeTable, LineNumberTable and MethodParameters attributes. If this flag is set\n     * these attributes are neither parsed nor visited (i.e. {@link ClassVisitor#visitSource}, {@link\n     * MethodVisitor#visitLocalVariable}, {@link MethodVisitor#visitLineNumber} and {@link\n     * MethodVisitor#visitParameter} are not called).\n     */\n    public static final  int               SKIP_DEBUG                   = 2;\n    /**\n     * A flag to skip the StackMap and StackMapTable attributes. If this flag is set these attributes\n     * are neither parsed nor visited (i.e. {@link MethodVisitor#visitFrame} is not called). This flag\n     * is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is used: it avoids visiting frames\n     * that will be ignored and recomputed from scratch.\n     */\n    public static final  int               SKIP_FRAMES                  = 4;\n    /**\n     * A flag to expand the stack map frames. By default stack map frames are visited in their\n     * original format (i.e. \"expanded\" for classes whose version is less than V1_6, and \"compressed\"\n     * for the other classes). If this flag is set, stack map frames are always visited in expanded\n     * format (this option adds a decompression/compression step in ClassReader and ClassWriter which\n     * degrades performance quite a lot).\n     */\n    public static final  int               EXPAND_FRAMES                = 8;\n    /**\n     * A flag to expand the ASM specific instructions into an equivalent sequence of standard bytecode\n     * instructions. When resolving a forward jump it may happen that the signed 2 bytes offset\n     * reserved for it is not sufficient to store the bytecode offset. In this case the jump\n     * instruction is replaced with a temporary ASM specific instruction using an unsigned 2 bytes\n     * offset (see {@link Label#resolve}). This internal flag is used to re-read classes containing\n     * such instructions, in order to replace them with standard instructions. In addition, when this\n     * flag is used, goto_w and jsr_w are <i>not</i> converted into goto and jsr, to make sure that\n     * infinite loops where a goto_w is replaced with a goto in ClassReader and converted back to a\n     * goto_w in ClassWriter cannot occur.\n     */\n    static final         int               EXPAND_ASM_INSNS             = 256;\n    /** The size of the temporary byte array used to read class input streams chunk by chunk. */\n    private static final int               INPUT_STREAM_DATA_CHUNK_SIZE = 4096;\n    /**\n     * A byte array containing the JVMS ClassFile structure to be parsed.\n     *\n     * @deprecated Use {@link #readByte(int)} and the other read methods instead. This field will\n     *     eventually be deleted.\n     */\n    @Deprecated\n    // DontCheck(MemberName): can't be renamed (for backward binary compatibility).\n    public final         byte[]            b;\n    /**\n     * A byte array containing the JVMS ClassFile structure to be parsed. <i>The content of this array\n     * must not be modified. This field is intended for {@link Attribute} sub classes, and is normally\n     * not needed by class visitors.</i>\n     *\n     * <p>NOTE: the ClassFile structure can start at any offset within this array, i.e. it does not\n     * necessarily start at offset 0. Use {@link #getItem} and {@link #header} to get correct\n     * ClassFile element offsets within this byte array.\n     */\n    final                byte[]            classFileBuffer;\n    /**\n     * The offset in bytes, in {@link #classFileBuffer}, of each cp_info entry of the ClassFile's\n     * constant_pool array, <i>plus one</i>. In other words, the offset of constant pool entry i is\n     * given by cpInfoOffsets[i] - 1, i.e. its cp_info's tag field is given by b[cpInfoOffsets[i] -\n     * 1].\n     */\n    private final        int[]             cpInfoOffsets;\n    /**\n     * The String objects corresponding to the CONSTANT_Utf8 constant pool items. This cache avoids\n     * multiple parsing of a given CONSTANT_Utf8 constant pool item.\n     */\n    private final        String[]          constantUtf8Values;\n    /**\n     * The ConstantDynamic objects corresponding to the CONSTANT_Dynamic constant pool items. This\n     * cache avoids multiple parsing of a given CONSTANT_Dynamic constant pool item.\n     */\n    private final        ConstantDynamic[] constantDynamicValues;\n    /**\n     * The start offsets in {@link #classFileBuffer} of each element of the bootstrap_methods array\n     * (in the BootstrapMethods attribute).\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23\">JVMS\n     *     4.7.23</a>\n     */\n    private final        int[]             bootstrapMethodOffsets;\n    /**\n     * A conservative estimate of the maximum length of the strings contained in the constant pool of\n     * the class.\n     */\n    private final        int               maxStringLength;\n    /** The offset in bytes of the ClassFile's access_flags field. */\n    public final         int               header;\n    // -----------------------------------------------------------------------------------------------\n    // Constructors\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param classFile the JVMS ClassFile structure to be read.\n     */\n    public ClassReader(final byte[] classFile) {\n        this(classFile, 0, classFile.length);\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.\n     * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.\n     * @param classFileLength the length in bytes of the ClassFile to be read.\n     */\n    public ClassReader(final byte[] classFileBuffer, final int classFileOffset, final int classFileLength) { // NOPMD(UnusedFormalParameter) used for backward compatibility.\n        this(classFileBuffer, classFileOffset, /* checkClassVersion = */ true);\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object. <i>This internal constructor must not be exposed\n     * as a public API</i>.\n     *\n     * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.\n     * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.\n     * @param checkClassVersion whether to check the class version or not.\n     */\n    ClassReader(final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {\n        this.classFileBuffer = classFileBuffer;\n        this.b = classFileBuffer;\n        // Check the class' major_version. This field is after the magic and minor_version fields, which\n        // use 4 and 2 bytes respectively.\n        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V15) {\n            throw new IllegalArgumentException(\"Unsupported class file major version \" + readShort(classFileOffset + 6));\n        }\n        // Create the constant pool arrays. The constant_pool_count field is after the magic,\n        // minor_version and major_version fields, which use 4, 2 and 2 bytes respectively.\n        int constantPoolCount = readUnsignedShort(classFileOffset + 8);\n        cpInfoOffsets = new int[constantPoolCount];\n        constantUtf8Values = new String[constantPoolCount];\n        // Compute the offset of each constant pool entry, as well as a conservative estimate of the\n        // maximum length of the constant pool strings. The first constant pool entry is after the\n        // magic, minor_version, major_version and constant_pool_count fields, which use 4, 2, 2 and 2\n        // bytes respectively.\n        int currentCpInfoIndex = 1;\n        int currentCpInfoOffset = classFileOffset + 10;\n        int currentMaxStringLength = 0;\n        boolean hasBootstrapMethods = false;\n        boolean hasConstantDynamic = false;\n        // The offset of the other entries depend on the total size of all the previous entries.\n        while (currentCpInfoIndex < constantPoolCount) {\n            cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;\n            int cpInfoSize;\n            switch (classFileBuffer[currentCpInfoOffset]) {\n            case Symbol.CONSTANT_FIELDREF_TAG:\n            case Symbol.CONSTANT_METHODREF_TAG:\n            case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n            case Symbol.CONSTANT_INTEGER_TAG:\n            case Symbol.CONSTANT_FLOAT_TAG:\n            case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n                cpInfoSize = 5;\n                break;\n            case Symbol.CONSTANT_DYNAMIC_TAG:\n                cpInfoSize = 5;\n                hasBootstrapMethods = true;\n                hasConstantDynamic = true;\n                break;\n            case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n                cpInfoSize = 5;\n                hasBootstrapMethods = true;\n                break;\n            case Symbol.CONSTANT_LONG_TAG:\n            case Symbol.CONSTANT_DOUBLE_TAG:\n                cpInfoSize = 9;\n                currentCpInfoIndex++;\n                break;\n            case Symbol.CONSTANT_UTF8_TAG:\n                cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);\n                if (cpInfoSize > currentMaxStringLength) {\n                    // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate\n                    // of the length in characters of the corresponding string, and is much cheaper to\n                    // compute than this exact length.\n                    currentMaxStringLength = cpInfoSize;\n                }\n                break;\n            case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n                cpInfoSize = 4;\n                break;\n            case Symbol.CONSTANT_CLASS_TAG:\n            case Symbol.CONSTANT_STRING_TAG:\n            case Symbol.CONSTANT_METHOD_TYPE_TAG:\n            case Symbol.CONSTANT_PACKAGE_TAG:\n            case Symbol.CONSTANT_MODULE_TAG:\n                cpInfoSize = 3;\n                break;\n            default:\n                throw new IllegalArgumentException();\n            }\n            currentCpInfoOffset += cpInfoSize;\n        }\n        maxStringLength = currentMaxStringLength;\n        // The Classfile's access_flags field is just after the last constant pool entry.\n        header = currentCpInfoOffset;\n        // Allocate the cache of ConstantDynamic values, if there is at least one.\n        constantDynamicValues = hasConstantDynamic ? new ConstantDynamic[constantPoolCount] : null;\n        // Read the BootstrapMethods attribute, if any (only get the offset of each method).\n        bootstrapMethodOffsets = hasBootstrapMethods ? readBootstrapMethodsAttribute(currentMaxStringLength) : null;\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param inputStream an input stream of the JVMS ClassFile structure to be read. This input\n     *     stream must contain nothing more than the ClassFile structure itself. It is read from its\n     *     current position to its end.\n     * @throws IOException if a problem occurs during reading.\n     */\n    public ClassReader(final InputStream inputStream) throws IOException {\n        this(readStream(inputStream, false));\n    }\n\n    /**\n     * Constructs a new {@link ClassReader} object.\n     *\n     * @param className the fully qualified name of the class to be read. The ClassFile structure is\n     *     retrieved with the current class loader's {@link ClassLoader#getSystemResourceAsStream}.\n     * @throws IOException if an exception occurs during reading.\n     */\n    public ClassReader(final String className) throws IOException {\n        this(readStream(ClassLoader.getSystemResourceAsStream(className.replace('.', '/') + \".class\"), true));\n    }\n\n    /**\n     * Reads the given input stream and returns its content as a byte array.\n     *\n     * @param inputStream an input stream.\n     * @param close true to close the input stream after reading.\n     * @return the content of the given input stream.\n     * @throws IOException if a problem occurs during reading.\n     */\n    private static byte[] readStream(final InputStream inputStream, final boolean close) throws IOException {\n        if (inputStream == null) {\n            throw new IOException(\"Class not found\");\n        }\n        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n            byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {\n                outputStream.write(data, 0, bytesRead);\n            }\n            outputStream.flush();\n            return outputStream.toByteArray();\n        } finally {\n            if (close) {\n                inputStream.close();\n            }\n        }\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Accessors\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the class's access flags (see {@link Opcodes}). This value may not reflect Deprecated\n     * and Synthetic flags when bytecode is before 1.5 and those flags are represented by attributes.\n     *\n     * @return the class access flags.\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public int getAccess() {\n        return readUnsignedShort(header);\n    }\n\n    /**\n     * Returns the internal name of the class (see {@link Type#getInternalName()}).\n     *\n     * @return the internal class name.\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getClassName() {\n        // this_class is just after the access_flags field (using 2 bytes).\n        return readClass(header + 2, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal of name of the super class (see {@link Type#getInternalName()}). For\n     * interfaces, the super class is {@link Object}.\n     *\n     * @return the internal name of the super class, or {@literal null} for {@link Object} class.\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String getSuperName() {\n        // super_class is after the access_flags and this_class fields (2 bytes each).\n        return readClass(header + 4, new char[maxStringLength]);\n    }\n\n    /**\n     * Returns the internal names of the implemented interfaces (see {@link Type#getInternalName()}).\n     *\n     * @return the internal names of the directly implemented interfaces. Inherited implemented\n     *     interfaces are not returned.\n     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n     */\n    public String[] getInterfaces() {\n        // interfaces_count is after the access_flags, this_class and super_class fields (2 bytes each).\n        int currentOffset = header + 6;\n        int interfacesCount = readUnsignedShort(currentOffset);\n        String[] interfaces = new String[interfacesCount];\n        if (interfacesCount > 0) {\n            char[] charBuffer = new char[maxStringLength];\n            for (int i = 0; i < interfacesCount; ++i) {\n                currentOffset += 2;\n                interfaces[i] = readClass(currentOffset, charBuffer);\n            }\n        }\n        return interfaces;\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Public methods\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this\n     * {@link ClassReader}.\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param parsingOptions the options to use to parse this class. One or more of {@link\n     *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.\n     */\n    public void accept(final ClassVisitor classVisitor, final int parsingOptions) {\n        accept(classVisitor, new Attribute[0], parsingOptions);\n    }\n\n    /**\n     * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this\n     * {@link ClassReader}.\n     *\n     * @param classVisitor the visitor that must visit this class.\n     * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of\n     *     the class. Any attribute whose type is not equal to the type of one the prototypes will not\n     *     be parsed: its byte array value will be passed unchanged to the ClassWriter. <i>This may\n     *     corrupt it if this value contains references to the constant pool, or has syntactic or\n     *     semantic links with a class element that has been transformed by a class adapter between\n     *     the reader and the writer</i>.\n     * @param parsingOptions the options to use to parse this class. One or more of {@link\n     *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.\n     */\n    public void accept(final ClassVisitor classVisitor, final Attribute[] attributePrototypes, final int parsingOptions) {\n        Context context = new Context();\n        context.attributePrototypes = attributePrototypes;\n        context.parsingOptions = parsingOptions;\n        context.charBuffer = new char[maxStringLength];\n        // Read the access_flags, this_class, super_class, interface_count and interfaces fields.\n        char[] charBuffer = context.charBuffer;\n        int currentOffset = header;\n        int accessFlags = readUnsignedShort(currentOffset);\n        String thisClass = readClass(currentOffset + 2, charBuffer);\n        String superClass = readClass(currentOffset + 4, charBuffer);\n        String[] interfaces = new String[readUnsignedShort(currentOffset + 6)];\n        currentOffset += 8;\n        for (int i = 0; i < interfaces.length; ++i) {\n            interfaces[i] = readClass(currentOffset, charBuffer);\n            currentOffset += 2;\n        }\n        // Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).\n        // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n        // - The offset of the InnerClasses attribute, or 0.\n        int innerClassesOffset = 0;\n        // - The offset of the EnclosingMethod attribute, or 0.\n        int enclosingMethodOffset = 0;\n        // - The string corresponding to the Signature attribute, or null.\n        String signature = null;\n        // - The string corresponding to the SourceFile attribute, or null.\n        String sourceFile = null;\n        // - The string corresponding to the SourceDebugExtension attribute, or null.\n        String sourceDebugExtension = null;\n        // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n        int runtimeVisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n        int runtimeInvisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n        int runtimeVisibleTypeAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n        int runtimeInvisibleTypeAnnotationsOffset = 0;\n        // - The offset of the Module attribute, or 0.\n        int moduleOffset = 0;\n        // - The offset of the ModulePackages attribute, or 0.\n        int modulePackagesOffset = 0;\n        // - The string corresponding to the ModuleMainClass attribute, or null.\n        String moduleMainClass = null;\n        // - The string corresponding to the NestHost attribute, or null.\n        String nestHostClass = null;\n        // - The offset of the NestMembers attribute, or 0.\n        int nestMembersOffset = 0;\n        // - The offset of the PermittedSubtypes attribute, or 0\n        int permittedSubtypesOffset = 0;\n        // - The offset of the Record attribute, or 0.\n        int recordOffset = 0;\n        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n        Attribute attributes = null;\n        int currentAttributeOffset = getFirstAttributeOffset();\n        for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentAttributeOffset, charBuffer);\n            int attributeLength = readInt(currentAttributeOffset + 2);\n            currentAttributeOffset += 6;\n            // The tests are sorted in decreasing frequency order (based on frequencies observed on\n            // typical classes).\n            if (Constants.SOURCE_FILE.equals(attributeName)) {\n                sourceFile = readUTF8(currentAttributeOffset, charBuffer);\n            } else if (Constants.INNER_CLASSES.equals(attributeName)) {\n                innerClassesOffset = currentAttributeOffset;\n            } else if (Constants.ENCLOSING_METHOD.equals(attributeName)) {\n                enclosingMethodOffset = currentAttributeOffset;\n            } else if (Constants.NEST_HOST.equals(attributeName)) {\n                nestHostClass = readClass(currentAttributeOffset, charBuffer);\n            } else if (Constants.NEST_MEMBERS.equals(attributeName)) {\n                nestMembersOffset = currentAttributeOffset;\n            } else if (Constants.PERMITTED_SUBTYPES.equals(attributeName)) {\n                permittedSubtypesOffset = currentAttributeOffset;\n            } else if (Constants.SIGNATURE.equals(attributeName)) {\n                signature = readUTF8(currentAttributeOffset, charBuffer);\n            } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleAnnotationsOffset = currentAttributeOffset;\n            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;\n            } else if (Constants.DEPRECATED.equals(attributeName)) {\n                accessFlags |= Opcodes.ACC_DEPRECATED;\n            } else if (Constants.SYNTHETIC.equals(attributeName)) {\n                accessFlags |= Opcodes.ACC_SYNTHETIC;\n            } else if (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {\n                sourceDebugExtension = readUtf(currentAttributeOffset, attributeLength, new char[attributeLength]);\n            } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleAnnotationsOffset = currentAttributeOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;\n            } else if (Constants.RECORD.equals(attributeName)) {\n                recordOffset = currentAttributeOffset;\n            } else if (Constants.MODULE.equals(attributeName)) {\n                moduleOffset = currentAttributeOffset;\n            } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {\n                moduleMainClass = readClass(currentAttributeOffset, charBuffer);\n            } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {\n                modulePackagesOffset = currentAttributeOffset;\n            } else if (!Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n                // The BootstrapMethods attribute is read in the constructor.\n                Attribute attribute = readAttribute(attributePrototypes, attributeName, currentAttributeOffset, attributeLength, charBuffer, -1, null);\n                attribute.nextAttribute = attributes;\n                attributes = attribute;\n            }\n            currentAttributeOffset += attributeLength;\n        }\n        // Visit the class declaration. The minor_version and major_version fields start 6 bytes before\n        // the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).\n        classVisitor.visit(readInt(cpInfoOffsets[1] - 7), accessFlags, thisClass, signature, superClass, interfaces);\n        // Visit the SourceFile and SourceDebugExtenstion attributes.\n        if ((parsingOptions & SKIP_DEBUG) == 0 && (sourceFile != null || sourceDebugExtension != null)) {\n            classVisitor.visitSource(sourceFile, sourceDebugExtension);\n        }\n        // Visit the Module, ModulePackages and ModuleMainClass attributes.\n        if (moduleOffset != 0) {\n            readModuleAttributes(classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);\n        }\n        // Visit the NestHost attribute.\n        if (nestHostClass != null) {\n            classVisitor.visitNestHost(nestHostClass);\n        }\n        // Visit the EnclosingMethod attribute.\n        if (enclosingMethodOffset != 0) {\n            String className = readClass(enclosingMethodOffset, charBuffer);\n            int methodIndex = readUnsignedShort(enclosingMethodOffset + 2);\n            String name = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex], charBuffer);\n            String type = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex] + 2, charBuffer);\n            classVisitor.visitOuterClass(className, name, type);\n        }\n        // Visit the RuntimeVisibleAnnotations attribute.\n        if (runtimeVisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleAnnotations attribute.\n        if (runtimeInvisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeVisibleTypeAnnotations attribute.\n        if (runtimeVisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(classVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleTypeAnnotations attribute.\n        if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(classVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the non standard attributes.\n        while (attributes != null) {\n            // Copy and reset the nextAttribute field so that it can also be used in ClassWriter.\n            Attribute nextAttribute = attributes.nextAttribute;\n            attributes.nextAttribute = null;\n            classVisitor.visitAttribute(attributes);\n            attributes = nextAttribute;\n        }\n        // Visit the NestedMembers attribute.\n        if (nestMembersOffset != 0) {\n            int numberOfNestMembers = readUnsignedShort(nestMembersOffset);\n            int currentNestMemberOffset = nestMembersOffset + 2;\n            while (numberOfNestMembers-- > 0) {\n                classVisitor.visitNestMember(readClass(currentNestMemberOffset, charBuffer));\n                currentNestMemberOffset += 2;\n            }\n        }\n        // Visit the PermittedSubtypes attribute.\n        if (permittedSubtypesOffset != 0) {\n            int numberOfPermittedSubtypes = readUnsignedShort(permittedSubtypesOffset);\n            int currentPermittedSubtypeOffset = permittedSubtypesOffset + 2;\n            while (numberOfPermittedSubtypes-- > 0) {\n                classVisitor.visitPermittedSubtypeExperimental(readClass(currentPermittedSubtypeOffset, charBuffer));\n                currentPermittedSubtypeOffset += 2;\n            }\n        }\n        // Visit the InnerClasses attribute.\n        if (innerClassesOffset != 0) {\n            int numberOfClasses = readUnsignedShort(innerClassesOffset);\n            int currentClassesOffset = innerClassesOffset + 2;\n            while (numberOfClasses-- > 0) {\n                classVisitor.visitInnerClass(readClass(currentClassesOffset, charBuffer), readClass(currentClassesOffset + 2, charBuffer), readUTF8(currentClassesOffset + 4, charBuffer), readUnsignedShort(currentClassesOffset + 6));\n                currentClassesOffset += 8;\n            }\n        }\n        // Visit Record components.\n        if (recordOffset != 0) {\n            int recordComponentsCount = readUnsignedShort(recordOffset);\n            recordOffset += 2;\n            while (recordComponentsCount-- > 0) {\n                recordOffset = readRecordComponent(classVisitor, context, recordOffset);\n            }\n        }\n        // Visit the fields and methods.\n        int fieldsCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (fieldsCount-- > 0) {\n            currentOffset = readField(classVisitor, context, currentOffset);\n        }\n        int methodsCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (methodsCount-- > 0) {\n            currentOffset = readMethod(classVisitor, context, currentOffset);\n        }\n        // Visit the end of the class.\n        classVisitor.visitEnd();\n    }\n    // ----------------------------------------------------------------------------------------------\n    // Methods to parse modules, fields and methods\n    // ----------------------------------------------------------------------------------------------\n\n    /**\n     * Reads the Module, ModulePackages and ModuleMainClass attributes and visit them.\n     *\n     * @param classVisitor the current class visitor\n     * @param context information about the class being parsed.\n     * @param moduleOffset the offset of the Module attribute (excluding the attribute_info's\n     *     attribute_name_index and attribute_length fields).\n     * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the\n     *     attribute_info's attribute_name_index and attribute_length fields), or 0.\n     * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or {@literal\n     *     null}.\n     */\n    private void readModuleAttributes(final ClassVisitor classVisitor, final Context context, final int moduleOffset, final int modulePackagesOffset, final String moduleMainClass) {\n        char[] buffer = context.charBuffer;\n        // Read the module_name_index, module_flags and module_version_index fields and visit them.\n        int currentOffset = moduleOffset;\n        String moduleName = readModule(currentOffset, buffer);\n        int moduleFlags = readUnsignedShort(currentOffset + 2);\n        String moduleVersion = readUTF8(currentOffset + 4, buffer);\n        currentOffset += 6;\n        ModuleVisitor moduleVisitor = classVisitor.visitModule(moduleName, moduleFlags, moduleVersion);\n        if (moduleVisitor == null) {\n            return;\n        }\n        // Visit the ModuleMainClass attribute.\n        if (moduleMainClass != null) {\n            moduleVisitor.visitMainClass(moduleMainClass);\n        }\n        // Visit the ModulePackages attribute.\n        if (modulePackagesOffset != 0) {\n            int packageCount = readUnsignedShort(modulePackagesOffset);\n            int currentPackageOffset = modulePackagesOffset + 2;\n            while (packageCount-- > 0) {\n                moduleVisitor.visitPackage(readPackage(currentPackageOffset, buffer));\n                currentPackageOffset += 2;\n            }\n        }\n        // Read the 'requires_count' and 'requires' fields.\n        int requiresCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (requiresCount-- > 0) {\n            // Read the requires_index, requires_flags and requires_version fields and visit them.\n            String requires = readModule(currentOffset, buffer);\n            int requiresFlags = readUnsignedShort(currentOffset + 2);\n            String requiresVersion = readUTF8(currentOffset + 4, buffer);\n            currentOffset += 6;\n            moduleVisitor.visitRequire(requires, requiresFlags, requiresVersion);\n        }\n        // Read the 'exports_count' and 'exports' fields.\n        int exportsCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (exportsCount-- > 0) {\n            // Read the exports_index, exports_flags, exports_to_count and exports_to_index fields\n            // and visit them.\n            String exports = readPackage(currentOffset, buffer);\n            int exportsFlags = readUnsignedShort(currentOffset + 2);\n            int exportsToCount = readUnsignedShort(currentOffset + 4);\n            currentOffset += 6;\n            String[] exportsTo = null;\n            if (exportsToCount != 0) {\n                exportsTo = new String[exportsToCount];\n                for (int i = 0; i < exportsToCount; ++i) {\n                    exportsTo[i] = readModule(currentOffset, buffer);\n                    currentOffset += 2;\n                }\n            }\n            moduleVisitor.visitExport(exports, exportsFlags, exportsTo);\n        }\n        // Reads the 'opens_count' and 'opens' fields.\n        int opensCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (opensCount-- > 0) {\n            // Read the opens_index, opens_flags, opens_to_count and opens_to_index fields and visit them.\n            String opens = readPackage(currentOffset, buffer);\n            int opensFlags = readUnsignedShort(currentOffset + 2);\n            int opensToCount = readUnsignedShort(currentOffset + 4);\n            currentOffset += 6;\n            String[] opensTo = null;\n            if (opensToCount != 0) {\n                opensTo = new String[opensToCount];\n                for (int i = 0; i < opensToCount; ++i) {\n                    opensTo[i] = readModule(currentOffset, buffer);\n                    currentOffset += 2;\n                }\n            }\n            moduleVisitor.visitOpen(opens, opensFlags, opensTo);\n        }\n        // Read the 'uses_count' and 'uses' fields.\n        int usesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (usesCount-- > 0) {\n            moduleVisitor.visitUse(readClass(currentOffset, buffer));\n            currentOffset += 2;\n        }\n        // Read the  'provides_count' and 'provides' fields.\n        int providesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (providesCount-- > 0) {\n            // Read the provides_index, provides_with_count and provides_with_index fields and visit them.\n            String provides = readClass(currentOffset, buffer);\n            int providesWithCount = readUnsignedShort(currentOffset + 2);\n            currentOffset += 4;\n            String[] providesWith = new String[providesWithCount];\n            for (int i = 0; i < providesWithCount; ++i) {\n                providesWith[i] = readClass(currentOffset, buffer);\n                currentOffset += 2;\n            }\n            moduleVisitor.visitProvide(provides, providesWith);\n        }\n        // Visit the end of the module attributes.\n        moduleVisitor.visitEnd();\n    }\n\n    /**\n     * Reads a record component and visit it.\n     *\n     * @param classVisitor the current class visitor\n     * @param context information about the class being parsed.\n     * @param recordComponentOffset the offset of the current record component.\n     * @return the offset of the first byte following the record component.\n     */\n    private int readRecordComponent(final ClassVisitor classVisitor, final Context context, final int recordComponentOffset) {\n        char[] charBuffer = context.charBuffer;\n        int currentOffset = recordComponentOffset;\n        String name = readUTF8(currentOffset, charBuffer);\n        String descriptor = readUTF8(currentOffset + 2, charBuffer);\n        currentOffset += 4;\n        // Read the record component attributes (the variables are ordered as in Section 4.7 of the\n        // JVMS).\n        int accessFlags = 0;\n        // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n        // - The string corresponding to the Signature attribute, or null.\n        String signature = null;\n        // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n        int runtimeVisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n        int runtimeInvisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n        int runtimeVisibleTypeAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n        int runtimeInvisibleTypeAnnotationsOffset = 0;\n        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n        Attribute attributes = null;\n        int attributesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (attributesCount-- > 0) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentOffset, charBuffer);\n            int attributeLength = readInt(currentOffset + 2);\n            currentOffset += 6;\n            // The tests are sorted in decreasing frequency order (based on frequencies observed on\n            // typical classes).\n            if (Constants.SIGNATURE.equals(attributeName)) {\n                signature = readUTF8(currentOffset, charBuffer);\n            } else if (Constants.DEPRECATED.equals(attributeName)) {\n                accessFlags |= Opcodes.ACC_DEPRECATED;\n            } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleTypeAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleTypeAnnotationsOffset = currentOffset;\n            } else {\n                Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, -1, null);\n                attribute.nextAttribute = attributes;\n                attributes = attribute;\n            }\n            currentOffset += attributeLength;\n        }\n        RecordComponentVisitor recordComponentVisitor = classVisitor.visitRecordComponentExperimental(accessFlags, name, descriptor, signature);\n        if (recordComponentVisitor == null) {\n            return currentOffset;\n        }\n        // Visit the RuntimeVisibleAnnotations attribute.\n        if (runtimeVisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(recordComponentVisitor.visitAnnotationExperimental(annotationDescriptor, /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleAnnotations attribute.\n        if (runtimeInvisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(recordComponentVisitor.visitAnnotationExperimental(annotationDescriptor, /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeVisibleTypeAnnotations attribute.\n        if (runtimeVisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(recordComponentVisitor.visitTypeAnnotationExperimental(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleTypeAnnotations attribute.\n        if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(recordComponentVisitor.visitTypeAnnotationExperimental(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the non standard attributes.\n        while (attributes != null) {\n            // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.\n            Attribute nextAttribute = attributes.nextAttribute;\n            attributes.nextAttribute = null;\n            recordComponentVisitor.visitAttributeExperimental(attributes);\n            attributes = nextAttribute;\n        }\n        // Visit the end of the field.\n        recordComponentVisitor.visitEndExperimental();\n        return currentOffset;\n    }\n\n    /**\n     * Reads a JVMS field_info structure and makes the given visitor visit it.\n     *\n     * @param classVisitor the visitor that must visit the field.\n     * @param context information about the class being parsed.\n     * @param fieldInfoOffset the start offset of the field_info structure.\n     * @return the offset of the first byte following the field_info structure.\n     */\n    private int readField(final ClassVisitor classVisitor, final Context context, final int fieldInfoOffset) {\n        char[] charBuffer = context.charBuffer;\n        // Read the access_flags, name_index and descriptor_index fields.\n        int currentOffset = fieldInfoOffset;\n        int accessFlags = readUnsignedShort(currentOffset);\n        String name = readUTF8(currentOffset + 2, charBuffer);\n        String descriptor = readUTF8(currentOffset + 4, charBuffer);\n        currentOffset += 6;\n        // Read the field attributes (the variables are ordered as in Section 4.7 of the JVMS).\n        // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n        // - The value corresponding to the ConstantValue attribute, or null.\n        Object constantValue = null;\n        // - The string corresponding to the Signature attribute, or null.\n        String signature = null;\n        // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n        int runtimeVisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n        int runtimeInvisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n        int runtimeVisibleTypeAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n        int runtimeInvisibleTypeAnnotationsOffset = 0;\n        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n        Attribute attributes = null;\n        int attributesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (attributesCount-- > 0) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentOffset, charBuffer);\n            int attributeLength = readInt(currentOffset + 2);\n            currentOffset += 6;\n            // The tests are sorted in decreasing frequency order (based on frequencies observed on\n            // typical classes).\n            if (Constants.CONSTANT_VALUE.equals(attributeName)) {\n                int constantvalueIndex = readUnsignedShort(currentOffset);\n                constantValue = constantvalueIndex == 0 ? null : readConst(constantvalueIndex, charBuffer);\n            } else if (Constants.SIGNATURE.equals(attributeName)) {\n                signature = readUTF8(currentOffset, charBuffer);\n            } else if (Constants.DEPRECATED.equals(attributeName)) {\n                accessFlags |= Opcodes.ACC_DEPRECATED;\n            } else if (Constants.SYNTHETIC.equals(attributeName)) {\n                accessFlags |= Opcodes.ACC_SYNTHETIC;\n            } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleTypeAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleTypeAnnotationsOffset = currentOffset;\n            } else {\n                Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, -1, null);\n                attribute.nextAttribute = attributes;\n                attributes = attribute;\n            }\n            currentOffset += attributeLength;\n        }\n        // Visit the field declaration.\n        FieldVisitor fieldVisitor = classVisitor.visitField(accessFlags, name, descriptor, signature, constantValue);\n        if (fieldVisitor == null) {\n            return currentOffset;\n        }\n        // Visit the RuntimeVisibleAnnotations attribute.\n        if (runtimeVisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(fieldVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleAnnotations attribute.\n        if (runtimeInvisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(fieldVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeVisibleTypeAnnotations attribute.\n        if (runtimeVisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(fieldVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleTypeAnnotations attribute.\n        if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(fieldVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the non standard attributes.\n        while (attributes != null) {\n            // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.\n            Attribute nextAttribute = attributes.nextAttribute;\n            attributes.nextAttribute = null;\n            fieldVisitor.visitAttribute(attributes);\n            attributes = nextAttribute;\n        }\n        // Visit the end of the field.\n        fieldVisitor.visitEnd();\n        return currentOffset;\n    }\n\n    /**\n     * Reads a JVMS method_info structure and makes the given visitor visit it.\n     *\n     * @param classVisitor the visitor that must visit the method.\n     * @param context information about the class being parsed.\n     * @param methodInfoOffset the start offset of the method_info structure.\n     * @return the offset of the first byte following the method_info structure.\n     */\n    private int readMethod(final ClassVisitor classVisitor, final Context context, final int methodInfoOffset) {\n        char[] charBuffer = context.charBuffer;\n        // Read the access_flags, name_index and descriptor_index fields.\n        int currentOffset = methodInfoOffset;\n        context.currentMethodAccessFlags = readUnsignedShort(currentOffset);\n        context.currentMethodName = readUTF8(currentOffset + 2, charBuffer);\n        context.currentMethodDescriptor = readUTF8(currentOffset + 4, charBuffer);\n        currentOffset += 6;\n        // Read the method attributes (the variables are ordered as in Section 4.7 of the JVMS).\n        // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n        // - The offset of the Code attribute, or 0.\n        int codeOffset = 0;\n        // - The offset of the Exceptions attribute, or 0.\n        int exceptionsOffset = 0;\n        // - The strings corresponding to the Exceptions attribute, or null.\n        String[] exceptions = null;\n        // - Whether the method has a Synthetic attribute.\n        boolean synthetic = false;\n        // - The constant pool index contained in the Signature attribute, or 0.\n        int signatureIndex = 0;\n        // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n        int runtimeVisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n        int runtimeInvisibleAnnotationsOffset = 0;\n        // - The offset of the RuntimeVisibleParameterAnnotations attribute, or 0.\n        int runtimeVisibleParameterAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleParameterAnnotations attribute, or 0.\n        int runtimeInvisibleParameterAnnotationsOffset = 0;\n        // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n        int runtimeVisibleTypeAnnotationsOffset = 0;\n        // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n        int runtimeInvisibleTypeAnnotationsOffset = 0;\n        // - The offset of the AnnotationDefault attribute, or 0.\n        int annotationDefaultOffset = 0;\n        // - The offset of the MethodParameters attribute, or 0.\n        int methodParametersOffset = 0;\n        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n        Attribute attributes = null;\n        int attributesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (attributesCount-- > 0) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentOffset, charBuffer);\n            int attributeLength = readInt(currentOffset + 2);\n            currentOffset += 6;\n            // The tests are sorted in decreasing frequency order (based on frequencies observed on\n            // typical classes).\n            if (Constants.CODE.equals(attributeName)) {\n                if ((context.parsingOptions & SKIP_CODE) == 0) {\n                    codeOffset = currentOffset;\n                }\n            } else if (Constants.EXCEPTIONS.equals(attributeName)) {\n                exceptionsOffset = currentOffset;\n                exceptions = new String[readUnsignedShort(exceptionsOffset)];\n                int currentExceptionOffset = exceptionsOffset + 2;\n                for (int i = 0; i < exceptions.length; ++i) {\n                    exceptions[i] = readClass(currentExceptionOffset, charBuffer);\n                    currentExceptionOffset += 2;\n                }\n            } else if (Constants.SIGNATURE.equals(attributeName)) {\n                signatureIndex = readUnsignedShort(currentOffset);\n            } else if (Constants.DEPRECATED.equals(attributeName)) {\n                context.currentMethodAccessFlags |= Opcodes.ACC_DEPRECATED;\n            } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleTypeAnnotationsOffset = currentOffset;\n            } else if (Constants.ANNOTATION_DEFAULT.equals(attributeName)) {\n                annotationDefaultOffset = currentOffset;\n            } else if (Constants.SYNTHETIC.equals(attributeName)) {\n                synthetic = true;\n                context.currentMethodAccessFlags |= Opcodes.ACC_SYNTHETIC;\n            } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleTypeAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {\n                runtimeVisibleParameterAnnotationsOffset = currentOffset;\n            } else if (Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {\n                runtimeInvisibleParameterAnnotationsOffset = currentOffset;\n            } else if (Constants.METHOD_PARAMETERS.equals(attributeName)) {\n                methodParametersOffset = currentOffset;\n            } else {\n                Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, -1, null);\n                attribute.nextAttribute = attributes;\n                attributes = attribute;\n            }\n            currentOffset += attributeLength;\n        }\n        // Visit the method declaration.\n        MethodVisitor methodVisitor = classVisitor.visitMethod(context.currentMethodAccessFlags, context.currentMethodName, context.currentMethodDescriptor, signatureIndex == 0 ? null : readUtf(signatureIndex, charBuffer), exceptions);\n        if (methodVisitor == null) {\n            return currentOffset;\n        }\n        // If the returned MethodVisitor is in fact a MethodWriter, it means there is no method\n        // adapter between the reader and the writer. In this case, it might be possible to copy\n        // the method attributes directly into the writer. If so, return early without visiting\n        // the content of these attributes.\n        if (methodVisitor instanceof MethodWriter) {\n            MethodWriter methodWriter = (MethodWriter) methodVisitor;\n            if (methodWriter.canCopyMethodAttributes(this, synthetic, (context.currentMethodAccessFlags & Opcodes.ACC_DEPRECATED) != 0, readUnsignedShort(methodInfoOffset + 4), signatureIndex, exceptionsOffset)) {\n                methodWriter.setMethodAttributesSource(methodInfoOffset, currentOffset - methodInfoOffset);\n                return currentOffset;\n            }\n        }\n        // Visit the MethodParameters attribute.\n        if (methodParametersOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {\n            int parametersCount = readByte(methodParametersOffset);\n            int currentParameterOffset = methodParametersOffset + 1;\n            while (parametersCount-- > 0) {\n                // Read the name_index and access_flags fields and visit them.\n                methodVisitor.visitParameter(readUTF8(currentParameterOffset, charBuffer), readUnsignedShort(currentParameterOffset + 2));\n                currentParameterOffset += 4;\n            }\n        }\n        // Visit the AnnotationDefault attribute.\n        if (annotationDefaultOffset != 0) {\n            AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();\n            readElementValue(annotationVisitor, annotationDefaultOffset, null, charBuffer);\n            if (annotationVisitor != null) {\n                annotationVisitor.visitEnd();\n            }\n        }\n        // Visit the RuntimeVisibleAnnotations attribute.\n        if (runtimeVisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(methodVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleAnnotations attribute.\n        if (runtimeInvisibleAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(methodVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeVisibleTypeAnnotations attribute.\n        if (runtimeVisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(methodVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ true), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeInvisibleTypeAnnotations attribute.\n        if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n            int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n            int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n            while (numAnnotations-- > 0) {\n                // Parse the target_type, target_info and target_path fields.\n                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                currentAnnotationOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentAnnotationOffset = readElementValues(methodVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                        /* visible = */ false), currentAnnotationOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n        // Visit the RuntimeVisibleParameterAnnotations attribute.\n        if (runtimeVisibleParameterAnnotationsOffset != 0) {\n            readParameterAnnotations(methodVisitor, context, runtimeVisibleParameterAnnotationsOffset, /* visible = */ true);\n        }\n        // Visit the RuntimeInvisibleParameterAnnotations attribute.\n        if (runtimeInvisibleParameterAnnotationsOffset != 0) {\n            readParameterAnnotations(methodVisitor, context, runtimeInvisibleParameterAnnotationsOffset,\n                    /* visible = */ false);\n        }\n        // Visit the non standard attributes.\n        while (attributes != null) {\n            // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.\n            Attribute nextAttribute = attributes.nextAttribute;\n            attributes.nextAttribute = null;\n            methodVisitor.visitAttribute(attributes);\n            attributes = nextAttribute;\n        }\n        // Visit the Code attribute.\n        if (codeOffset != 0) {\n            methodVisitor.visitCode();\n            readCode(methodVisitor, context, codeOffset);\n        }\n        // Visit the end of the method.\n        methodVisitor.visitEnd();\n        return currentOffset;\n    }\n    // ----------------------------------------------------------------------------------------------\n    // Methods to parse a Code attribute\n    // ----------------------------------------------------------------------------------------------\n\n    /**\n     * Reads a JVMS 'Code' attribute and makes the given visitor visit it.\n     *\n     * @param methodVisitor the visitor that must visit the Code attribute.\n     * @param context information about the class being parsed.\n     * @param codeOffset the start offset in {@link #classFileBuffer} of the Code attribute, excluding\n     *     its attribute_name_index and attribute_length fields.\n     */\n    private void readCode(final MethodVisitor methodVisitor, final Context context, final int codeOffset) {\n        int currentOffset = codeOffset;\n        // Read the max_stack, max_locals and code_length fields.\n        final byte[] classBuffer = classFileBuffer;\n        final char[] charBuffer = context.charBuffer;\n        final int maxStack = readUnsignedShort(currentOffset);\n        final int maxLocals = readUnsignedShort(currentOffset + 2);\n        final int codeLength = readInt(currentOffset + 4);\n        currentOffset += 8;\n        // Read the bytecode 'code' array to create a label for each referenced instruction.\n        final int bytecodeStartOffset = currentOffset;\n        final int bytecodeEndOffset = currentOffset + codeLength;\n        final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];\n        while (currentOffset < bytecodeEndOffset) {\n            final int bytecodeOffset = currentOffset - bytecodeStartOffset;\n            final int opcode = classBuffer[currentOffset] & 0xFF;\n            switch (opcode) {\n            case Constants.NOP:\n            case Constants.ACONST_NULL:\n            case Constants.ICONST_M1:\n            case Constants.ICONST_0:\n            case Constants.ICONST_1:\n            case Constants.ICONST_2:\n            case Constants.ICONST_3:\n            case Constants.ICONST_4:\n            case Constants.ICONST_5:\n            case Constants.LCONST_0:\n            case Constants.LCONST_1:\n            case Constants.FCONST_0:\n            case Constants.FCONST_1:\n            case Constants.FCONST_2:\n            case Constants.DCONST_0:\n            case Constants.DCONST_1:\n            case Constants.IALOAD:\n            case Constants.LALOAD:\n            case Constants.FALOAD:\n            case Constants.DALOAD:\n            case Constants.AALOAD:\n            case Constants.BALOAD:\n            case Constants.CALOAD:\n            case Constants.SALOAD:\n            case Constants.IASTORE:\n            case Constants.LASTORE:\n            case Constants.FASTORE:\n            case Constants.DASTORE:\n            case Constants.AASTORE:\n            case Constants.BASTORE:\n            case Constants.CASTORE:\n            case Constants.SASTORE:\n            case Constants.POP:\n            case Constants.POP2:\n            case Constants.DUP:\n            case Constants.DUP_X1:\n            case Constants.DUP_X2:\n            case Constants.DUP2:\n            case Constants.DUP2_X1:\n            case Constants.DUP2_X2:\n            case Constants.SWAP:\n            case Constants.IADD:\n            case Constants.LADD:\n            case Constants.FADD:\n            case Constants.DADD:\n            case Constants.ISUB:\n            case Constants.LSUB:\n            case Constants.FSUB:\n            case Constants.DSUB:\n            case Constants.IMUL:\n            case Constants.LMUL:\n            case Constants.FMUL:\n            case Constants.DMUL:\n            case Constants.IDIV:\n            case Constants.LDIV:\n            case Constants.FDIV:\n            case Constants.DDIV:\n            case Constants.IREM:\n            case Constants.LREM:\n            case Constants.FREM:\n            case Constants.DREM:\n            case Constants.INEG:\n            case Constants.LNEG:\n            case Constants.FNEG:\n            case Constants.DNEG:\n            case Constants.ISHL:\n            case Constants.LSHL:\n            case Constants.ISHR:\n            case Constants.LSHR:\n            case Constants.IUSHR:\n            case Constants.LUSHR:\n            case Constants.IAND:\n            case Constants.LAND:\n            case Constants.IOR:\n            case Constants.LOR:\n            case Constants.IXOR:\n            case Constants.LXOR:\n            case Constants.I2L:\n            case Constants.I2F:\n            case Constants.I2D:\n            case Constants.L2I:\n            case Constants.L2F:\n            case Constants.L2D:\n            case Constants.F2I:\n            case Constants.F2L:\n            case Constants.F2D:\n            case Constants.D2I:\n            case Constants.D2L:\n            case Constants.D2F:\n            case Constants.I2B:\n            case Constants.I2C:\n            case Constants.I2S:\n            case Constants.LCMP:\n            case Constants.FCMPL:\n            case Constants.FCMPG:\n            case Constants.DCMPL:\n            case Constants.DCMPG:\n            case Constants.IRETURN:\n            case Constants.LRETURN:\n            case Constants.FRETURN:\n            case Constants.DRETURN:\n            case Constants.ARETURN:\n            case Constants.RETURN:\n            case Constants.ARRAYLENGTH:\n            case Constants.ATHROW:\n            case Constants.MONITORENTER:\n            case Constants.MONITOREXIT:\n            case Constants.ILOAD_0:\n            case Constants.ILOAD_1:\n            case Constants.ILOAD_2:\n            case Constants.ILOAD_3:\n            case Constants.LLOAD_0:\n            case Constants.LLOAD_1:\n            case Constants.LLOAD_2:\n            case Constants.LLOAD_3:\n            case Constants.FLOAD_0:\n            case Constants.FLOAD_1:\n            case Constants.FLOAD_2:\n            case Constants.FLOAD_3:\n            case Constants.DLOAD_0:\n            case Constants.DLOAD_1:\n            case Constants.DLOAD_2:\n            case Constants.DLOAD_3:\n            case Constants.ALOAD_0:\n            case Constants.ALOAD_1:\n            case Constants.ALOAD_2:\n            case Constants.ALOAD_3:\n            case Constants.ISTORE_0:\n            case Constants.ISTORE_1:\n            case Constants.ISTORE_2:\n            case Constants.ISTORE_3:\n            case Constants.LSTORE_0:\n            case Constants.LSTORE_1:\n            case Constants.LSTORE_2:\n            case Constants.LSTORE_3:\n            case Constants.FSTORE_0:\n            case Constants.FSTORE_1:\n            case Constants.FSTORE_2:\n            case Constants.FSTORE_3:\n            case Constants.DSTORE_0:\n            case Constants.DSTORE_1:\n            case Constants.DSTORE_2:\n            case Constants.DSTORE_3:\n            case Constants.ASTORE_0:\n            case Constants.ASTORE_1:\n            case Constants.ASTORE_2:\n            case Constants.ASTORE_3:\n                currentOffset += 1;\n                break;\n            case Constants.IFEQ:\n            case Constants.IFNE:\n            case Constants.IFLT:\n            case Constants.IFGE:\n            case Constants.IFGT:\n            case Constants.IFLE:\n            case Constants.IF_ICMPEQ:\n            case Constants.IF_ICMPNE:\n            case Constants.IF_ICMPLT:\n            case Constants.IF_ICMPGE:\n            case Constants.IF_ICMPGT:\n            case Constants.IF_ICMPLE:\n            case Constants.IF_ACMPEQ:\n            case Constants.IF_ACMPNE:\n            case Constants.GOTO:\n            case Constants.JSR:\n            case Constants.IFNULL:\n            case Constants.IFNONNULL:\n                createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);\n                currentOffset += 3;\n                break;\n            case Constants.ASM_IFEQ:\n            case Constants.ASM_IFNE:\n            case Constants.ASM_IFLT:\n            case Constants.ASM_IFGE:\n            case Constants.ASM_IFGT:\n            case Constants.ASM_IFLE:\n            case Constants.ASM_IF_ICMPEQ:\n            case Constants.ASM_IF_ICMPNE:\n            case Constants.ASM_IF_ICMPLT:\n            case Constants.ASM_IF_ICMPGE:\n            case Constants.ASM_IF_ICMPGT:\n            case Constants.ASM_IF_ICMPLE:\n            case Constants.ASM_IF_ACMPEQ:\n            case Constants.ASM_IF_ACMPNE:\n            case Constants.ASM_GOTO:\n            case Constants.ASM_JSR:\n            case Constants.ASM_IFNULL:\n            case Constants.ASM_IFNONNULL:\n                createLabel(bytecodeOffset + readUnsignedShort(currentOffset + 1), labels);\n                currentOffset += 3;\n                break;\n            case Constants.GOTO_W:\n            case Constants.JSR_W:\n            case Constants.ASM_GOTO_W:\n                createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);\n                currentOffset += 5;\n                break;\n            case Constants.WIDE:\n                switch (classBuffer[currentOffset + 1] & 0xFF) {\n                case Constants.ILOAD:\n                case Constants.FLOAD:\n                case Constants.ALOAD:\n                case Constants.LLOAD:\n                case Constants.DLOAD:\n                case Constants.ISTORE:\n                case Constants.FSTORE:\n                case Constants.ASTORE:\n                case Constants.LSTORE:\n                case Constants.DSTORE:\n                case Constants.RET:\n                    currentOffset += 4;\n                    break;\n                case Constants.IINC:\n                    currentOffset += 6;\n                    break;\n                default:\n                    throw new IllegalArgumentException();\n                }\n                break;\n            case Constants.TABLESWITCH:\n                // Skip 0 to 3 padding bytes.\n                currentOffset += 4 - (bytecodeOffset & 3);\n                // Read the default label and the number of table entries.\n                createLabel(bytecodeOffset + readInt(currentOffset), labels);\n                int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;\n                currentOffset += 12;\n                // Read the table labels.\n                while (numTableEntries-- > 0) {\n                    createLabel(bytecodeOffset + readInt(currentOffset), labels);\n                    currentOffset += 4;\n                }\n                break;\n            case Constants.LOOKUPSWITCH:\n                // Skip 0 to 3 padding bytes.\n                currentOffset += 4 - (bytecodeOffset & 3);\n                // Read the default label and the number of switch cases.\n                createLabel(bytecodeOffset + readInt(currentOffset), labels);\n                int numSwitchCases = readInt(currentOffset + 4);\n                currentOffset += 8;\n                // Read the switch labels.\n                while (numSwitchCases-- > 0) {\n                    createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);\n                    currentOffset += 8;\n                }\n                break;\n            case Constants.ILOAD:\n            case Constants.LLOAD:\n            case Constants.FLOAD:\n            case Constants.DLOAD:\n            case Constants.ALOAD:\n            case Constants.ISTORE:\n            case Constants.LSTORE:\n            case Constants.FSTORE:\n            case Constants.DSTORE:\n            case Constants.ASTORE:\n            case Constants.RET:\n            case Constants.BIPUSH:\n            case Constants.NEWARRAY:\n            case Constants.LDC:\n                currentOffset += 2;\n                break;\n            case Constants.SIPUSH:\n            case Constants.LDC_W:\n            case Constants.LDC2_W:\n            case Constants.GETSTATIC:\n            case Constants.PUTSTATIC:\n            case Constants.GETFIELD:\n            case Constants.PUTFIELD:\n            case Constants.INVOKEVIRTUAL:\n            case Constants.INVOKESPECIAL:\n            case Constants.INVOKESTATIC:\n            case Constants.NEW:\n            case Constants.ANEWARRAY:\n            case Constants.CHECKCAST:\n            case Constants.INSTANCEOF:\n            case Constants.IINC:\n                currentOffset += 3;\n                break;\n            case Constants.INVOKEINTERFACE:\n            case Constants.INVOKEDYNAMIC:\n                currentOffset += 5;\n                break;\n            case Constants.MULTIANEWARRAY:\n                currentOffset += 4;\n                break;\n            default:\n                throw new IllegalArgumentException();\n            }\n        }\n        // Read the 'exception_table_length' and 'exception_table' field to create a label for each\n        // referenced instruction, and to make methodVisitor visit the corresponding try catch blocks.\n        int exceptionTableLength = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (exceptionTableLength-- > 0) {\n            Label start = createLabel(readUnsignedShort(currentOffset), labels);\n            Label end = createLabel(readUnsignedShort(currentOffset + 2), labels);\n            Label handler = createLabel(readUnsignedShort(currentOffset + 4), labels);\n            String catchType = readUTF8(cpInfoOffsets[readUnsignedShort(currentOffset + 6)], charBuffer);\n            currentOffset += 8;\n            methodVisitor.visitTryCatchBlock(start, end, handler, catchType);\n        }\n        // Read the Code attributes to create a label for each referenced instruction (the variables\n        // are ordered as in Section 4.7 of the JVMS). Attribute offsets exclude the\n        // attribute_name_index and attribute_length fields.\n        // - The offset of the current 'stack_map_frame' in the StackMap[Table] attribute, or 0.\n        // Initially, this is the offset of the first 'stack_map_frame' entry. Then this offset is\n        // updated after each stack_map_frame is read.\n        int stackMapFrameOffset = 0;\n        // - The end offset of the StackMap[Table] attribute, or 0.\n        int stackMapTableEndOffset = 0;\n        // - Whether the stack map frames are compressed (i.e. in a StackMapTable) or not.\n        boolean compressedFrames = true;\n        // - The offset of the LocalVariableTable attribute, or 0.\n        int localVariableTableOffset = 0;\n        // - The offset of the LocalVariableTypeTable attribute, or 0.\n        int localVariableTypeTableOffset = 0;\n        // - The offset of each 'type_annotation' entry in the RuntimeVisibleTypeAnnotations\n        // attribute, or null.\n        int[] visibleTypeAnnotationOffsets = null;\n        // - The offset of each 'type_annotation' entry in the RuntimeInvisibleTypeAnnotations\n        // attribute, or null.\n        int[] invisibleTypeAnnotationOffsets = null;\n        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n        Attribute attributes = null;\n        int attributesCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (attributesCount-- > 0) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentOffset, charBuffer);\n            int attributeLength = readInt(currentOffset + 2);\n            currentOffset += 6;\n            if (Constants.LOCAL_VARIABLE_TABLE.equals(attributeName)) {\n                if ((context.parsingOptions & SKIP_DEBUG) == 0) {\n                    localVariableTableOffset = currentOffset;\n                    // Parse the attribute to find the corresponding (debug only) labels.\n                    int currentLocalVariableTableOffset = currentOffset;\n                    int localVariableTableLength = readUnsignedShort(currentLocalVariableTableOffset);\n                    currentLocalVariableTableOffset += 2;\n                    while (localVariableTableLength-- > 0) {\n                        int startPc = readUnsignedShort(currentLocalVariableTableOffset);\n                        createDebugLabel(startPc, labels);\n                        int length = readUnsignedShort(currentLocalVariableTableOffset + 2);\n                        createDebugLabel(startPc + length, labels);\n                        // Skip the name_index, descriptor_index and index fields (2 bytes each).\n                        currentLocalVariableTableOffset += 10;\n                    }\n                }\n            } else if (Constants.LOCAL_VARIABLE_TYPE_TABLE.equals(attributeName)) {\n                localVariableTypeTableOffset = currentOffset;\n                // Here we do not extract the labels corresponding to the attribute content. We assume they\n                // are the same or a subset of those of the LocalVariableTable attribute.\n            } else if (Constants.LINE_NUMBER_TABLE.equals(attributeName)) {\n                if ((context.parsingOptions & SKIP_DEBUG) == 0) {\n                    // Parse the attribute to find the corresponding (debug only) labels.\n                    int currentLineNumberTableOffset = currentOffset;\n                    int lineNumberTableLength = readUnsignedShort(currentLineNumberTableOffset);\n                    currentLineNumberTableOffset += 2;\n                    while (lineNumberTableLength-- > 0) {\n                        int startPc = readUnsignedShort(currentLineNumberTableOffset);\n                        int lineNumber = readUnsignedShort(currentLineNumberTableOffset + 2);\n                        currentLineNumberTableOffset += 4;\n                        createDebugLabel(startPc, labels);\n                        labels[startPc].addLineNumber(lineNumber);\n                    }\n                }\n            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                visibleTypeAnnotationOffsets = readTypeAnnotations(methodVisitor, context, currentOffset, /* visible = */ true);\n                // Here we do not extract the labels corresponding to the attribute content. This would\n                // require a full parsing of the attribute, which would need to be repeated when parsing\n                // the bytecode instructions (see below). Instead, the content of the attribute is read one\n                // type annotation at a time (i.e. after a type annotation has been visited, the next type\n                // annotation is read), and the labels it contains are also extracted one annotation at a\n                // time. This assumes that type annotations are ordered by increasing bytecode offset.\n            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n                invisibleTypeAnnotationOffsets = readTypeAnnotations(methodVisitor, context, currentOffset, /* visible = */ false);\n                // Same comment as above for the RuntimeVisibleTypeAnnotations attribute.\n            } else if (Constants.STACK_MAP_TABLE.equals(attributeName)) {\n                if ((context.parsingOptions & SKIP_FRAMES) == 0) {\n                    stackMapFrameOffset = currentOffset + 2;\n                    stackMapTableEndOffset = currentOffset + attributeLength;\n                }\n                // Here we do not extract the labels corresponding to the attribute content. This would\n                // require a full parsing of the attribute, which would need to be repeated when parsing\n                // the bytecode instructions (see below). Instead, the content of the attribute is read one\n                // frame at a time (i.e. after a frame has been visited, the next frame is read), and the\n                // labels it contains are also extracted one frame at a time. Thanks to the ordering of\n                // frames, having only a \"one frame lookahead\" is not a problem, i.e. it is not possible to\n                // see an offset smaller than the offset of the current instruction and for which no Label\n                // exist. Except for UNINITIALIZED type offsets. We solve this by parsing the stack map\n                // table without a full decoding (see below).\n            } else if (\"StackMap\".equals(attributeName)) {\n                if ((context.parsingOptions & SKIP_FRAMES) == 0) {\n                    stackMapFrameOffset = currentOffset + 2;\n                    stackMapTableEndOffset = currentOffset + attributeLength;\n                    compressedFrames = false;\n                }\n                // IMPORTANT! Here we assume that the frames are ordered, as in the StackMapTable attribute,\n                // although this is not guaranteed by the attribute format. This allows an incremental\n                // extraction of the labels corresponding to this attribute (see the comment above for the\n                // StackMapTable attribute).\n            } else {\n                Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, codeOffset, labels);\n                attribute.nextAttribute = attributes;\n                attributes = attribute;\n            }\n            currentOffset += attributeLength;\n        }\n        // Initialize the context fields related to stack map frames, and generate the first\n        // (implicit) stack map frame, if needed.\n        final boolean expandFrames = (context.parsingOptions & EXPAND_FRAMES) != 0;\n        if (stackMapFrameOffset != 0) {\n            // The bytecode offset of the first explicit frame is not offset_delta + 1 but only\n            // offset_delta. Setting the implicit frame offset to -1 allows us to use of the\n            // \"offset_delta + 1\" rule in all cases.\n            context.currentFrameOffset = -1;\n            context.currentFrameType = 0;\n            context.currentFrameLocalCount = 0;\n            context.currentFrameLocalCountDelta = 0;\n            context.currentFrameLocalTypes = new Object[maxLocals];\n            context.currentFrameStackCount = 0;\n            context.currentFrameStackTypes = new Object[maxStack];\n            if (expandFrames) {\n                computeImplicitFrame(context);\n            }\n            // Find the labels for UNINITIALIZED frame types. Instead of decoding each element of the\n            // stack map table, we look for 3 consecutive bytes that \"look like\" an UNINITIALIZED type\n            // (tag ITEM_Uninitialized, offset within bytecode bounds, NEW instruction at this offset).\n            // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,\n            // and the only consequence will be the creation of an unneeded label. This is better than\n            // creating a label for each NEW instruction, and faster than fully decoding the whole stack\n            // map table.\n            for (int offset = stackMapFrameOffset; offset < stackMapTableEndOffset - 2; ++offset) {\n                if (classBuffer[offset] == Frame.ITEM_UNINITIALIZED) {\n                    int potentialBytecodeOffset = readUnsignedShort(offset + 1);\n                    if (potentialBytecodeOffset >= 0 && potentialBytecodeOffset < codeLength && (classBuffer[bytecodeStartOffset + potentialBytecodeOffset] & 0xFF) == Opcodes.NEW) {\n                        createLabel(potentialBytecodeOffset, labels);\n                    }\n                }\n            }\n        }\n        if (expandFrames && (context.parsingOptions & EXPAND_ASM_INSNS) != 0) {\n            // Expanding the ASM specific instructions can introduce F_INSERT frames, even if the method\n            // does not currently have any frame. These inserted frames must be computed by simulating the\n            // effect of the bytecode instructions, one by one, starting from the implicit first frame.\n            // For this, MethodWriter needs to know maxLocals before the first instruction is visited. To\n            // ensure this, we visit the implicit first frame here (passing only maxLocals - the rest is\n            // computed in MethodWriter).\n            methodVisitor.visitFrame(Opcodes.F_NEW, maxLocals, null, 0, null);\n        }\n        // Visit the bytecode instructions. First, introduce state variables for the incremental parsing\n        // of the type annotations.\n        // Index of the next runtime visible type annotation to read (in the\n        // visibleTypeAnnotationOffsets array).\n        int currentVisibleTypeAnnotationIndex = 0;\n        // The bytecode offset of the next runtime visible type annotation to read, or -1.\n        int currentVisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, 0);\n        // Index of the next runtime invisible type annotation to read (in the\n        // invisibleTypeAnnotationOffsets array).\n        int currentInvisibleTypeAnnotationIndex = 0;\n        // The bytecode offset of the next runtime invisible type annotation to read, or -1.\n        int currentInvisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, 0);\n        // Whether a F_INSERT stack map frame must be inserted before the current instruction.\n        boolean insertFrame = false;\n        // The delta to subtract from a goto_w or jsr_w opcode to get the corresponding goto or jsr\n        // opcode, or 0 if goto_w and jsr_w must be left unchanged (i.e. when expanding ASM specific\n        // instructions).\n        final int wideJumpOpcodeDelta = (context.parsingOptions & EXPAND_ASM_INSNS) == 0 ? Constants.WIDE_JUMP_OPCODE_DELTA : 0;\n        currentOffset = bytecodeStartOffset;\n        while (currentOffset < bytecodeEndOffset) {\n            final int currentBytecodeOffset = currentOffset - bytecodeStartOffset;\n            // Visit the label and the line number(s) for this bytecode offset, if any.\n            Label currentLabel = labels[currentBytecodeOffset];\n            if (currentLabel != null) {\n                currentLabel.accept(methodVisitor, (context.parsingOptions & SKIP_DEBUG) == 0);\n            }\n            // Visit the stack map frame for this bytecode offset, if any.\n            while (stackMapFrameOffset != 0 && (context.currentFrameOffset == currentBytecodeOffset || context.currentFrameOffset == -1)) {\n                // If there is a stack map frame for this offset, make methodVisitor visit it, and read the\n                // next stack map frame if there is one.\n                if (context.currentFrameOffset != -1) {\n                    if (!compressedFrames || expandFrames) {\n                        methodVisitor.visitFrame(Opcodes.F_NEW, context.currentFrameLocalCount, context.currentFrameLocalTypes, context.currentFrameStackCount, context.currentFrameStackTypes);\n                    } else {\n                        methodVisitor.visitFrame(context.currentFrameType, context.currentFrameLocalCountDelta, context.currentFrameLocalTypes, context.currentFrameStackCount, context.currentFrameStackTypes);\n                    }\n                    // Since there is already a stack map frame for this bytecode offset, there is no need to\n                    // insert a new one.\n                    insertFrame = false;\n                }\n                if (stackMapFrameOffset < stackMapTableEndOffset) {\n                    stackMapFrameOffset = readStackMapFrame(stackMapFrameOffset, compressedFrames, expandFrames, context);\n                } else {\n                    stackMapFrameOffset = 0;\n                }\n            }\n            // Insert a stack map frame for this bytecode offset, if requested by setting insertFrame to\n            // true during the previous iteration. The actual frame content is computed in MethodWriter.\n            if (insertFrame) {\n                if ((context.parsingOptions & EXPAND_FRAMES) != 0) {\n                    methodVisitor.visitFrame(Constants.F_INSERT, 0, null, 0, null);\n                }\n                insertFrame = false;\n            }\n            // Visit the instruction at this bytecode offset.\n            int opcode = classBuffer[currentOffset] & 0xFF;\n            switch (opcode) {\n            case Constants.NOP:\n            case Constants.ACONST_NULL:\n            case Constants.ICONST_M1:\n            case Constants.ICONST_0:\n            case Constants.ICONST_1:\n            case Constants.ICONST_2:\n            case Constants.ICONST_3:\n            case Constants.ICONST_4:\n            case Constants.ICONST_5:\n            case Constants.LCONST_0:\n            case Constants.LCONST_1:\n            case Constants.FCONST_0:\n            case Constants.FCONST_1:\n            case Constants.FCONST_2:\n            case Constants.DCONST_0:\n            case Constants.DCONST_1:\n            case Constants.IALOAD:\n            case Constants.LALOAD:\n            case Constants.FALOAD:\n            case Constants.DALOAD:\n            case Constants.AALOAD:\n            case Constants.BALOAD:\n            case Constants.CALOAD:\n            case Constants.SALOAD:\n            case Constants.IASTORE:\n            case Constants.LASTORE:\n            case Constants.FASTORE:\n            case Constants.DASTORE:\n            case Constants.AASTORE:\n            case Constants.BASTORE:\n            case Constants.CASTORE:\n            case Constants.SASTORE:\n            case Constants.POP:\n            case Constants.POP2:\n            case Constants.DUP:\n            case Constants.DUP_X1:\n            case Constants.DUP_X2:\n            case Constants.DUP2:\n            case Constants.DUP2_X1:\n            case Constants.DUP2_X2:\n            case Constants.SWAP:\n            case Constants.IADD:\n            case Constants.LADD:\n            case Constants.FADD:\n            case Constants.DADD:\n            case Constants.ISUB:\n            case Constants.LSUB:\n            case Constants.FSUB:\n            case Constants.DSUB:\n            case Constants.IMUL:\n            case Constants.LMUL:\n            case Constants.FMUL:\n            case Constants.DMUL:\n            case Constants.IDIV:\n            case Constants.LDIV:\n            case Constants.FDIV:\n            case Constants.DDIV:\n            case Constants.IREM:\n            case Constants.LREM:\n            case Constants.FREM:\n            case Constants.DREM:\n            case Constants.INEG:\n            case Constants.LNEG:\n            case Constants.FNEG:\n            case Constants.DNEG:\n            case Constants.ISHL:\n            case Constants.LSHL:\n            case Constants.ISHR:\n            case Constants.LSHR:\n            case Constants.IUSHR:\n            case Constants.LUSHR:\n            case Constants.IAND:\n            case Constants.LAND:\n            case Constants.IOR:\n            case Constants.LOR:\n            case Constants.IXOR:\n            case Constants.LXOR:\n            case Constants.I2L:\n            case Constants.I2F:\n            case Constants.I2D:\n            case Constants.L2I:\n            case Constants.L2F:\n            case Constants.L2D:\n            case Constants.F2I:\n            case Constants.F2L:\n            case Constants.F2D:\n            case Constants.D2I:\n            case Constants.D2L:\n            case Constants.D2F:\n            case Constants.I2B:\n            case Constants.I2C:\n            case Constants.I2S:\n            case Constants.LCMP:\n            case Constants.FCMPL:\n            case Constants.FCMPG:\n            case Constants.DCMPL:\n            case Constants.DCMPG:\n            case Constants.IRETURN:\n            case Constants.LRETURN:\n            case Constants.FRETURN:\n            case Constants.DRETURN:\n            case Constants.ARETURN:\n            case Constants.RETURN:\n            case Constants.ARRAYLENGTH:\n            case Constants.ATHROW:\n            case Constants.MONITORENTER:\n            case Constants.MONITOREXIT:\n                methodVisitor.visitInsn(opcode);\n                currentOffset += 1;\n                break;\n            case Constants.ILOAD_0:\n            case Constants.ILOAD_1:\n            case Constants.ILOAD_2:\n            case Constants.ILOAD_3:\n            case Constants.LLOAD_0:\n            case Constants.LLOAD_1:\n            case Constants.LLOAD_2:\n            case Constants.LLOAD_3:\n            case Constants.FLOAD_0:\n            case Constants.FLOAD_1:\n            case Constants.FLOAD_2:\n            case Constants.FLOAD_3:\n            case Constants.DLOAD_0:\n            case Constants.DLOAD_1:\n            case Constants.DLOAD_2:\n            case Constants.DLOAD_3:\n            case Constants.ALOAD_0:\n            case Constants.ALOAD_1:\n            case Constants.ALOAD_2:\n            case Constants.ALOAD_3:\n                opcode -= Constants.ILOAD_0;\n                methodVisitor.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\n                currentOffset += 1;\n                break;\n            case Constants.ISTORE_0:\n            case Constants.ISTORE_1:\n            case Constants.ISTORE_2:\n            case Constants.ISTORE_3:\n            case Constants.LSTORE_0:\n            case Constants.LSTORE_1:\n            case Constants.LSTORE_2:\n            case Constants.LSTORE_3:\n            case Constants.FSTORE_0:\n            case Constants.FSTORE_1:\n            case Constants.FSTORE_2:\n            case Constants.FSTORE_3:\n            case Constants.DSTORE_0:\n            case Constants.DSTORE_1:\n            case Constants.DSTORE_2:\n            case Constants.DSTORE_3:\n            case Constants.ASTORE_0:\n            case Constants.ASTORE_1:\n            case Constants.ASTORE_2:\n            case Constants.ASTORE_3:\n                opcode -= Constants.ISTORE_0;\n                methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);\n                currentOffset += 1;\n                break;\n            case Constants.IFEQ:\n            case Constants.IFNE:\n            case Constants.IFLT:\n            case Constants.IFGE:\n            case Constants.IFGT:\n            case Constants.IFLE:\n            case Constants.IF_ICMPEQ:\n            case Constants.IF_ICMPNE:\n            case Constants.IF_ICMPLT:\n            case Constants.IF_ICMPGE:\n            case Constants.IF_ICMPGT:\n            case Constants.IF_ICMPLE:\n            case Constants.IF_ACMPEQ:\n            case Constants.IF_ACMPNE:\n            case Constants.GOTO:\n            case Constants.JSR:\n            case Constants.IFNULL:\n            case Constants.IFNONNULL:\n                methodVisitor.visitJumpInsn(opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);\n                currentOffset += 3;\n                break;\n            case Constants.GOTO_W:\n            case Constants.JSR_W:\n                methodVisitor.visitJumpInsn(opcode - wideJumpOpcodeDelta, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);\n                currentOffset += 5;\n                break;\n            case Constants.ASM_IFEQ:\n            case Constants.ASM_IFNE:\n            case Constants.ASM_IFLT:\n            case Constants.ASM_IFGE:\n            case Constants.ASM_IFGT:\n            case Constants.ASM_IFLE:\n            case Constants.ASM_IF_ICMPEQ:\n            case Constants.ASM_IF_ICMPNE:\n            case Constants.ASM_IF_ICMPLT:\n            case Constants.ASM_IF_ICMPGE:\n            case Constants.ASM_IF_ICMPGT:\n            case Constants.ASM_IF_ICMPLE:\n            case Constants.ASM_IF_ACMPEQ:\n            case Constants.ASM_IF_ACMPNE:\n            case Constants.ASM_GOTO:\n            case Constants.ASM_JSR:\n            case Constants.ASM_IFNULL:\n            case Constants.ASM_IFNONNULL: {\n                // A forward jump with an offset > 32767. In this case we automatically replace ASM_GOTO\n                // with GOTO_W, ASM_JSR with JSR_W and ASM_IFxxx <l> with IFNOTxxx <L> GOTO_W <l> L:...,\n                // where IFNOTxxx is the \"opposite\" opcode of ASMS_IFxxx (e.g. IFNE for ASM_IFEQ) and\n                // where <L> designates the instruction just after the GOTO_W.\n                // First, change the ASM specific opcodes ASM_IFEQ ... ASM_JSR, ASM_IFNULL and\n                // ASM_IFNONNULL to IFEQ ... JSR, IFNULL and IFNONNULL.\n                opcode = opcode < Constants.ASM_IFNULL ? opcode - Constants.ASM_OPCODE_DELTA : opcode - Constants.ASM_IFNULL_OPCODE_DELTA;\n                Label target = labels[currentBytecodeOffset + readUnsignedShort(currentOffset + 1)];\n                if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {\n                    // Replace GOTO with GOTO_W and JSR with JSR_W.\n                    methodVisitor.visitJumpInsn(opcode + Constants.WIDE_JUMP_OPCODE_DELTA, target);\n                } else {\n                    // Compute the \"opposite\" of opcode. This can be done by flipping the least\n                    // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ\n                    // (with a pre and post offset by 1).\n                    opcode = opcode < Opcodes.GOTO ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1;\n                    Label endif = createLabel(currentBytecodeOffset + 3, labels);\n                    methodVisitor.visitJumpInsn(opcode, endif);\n                    methodVisitor.visitJumpInsn(Constants.GOTO_W, target);\n                    // endif designates the instruction just after GOTO_W, and is visited as part of the\n                    // next instruction. Since it is a jump target, we need to insert a frame here.\n                    insertFrame = true;\n                }\n                currentOffset += 3;\n                break;\n            }\n            case Constants.ASM_GOTO_W:\n                // Replace ASM_GOTO_W with GOTO_W.\n                methodVisitor.visitJumpInsn(Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);\n                // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns\n                // IFNOTxxx <L> ASM_GOTO_W <l> L:..., see MethodWriter), so we need to insert a frame\n                // here.\n                insertFrame = true;\n                currentOffset += 5;\n                break;\n            case Constants.WIDE:\n                opcode = classBuffer[currentOffset + 1] & 0xFF;\n                if (opcode == Opcodes.IINC) {\n                    methodVisitor.visitIincInsn(readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));\n                    currentOffset += 6;\n                } else {\n                    methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));\n                    currentOffset += 4;\n                }\n                break;\n            case Constants.TABLESWITCH: {\n                // Skip 0 to 3 padding bytes.\n                currentOffset += 4 - (currentBytecodeOffset & 3);\n                // Read the instruction.\n                Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];\n                int low = readInt(currentOffset + 4);\n                int high = readInt(currentOffset + 8);\n                currentOffset += 12;\n                Label[] table = new Label[high - low + 1];\n                for (int i = 0; i < table.length; ++i) {\n                    table[i] = labels[currentBytecodeOffset + readInt(currentOffset)];\n                    currentOffset += 4;\n                }\n                methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);\n                break;\n            }\n            case Constants.LOOKUPSWITCH: {\n                // Skip 0 to 3 padding bytes.\n                currentOffset += 4 - (currentBytecodeOffset & 3);\n                // Read the instruction.\n                Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];\n                int numPairs = readInt(currentOffset + 4);\n                currentOffset += 8;\n                int[] keys = new int[numPairs];\n                Label[] values = new Label[numPairs];\n                for (int i = 0; i < numPairs; ++i) {\n                    keys[i] = readInt(currentOffset);\n                    values[i] = labels[currentBytecodeOffset + readInt(currentOffset + 4)];\n                    currentOffset += 8;\n                }\n                methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);\n                break;\n            }\n            case Constants.ILOAD:\n            case Constants.LLOAD:\n            case Constants.FLOAD:\n            case Constants.DLOAD:\n            case Constants.ALOAD:\n            case Constants.ISTORE:\n            case Constants.LSTORE:\n            case Constants.FSTORE:\n            case Constants.DSTORE:\n            case Constants.ASTORE:\n            case Constants.RET:\n                methodVisitor.visitVarInsn(opcode, classBuffer[currentOffset + 1] & 0xFF);\n                currentOffset += 2;\n                break;\n            case Constants.BIPUSH:\n            case Constants.NEWARRAY:\n                methodVisitor.visitIntInsn(opcode, classBuffer[currentOffset + 1]);\n                currentOffset += 2;\n                break;\n            case Constants.SIPUSH:\n                methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));\n                currentOffset += 3;\n                break;\n            case Constants.LDC:\n                methodVisitor.visitLdcInsn(readConst(classBuffer[currentOffset + 1] & 0xFF, charBuffer));\n                currentOffset += 2;\n                break;\n            case Constants.LDC_W:\n            case Constants.LDC2_W:\n                methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));\n                currentOffset += 3;\n                break;\n            case Constants.GETSTATIC:\n            case Constants.PUTSTATIC:\n            case Constants.GETFIELD:\n            case Constants.PUTFIELD:\n            case Constants.INVOKEVIRTUAL:\n            case Constants.INVOKESPECIAL:\n            case Constants.INVOKESTATIC:\n            case Constants.INVOKEINTERFACE: {\n                int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];\n                int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\n                String owner = readClass(cpInfoOffset, charBuffer);\n                String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\n                String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\n                if (opcode < Opcodes.INVOKEVIRTUAL) {\n                    methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);\n                } else {\n                    boolean isInterface = classBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;\n                    methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n                }\n                if (opcode == Opcodes.INVOKEINTERFACE) {\n                    currentOffset += 5;\n                } else {\n                    currentOffset += 3;\n                }\n                break;\n            }\n            case Constants.INVOKEDYNAMIC: {\n                int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];\n                int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\n                String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\n                String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\n                int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];\n                Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\n                Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];\n                bootstrapMethodOffset += 4;\n                for (int i = 0; i < bootstrapMethodArguments.length; i++) {\n                    bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\n                    bootstrapMethodOffset += 2;\n                }\n                methodVisitor.visitInvokeDynamicInsn(name, descriptor, handle, bootstrapMethodArguments);\n                currentOffset += 5;\n                break;\n            }\n            case Constants.NEW:\n            case Constants.ANEWARRAY:\n            case Constants.CHECKCAST:\n            case Constants.INSTANCEOF:\n                methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));\n                currentOffset += 3;\n                break;\n            case Constants.IINC:\n                methodVisitor.visitIincInsn(classBuffer[currentOffset + 1] & 0xFF, classBuffer[currentOffset + 2]);\n                currentOffset += 3;\n                break;\n            case Constants.MULTIANEWARRAY:\n                methodVisitor.visitMultiANewArrayInsn(readClass(currentOffset + 1, charBuffer), classBuffer[currentOffset + 3] & 0xFF);\n                currentOffset += 4;\n                break;\n            default:\n                throw new AssertionError();\n            }\n            // Visit the runtime visible instruction annotations, if any.\n            while (visibleTypeAnnotationOffsets != null && currentVisibleTypeAnnotationIndex < visibleTypeAnnotationOffsets.length && currentVisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {\n                if (currentVisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {\n                    // Parse the target_type, target_info and target_path fields.\n                    int currentAnnotationOffset = readTypeAnnotationTarget(context, visibleTypeAnnotationOffsets[currentVisibleTypeAnnotationIndex]);\n                    // Parse the type_index field.\n                    String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                    currentAnnotationOffset += 2;\n                    // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                    readElementValues(methodVisitor.visitInsnAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                            /* visible = */ true), currentAnnotationOffset,\n                            /* named = */ true, charBuffer);\n                }\n                currentVisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, ++currentVisibleTypeAnnotationIndex);\n            }\n            // Visit the runtime invisible instruction annotations, if any.\n            while (invisibleTypeAnnotationOffsets != null && currentInvisibleTypeAnnotationIndex < invisibleTypeAnnotationOffsets.length && currentInvisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {\n                if (currentInvisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {\n                    // Parse the target_type, target_info and target_path fields.\n                    int currentAnnotationOffset = readTypeAnnotationTarget(context, invisibleTypeAnnotationOffsets[currentInvisibleTypeAnnotationIndex]);\n                    // Parse the type_index field.\n                    String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n                    currentAnnotationOffset += 2;\n                    // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                    readElementValues(methodVisitor.visitInsnAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor,\n                            /* visible = */ false), currentAnnotationOffset,\n                            /* named = */ true, charBuffer);\n                }\n                currentInvisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, ++currentInvisibleTypeAnnotationIndex);\n            }\n        }\n        if (labels[codeLength] != null) {\n            methodVisitor.visitLabel(labels[codeLength]);\n        }\n        // Visit LocalVariableTable and LocalVariableTypeTable attributes.\n        if (localVariableTableOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {\n            // The (start_pc, index, signature_index) fields of each entry of the LocalVariableTypeTable.\n            int[] typeTable = null;\n            if (localVariableTypeTableOffset != 0) {\n                typeTable = new int[readUnsignedShort(localVariableTypeTableOffset) * 3];\n                currentOffset = localVariableTypeTableOffset + 2;\n                int typeTableIndex = typeTable.length;\n                while (typeTableIndex > 0) {\n                    // Store the offset of 'signature_index', and the value of 'index' and 'start_pc'.\n                    typeTable[--typeTableIndex] = currentOffset + 6;\n                    typeTable[--typeTableIndex] = readUnsignedShort(currentOffset + 8);\n                    typeTable[--typeTableIndex] = readUnsignedShort(currentOffset);\n                    currentOffset += 10;\n                }\n            }\n            int localVariableTableLength = readUnsignedShort(localVariableTableOffset);\n            currentOffset = localVariableTableOffset + 2;\n            while (localVariableTableLength-- > 0) {\n                int startPc = readUnsignedShort(currentOffset);\n                int length = readUnsignedShort(currentOffset + 2);\n                String name = readUTF8(currentOffset + 4, charBuffer);\n                String descriptor = readUTF8(currentOffset + 6, charBuffer);\n                int index = readUnsignedShort(currentOffset + 8);\n                currentOffset += 10;\n                String signature = null;\n                if (typeTable != null) {\n                    for (int i = 0; i < typeTable.length; i += 3) {\n                        if (typeTable[i] == startPc && typeTable[i + 1] == index) {\n                            signature = readUTF8(typeTable[i + 2], charBuffer);\n                            break;\n                        }\n                    }\n                }\n                methodVisitor.visitLocalVariable(name, descriptor, signature, labels[startPc], labels[startPc + length], index);\n            }\n        }\n        // Visit the local variable type annotations of the RuntimeVisibleTypeAnnotations attribute.\n        if (visibleTypeAnnotationOffsets != null) {\n            for (int typeAnnotationOffset : visibleTypeAnnotationOffsets) {\n                int targetType = readByte(typeAnnotationOffset);\n                if (targetType == TypeReference.LOCAL_VARIABLE || targetType == TypeReference.RESOURCE_VARIABLE) {\n                    // Parse the target_type, target_info and target_path fields.\n                    currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);\n                    // Parse the type_index field.\n                    String annotationDescriptor = readUTF8(currentOffset, charBuffer);\n                    currentOffset += 2;\n                    // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                    readElementValues(methodVisitor.visitLocalVariableAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, context.currentLocalVariableAnnotationRangeStarts, context.currentLocalVariableAnnotationRangeEnds, context.currentLocalVariableAnnotationRangeIndices, annotationDescriptor,\n                            /* visible = */ true), currentOffset,\n                            /* named = */ true, charBuffer);\n                }\n            }\n        }\n        // Visit the local variable type annotations of the RuntimeInvisibleTypeAnnotations attribute.\n        if (invisibleTypeAnnotationOffsets != null) {\n            for (int typeAnnotationOffset : invisibleTypeAnnotationOffsets) {\n                int targetType = readByte(typeAnnotationOffset);\n                if (targetType == TypeReference.LOCAL_VARIABLE || targetType == TypeReference.RESOURCE_VARIABLE) {\n                    // Parse the target_type, target_info and target_path fields.\n                    currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);\n                    // Parse the type_index field.\n                    String annotationDescriptor = readUTF8(currentOffset, charBuffer);\n                    currentOffset += 2;\n                    // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                    readElementValues(methodVisitor.visitLocalVariableAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, context.currentLocalVariableAnnotationRangeStarts, context.currentLocalVariableAnnotationRangeEnds, context.currentLocalVariableAnnotationRangeIndices, annotationDescriptor,\n                            /* visible = */ false), currentOffset,\n                            /* named = */ true, charBuffer);\n                }\n            }\n        }\n        // Visit the non standard attributes.\n        while (attributes != null) {\n            // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.\n            Attribute nextAttribute = attributes.nextAttribute;\n            attributes.nextAttribute = null;\n            methodVisitor.visitAttribute(attributes);\n            attributes = nextAttribute;\n        }\n        // Visit the max stack and max locals values.\n        methodVisitor.visitMaxs(maxStack, maxLocals);\n    }\n\n    /**\n     * Returns the label corresponding to the given bytecode offset. The default implementation of\n     * this method creates a label for the given offset if it has not been already created.\n     *\n     * @param bytecodeOffset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset. If a label already exists\n     *     for bytecodeOffset this method must not create a new one. Otherwise it must store the new\n     *     label in this array.\n     * @return a non null Label, which must be equal to labels[bytecodeOffset].\n     */\n    protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n        if (labels[bytecodeOffset] == null) {\n            labels[bytecodeOffset] = new Label();\n        }\n        return labels[bytecodeOffset];\n    }\n\n    /**\n     * Creates a label without the {@link Label#FLAG_DEBUG_ONLY} flag set, for the given bytecode\n     * offset. The label is created with a call to {@link #readLabel} and its {@link\n     * Label#FLAG_DEBUG_ONLY} flag is cleared.\n     *\n     * @param bytecodeOffset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset.\n     * @return a Label without the {@link Label#FLAG_DEBUG_ONLY} flag set.\n     */\n    private Label createLabel(final int bytecodeOffset, final Label[] labels) {\n        Label label = readLabel(bytecodeOffset, labels);\n        label.flags &= ~Label.FLAG_DEBUG_ONLY;\n        return label;\n    }\n\n    /**\n     * Creates a label with the {@link Label#FLAG_DEBUG_ONLY} flag set, if there is no already\n     * existing label for the given bytecode offset (otherwise does nothing). The label is created\n     * with a call to {@link #readLabel}.\n     *\n     * @param bytecodeOffset a bytecode offset in a method.\n     * @param labels the already created labels, indexed by their offset.\n     */\n    private void createDebugLabel(final int bytecodeOffset, final Label[] labels) {\n        if (labels[bytecodeOffset] == null) {\n            readLabel(bytecodeOffset, labels).flags |= Label.FLAG_DEBUG_ONLY;\n        }\n    }\n    // ----------------------------------------------------------------------------------------------\n    // Methods to parse annotations, type annotations and parameter annotations\n    // ----------------------------------------------------------------------------------------------\n\n    /**\n     * Parses a Runtime[In]VisibleTypeAnnotations attribute to find the offset of each type_annotation\n     * entry it contains, to find the corresponding labels, and to visit the try catch block\n     * annotations.\n     *\n     * @param methodVisitor the method visitor to be used to visit the try catch block annotations.\n     * @param context information about the class being parsed.\n     * @param runtimeTypeAnnotationsOffset the start offset of a Runtime[In]VisibleTypeAnnotations\n     *     attribute, excluding the attribute_info's attribute_name_index and attribute_length fields.\n     * @param visible true if the attribute to parse is a RuntimeVisibleTypeAnnotations attribute,\n     *     false it is a RuntimeInvisibleTypeAnnotations attribute.\n     * @return the start offset of each entry of the Runtime[In]VisibleTypeAnnotations_attribute's\n     *     'annotations' array field.\n     */\n    private int[] readTypeAnnotations(final MethodVisitor methodVisitor, final Context context, final int runtimeTypeAnnotationsOffset, final boolean visible) {\n        char[] charBuffer = context.charBuffer;\n        int currentOffset = runtimeTypeAnnotationsOffset;\n        // Read the num_annotations field and create an array to store the type_annotation offsets.\n        int[] typeAnnotationsOffsets = new int[readUnsignedShort(currentOffset)];\n        currentOffset += 2;\n        // Parse the 'annotations' array field.\n        for (int i = 0; i < typeAnnotationsOffsets.length; ++i) {\n            typeAnnotationsOffsets[i] = currentOffset;\n            // Parse the type_annotation's target_type and the target_info fields. The size of the\n            // target_info field depends on the value of target_type.\n            int targetType = readInt(currentOffset);\n            switch (targetType >>> 24) {\n            case TypeReference.LOCAL_VARIABLE:\n            case TypeReference.RESOURCE_VARIABLE:\n                // A localvar_target has a variable size, which depends on the value of their table_length\n                // field. It also references bytecode offsets, for which we need labels.\n                int tableLength = readUnsignedShort(currentOffset + 1);\n                currentOffset += 3;\n                while (tableLength-- > 0) {\n                    int startPc = readUnsignedShort(currentOffset);\n                    int length = readUnsignedShort(currentOffset + 2);\n                    // Skip the index field (2 bytes).\n                    currentOffset += 6;\n                    createLabel(startPc, context.currentMethodLabels);\n                    createLabel(startPc + length, context.currentMethodLabels);\n                }\n                break;\n            case TypeReference.CAST:\n            case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\n            case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:\n            case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\n            case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:\n                currentOffset += 4;\n                break;\n            case TypeReference.CLASS_EXTENDS:\n            case TypeReference.CLASS_TYPE_PARAMETER_BOUND:\n            case TypeReference.METHOD_TYPE_PARAMETER_BOUND:\n            case TypeReference.THROWS:\n            case TypeReference.EXCEPTION_PARAMETER:\n            case TypeReference.INSTANCEOF:\n            case TypeReference.NEW:\n            case TypeReference.CONSTRUCTOR_REFERENCE:\n            case TypeReference.METHOD_REFERENCE:\n                currentOffset += 3;\n                break;\n            case TypeReference.CLASS_TYPE_PARAMETER:\n            case TypeReference.METHOD_TYPE_PARAMETER:\n            case TypeReference.METHOD_FORMAL_PARAMETER:\n            case TypeReference.FIELD:\n            case TypeReference.METHOD_RETURN:\n            case TypeReference.METHOD_RECEIVER:\n            default:\n                // TypeReference type which can't be used in Code attribute, or which is unknown.\n                throw new IllegalArgumentException();\n            }\n            // Parse the rest of the type_annotation structure, starting with the target_path structure\n            // (whose size depends on its path_length field).\n            int pathLength = readByte(currentOffset);\n            if ((targetType >>> 24) == TypeReference.EXCEPTION_PARAMETER) {\n                // Parse the target_path structure and create a corresponding TypePath.\n                TypePath path = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);\n                currentOffset += 1 + 2 * pathLength;\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentOffset, charBuffer);\n                currentOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentOffset = readElementValues(methodVisitor.visitTryCatchAnnotation(targetType & 0xFFFFFF00, path, annotationDescriptor, visible), currentOffset,\n                        /* named = */ true, charBuffer);\n            } else {\n                // We don't want to visit the other target_type annotations, so we just skip them (which\n                // requires some parsing because the element_value_pairs array has a variable size). First,\n                // skip the target_path structure:\n                currentOffset += 3 + 2 * pathLength;\n                // Then skip the num_element_value_pairs and element_value_pairs fields (by reading them\n                // with a null AnnotationVisitor).\n                currentOffset = readElementValues(\n                        /* annotationVisitor = */ null, currentOffset, /* named = */ true, charBuffer);\n            }\n        }\n        return typeAnnotationsOffsets;\n    }\n\n    /**\n     * Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or\n     * -1 if there is no such type_annotation of if it does not have a bytecode offset.\n     *\n     * @param typeAnnotationOffsets the offset of each 'type_annotation' entry in a\n     *     Runtime[In]VisibleTypeAnnotations attribute, or {@literal null}.\n     * @param typeAnnotationIndex the index a 'type_annotation' entry in typeAnnotationOffsets.\n     * @return bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or -1\n     *     if there is no such type_annotation of if it does not have a bytecode offset.\n     */\n    private int getTypeAnnotationBytecodeOffset(final int[] typeAnnotationOffsets, final int typeAnnotationIndex) {\n        if (typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets.length || readByte(typeAnnotationOffsets[typeAnnotationIndex]) < TypeReference.INSTANCEOF) {\n            return -1;\n        }\n        return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1);\n    }\n\n    /**\n     * Parses the header of a JVMS type_annotation structure to extract its target_type, target_info\n     * and target_path (the result is stored in the given context), and returns the start offset of\n     * the rest of the type_annotation structure.\n     *\n     * @param context information about the class being parsed. This is where the extracted\n     *     target_type and target_path must be stored.\n     * @param typeAnnotationOffset the start offset of a type_annotation structure.\n     * @return the start offset of the rest of the type_annotation structure.\n     */\n    private int readTypeAnnotationTarget(final Context context, final int typeAnnotationOffset) {\n        int currentOffset = typeAnnotationOffset;\n        // Parse and store the target_type structure.\n        int targetType = readInt(typeAnnotationOffset);\n        switch (targetType >>> 24) {\n        case TypeReference.CLASS_TYPE_PARAMETER:\n        case TypeReference.METHOD_TYPE_PARAMETER:\n        case TypeReference.METHOD_FORMAL_PARAMETER:\n            targetType &= 0xFFFF0000;\n            currentOffset += 2;\n            break;\n        case TypeReference.FIELD:\n        case TypeReference.METHOD_RETURN:\n        case TypeReference.METHOD_RECEIVER:\n            targetType &= 0xFF000000;\n            currentOffset += 1;\n            break;\n        case TypeReference.LOCAL_VARIABLE:\n        case TypeReference.RESOURCE_VARIABLE:\n            targetType &= 0xFF000000;\n            int tableLength = readUnsignedShort(currentOffset + 1);\n            currentOffset += 3;\n            context.currentLocalVariableAnnotationRangeStarts = new Label[tableLength];\n            context.currentLocalVariableAnnotationRangeEnds = new Label[tableLength];\n            context.currentLocalVariableAnnotationRangeIndices = new int[tableLength];\n            for (int i = 0; i < tableLength; ++i) {\n                int startPc = readUnsignedShort(currentOffset);\n                int length = readUnsignedShort(currentOffset + 2);\n                int index = readUnsignedShort(currentOffset + 4);\n                currentOffset += 6;\n                context.currentLocalVariableAnnotationRangeStarts[i] = createLabel(startPc, context.currentMethodLabels);\n                context.currentLocalVariableAnnotationRangeEnds[i] = createLabel(startPc + length, context.currentMethodLabels);\n                context.currentLocalVariableAnnotationRangeIndices[i] = index;\n            }\n            break;\n        case TypeReference.CAST:\n        case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\n        case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:\n        case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\n        case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:\n            targetType &= 0xFF0000FF;\n            currentOffset += 4;\n            break;\n        case TypeReference.CLASS_EXTENDS:\n        case TypeReference.CLASS_TYPE_PARAMETER_BOUND:\n        case TypeReference.METHOD_TYPE_PARAMETER_BOUND:\n        case TypeReference.THROWS:\n        case TypeReference.EXCEPTION_PARAMETER:\n            targetType &= 0xFFFFFF00;\n            currentOffset += 3;\n            break;\n        case TypeReference.INSTANCEOF:\n        case TypeReference.NEW:\n        case TypeReference.CONSTRUCTOR_REFERENCE:\n        case TypeReference.METHOD_REFERENCE:\n            targetType &= 0xFF000000;\n            currentOffset += 3;\n            break;\n        default:\n            throw new IllegalArgumentException();\n        }\n        context.currentTypeAnnotationTarget = targetType;\n        // Parse and store the target_path structure.\n        int pathLength = readByte(currentOffset);\n        context.currentTypeAnnotationTargetPath = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);\n        // Return the start offset of the rest of the type_annotation structure.\n        return currentOffset + 1 + 2 * pathLength;\n    }\n\n    /**\n     * Reads a Runtime[In]VisibleParameterAnnotations attribute and makes the given visitor visit it.\n     *\n     * @param methodVisitor the visitor that must visit the parameter annotations.\n     * @param context information about the class being parsed.\n     * @param runtimeParameterAnnotationsOffset the start offset of a\n     *     Runtime[In]VisibleParameterAnnotations attribute, excluding the attribute_info's\n     *     attribute_name_index and attribute_length fields.\n     * @param visible true if the attribute to parse is a RuntimeVisibleParameterAnnotations\n     *     attribute, false it is a RuntimeInvisibleParameterAnnotations attribute.\n     */\n    private void readParameterAnnotations(final MethodVisitor methodVisitor, final Context context, final int runtimeParameterAnnotationsOffset, final boolean visible) {\n        int currentOffset = runtimeParameterAnnotationsOffset;\n        int numParameters = classFileBuffer[currentOffset++] & 0xFF;\n        methodVisitor.visitAnnotableParameterCount(numParameters, visible);\n        char[] charBuffer = context.charBuffer;\n        for (int i = 0; i < numParameters; ++i) {\n            int numAnnotations = readUnsignedShort(currentOffset);\n            currentOffset += 2;\n            while (numAnnotations-- > 0) {\n                // Parse the type_index field.\n                String annotationDescriptor = readUTF8(currentOffset, charBuffer);\n                currentOffset += 2;\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\n                currentOffset = readElementValues(methodVisitor.visitParameterAnnotation(i, annotationDescriptor, visible), currentOffset,\n                        /* named = */ true, charBuffer);\n            }\n        }\n    }\n\n    /**\n     * Reads the element values of a JVMS 'annotation' structure and makes the given visitor visit\n     * them. This method can also be used to read the values of the JVMS 'array_value' field of an\n     * annotation's 'element_value'.\n     *\n     * @param annotationVisitor the visitor that must visit the values.\n     * @param annotationOffset the start offset of an 'annotation' structure (excluding its type_index\n     *     field) or of an 'array_value' structure.\n     * @param named if the annotation values are named or not. This should be true to parse the values\n     *     of a JVMS 'annotation' structure, and false to parse the JVMS 'array_value' of an\n     *     annotation's element_value.\n     * @param charBuffer the buffer used to read strings in the constant pool.\n     * @return the end offset of the JVMS 'annotation' or 'array_value' structure.\n     */\n    private int readElementValues(final AnnotationVisitor annotationVisitor, final int annotationOffset, final boolean named, final char[] charBuffer) {\n        int currentOffset = annotationOffset;\n        // Read the num_element_value_pairs field (or num_values field for an array_value).\n        int numElementValuePairs = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        if (named) {\n            // Parse the element_value_pairs array.\n            while (numElementValuePairs-- > 0) {\n                String elementName = readUTF8(currentOffset, charBuffer);\n                currentOffset = readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer);\n            }\n        } else {\n            // Parse the array_value array.\n            while (numElementValuePairs-- > 0) {\n                currentOffset = readElementValue(annotationVisitor, currentOffset, /* named = */ null, charBuffer);\n            }\n        }\n        if (annotationVisitor != null) {\n            annotationVisitor.visitEnd();\n        }\n        return currentOffset;\n    }\n\n    /**\n     * Reads a JVMS 'element_value' structure and makes the given visitor visit it.\n     *\n     * @param annotationVisitor the visitor that must visit the element_value structure.\n     * @param elementValueOffset the start offset in {@link #classFileBuffer} of the element_value\n     *     structure to be read.\n     * @param elementName the name of the element_value structure to be read, or {@literal null}.\n     * @param charBuffer the buffer used to read strings in the constant pool.\n     * @return the end offset of the JVMS 'element_value' structure.\n     */\n    private int readElementValue(final AnnotationVisitor annotationVisitor, final int elementValueOffset, final String elementName, final char[] charBuffer) {\n        int currentOffset = elementValueOffset;\n        if (annotationVisitor == null) {\n            switch (classFileBuffer[currentOffset] & 0xFF) {\n            case 'e': // enum_const_value\n                return currentOffset + 5;\n            case '@': // annotation_value\n                return readElementValues(null, currentOffset + 3, /* named = */ true, charBuffer);\n            case '[': // array_value\n                return readElementValues(null, currentOffset + 1, /* named = */ false, charBuffer);\n            default:\n                return currentOffset + 3;\n            }\n        }\n        switch (classFileBuffer[currentOffset++] & 0xFF) {\n        case 'B': // const_value_index, CONSTANT_Integer\n            annotationVisitor.visit(elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\n            currentOffset += 2;\n            break;\n        case 'C': // const_value_index, CONSTANT_Integer\n            annotationVisitor.visit(elementName, (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\n            currentOffset += 2;\n            break;\n        case 'D': // const_value_index, CONSTANT_Double\n        case 'F': // const_value_index, CONSTANT_Float\n        case 'I': // const_value_index, CONSTANT_Integer\n        case 'J': // const_value_index, CONSTANT_Long\n            annotationVisitor.visit(elementName, readConst(readUnsignedShort(currentOffset), charBuffer));\n            currentOffset += 2;\n            break;\n        case 'S': // const_value_index, CONSTANT_Integer\n            annotationVisitor.visit(elementName, (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\n            currentOffset += 2;\n            break;\n        case 'Z': // const_value_index, CONSTANT_Integer\n            annotationVisitor.visit(elementName, readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\n            currentOffset += 2;\n            break;\n        case 's': // const_value_index, CONSTANT_Utf8\n            annotationVisitor.visit(elementName, readUTF8(currentOffset, charBuffer));\n            currentOffset += 2;\n            break;\n        case 'e': // enum_const_value\n            annotationVisitor.visitEnum(elementName, readUTF8(currentOffset, charBuffer), readUTF8(currentOffset + 2, charBuffer));\n            currentOffset += 4;\n            break;\n        case 'c': // class_info\n            annotationVisitor.visit(elementName, Type.getType(readUTF8(currentOffset, charBuffer)));\n            currentOffset += 2;\n            break;\n        case '@': // annotation_value\n            currentOffset = readElementValues(annotationVisitor.visitAnnotation(elementName, readUTF8(currentOffset, charBuffer)), currentOffset + 2, true, charBuffer);\n            break;\n        case '[': // array_value\n            int numValues = readUnsignedShort(currentOffset);\n            currentOffset += 2;\n            if (numValues == 0) {\n                return readElementValues(annotationVisitor.visitArray(elementName), currentOffset - 2,\n                        /* named = */ false, charBuffer);\n            }\n            switch (classFileBuffer[currentOffset] & 0xFF) {\n            case 'B':\n                byte[] byteValues = new byte[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, byteValues);\n                break;\n            case 'Z':\n                boolean[] booleanValues = new boolean[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    booleanValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]) != 0;\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, booleanValues);\n                break;\n            case 'S':\n                short[] shortValues = new short[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    shortValues[i] = (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, shortValues);\n                break;\n            case 'C':\n                char[] charValues = new char[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    charValues[i] = (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, charValues);\n                break;\n            case 'I':\n                int[] intValues = new int[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    intValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, intValues);\n                break;\n            case 'J':\n                long[] longValues = new long[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    longValues[i] = readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, longValues);\n                break;\n            case 'F':\n                float[] floatValues = new float[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    floatValues[i] = Float.intBitsToFloat(readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, floatValues);\n                break;\n            case 'D':\n                double[] doubleValues = new double[numValues];\n                for (int i = 0; i < numValues; i++) {\n                    doubleValues[i] = Double.longBitsToDouble(readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));\n                    currentOffset += 3;\n                }\n                annotationVisitor.visit(elementName, doubleValues);\n                break;\n            default:\n                currentOffset = readElementValues(annotationVisitor.visitArray(elementName), currentOffset - 2,\n                        /* named = */ false, charBuffer);\n                break;\n            }\n            break;\n        default:\n            throw new IllegalArgumentException();\n        }\n        return currentOffset;\n    }\n    // ----------------------------------------------------------------------------------------------\n    // Methods to parse stack map frames\n    // ----------------------------------------------------------------------------------------------\n\n    /**\n     * Computes the implicit frame of the method currently being parsed (as defined in the given\n     * {@link Context}) and stores it in the given context.\n     *\n     * @param context information about the class being parsed.\n     */\n    private void computeImplicitFrame(final Context context) {\n        String methodDescriptor = context.currentMethodDescriptor;\n        Object[] locals = context.currentFrameLocalTypes;\n        int numLocal = 0;\n        if ((context.currentMethodAccessFlags & Opcodes.ACC_STATIC) == 0) {\n            if (\"<init>\".equals(context.currentMethodName)) {\n                locals[numLocal++] = Opcodes.UNINITIALIZED_THIS;\n            } else {\n                locals[numLocal++] = readClass(header + 2, context.charBuffer);\n            }\n        }\n        // Parse the method descriptor, one argument type descriptor at each iteration. Start by\n        // skipping the first method descriptor character, which is always '('.\n        int currentMethodDescritorOffset = 1;\n        while (true) {\n            int currentArgumentDescriptorStartOffset = currentMethodDescritorOffset;\n            switch (methodDescriptor.charAt(currentMethodDescritorOffset++)) {\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                locals[numLocal++] = Opcodes.INTEGER;\n                break;\n            case 'F':\n                locals[numLocal++] = Opcodes.FLOAT;\n                break;\n            case 'J':\n                locals[numLocal++] = Opcodes.LONG;\n                break;\n            case 'D':\n                locals[numLocal++] = Opcodes.DOUBLE;\n                break;\n            case '[':\n                while (methodDescriptor.charAt(currentMethodDescritorOffset) == '[') {\n                    ++currentMethodDescritorOffset;\n                }\n                if (methodDescriptor.charAt(currentMethodDescritorOffset) == 'L') {\n                    ++currentMethodDescritorOffset;\n                    while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {\n                        ++currentMethodDescritorOffset;\n                    }\n                }\n                locals[numLocal++] = methodDescriptor.substring(currentArgumentDescriptorStartOffset, ++currentMethodDescritorOffset);\n                break;\n            case 'L':\n                while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {\n                    ++currentMethodDescritorOffset;\n                }\n                locals[numLocal++] = methodDescriptor.substring(currentArgumentDescriptorStartOffset + 1, currentMethodDescritorOffset++);\n                break;\n            default:\n                context.currentFrameLocalCount = numLocal;\n                return;\n            }\n        }\n    }\n\n    /**\n     * Reads a JVMS 'stack_map_frame' structure and stores the result in the given {@link Context}\n     * object. This method can also be used to read a full_frame structure, excluding its frame_type\n     * field (this is used to parse the legacy StackMap attributes).\n     *\n     * @param stackMapFrameOffset the start offset in {@link #classFileBuffer} of the\n     *     stack_map_frame_value structure to be read, or the start offset of a full_frame structure\n     *     (excluding its frame_type field).\n     * @param compressed true to read a 'stack_map_frame' structure, false to read a 'full_frame'\n     *     structure without its frame_type field.\n     * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.\n     * @param context where the parsed stack map frame must be stored.\n     * @return the end offset of the JVMS 'stack_map_frame' or 'full_frame' structure.\n     */\n    private int readStackMapFrame(final int stackMapFrameOffset, final boolean compressed, final boolean expand, final Context context) {\n        int currentOffset = stackMapFrameOffset;\n        final char[] charBuffer = context.charBuffer;\n        final Label[] labels = context.currentMethodLabels;\n        int frameType;\n        if (compressed) {\n            // Read the frame_type field.\n            frameType = classFileBuffer[currentOffset++] & 0xFF;\n        } else {\n            frameType = Frame.FULL_FRAME;\n            context.currentFrameOffset = -1;\n        }\n        int offsetDelta;\n        context.currentFrameLocalCountDelta = 0;\n        if (frameType < Frame.SAME_LOCALS_1_STACK_ITEM_FRAME) {\n            offsetDelta = frameType;\n            context.currentFrameType = Opcodes.F_SAME;\n            context.currentFrameStackCount = 0;\n        } else if (frameType < Frame.RESERVED) {\n            offsetDelta = frameType - Frame.SAME_LOCALS_1_STACK_ITEM_FRAME;\n            currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);\n            context.currentFrameType = Opcodes.F_SAME1;\n            context.currentFrameStackCount = 1;\n        } else if (frameType >= Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n            offsetDelta = readUnsignedShort(currentOffset);\n            currentOffset += 2;\n            if (frameType == Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n                currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);\n                context.currentFrameType = Opcodes.F_SAME1;\n                context.currentFrameStackCount = 1;\n            } else if (frameType >= Frame.CHOP_FRAME && frameType < Frame.SAME_FRAME_EXTENDED) {\n                context.currentFrameType = Opcodes.F_CHOP;\n                context.currentFrameLocalCountDelta = Frame.SAME_FRAME_EXTENDED - frameType;\n                context.currentFrameLocalCount -= context.currentFrameLocalCountDelta;\n                context.currentFrameStackCount = 0;\n            } else if (frameType == Frame.SAME_FRAME_EXTENDED) {\n                context.currentFrameType = Opcodes.F_SAME;\n                context.currentFrameStackCount = 0;\n            } else if (frameType < Frame.FULL_FRAME) {\n                int local = expand ? context.currentFrameLocalCount : 0;\n                for (int k = frameType - Frame.SAME_FRAME_EXTENDED; k > 0; k--) {\n                    currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameLocalTypes, local++, charBuffer, labels);\n                }\n                context.currentFrameType = Opcodes.F_APPEND;\n                context.currentFrameLocalCountDelta = frameType - Frame.SAME_FRAME_EXTENDED;\n                context.currentFrameLocalCount += context.currentFrameLocalCountDelta;\n                context.currentFrameStackCount = 0;\n            } else {\n                final int numberOfLocals = readUnsignedShort(currentOffset);\n                currentOffset += 2;\n                context.currentFrameType = Opcodes.F_FULL;\n                context.currentFrameLocalCountDelta = numberOfLocals;\n                context.currentFrameLocalCount = numberOfLocals;\n                for (int local = 0; local < numberOfLocals; ++local) {\n                    currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameLocalTypes, local, charBuffer, labels);\n                }\n                final int numberOfStackItems = readUnsignedShort(currentOffset);\n                currentOffset += 2;\n                context.currentFrameStackCount = numberOfStackItems;\n                for (int stack = 0; stack < numberOfStackItems; ++stack) {\n                    currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, stack, charBuffer, labels);\n                }\n            }\n        } else {\n            throw new IllegalArgumentException();\n        }\n        context.currentFrameOffset += offsetDelta + 1;\n        createLabel(context.currentFrameOffset, labels);\n        return currentOffset;\n    }\n\n    /**\n     * Reads a JVMS 'verification_type_info' structure and stores it at the given index in the given\n     * array.\n     *\n     * @param verificationTypeInfoOffset the start offset of the 'verification_type_info' structure to\n     *     read.\n     * @param frame the array where the parsed type must be stored.\n     * @param index the index in 'frame' where the parsed type must be stored.\n     * @param charBuffer the buffer used to read strings in the constant pool.\n     * @param labels the labels of the method currently being parsed, indexed by their offset. If the\n     *     parsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is\n     *     stored in this array if it does not already exist.\n     * @return the end offset of the JVMS 'verification_type_info' structure.\n     */\n    private int readVerificationTypeInfo(final int verificationTypeInfoOffset, final Object[] frame, final int index, final char[] charBuffer, final Label[] labels) {\n        int currentOffset = verificationTypeInfoOffset;\n        int tag = classFileBuffer[currentOffset++] & 0xFF;\n        switch (tag) {\n        case Frame.ITEM_TOP:\n            frame[index] = Opcodes.TOP;\n            break;\n        case Frame.ITEM_INTEGER:\n            frame[index] = Opcodes.INTEGER;\n            break;\n        case Frame.ITEM_FLOAT:\n            frame[index] = Opcodes.FLOAT;\n            break;\n        case Frame.ITEM_DOUBLE:\n            frame[index] = Opcodes.DOUBLE;\n            break;\n        case Frame.ITEM_LONG:\n            frame[index] = Opcodes.LONG;\n            break;\n        case Frame.ITEM_NULL:\n            frame[index] = Opcodes.NULL;\n            break;\n        case Frame.ITEM_UNINITIALIZED_THIS:\n            frame[index] = Opcodes.UNINITIALIZED_THIS;\n            break;\n        case Frame.ITEM_OBJECT:\n            frame[index] = readClass(currentOffset, charBuffer);\n            currentOffset += 2;\n            break;\n        case Frame.ITEM_UNINITIALIZED:\n            frame[index] = createLabel(readUnsignedShort(currentOffset), labels);\n            currentOffset += 2;\n            break;\n        default:\n            throw new IllegalArgumentException();\n        }\n        return currentOffset;\n    }\n    // ----------------------------------------------------------------------------------------------\n    // Methods to parse attributes\n    // ----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array\n     * field entry.\n     *\n     * @return the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array\n     *     field entry.\n     */\n    final int getFirstAttributeOffset() {\n        // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes\n        // each), as well as the interfaces array field (2 bytes per interface).\n        int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;\n        // Read the fields_count field.\n        int fieldsCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        // Skip the 'fields' array field.\n        while (fieldsCount-- > 0) {\n            // Invariant: currentOffset is the offset of a field_info structure.\n            // Skip the access_flags, name_index and descriptor_index fields (2 bytes each), and read the\n            // attributes_count field.\n            int attributesCount = readUnsignedShort(currentOffset + 6);\n            currentOffset += 8;\n            // Skip the 'attributes' array field.\n            while (attributesCount-- > 0) {\n                // Invariant: currentOffset is the offset of an attribute_info structure.\n                // Read the attribute_length field (2 bytes after the start of the attribute_info) and skip\n                // this many bytes, plus 6 for the attribute_name_index and attribute_length fields\n                // (yielding the total size of the attribute_info structure).\n                currentOffset += 6 + readInt(currentOffset + 2);\n            }\n        }\n        // Skip the methods_count and 'methods' fields, using the same method as above.\n        int methodsCount = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        while (methodsCount-- > 0) {\n            int attributesCount = readUnsignedShort(currentOffset + 6);\n            currentOffset += 8;\n            while (attributesCount-- > 0) {\n                currentOffset += 6 + readInt(currentOffset + 2);\n            }\n        }\n        // Skip the ClassFile's attributes_count field.\n        return currentOffset + 2;\n    }\n\n    /**\n     * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.\n     *\n     * @param maxStringLength a conservative estimate of the maximum length of the strings contained\n     *     in the constant pool of the class.\n     * @return the offsets of the bootstrap methods.\n     */\n    private int[] readBootstrapMethodsAttribute(final int maxStringLength) {\n        char[] charBuffer = new char[maxStringLength];\n        int currentAttributeOffset = getFirstAttributeOffset();\n        int[] currentBootstrapMethodOffsets = null;\n        for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentAttributeOffset, charBuffer);\n            int attributeLength = readInt(currentAttributeOffset + 2);\n            currentAttributeOffset += 6;\n            if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n                // Read the num_bootstrap_methods field and create an array of this size.\n                currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];\n                // Compute and store the offset of each 'bootstrap_methods' array field entry.\n                int currentBootstrapMethodOffset = currentAttributeOffset + 2;\n                for (int j = 0; j < currentBootstrapMethodOffsets.length; ++j) {\n                    currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;\n                    // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),\n                    // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).\n                    currentBootstrapMethodOffset += 4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;\n                }\n                return currentBootstrapMethodOffsets;\n            }\n            currentAttributeOffset += attributeLength;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    /**\n     * Reads a non standard JVMS 'attribute' structure in {@link #classFileBuffer}.\n     *\n     * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of\n     *     the class. Any attribute whose type is not equal to the type of one the prototypes will not\n     *     be parsed: its byte array value will be passed unchanged to the ClassWriter.\n     * @param type the type of the attribute.\n     * @param offset the start offset of the JVMS 'attribute' structure in {@link #classFileBuffer}.\n     *     The 6 attribute header bytes (attribute_name_index and attribute_length) are not taken into\n     *     account here.\n     * @param length the length of the attribute's content (excluding the 6 attribute header bytes).\n     * @param charBuffer the buffer to be used to read strings in the constant pool.\n     * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link\n     *     #classFileBuffer}, or -1 if the attribute to be read is not a code attribute. The 6\n     *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\n     *     account here.\n     * @param labels the labels of the method's code, or {@literal null} if the attribute to be read\n     *     is not a code attribute.\n     * @return the attribute that has been read.\n     */\n    private Attribute readAttribute(final Attribute[] attributePrototypes, final String type, final int offset, final int length, final char[] charBuffer, final int codeAttributeOffset, final Label[] labels) {\n        for (Attribute attributePrototype : attributePrototypes) {\n            if (attributePrototype.type.equals(type)) {\n                return attributePrototype.read(this, offset, length, charBuffer, codeAttributeOffset, labels);\n            }\n        }\n        return new Attribute(type).read(this, offset, length, null, -1, null);\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Utility methods: low level parsing\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the number of entries in the class's constant pool table.\n     *\n     * @return the number of entries in the class's constant pool table.\n     */\n    public int getItemCount() {\n        return cpInfoOffsets.length;\n    }\n\n    /**\n     * Returns the start offset in this {@link ClassReader} of a JVMS 'cp_info' structure (i.e. a\n     * constant pool entry), plus one. <i>This method is intended for {@link Attribute} sub classes,\n     * and is normally not needed by class generators or adapters.</i>\n     *\n     * @param constantPoolEntryIndex the index a constant pool entry in the class's constant pool\n     *     table.\n     * @return the start offset in this {@link ClassReader} of the corresponding JVMS 'cp_info'\n     *     structure, plus one.\n     */\n    public int getItem(final int constantPoolEntryIndex) {\n        return cpInfoOffsets[constantPoolEntryIndex];\n    }\n\n    /**\n     * Returns a conservative estimate of the maximum length of the strings contained in the class's\n     * constant pool table.\n     *\n     * @return a conservative estimate of the maximum length of the strings contained in the class's\n     *     constant pool table.\n     */\n    public int getMaxStringLength() {\n        return maxStringLength;\n    }\n\n    /**\n     * Reads a byte value in this {@link ClassReader}. <i>This method is intended for {@link\n     * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n     *\n     * @param offset the start offset of the value to be read in this {@link ClassReader}.\n     * @return the read value.\n     */\n    public int readByte(final int offset) {\n        return classFileBuffer[offset] & 0xFF;\n    }\n\n    /**\n     * Reads an unsigned short value in this {@link ClassReader}. <i>This method is intended for\n     * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n     *\n     * @param offset the start index of the value to be read in this {@link ClassReader}.\n     * @return the read value.\n     */\n    public int readUnsignedShort(final int offset) {\n        byte[] classBuffer = classFileBuffer;\n        return ((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF);\n    }\n\n    /**\n     * Reads a signed short value in this {@link ClassReader}. <i>This method is intended for {@link\n     * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n     *\n     * @param offset the start offset of the value to be read in this {@link ClassReader}.\n     * @return the read value.\n     */\n    public short readShort(final int offset) {\n        byte[] classBuffer = classFileBuffer;\n        return (short) (((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF));\n    }\n\n    /**\n     * Reads a signed int value in this {@link ClassReader}. <i>This method is intended for {@link\n     * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n     *\n     * @param offset the start offset of the value to be read in this {@link ClassReader}.\n     * @return the read value.\n     */\n    public int readInt(final int offset) {\n        byte[] classBuffer = classFileBuffer;\n        return ((classBuffer[offset] & 0xFF) << 24) | ((classBuffer[offset + 1] & 0xFF) << 16) | ((classBuffer[offset + 2] & 0xFF) << 8) | (classBuffer[offset + 3] & 0xFF);\n    }\n\n    /**\n     * Reads a signed long value in this {@link ClassReader}. <i>This method is intended for {@link\n     * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n     *\n     * @param offset the start offset of the value to be read in this {@link ClassReader}.\n     * @return the read value.\n     */\n    public long readLong(final int offset) {\n        long l1 = readInt(offset);\n        long l0 = readInt(offset + 4) & 0xFFFFFFFFL;\n        return (l1 << 32) | l0;\n    }\n\n    /**\n     * Reads a CONSTANT_Utf8 constant pool entry in this {@link ClassReader}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n     *     value is the index of a CONSTANT_Utf8 entry in the class's constant pool table.\n     * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified CONSTANT_Utf8 entry.\n     */\n    // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\n    public String readUTF8(final int offset, final char[] charBuffer) {\n        int constantPoolEntryIndex = readUnsignedShort(offset);\n        if (offset == 0 || constantPoolEntryIndex == 0) {\n            return null;\n        }\n        return readUtf(constantPoolEntryIndex, charBuffer);\n    }\n\n    /**\n     * Reads a CONSTANT_Utf8 constant pool entry in {@link #classFileBuffer}.\n     *\n     * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pool\n     *     table.\n     * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified CONSTANT_Utf8 entry.\n     */\n    final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n        String value = constantUtf8Values[constantPoolEntryIndex];\n        if (value != null) {\n            return value;\n        }\n        int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\n        return constantUtf8Values[constantPoolEntryIndex] = readUtf(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);\n    }\n\n    /**\n     * Reads an UTF8 string in {@link #classFileBuffer}.\n     *\n     * @param utfOffset the start offset of the UTF8 string to be read.\n     * @param utfLength the length of the UTF8 string to be read.\n     * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified UTF8 string.\n     */\n    private String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {\n        int currentOffset = utfOffset;\n        int endOffset = currentOffset + utfLength;\n        int strLength = 0;\n        byte[] classBuffer = classFileBuffer;\n        while (currentOffset < endOffset) {\n            int currentByte = classBuffer[currentOffset++];\n            if ((currentByte & 0x80) == 0) {\n                charBuffer[strLength++] = (char) (currentByte & 0x7F);\n            } else if ((currentByte & 0xE0) == 0xC0) {\n                charBuffer[strLength++] = (char) (((currentByte & 0x1F) << 6) + (classBuffer[currentOffset++] & 0x3F));\n            } else {\n                charBuffer[strLength++] = (char) (((currentByte & 0xF) << 12) + ((classBuffer[currentOffset++] & 0x3F) << 6) + (classBuffer[currentOffset++] & 0x3F));\n            }\n        }\n        return new String(charBuffer, 0, strLength);\n    }\n\n    /**\n     * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or\n     * CONSTANT_Package constant pool entry in {@link #classFileBuffer}. <i>This method is intended\n     * for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param offset the start offset of an unsigned short value in {@link #classFileBuffer}, whose\n     *     value is the index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,\n     *     CONSTANT_Module or CONSTANT_Package entry in class's constant pool table.\n     * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified constant pool entry.\n     */\n    private String readStringish(final int offset, final char[] charBuffer) {\n        // Get the start offset of the cp_info structure (plus one), and read the CONSTANT_Utf8 entry\n        // designated by the first two bytes of this cp_info.\n        return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);\n    }\n\n    /**\n     * Reads a CONSTANT_Class constant pool entry in this {@link ClassReader}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n     *     value is the index of a CONSTANT_Class entry in class's constant pool table.\n     * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified CONSTANT_Class entry.\n     */\n    public String readClass(final int offset, final char[] charBuffer) {\n        return readStringish(offset, charBuffer);\n    }\n\n    /**\n     * Reads a CONSTANT_Module constant pool entry in this {@link ClassReader}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n     *     value is the index of a CONSTANT_Module entry in class's constant pool table.\n     * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified CONSTANT_Module entry.\n     */\n    public String readModule(final int offset, final char[] charBuffer) {\n        return readStringish(offset, charBuffer);\n    }\n\n    /**\n     * Reads a CONSTANT_Package constant pool entry in this {@link ClassReader}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n     *     value is the index of a CONSTANT_Package entry in class's constant pool table.\n     * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the String corresponding to the specified CONSTANT_Package entry.\n     */\n    public String readPackage(final int offset, final char[] charBuffer) {\n        return readStringish(offset, charBuffer);\n    }\n\n    /**\n     * Reads a CONSTANT_Dynamic constant pool entry in {@link #classFileBuffer}.\n     *\n     * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class's constant\n     *     pool table.\n     * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the ConstantDynamic corresponding to the specified CONSTANT_Dynamic entry.\n     */\n    private ConstantDynamic readConstantDynamic(final int constantPoolEntryIndex, final char[] charBuffer) {\n        ConstantDynamic constantDynamic = constantDynamicValues[constantPoolEntryIndex];\n        if (constantDynamic != null) {\n            return constantDynamic;\n        }\n        int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\n        int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\n        String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\n        String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\n        int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];\n        Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\n        Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];\n        bootstrapMethodOffset += 4;\n        for (int i = 0; i < bootstrapMethodArguments.length; i++) {\n            bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\n            bootstrapMethodOffset += 2;\n        }\n        return constantDynamicValues[constantPoolEntryIndex] = new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);\n    }\n\n    /**\n     * Reads a numeric or string constant pool entry in this {@link ClassReader}. <i>This method is\n     * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n     * adapters.</i>\n     *\n     * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,\n     *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,\n     *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class's constant pool.\n     * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently\n     *     large. It is not automatically resized.\n     * @return the {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String},\n     *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified\n     *     constant pool entry.\n     */\n    public Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {\n        int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\n        switch (classFileBuffer[cpInfoOffset - 1]) {\n        case Symbol.CONSTANT_INTEGER_TAG:\n            return readInt(cpInfoOffset);\n        case Symbol.CONSTANT_FLOAT_TAG:\n            return Float.intBitsToFloat(readInt(cpInfoOffset));\n        case Symbol.CONSTANT_LONG_TAG:\n            return readLong(cpInfoOffset);\n        case Symbol.CONSTANT_DOUBLE_TAG:\n            return Double.longBitsToDouble(readLong(cpInfoOffset));\n        case Symbol.CONSTANT_CLASS_TAG:\n            return Type.getObjectType(readUTF8(cpInfoOffset, charBuffer));\n        case Symbol.CONSTANT_STRING_TAG:\n            return readUTF8(cpInfoOffset, charBuffer);\n        case Symbol.CONSTANT_METHOD_TYPE_TAG:\n            return Type.getMethodType(readUTF8(cpInfoOffset, charBuffer));\n        case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n            int referenceKind = readByte(cpInfoOffset);\n            int referenceCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 1)];\n            int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];\n            String owner = readClass(referenceCpInfoOffset, charBuffer);\n            String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\n            String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\n            boolean isInterface = classFileBuffer[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;\n            return new Handle(referenceKind, owner, name, descriptor, isInterface);\n        case Symbol.CONSTANT_DYNAMIC_TAG:\n            return readConstantDynamic(constantPoolEntryIndex, charBuffer);\n        default:\n            throw new IllegalArgumentException();\n        }\n    }\n}\n",
            "file_name": "ClassReader.java",
            "human_label": "Read a CONSTANT_Utf8 constant pool entry in the classFileBuffer.",
            "level": "class_runnable",
            "lineno": "3156",
            "name": "readUtf",
            "oracle_context": "{ \"apis\" : \"[readUnsignedShort]\", \"classes\" : \"[String]\", \"vars\" : \"[constantUtf8Values, cpInfoOffsets]\" }",
            "package": "net.hasor.utils.asm",
            "project": "hasor-master"
        },
        {
            "_id": "636766f21a6d9265ec01767d",
            "all_context": "{ \"class_level\" : \"import java.io.IOException;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Locale;\\nString EMPTY;\\nint INDEX_NOT_FOUND;\\nint PAD_LIMIT;\\nchar[] escapes;\\nStringUtils();\\nisNotEmpty(String str);\\nisBlank(String str);\\nisNotBlank(String str);\\ntrim(String str);\\ntrimToNull(String str);\\ntrimToEmpty(String str);\\nstrip(String str);\\nstripToNull(String str);\\nstripToEmpty(String str);\\nstrip(String str,String stripChars);\\nstripStart(String str,String stripChars);\\nstripEnd(String str,String stripChars);\\nstripAll(String[] strs);\\nstripAll(String[] strs,String stripChars);\\nequals(String str1,String str2);\\nequalsIgnoreCase(String str1,String str2);\\nindexOf(String str,char searchChar);\\nindexOf(String str,char searchChar,int startPos);\\nindexOf(String str,String searchStr);\\nordinalIndexOf(String str,String searchStr,int ordinal);\\nordinalIndexOf(String str,String searchStr,int ordinal,boolean lastIndex);\\nindexOf(String str,String searchStr,int startPos);\\nindexOfIgnoreCase(String str,String searchStr);\\nindexOfIgnoreCase(String str,String searchStr,int startPos);\\nlastIndexOf(String str,char searchChar);\\nlastIndexOf(String str,char searchChar,int startPos);\\nlastIndexOf(String str,String searchStr);\\nlastOrdinalIndexOf(String str,String searchStr,int ordinal);\\nlastIndexOf(String str,String searchStr,int startPos);\\nlastIndexOfIgnoreCase(String str,String searchStr);\\nlastIndexOfIgnoreCase(String str,String searchStr,int startPos);\\ncontains(String str,char searchChar);\\ncontains(String str,String searchStr);\\ncontainsIgnoreCase(String str,String searchStr);\\nindexOfAny(String str,char[] searchChars);\\nindexOfAny(String str,String searchChars);\\ncontainsAny(String str,char[] searchChars);\\ncontainsAny(String str,String searchChars);\\nindexOfAnyBut(String str,char[] searchChars);\\nindexOfAnyBut(String str,String searchChars);\\ncontainsOnly(String str,char[] valid);\\ncontainsOnly(String str,String validChars);\\ncontainsNone(String str,char[] searchChars);\\ncontainsNone(String str,String invalidChars);\\nindexOfAny(String str,String[] searchStrs);\\nlastIndexOfAny(String str,String[] searchStrs);\\nsubstring(String str,int start);\\nsubstring(String str,int start,int end);\\nleft(String str,int len);\\nright(String str,int len);\\nmid(String str,int pos,int len);\\nsubstringBefore(String str,String separator);\\nsubstringAfter(String str,String separator);\\nsubstringBeforeLast(String str,String separator);\\nsubstringAfterLast(String str,String separator);\\nsubstringBetween(String str,String tag);\\nsubstringBetween(String str,String open,String close);\\nsubstringsBetween(String str,String open,String close);\\nsplitKeep(String str,char separatorChar);\\nsplitKeep(String str,String separatorStr);\\nsplit(String str);\\nsplit(String str,char separatorChar);\\nsplit(String str,String separatorChars);\\nsplit(String str,String separatorChars,int max);\\nsplitByWholeSeparator(String str,String separator);\\nsplitByWholeSeparator(String str,String separator,int max);\\nsplitByWholeSeparatorPreserveAllTokens(String str,String separator);\\nsplitByWholeSeparatorPreserveAllTokens(String str,String separator,int max);\\nsplitByWholeSeparatorWorker(String str,String separator,int max,boolean preserveAllTokens);\\nsplitPreserveAllTokens(String str);\\nsplitPreserveAllTokens(String str,char separatorChar);\\nsplitWorker(String str,char separatorChar,boolean preserveAllTokens);\\nsplitPreserveAllTokens(String str,String separatorChars);\\nsplitPreserveAllTokens(String str,String separatorChars,int max);\\nsplitWorker(String str,String separatorChars,int max,boolean preserveAllTokens);\\nsplitByCharacterType(String str);\\nsplitByCharacterTypeCamelCase(String str);\\nsplitByCharacterType(String str,boolean camelCase);\\njoin(Object[] array);\\njoin(Object[] array,char separator);\\njoin(Object[] array,char separator,int startIndex,int endIndex);\\njoin(Object[] array,String separator);\\njoin(Object[] array,String separator,int startIndex,int endIndex);\\ndeleteWhitespace(String str);\\nremoveStart(String str,String remove);\\nremoveStartIgnoreCase(String str,String remove);\\nremoveEnd(String str,String remove);\\nremoveEndIgnoreCase(String str,String remove);\\nremove(String str,String remove);\\nremove(String str,char remove);\\nreplaceOnce(String text,String searchString,String replacement);\\nreplace(String text,String searchString,String replacement);\\nreplace(String text,String searchString,String replacement,int max);\\nreplaceEach(String text,String[] searchList,String[] replacementList);\\nreplaceEachRepeatedly(String text,String[] searchList,String[] replacementList);\\nreplaceEach(String text,String[] searchList,String[] replacementList,boolean repeat,int timeToLive);\\nreplaceChars(String str,char searchChar,char replaceChar);\\nreplaceChars(String str,String searchChars,String replaceChars);\\noverlay(String str,String overlay,int start,int end);\\nchomp(String str);\\nchomp(String str,String separator);\\nchop(String str);\\nrepeat(char character,int repeat);\\nrepeat(String str,int repeat);\\nrepeat(String str,String separator,int repeat);\\npadding(int repeat,char padChar);\\nrightPad(String str,int size);\\nrightPad(String str,int size,char padChar);\\nrightPad(String str,int size,String padStr);\\nleftPad(String str,int size);\\nleftPad(String str,int size,char padChar);\\nleftPad(String str,int size,String padStr);\\nlength(String str);\\ncenter(String str,int size);\\ncenter(String str,int size,char padChar);\\ncenter(String str,int size,String padStr);\\nupperCase(String str);\\nupperCase(String str,Locale locale);\\nlowerCase(String str);\\nlowerCase(String str,Locale locale);\\ncapitalize(String str);\\nuncapitalize(String str);\\nswapCase(String str);\\ncountMatches(String str,String sub);\\nisAlpha(String str);\\nisAlphaSpace(String str);\\nisAlphanumeric(String str);\\nisAlphanumericSpace(String str);\\nisAsciiPrintable(String str);\\nisNumeric(String str);\\nisNumericSpace(String str);\\nisWhitespace(String str);\\nisAllLowerCase(String str);\\nisAllUpperCase(String str);\\ndefaultString(String str);\\ndefaultString(String str,String defaultStr);\\ndefaultIfBlank(String str,String defaultStr);\\ndefaultIfEmpty(String str,String defaultStr);\\nreverse(String str);\\nreverseDelimited(String str,char separatorChar);\\nabbreviate(String str,int maxWidth);\\nabbreviate(String str,int offset,int maxWidth);\\nabbreviateMiddle(String str,String middle,int length);\\ndifference(String str1,String str2);\\nindexOfDifference(String str1,String str2);\\nindexOfDifference(String[] strs);\\ngetCommonPrefix(String[] strs);\\ngetLevenshteinDistance(String s,String t);\\nstartsWith(String str,String prefix);\\nstartsWithIgnoreCase(String str,String prefix);\\nstartsWith(String str,String prefix,boolean ignoreCase);\\nstartsWithAny(String string,String[] searchStrings);\\nendsWith(String str,String suffix);\\nendsWithIgnoreCase(String str,String suffix);\\nendsWith(String str,String suffix,boolean ignoreCase);\\nnormalizeSpace(String str);\\nendsWithAny(String string,String[] searchStrings);\\nfirstCharToUpperCase(String value);\\nfirstCharToLowerCase(String value);\\nequalsBlankIgnoreCase(String str1,String str2);\\nquote(String input);\\nquote(Appendable buffer,String input);\\ntoString(Object object);\\nisEmpty(String str);\\n\", \"repo_level\" : \"\" }",
            "class_name": "StringUtils",
            "code": "public static String toString(Object object){\n  return (object == null) ? null : object.toString();\n}\n",
            "docstring": "/** \n * Object to String ,when null object then null else return toString(); \n */\n",
            "end_lineno": "6136",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\n/**\n * <p>Operations on {@link String} that are\n * <code>null</code> safe.</p>\n *\n * <ul>\n *  <li><b>IsEmpty/IsBlank</b>\n *      - checks if a String contains text</li>\n *  <li><b>Trim/Strip</b>\n *      - removes leading and trailing whitespace</li>\n *  <li><b>Equals</b>\n *      - compares two strings null-safe</li>\n *  <li><b>startsWith</b>\n *      - check if a String starts with a prefix null-safe</li>\n *  <li><b>endsWith</b>\n *      - check if a String ends with a suffix null-safe</li>\n *  <li><b>IndexOf/LastIndexOf/Contains</b>\n *      - null-safe index-of checks\n *  <li><b>IndexOfAny/LastIndexOfAny/IndexOfAnyBut/LastIndexOfAnyBut</b>\n *      - index-of any of a set of Strings</li>\n *  <li><b>ContainsOnly/ContainsNone/ContainsAny</b>\n *      - does String contains only/none/any of these characters</li>\n *  <li><b>Substring/Left/Right/Mid</b>\n *      - null-safe substring extractions</li>\n *  <li><b>SubstringBefore/SubstringAfter/SubstringBetween</b>\n *      - substring extraction relative to other strings</li>\n *  <li><b>Split/Join</b>\n *      - splits a String into an array of substrings and vice versa</li>\n *  <li><b>Remove/Delete</b>\n *      - removes part of a String</li>\n *  <li><b>Replace/Overlay</b>\n *      - Searches a String and replaces one String with another</li>\n *  <li><b>Chomp/Chop</b>\n *      - removes the last part of a String</li>\n *  <li><b>LeftPad/RightPad/Center/Repeat</b>\n *      - pads a String</li>\n *  <li><b>UpperCase/LowerCase/SwapCase/Capitalize/Uncapitalize</b>\n *      - changes the case of a String</li>\n *  <li><b>CountMatches</b>\n *      - counts the number of occurrences of one String in another</li>\n *  <li><b>IsAlpha/IsNumeric/IsWhitespace/IsAsciiPrintable</b>\n *      - checks the characters in a String</li>\n *  <li><b>DefaultString</b>\n *      - protects against a null input String</li>\n *  <li><b>Reverse/ReverseDelimited</b>\n *      - reverses a String</li>\n *  <li><b>Abbreviate</b>\n *      - abbreviates a string using ellipsis</li>\n *  <li><b>Difference</b>\n *      - compares Strings and reports on their differences</li>\n *  <li><b>LevensteinDistance</b>\n *      - the number of changes needed to change one String into another</li>\n * </ul>\n *\n * <p>The <code>StringUtils</code> class defines certain words related to\n * String handling.</p>\n *\n * <ul>\n *  <li>null - <code>null</code></li>\n *  <li>empty - a zero-length string (<code>\"\"</code>)</li>\n *  <li>space - the space character (<code>' '</code>, char 32)</li>\n *  <li>whitespace - the characters defined by {@link Character#isWhitespace(char)}</li>\n *  <li>trim - the characters &lt;= 32 as in {@link String#trim()}</li>\n * </ul>\n *\n * <p><code>StringUtils</code> handles <code>null</code> input Strings quietly.\n * That is to say that a <code>null</code> input will return <code>null</code>.\n * Where a <code>boolean</code> or <code>int</code> is being returned\n * details vary by method.</p>\n *\n * <p>A side effect of the <code>null</code> handling is that a\n * <code>NullPointerException</code> should be considered a bug in\n * <code>StringUtils</code> (except for deprecated methods).</p>\n *\n * <p>Methods in this class give sample code to explain their operation.\n * The symbol <code>*</code> is used to indicate any input including <code>null</code>.</p>\n *\n * <p>#ThreadSafe#</p>\n * @see String\n * @author Apache Software Foundation\n * @author <a href=\"http://jakarta.apache.org/turbine/\">Apache Jakarta Turbine</a>\n * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n * @author Daniel L. Rall\n * @author <a href=\"mailto:gcoladonato@yahoo.com\">Greg Coladonato</a>\n * @author <a href=\"mailto:ed@apache.org\">Ed Korthof</a>\n * @author <a href=\"mailto:rand_mcneely@yahoo.com\">Rand McNeely</a>\n * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n * @author Holger Krauth\n * @author <a href=\"mailto:alex@purpletech.com\">Alexander Day Chaffee</a>\n * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n * @author Arun Mammen Thomas\n * @author Gary Gregory\n * @author Phil Steitz\n * @author Al Chou\n * @author Michael Davey\n * @author Reuben Sivan\n * @author Chris Hyzer\n * @author Scott Johnson\n * @since 1.0\n * @version $Id: StringUtils.java 1058365 2011-01-13 00:04:49Z niallp $\n */\n//@Immutable\npublic class StringUtils {\n    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n    // Whitespace:\n    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n    // where WHITESPACE is a string of all whitespace characters\n    //\n    // Character access:\n    // String.charAt(n) versus toCharArray(), then array[n]\n    // String.charAt(n) is about 15% worse for a 10K string\n    // They are about equal for a length 50 string\n    // String.charAt(n) is about 4 times better for a length 3 string\n    // String.charAt(n) is best bet overall\n    //\n    // Append:\n    // String.concat about twice as fast as StringBuffer.append\n    // (not sure who tested this)\n    /**\n     * The empty String <code>\"\"</code>.\n     * @since 2.0\n     */\n    public static final  String EMPTY           = \"\";\n    /**\n     * Represents a failed index search.\n     * @since 2.1\n     */\n    public static final  int    INDEX_NOT_FOUND = -1;\n    /**\n     * <p>The maximum size to which the padding constant(s) can expand.</p>\n     */\n    private static final int    PAD_LIMIT       = 8192;\n\n    /**\n     * <p><code>StringUtils</code> instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * <code>StringUtils.trim(\" foo \");</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean\n     * instance to operate.</p>\n     */\n    public StringUtils() {\n        super();\n    }\n    // Empty checks\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if a String is empty (\"\") or null.</p>\n     *\n     * <pre>\n     * StringUtils.isEmpty(null)      = true\n     * StringUtils.isEmpty(\"\")        = true\n     * StringUtils.isEmpty(\" \")       = false\n     * StringUtils.isEmpty(\"bob\")     = false\n     * StringUtils.isEmpty(\"  bob  \") = false\n     * </pre>\n     *\n     * <p>NOTE: This method changed in Lang version 2.0.\n     * It no longer trims the String.\n     * That functionality is available in isBlank().</p>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if the String is empty or null\n     */\n    public static boolean isEmpty(final String str) {\n        return str == null || str.length() == 0;\n    }\n\n    /**\n     * <p>Checks if a String is not empty (\"\") and not null.</p>\n     *\n     * <pre>\n     * StringUtils.isNotEmpty(null)      = false\n     * StringUtils.isNotEmpty(\"\")        = false\n     * StringUtils.isNotEmpty(\" \")       = true\n     * StringUtils.isNotEmpty(\"bob\")     = true\n     * StringUtils.isNotEmpty(\"  bob  \") = true\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if the String is not empty and not null\n     */\n    public static boolean isNotEmpty(final String str) {\n        return !StringUtils.isEmpty(str);\n    }\n\n    /**\n     * <p>Checks if a String is whitespace, empty (\"\") or null.</p>\n     *\n     * <pre>\n     * StringUtils.isBlank(null)      = true\n     * StringUtils.isBlank(\"\")        = true\n     * StringUtils.isBlank(\" \")       = true\n     * StringUtils.isBlank(\"bob\")     = false\n     * StringUtils.isBlank(\"  bob  \") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if the String is null, empty or whitespace\n     * @since 2.0\n     */\n    public static boolean isBlank(final String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return true;\n        }\n        for (int i = 0; i < strLen; i++) {\n            if (Character.isWhitespace(str.charAt(i)) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if a String is not empty (\"\"), not null and not whitespace only.</p>\n     *\n     * <pre>\n     * StringUtils.isNotBlank(null)      = false\n     * StringUtils.isNotBlank(\"\")        = false\n     * StringUtils.isNotBlank(\" \")       = false\n     * StringUtils.isNotBlank(\"bob\")     = true\n     * StringUtils.isNotBlank(\"  bob  \") = true\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if the String is\n     *  not empty and not null and not whitespace\n     * @since 2.0\n     */\n    public static boolean isNotBlank(final String str) {\n        return !StringUtils.isBlank(str);\n    }\n    // Trim\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Removes control characters (char &lt;= 32) from both\n     * ends of this String, handling <code>null</code> by returning\n     * <code>null</code>.</p>\n     *\n     * <p>The String is trimmed using {@link String#trim()}.\n     * Trim removes start and end characters &lt;= 32.\n     * To strip whitespace use {@link #strip(String)}.</p>\n     *\n     * <p>To trim your choice of characters, use the\n     * {@link #strip(String, String)} methods.</p>\n     *\n     * <pre>\n     * StringUtils.trim(null)          = null\n     * StringUtils.trim(\"\")            = \"\"\n     * StringUtils.trim(\"     \")       = \"\"\n     * StringUtils.trim(\"abc\")         = \"abc\"\n     * StringUtils.trim(\"    abc    \") = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to be trimmed, may be null\n     * @return the trimmed string, <code>null</code> if null String input\n     */\n    public static String trim(final String str) {\n        return str == null ? null : str.trim();\n    }\n\n    /**\n     * <p>Removes control characters (char &lt;= 32) from both\n     * ends of this String returning <code>null</code> if the String is\n     * empty (\"\") after the trim or if it is <code>null</code>.\n     *\n     * <p>The String is trimmed using {@link String#trim()}.\n     * Trim removes start and end characters &lt;= 32.\n     * To strip whitespace use {@link #stripToNull(String)}.</p>\n     *\n     * <pre>\n     * StringUtils.trimToNull(null)          = null\n     * StringUtils.trimToNull(\"\")            = null\n     * StringUtils.trimToNull(\"     \")       = null\n     * StringUtils.trimToNull(\"abc\")         = \"abc\"\n     * StringUtils.trimToNull(\"    abc    \") = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to be trimmed, may be null\n     * @return the trimmed String,\n     *  <code>null</code> if only chars &lt;= 32, empty or null String input\n     * @since 2.0\n     */\n    public static String trimToNull(final String str) {\n        String ts = StringUtils.trim(str);\n        return StringUtils.isEmpty(ts) ? null : ts;\n    }\n\n    /**\n     * <p>Removes control characters (char &lt;= 32) from both\n     * ends of this String returning an empty String (\"\") if the String\n     * is empty (\"\") after the trim or if it is <code>null</code>.\n     *\n     * <p>The String is trimmed using {@link String#trim()}.\n     * Trim removes start and end characters &lt;= 32.\n     * To strip whitespace use {@link #stripToEmpty(String)}.</p>\n     *\n     * <pre>\n     * StringUtils.trimToEmpty(null)          = \"\"\n     * StringUtils.trimToEmpty(\"\")            = \"\"\n     * StringUtils.trimToEmpty(\"     \")       = \"\"\n     * StringUtils.trimToEmpty(\"abc\")         = \"abc\"\n     * StringUtils.trimToEmpty(\"    abc    \") = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to be trimmed, may be null\n     * @return the trimmed String, or an empty String if <code>null</code> input\n     * @since 2.0\n     */\n    public static String trimToEmpty(final String str) {\n        return str == null ? StringUtils.EMPTY : str.trim();\n    }\n    // Stripping\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Strips whitespace from the start and end of a String.</p>\n     *\n     * <p>This is similar to {@link #trim(String)} but removes whitespace.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.strip(null)     = null\n     * StringUtils.strip(\"\")       = \"\"\n     * StringUtils.strip(\"   \")    = \"\"\n     * StringUtils.strip(\"abc\")    = \"abc\"\n     * StringUtils.strip(\"  abc\")  = \"abc\"\n     * StringUtils.strip(\"abc  \")  = \"abc\"\n     * StringUtils.strip(\" abc \")  = \"abc\"\n     * StringUtils.strip(\" ab c \") = \"ab c\"\n     * </pre>\n     *\n     * @param str  the String to remove whitespace from, may be null\n     * @return the stripped String, <code>null</code> if null String input\n     */\n    public static String strip(final String str) {\n        return StringUtils.strip(str, null);\n    }\n\n    /**\n     * <p>Strips whitespace from the start and end of a String  returning\n     * <code>null</code> if the String is empty (\"\") after the strip.</p>\n     *\n     * <p>This is similar to {@link #trimToNull(String)} but removes whitespace.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <pre>\n     * StringUtils.stripToNull(null)     = null\n     * StringUtils.stripToNull(\"\")       = null\n     * StringUtils.stripToNull(\"   \")    = null\n     * StringUtils.stripToNull(\"abc\")    = \"abc\"\n     * StringUtils.stripToNull(\"  abc\")  = \"abc\"\n     * StringUtils.stripToNull(\"abc  \")  = \"abc\"\n     * StringUtils.stripToNull(\" abc \")  = \"abc\"\n     * StringUtils.stripToNull(\" ab c \") = \"ab c\"\n     * </pre>\n     *\n     * @param str  the String to be stripped, may be null\n     * @return the stripped String,\n     *  <code>null</code> if whitespace, empty or null String input\n     * @since 2.0\n     */\n    public static String stripToNull(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = StringUtils.strip(str, null);\n        return str.length() == 0 ? null : str;\n    }\n\n    /**\n     * <p>Strips whitespace from the start and end of a String  returning\n     * an empty String if <code>null</code> input.</p>\n     *\n     * <p>This is similar to {@link #trimToEmpty(String)} but removes whitespace.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <pre>\n     * StringUtils.stripToEmpty(null)     = \"\"\n     * StringUtils.stripToEmpty(\"\")       = \"\"\n     * StringUtils.stripToEmpty(\"   \")    = \"\"\n     * StringUtils.stripToEmpty(\"abc\")    = \"abc\"\n     * StringUtils.stripToEmpty(\"  abc\")  = \"abc\"\n     * StringUtils.stripToEmpty(\"abc  \")  = \"abc\"\n     * StringUtils.stripToEmpty(\" abc \")  = \"abc\"\n     * StringUtils.stripToEmpty(\" ab c \") = \"ab c\"\n     * </pre>\n     *\n     * @param str  the String to be stripped, may be null\n     * @return the trimmed String, or an empty String if <code>null</code> input\n     * @since 2.0\n     */\n    public static String stripToEmpty(final String str) {\n        return str == null ? StringUtils.EMPTY : StringUtils.strip(str, null);\n    }\n\n    /**\n     * <p>Strips any of a set of characters from the start and end of a String.\n     * This is similar to {@link String#trim()} but allows the characters\n     * to be stripped to be controlled.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * An empty string (\"\") input returns the empty string.</p>\n     *\n     * <p>If the stripChars String is <code>null</code>, whitespace is\n     * stripped as defined by {@link Character#isWhitespace(char)}.\n     * Alternatively use {@link #strip(String)}.</p>\n     *\n     * <pre>\n     * StringUtils.strip(null, *)          = null\n     * StringUtils.strip(\"\", *)            = \"\"\n     * StringUtils.strip(\"abc\", null)      = \"abc\"\n     * StringUtils.strip(\"  abc\", null)    = \"abc\"\n     * StringUtils.strip(\"abc  \", null)    = \"abc\"\n     * StringUtils.strip(\" abc \", null)    = \"abc\"\n     * StringUtils.strip(\"  abcyx\", \"xyz\") = \"  abc\"\n     * </pre>\n     *\n     * @param str  the String to remove characters from, may be null\n     * @param stripChars  the characters to remove, null treated as whitespace\n     * @return the stripped String, <code>null</code> if null String input\n     */\n    public static String strip(String str, final String stripChars) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        str = StringUtils.stripStart(str, stripChars);\n        return StringUtils.stripEnd(str, stripChars);\n    }\n\n    /**\n     * <p>Strips any of a set of characters from the start of a String.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * An empty string (\"\") input returns the empty string.</p>\n     *\n     * <p>If the stripChars String is <code>null</code>, whitespace is\n     * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <pre>\n     * StringUtils.stripStart(null, *)          = null\n     * StringUtils.stripStart(\"\", *)            = \"\"\n     * StringUtils.stripStart(\"abc\", \"\")        = \"abc\"\n     * StringUtils.stripStart(\"abc\", null)      = \"abc\"\n     * StringUtils.stripStart(\"  abc\", null)    = \"abc\"\n     * StringUtils.stripStart(\"abc  \", null)    = \"abc  \"\n     * StringUtils.stripStart(\" abc \", null)    = \"abc \"\n     * StringUtils.stripStart(\"yxabc  \", \"xyz\") = \"abc  \"\n     * </pre>\n     *\n     * @param str  the String to remove characters from, may be null\n     * @param stripChars  the characters to remove, null treated as whitespace\n     * @return the stripped String, <code>null</code> if null String input\n     */\n    public static String stripStart(final String str, final String stripChars) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        int start = 0;\n        if (stripChars == null) {\n            while (start != strLen && Character.isWhitespace(str.charAt(start))) {\n                start++;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while (start != strLen && stripChars.indexOf(str.charAt(start)) != StringUtils.INDEX_NOT_FOUND) {\n                start++;\n            }\n        }\n        return str.substring(start);\n    }\n\n    /**\n     * <p>Strips any of a set of characters from the end of a String.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * An empty string (\"\") input returns the empty string.</p>\n     *\n     * <p>If the stripChars String is <code>null</code>, whitespace is\n     * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <pre>\n     * StringUtils.stripEnd(null, *)          = null\n     * StringUtils.stripEnd(\"\", *)            = \"\"\n     * StringUtils.stripEnd(\"abc\", \"\")        = \"abc\"\n     * StringUtils.stripEnd(\"abc\", null)      = \"abc\"\n     * StringUtils.stripEnd(\"  abc\", null)    = \"  abc\"\n     * StringUtils.stripEnd(\"abc  \", null)    = \"abc\"\n     * StringUtils.stripEnd(\" abc \", null)    = \" abc\"\n     * StringUtils.stripEnd(\"  abcyx\", \"xyz\") = \"  abc\"\n     * StringUtils.stripEnd(\"120.00\", \".0\")   = \"12\"\n     * </pre>\n     *\n     * @param str  the String to remove characters from, may be null\n     * @param stripChars  the set of characters to remove, null treated as whitespace\n     * @return the stripped String, <code>null</code> if null String input\n     */\n    public static String stripEnd(final String str, final String stripChars) {\n        int end;\n        if (str == null || (end = str.length()) == 0) {\n            return str;\n        }\n        if (stripChars == null) {\n            while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {\n                end--;\n            }\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != StringUtils.INDEX_NOT_FOUND) {\n                end--;\n            }\n        }\n        return str.substring(0, end);\n    }\n    // StripAll\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Strips whitespace from the start and end of every String in an array.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <p>A new array is returned each time, except for length zero.\n     * A <code>null</code> array will return <code>null</code>.\n     * An empty array will return itself.\n     * A <code>null</code> array entry will be ignored.</p>\n     *\n     * <pre>\n     * StringUtils.stripAll(null)             = null\n     * StringUtils.stripAll([])               = []\n     * StringUtils.stripAll([\"abc\", \"  abc\"]) = [\"abc\", \"abc\"]\n     * StringUtils.stripAll([\"abc  \", null])  = [\"abc\", null]\n     * </pre>\n     *\n     * @param strs  the array to remove whitespace from, may be null\n     * @return the stripped Strings, <code>null</code> if null array input\n     */\n    public static String[] stripAll(final String[] strs) {\n        return StringUtils.stripAll(strs, null);\n    }\n\n    /**\n     * <p>Strips any of a set of characters from the start and end of every\n     * String in an array.</p>\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <p>A new array is returned each time, except for length zero.\n     * A <code>null</code> array will return <code>null</code>.\n     * An empty array will return itself.\n     * A <code>null</code> array entry will be ignored.\n     * A <code>null</code> stripChars will strip whitespace as defined by\n     * {@link Character#isWhitespace(char)}.</p>\n     *\n     * <pre>\n     * StringUtils.stripAll(null, *)                = null\n     * StringUtils.stripAll([], *)                  = []\n     * StringUtils.stripAll([\"abc\", \"  abc\"], null) = [\"abc\", \"abc\"]\n     * StringUtils.stripAll([\"abc  \", null], null)  = [\"abc\", null]\n     * StringUtils.stripAll([\"abc  \", null], \"yz\")  = [\"abc  \", null]\n     * StringUtils.stripAll([\"yabcz\", null], \"yz\")  = [\"abc\", null]\n     * </pre>\n     *\n     * @param strs  the array to remove characters from, may be null\n     * @param stripChars  the characters to remove, null treated as whitespace\n     * @return the stripped Strings, <code>null</code> if null array input\n     */\n    public static String[] stripAll(final String[] strs, final String stripChars) {\n        int strsLen;\n        if (strs == null || (strsLen = strs.length) == 0) {\n            return strs;\n        }\n        String[] newArr = new String[strsLen];\n        for (int i = 0; i < strsLen; i++) {\n            newArr[i] = StringUtils.strip(strs[i], stripChars);\n        }\n        return newArr;\n    }\n    // Equals\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered to be equal. The comparison is case sensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * @see String#equals(Object)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case sensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equals(final String str1, final String str2) {\n        return str1 == null ? str2 == null : str1.equals(str2);\n    }\n\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(final String str1, final String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n    // IndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the first index within a String, handling <code>null</code>.\n     * This method uses {@link String#indexOf(int)}.</p>\n     *\n     * <p>A <code>null</code> or empty (\"\") String will return <code>INDEX_NOT_FOUND (-1)</code>.</p>\n     *\n     * <pre>\n     * StringUtils.indexOf(null, *)         = -1\n     * StringUtils.indexOf(\"\", *)           = -1\n     * StringUtils.indexOf(\"aabaabaa\", 'a') = 0\n     * StringUtils.indexOf(\"aabaabaa\", 'b') = 2\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChar  the character to find\n     * @return the first index of the search character,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.0\n     */\n    public static int indexOf(final String str, final char searchChar) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchChar);\n    }\n\n    /**\n     * <p>Finds the first index within a String from a start position,\n     * handling <code>null</code>.\n     * This method uses {@link String#indexOf(int, int)}.</p>\n     *\n     * <p>A <code>null</code> or empty (\"\") String will return <code>(INDEX_NOT_FOUND) -1</code>.\n     * A negative start position is treated as zero.\n     * A start position greater than the string length returns <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.indexOf(null, *, *)          = -1\n     * StringUtils.indexOf(\"\", *, *)            = -1\n     * StringUtils.indexOf(\"aabaabaa\", 'b', 0)  = 2\n     * StringUtils.indexOf(\"aabaabaa\", 'b', 3)  = 5\n     * StringUtils.indexOf(\"aabaabaa\", 'b', 9)  = -1\n     * StringUtils.indexOf(\"aabaabaa\", 'b', -1) = 2\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChar  the character to find\n     * @param startPos  the start position, negative treated as zero\n     * @return the first index of the search character,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.0\n     */\n    public static int indexOf(final String str, final char searchChar, final int startPos) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchChar, startPos);\n    }\n\n    /**\n     * <p>Finds the first index within a String, handling <code>null</code>.\n     * This method uses {@link String#indexOf(String)}.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.indexOf(null, *)          = -1\n     * StringUtils.indexOf(*, null)          = -1\n     * StringUtils.indexOf(\"\", \"\")           = 0\n     * StringUtils.indexOf(\"\", *)            = -1 (except when * = \"\")\n     * StringUtils.indexOf(\"aabaabaa\", \"a\")  = 0\n     * StringUtils.indexOf(\"aabaabaa\", \"b\")  = 2\n     * StringUtils.indexOf(\"aabaabaa\", \"ab\") = 1\n     * StringUtils.indexOf(\"aabaabaa\", \"\")   = 0\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @return the first index of the search String,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.0\n     */\n    public static int indexOf(final String str, final String searchStr) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.indexOf(searchStr);\n    }\n\n    /**\n     * <p>Finds the n-th index within a String, handling <code>null</code>.\n     * This method uses {@link String#indexOf(String)}.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.ordinalIndexOf(null, *, *)          = -1\n     * StringUtils.ordinalIndexOf(*, null, *)          = -1\n     * StringUtils.ordinalIndexOf(\"\", \"\", *)           = 0\n     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 1)  = 0\n     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 2)  = 1\n     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 1)  = 2\n     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 2)  = 5\n     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 1) = 1\n     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 2) = 4\n     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 1)   = 0\n     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 2)   = 0\n     * </pre>\n     *\n     * <p>Note that 'head(String str, int n)' may be implemented as: </p>\n     *\n     * <pre>\n     *   str.substring(0, lastOrdinalIndexOf(str, \"\\n\", n))\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @param ordinal  the n-th <code>searchStr</code> to find\n     * @return the n-th index of the search String,\n     *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input\n     * @since 2.1\n     */\n    public static int ordinalIndexOf(final String str, final String searchStr, final int ordinal) {\n        return StringUtils.ordinalIndexOf(str, searchStr, ordinal, false);\n    }\n\n    /**\n     * <p>Finds the n-th index within a String, handling <code>null</code>.\n     * This method uses {@link String#indexOf(String)}.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @param ordinal  the n-th <code>searchStr</code> to find\n     * @param lastIndex true if lastOrdinalIndexOf() otherwise false if ordinalIndexOf()\n     * @return the n-th index of the search String,\n     *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input\n     */\n    // Shared code between ordinalIndexOf(String,String,int) and lastOrdinalIndexOf(String,String,int)\n    private static int ordinalIndexOf(final String str, final String searchStr, final int ordinal, final boolean lastIndex) {\n        if (str == null || searchStr == null || ordinal <= 0) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return lastIndex ? str.length() : 0;\n        }\n        int found = 0;\n        int index = lastIndex ? str.length() : StringUtils.INDEX_NOT_FOUND;\n        do {\n            if (lastIndex) {\n                index = str.lastIndexOf(searchStr, index - 1);\n            } else {\n                index = str.indexOf(searchStr, index + 1);\n            }\n            if (index < 0) {\n                return index;\n            }\n            found++;\n        } while (found < ordinal);\n        return index;\n    }\n\n    /**\n     * <p>Finds the first index within a String, handling <code>null</code>.\n     * This method uses {@link String#indexOf(String, int)}.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A negative start position is treated as zero.\n     * An empty (\"\") search String always matches.\n     * A start position greater than the string length only matches\n     * an empty search String.</p>\n     *\n     * <pre>\n     * StringUtils.indexOf(null, *, *)          = -1\n     * StringUtils.indexOf(*, null, *)          = -1\n     * StringUtils.indexOf(\"\", \"\", 0)           = 0\n     * StringUtils.indexOf(\"\", *, 0)            = -1 (except when * = \"\")\n     * StringUtils.indexOf(\"aabaabaa\", \"a\", 0)  = 0\n     * StringUtils.indexOf(\"aabaabaa\", \"b\", 0)  = 2\n     * StringUtils.indexOf(\"aabaabaa\", \"ab\", 0) = 1\n     * StringUtils.indexOf(\"aabaabaa\", \"b\", 3)  = 5\n     * StringUtils.indexOf(\"aabaabaa\", \"b\", 9)  = -1\n     * StringUtils.indexOf(\"aabaabaa\", \"b\", -1) = 2\n     * StringUtils.indexOf(\"aabaabaa\", \"\", 2)   = 2\n     * StringUtils.indexOf(\"abc\", \"\", 9)        = 3\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @param startPos  the start position, negative treated as zero\n     * @return the first index of the search String,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.0\n     */\n    public static int indexOf(final String str, final String searchStr, final int startPos) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        // JDK1.2/JDK1.3 have a bug, when startPos > str.length for \"\", hence\n        if (searchStr.length() == 0 && startPos >= str.length()) {\n            return str.length();\n        }\n        return str.indexOf(searchStr, startPos);\n    }\n\n    /**\n     * <p>Case in-sensitive find of the first index within a String.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A negative start position is treated as zero.\n     * An empty (\"\") search String always matches.\n     * A start position greater than the string length only matches\n     * an empty search String.</p>\n     *\n     * <pre>\n     * StringUtils.indexOfIgnoreCase(null, *)          = -1\n     * StringUtils.indexOfIgnoreCase(*, null)          = -1\n     * StringUtils.indexOfIgnoreCase(\"\", \"\")           = 0\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"a\")  = 0\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"b\")  = 2\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"ab\") = 1\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @return the first index of the search String,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.5\n     */\n    public static int indexOfIgnoreCase(final String str, final String searchStr) {\n        return StringUtils.indexOfIgnoreCase(str, searchStr, 0);\n    }\n\n    /**\n     * <p>Case in-sensitive find of the first index within a String\n     * from the specified position.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A negative start position is treated as zero.\n     * An empty (\"\") search String always matches.\n     * A start position greater than the string length only matches\n     * an empty search String.</p>\n     *\n     * <pre>\n     * StringUtils.indexOfIgnoreCase(null, *, *)          = -1\n     * StringUtils.indexOfIgnoreCase(*, null, *)          = -1\n     * StringUtils.indexOfIgnoreCase(\"\", \"\", 0)           = 0\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"A\", 0)  = 0\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", 0)  = 2\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"AB\", 0) = 1\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", 3)  = 5\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", 9)  = -1\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", -1) = 2\n     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"\", 2)   = 2\n     * StringUtils.indexOfIgnoreCase(\"abc\", \"\", 9)        = 3\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @param startPos  the start position, negative treated as zero\n     * @return the first index of the search String,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.5\n     */\n    public static int indexOfIgnoreCase(final String str, final String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        if (startPos < 0) {\n            startPos = 0;\n        }\n        int endLimit = str.length() - searchStr.length() + 1;\n        if (startPos > endLimit) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return startPos;\n        }\n        for (int i = startPos; i < endLimit; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {\n                return i;\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n    // LastIndexOf\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Finds the last index within a String, handling <code>null</code>.\n     * This method uses {@link String#lastIndexOf(int)}.</p>\n     *\n     * <p>A <code>null</code> or empty (\"\") String will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.lastIndexOf(null, *)         = -1\n     * StringUtils.lastIndexOf(\"\", *)           = -1\n     * StringUtils.lastIndexOf(\"aabaabaa\", 'a') = 7\n     * StringUtils.lastIndexOf(\"aabaabaa\", 'b') = 5\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChar  the character to find\n     * @return the last index of the search character,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.0\n     */\n    public static int lastIndexOf(final String str, final char searchChar) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchChar);\n    }\n\n    /**\n     * <p>Finds the last index within a String from a start position,\n     * handling <code>null</code>.\n     * This method uses {@link String#lastIndexOf(int, int)}.</p>\n     *\n     * <p>A <code>null</code> or empty (\"\") String will return <code>-1</code>.\n     * A negative start position returns <code>-1</code>.\n     * A start position greater than the string length searches the whole string.</p>\n     *\n     * <pre>\n     * StringUtils.lastIndexOf(null, *, *)          = -1\n     * StringUtils.lastIndexOf(\"\", *,  *)           = -1\n     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 8)  = 5\n     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 4)  = 2\n     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 0)  = -1\n     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 9)  = 5\n     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', -1) = -1\n     * StringUtils.lastIndexOf(\"aabaabaa\", 'a', 0)  = 0\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChar  the character to find\n     * @param startPos  the start position\n     * @return the last index of the search character,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.0\n     */\n    public static int lastIndexOf(final String str, final char searchChar, final int startPos) {\n        if (StringUtils.isEmpty(str)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchChar, startPos);\n    }\n\n    /**\n     * <p>Finds the last index within a String, handling <code>null</code>.\n     * This method uses {@link String#lastIndexOf(String)}.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.lastIndexOf(null, *)          = -1\n     * StringUtils.lastIndexOf(*, null)          = -1\n     * StringUtils.lastIndexOf(\"\", \"\")           = 0\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"a\")  = 7\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\")  = 5\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"ab\") = 4\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"\")   = 8\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @return the last index of the search String,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.0\n     */\n    public static int lastIndexOf(final String str, final String searchStr) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchStr);\n    }\n\n    /**\n     * <p>Finds the n-th last index within a String, handling <code>null</code>.\n     * This method uses {@link String#lastIndexOf(String)}.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.lastOrdinalIndexOf(null, *, *)          = -1\n     * StringUtils.lastOrdinalIndexOf(*, null, *)          = -1\n     * StringUtils.lastOrdinalIndexOf(\"\", \"\", *)           = 0\n     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"a\", 1)  = 7\n     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"a\", 2)  = 6\n     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"b\", 1)  = 5\n     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"b\", 2)  = 2\n     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"ab\", 1) = 4\n     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"ab\", 2) = 1\n     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"\", 1)   = 8\n     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"\", 2)   = 8\n     * </pre>\n     *\n     * <p>Note that 'tail(String str, int n)' may be implemented as: </p>\n     *\n     * <pre>\n     *   str.substring(lastOrdinalIndexOf(str, \"\\n\", n) + 1)\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @param ordinal  the n-th last <code>searchStr</code> to find\n     * @return the n-th last index of the search String,\n     *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input\n     * @since 2.5\n     */\n    public static int lastOrdinalIndexOf(final String str, final String searchStr, final int ordinal) {\n        return StringUtils.ordinalIndexOf(str, searchStr, ordinal, true);\n    }\n\n    /**\n     * <p>Finds the first index within a String, handling <code>null</code>.\n     * This method uses {@link String#lastIndexOf(String, int)}.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A negative start position returns <code>-1</code>.\n     * An empty (\"\") search String always matches unless the start position is negative.\n     * A start position greater than the string length searches the whole string.</p>\n     *\n     * <pre>\n     * StringUtils.lastIndexOf(null, *, *)          = -1\n     * StringUtils.lastIndexOf(*, null, *)          = -1\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 8)  = 7\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 8)  = 5\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"ab\", 8) = 4\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 9)  = 5\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", -1) = -1\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 0)  = 0\n     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 0)  = -1\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @param startPos  the start position, negative treated as zero\n     * @return the first index of the search String,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.0\n     */\n    public static int lastIndexOf(final String str, final String searchStr, final int startPos) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return str.lastIndexOf(searchStr, startPos);\n    }\n\n    /**\n     * <p>Case in-sensitive find of the last index within a String.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A negative start position returns <code>-1</code>.\n     * An empty (\"\") search String always matches unless the start position is negative.\n     * A start position greater than the string length searches the whole string.</p>\n     *\n     * <pre>\n     * StringUtils.lastIndexOfIgnoreCase(null, *)          = -1\n     * StringUtils.lastIndexOfIgnoreCase(*, null)          = -1\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"A\")  = 7\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\")  = 5\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"AB\") = 4\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @return the first index of the search String,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.5\n     */\n    public static int lastIndexOfIgnoreCase(final String str, final String searchStr) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return StringUtils.lastIndexOfIgnoreCase(str, searchStr, str.length());\n    }\n\n    /**\n     * <p>Case in-sensitive find of the last index within a String\n     * from the specified position.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A negative start position returns <code>-1</code>.\n     * An empty (\"\") search String always matches unless the start position is negative.\n     * A start position greater than the string length searches the whole string.</p>\n     *\n     * <pre>\n     * StringUtils.lastIndexOfIgnoreCase(null, *, *)          = -1\n     * StringUtils.lastIndexOfIgnoreCase(*, null, *)          = -1\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"A\", 8)  = 7\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", 8)  = 5\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"AB\", 8) = 4\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", 9)  = 5\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", -1) = -1\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"A\", 0)  = 0\n     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", 0)  = -1\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @param startPos  the start position\n     * @return the first index of the search String,\n     *  -1 if no match or <code>null</code> string input\n     * @since 2.5\n     */\n    public static int lastIndexOfIgnoreCase(final String str, final String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        if (startPos > str.length() - searchStr.length()) {\n            startPos = str.length() - searchStr.length();\n        }\n        if (startPos < 0) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        if (searchStr.length() == 0) {\n            return startPos;\n        }\n        for (int i = startPos; i >= 0; i--) {\n            if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {\n                return i;\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n    // Contains\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if String contains a search character, handling <code>null</code>.\n     * This method uses {@link String#indexOf(int)}.</p>\n     *\n     * <p>A <code>null</code> or empty (\"\") String will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.contains(null, *)    = false\n     * StringUtils.contains(\"\", *)      = false\n     * StringUtils.contains(\"abc\", 'a') = true\n     * StringUtils.contains(\"abc\", 'z') = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChar  the character to find\n     * @return true if the String contains the search character,\n     *  false if not or <code>null</code> string input\n     * @since 2.0\n     */\n    public static boolean contains(final String str, final char searchChar) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        return str.indexOf(searchChar) >= 0;\n    }\n\n    /**\n     * <p>Checks if String contains a search String, handling <code>null</code>.\n     * This method uses {@link String#indexOf(String)}.</p>\n     *\n     * <p>A <code>null</code> String will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.contains(null, *)     = false\n     * StringUtils.contains(*, null)     = false\n     * StringUtils.contains(\"\", \"\")      = true\n     * StringUtils.contains(\"abc\", \"\")   = true\n     * StringUtils.contains(\"abc\", \"a\")  = true\n     * StringUtils.contains(\"abc\", \"z\")  = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @return true if the String contains the search String,\n     *  false if not or <code>null</code> string input\n     * @since 2.0\n     */\n    public static boolean contains(final String str, final String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        return str.contains(searchStr);\n    }\n\n    /**\n     * <p>Checks if String contains a search String irrespective of case,\n     * handling <code>null</code>. Case-insensitivity is defined as by\n     * {@link String#equalsIgnoreCase(String)}.\n     *\n     * <p>A <code>null</code> String will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.contains(null, *) = false\n     * StringUtils.contains(*, null) = false\n     * StringUtils.contains(\"\", \"\") = true\n     * StringUtils.contains(\"abc\", \"\") = true\n     * StringUtils.contains(\"abc\", \"a\") = true\n     * StringUtils.contains(\"abc\", \"z\") = false\n     * StringUtils.contains(\"abc\", \"A\") = true\n     * StringUtils.contains(\"abc\", \"Z\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @return true if the String contains the search String irrespective of\n     * case or false if not or <code>null</code> string input\n     */\n    public static boolean containsIgnoreCase(final String str, final String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        int len = searchStr.length();\n        int max = str.length() - len;\n        for (int i = 0; i <= max; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // IndexOfAny chars\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Search a String to find the first index of any\n     * character in the given set of characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A <code>null</code> or zero length search array will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.indexOfAny(null, *)                = -1\n     * StringUtils.indexOfAny(\"\", *)                  = -1\n     * StringUtils.indexOfAny(*, null)                = -1\n     * StringUtils.indexOfAny(*, [])                  = -1\n     * StringUtils.indexOfAny(\"zzabyycdxx\",['z','a']) = 0\n     * StringUtils.indexOfAny(\"zzabyycdxx\",['b','y']) = 3\n     * StringUtils.indexOfAny(\"aba\", ['z'])           = -1\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChars  the chars to search for, may be null\n     * @return the index of any of the chars, -1 if no match or null input\n     * @since 2.0\n     */\n    public static int indexOfAny(final String str, final char[] searchChars) {\n        if (StringUtils.isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        int csLen = str.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        for (int i = 0; i < csLen; i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && CharUtils.isHighSurrogate(ch)) {\n                        // ch is a supplementary character\n                        if (searchChars[j + 1] == str.charAt(i + 1)) {\n                            return i;\n                        }\n                    } else {\n                        return i;\n                    }\n                }\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Search a String to find the first index of any\n     * character in the given set of characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A <code>null</code> search string will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.indexOfAny(null, *)            = -1\n     * StringUtils.indexOfAny(\"\", *)              = -1\n     * StringUtils.indexOfAny(*, null)            = -1\n     * StringUtils.indexOfAny(*, \"\")              = -1\n     * StringUtils.indexOfAny(\"zzabyycdxx\", \"za\") = 0\n     * StringUtils.indexOfAny(\"zzabyycdxx\", \"by\") = 3\n     * StringUtils.indexOfAny(\"aba\",\"z\")          = -1\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChars  the chars to search for, may be null\n     * @return the index of any of the chars, -1 if no match or null input\n     * @since 2.0\n     */\n    public static int indexOfAny(final String str, final String searchChars) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(searchChars)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        return StringUtils.indexOfAny(str, searchChars.toCharArray());\n    }\n    // ContainsAny\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if the String contains any character in the given\n     * set of characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>false</code>.\n     * A <code>null</code> or zero length search array will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.containsAny(null, *)                = false\n     * StringUtils.containsAny(\"\", *)                  = false\n     * StringUtils.containsAny(*, null)                = false\n     * StringUtils.containsAny(*, [])                  = false\n     * StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true\n     * StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true\n     * StringUtils.containsAny(\"aba\", ['z'])           = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChars  the chars to search for, may be null\n     * @return the <code>true</code> if any of the chars are found,\n     * <code>false</code> if no match or null input\n     * @since 2.4\n     */\n    public static boolean containsAny(final String str, final char[] searchChars) {\n        if (StringUtils.isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n            return false;\n        }\n        int csLength = str.length();\n        int searchLength = searchChars.length;\n        int csLast = csLength - 1;\n        int searchLast = searchLength - 1;\n        for (int i = 0; i < csLength; i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchLength; j++) {\n                if (searchChars[j] == ch) {\n                    if (CharUtils.isHighSurrogate(ch)) {\n                        if (j == searchLast) {\n                            // missing low surrogate, fine, like String.indexOf(String)\n                            return true;\n                        }\n                        if (i < csLast && searchChars[j + 1] == str.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        // ch is in the Basic Multilingual Plane\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * <p>\n     * Checks if the String contains any character in the given set of characters.\n     * </p>\n     *\n     * <p>\n     * A <code>null</code> String will return <code>false</code>. A <code>null</code> search string will return\n     * <code>false</code>.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.containsAny(null, *)            = false\n     * StringUtils.containsAny(\"\", *)              = false\n     * StringUtils.containsAny(*, null)            = false\n     * StringUtils.containsAny(*, \"\")              = false\n     * StringUtils.containsAny(\"zzabyycdxx\", \"za\") = true\n     * StringUtils.containsAny(\"zzabyycdxx\", \"by\") = true\n     * StringUtils.containsAny(\"aba\",\"z\")          = false\n     * </pre>\n     *\n     * @param str\n     *            the String to check, may be null\n     * @param searchChars\n     *            the chars to search for, may be null\n     * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n     * @since 2.4\n     */\n    public static boolean containsAny(final String str, final String searchChars) {\n        if (searchChars == null) {\n            return false;\n        }\n        return StringUtils.containsAny(str, searchChars.toCharArray());\n    }\n    // IndexOfAnyBut chars\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Search a String to find the first index of any\n     * character not in the given set of characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A <code>null</code> or zero length search array will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.indexOfAnyBut(null, *)                              = -1\n     * StringUtils.indexOfAnyBut(\"\", *)                                = -1\n     * StringUtils.indexOfAnyBut(*, null)                              = -1\n     * StringUtils.indexOfAnyBut(*, [])                                = -1\n     * StringUtils.indexOfAnyBut(\"zzabyycdxx\", new char[] {'z', 'a'} ) = 3\n     * StringUtils.indexOfAnyBut(\"aba\", new char[] {'z'} )             = 0\n     * StringUtils.indexOfAnyBut(\"aba\", new char[] {'a', 'b'} )        = -1\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChars  the chars to search for, may be null\n     * @return the index of any of the chars, -1 if no match or null input\n     * @since 2.0\n     */\n    public static int indexOfAnyBut(final String str, final char[] searchChars) {\n        if (StringUtils.isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        int csLen = str.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        outer:\n        for (int i = 0; i < csLen; i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && CharUtils.isHighSurrogate(ch)) {\n                        if (searchChars[j + 1] == str.charAt(i + 1)) {\n                            continue outer;\n                        }\n                    } else {\n                        continue outer;\n                    }\n                }\n            }\n            return i;\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Search a String to find the first index of any\n     * character not in the given set of characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A <code>null</code> or empty search string will return <code>-1</code>.</p>\n     *\n     * <pre>\n     * StringUtils.indexOfAnyBut(null, *)            = -1\n     * StringUtils.indexOfAnyBut(\"\", *)              = -1\n     * StringUtils.indexOfAnyBut(*, null)            = -1\n     * StringUtils.indexOfAnyBut(*, \"\")              = -1\n     * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"za\") = 3\n     * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"\")   = -1\n     * StringUtils.indexOfAnyBut(\"aba\",\"ab\")         = -1\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChars  the chars to search for, may be null\n     * @return the index of any of the chars, -1 if no match or null input\n     * @since 2.0\n     */\n    public static int indexOfAnyBut(final String str, final String searchChars) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(searchChars)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            char ch = str.charAt(i);\n            boolean chFound = searchChars.indexOf(ch) >= 0;\n            if (i + 1 < strLen && CharUtils.isHighSurrogate(ch)) {\n                char ch2 = str.charAt(i + 1);\n                if (chFound && searchChars.indexOf(ch2) < 0) {\n                    return i;\n                }\n            } else {\n                if (!chFound) {\n                    return i;\n                }\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n    // ContainsOnly\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if the String contains only certain characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>false</code>.\n     * A <code>null</code> valid character array will return <code>false</code>.\n     * An empty String (length()=0) always returns <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.containsOnly(null, *)       = false\n     * StringUtils.containsOnly(*, null)       = false\n     * StringUtils.containsOnly(\"\", *)         = true\n     * StringUtils.containsOnly(\"ab\", '')      = false\n     * StringUtils.containsOnly(\"abab\", 'abc') = true\n     * StringUtils.containsOnly(\"ab1\", 'abc')  = false\n     * StringUtils.containsOnly(\"abz\", 'abc')  = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param valid  an array of valid chars, may be null\n     * @return true if it only contains valid chars and is non-null\n     */\n    public static boolean containsOnly(final String str, final char[] valid) {\n        // All these pre-checks are to maintain API with an older version\n        if (valid == null || str == null) {\n            return false;\n        }\n        if (str.length() == 0) {\n            return true;\n        }\n        if (valid.length == 0) {\n            return false;\n        }\n        return StringUtils.indexOfAnyBut(str, valid) == StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the String contains only certain characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>false</code>.\n     * A <code>null</code> valid character String will return <code>false</code>.\n     * An empty String (length()=0) always returns <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.containsOnly(null, *)       = false\n     * StringUtils.containsOnly(*, null)       = false\n     * StringUtils.containsOnly(\"\", *)         = true\n     * StringUtils.containsOnly(\"ab\", \"\")      = false\n     * StringUtils.containsOnly(\"abab\", \"abc\") = true\n     * StringUtils.containsOnly(\"ab1\", \"abc\")  = false\n     * StringUtils.containsOnly(\"abz\", \"abc\")  = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param validChars  a String of valid chars, may be null\n     * @return true if it only contains valid chars and is non-null\n     * @since 2.0\n     */\n    public static boolean containsOnly(final String str, final String validChars) {\n        if (str == null || validChars == null) {\n            return false;\n        }\n        return StringUtils.containsOnly(str, validChars.toCharArray());\n    }\n    // ContainsNone\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks that the String does not contain certain characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>true</code>.\n     * A <code>null</code> invalid character array will return <code>true</code>.\n     * An empty String (length()=0) always returns true.</p>\n     *\n     * <pre>\n     * StringUtils.containsNone(null, *)       = true\n     * StringUtils.containsNone(*, null)       = true\n     * StringUtils.containsNone(\"\", *)         = true\n     * StringUtils.containsNone(\"ab\", '')      = true\n     * StringUtils.containsNone(\"abab\", 'xyz') = true\n     * StringUtils.containsNone(\"ab1\", 'xyz')  = true\n     * StringUtils.containsNone(\"abz\", 'xyz')  = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchChars  an array of invalid chars, may be null\n     * @return true if it contains none of the invalid chars, or is null\n     * @since 2.0\n     */\n    public static boolean containsNone(final String str, final char[] searchChars) {\n        if (str == null || searchChars == null) {\n            return true;\n        }\n        int csLen = str.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        for (int i = 0; i < csLen; i++) {\n            char ch = str.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (CharUtils.isHighSurrogate(ch)) {\n                        if (j == searchLast) {\n                            // missing low surrogate, fine, like String.indexOf(String)\n                            return false;\n                        }\n                        if (i < csLast && searchChars[j + 1] == str.charAt(i + 1)) {\n                            return false;\n                        }\n                    } else {\n                        // ch is in the Basic Multilingual Plane\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks that the String does not contain certain characters.</p>\n     *\n     * <p>A <code>null</code> String will return <code>true</code>.\n     * A <code>null</code> invalid character array will return <code>true</code>.\n     * An empty String (\"\") always returns true.</p>\n     *\n     * <pre>\n     * StringUtils.containsNone(null, *)       = true\n     * StringUtils.containsNone(*, null)       = true\n     * StringUtils.containsNone(\"\", *)         = true\n     * StringUtils.containsNone(\"ab\", \"\")      = true\n     * StringUtils.containsNone(\"abab\", \"xyz\") = true\n     * StringUtils.containsNone(\"ab1\", \"xyz\")  = true\n     * StringUtils.containsNone(\"abz\", \"xyz\")  = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param invalidChars  a String of invalid chars, may be null\n     * @return true if it contains none of the invalid chars, or is null\n     * @since 2.0\n     */\n    public static boolean containsNone(final String str, final String invalidChars) {\n        if (str == null || invalidChars == null) {\n            return true;\n        }\n        return StringUtils.containsNone(str, invalidChars.toCharArray());\n    }\n    // IndexOfAny strings\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Find the first index of any of a set of potential substrings.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A <code>null</code> or zero length search array will return <code>-1</code>.\n     * A <code>null</code> search array entry will be ignored, but a search\n     * array containing \"\" will return <code>0</code> if <code>str</code> is not\n     * null. This method uses {@link String#indexOf(String)}.</p>\n     *\n     * <pre>\n     * StringUtils.indexOfAny(null, *)                     = -1\n     * StringUtils.indexOfAny(*, null)                     = -1\n     * StringUtils.indexOfAny(*, [])                       = -1\n     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"ab\",\"cd\"])   = 2\n     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"cd\",\"ab\"])   = 2\n     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"])   = -1\n     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"zab\",\"aby\"]) = 1\n     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"\"])          = 0\n     * StringUtils.indexOfAny(\"\", [\"\"])                    = 0\n     * StringUtils.indexOfAny(\"\", [\"a\"])                   = -1\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStrs  the Strings to search for, may be null\n     * @return the first index of any of the searchStrs in str, -1 if no match\n     */\n    public static int indexOfAny(final String str, final String[] searchStrs) {\n        if (str == null || searchStrs == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        int sz = searchStrs.length;\n        // String's can't have a MAX_VALUEth index.\n        int ret = Integer.MAX_VALUE;\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            String search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = str.indexOf(search);\n            if (tmp == StringUtils.INDEX_NOT_FOUND) {\n                continue;\n            }\n            if (tmp < ret) {\n                ret = tmp;\n            }\n        }\n        return ret == Integer.MAX_VALUE ? StringUtils.INDEX_NOT_FOUND : ret;\n    }\n\n    /**\n     * <p>Find the latest index of any of a set of potential substrings.</p>\n     *\n     * <p>A <code>null</code> String will return <code>-1</code>.\n     * A <code>null</code> search array will return <code>-1</code>.\n     * A <code>null</code> or zero length search array entry will be ignored,\n     * but a search array containing \"\" will return the length of <code>str</code>\n     * if <code>str</code> is not null. This method uses {@link String#indexOf(String)}</p>\n     *\n     * <pre>\n     * StringUtils.lastIndexOfAny(null, *)                   = -1\n     * StringUtils.lastIndexOfAny(*, null)                   = -1\n     * StringUtils.lastIndexOfAny(*, [])                     = -1\n     * StringUtils.lastIndexOfAny(*, [null])                 = -1\n     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"ab\",\"cd\"]) = 6\n     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"cd\",\"ab\"]) = 6\n     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"]) = -1\n     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"]) = -1\n     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"\"])   = 10\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStrs  the Strings to search for, may be null\n     * @return the last index of any of the Strings, -1 if no match\n     */\n    public static int lastIndexOfAny(final String str, final String[] searchStrs) {\n        if (str == null || searchStrs == null) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        int sz = searchStrs.length;\n        int ret = StringUtils.INDEX_NOT_FOUND;\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            String search = searchStrs[i];\n            if (search == null) {\n                continue;\n            }\n            tmp = str.lastIndexOf(search);\n            if (tmp > ret) {\n                ret = tmp;\n            }\n        }\n        return ret;\n    }\n    // Substring\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Gets a substring from the specified String avoiding exceptions.</p>\n     *\n     * <p>A negative start position can be used to start <code>n</code>\n     * characters from the end of the String.</p>\n     *\n     * <p>A <code>null</code> String will return <code>null</code>.\n     * An empty (\"\") String will return \"\".</p>\n     *\n     * <pre>\n     * StringUtils.substring(null, *)   = null\n     * StringUtils.substring(\"\", *)     = \"\"\n     * StringUtils.substring(\"abc\", 0)  = \"abc\"\n     * StringUtils.substring(\"abc\", 2)  = \"c\"\n     * StringUtils.substring(\"abc\", 4)  = \"\"\n     * StringUtils.substring(\"abc\", -2) = \"bc\"\n     * StringUtils.substring(\"abc\", -4) = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to get the substring from, may be null\n     * @param start  the position to start from, negative means\n     *  count back from the end of the String by this many characters\n     * @return substring from start position, <code>null</code> if null String input\n     */\n    public static String substring(final String str, int start) {\n        if (str == null) {\n            return null;\n        }\n        // handle negatives, which means last n characters\n        if (start < 0) {\n            start = str.length() + start; // remember start is negative\n        }\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > str.length()) {\n            return StringUtils.EMPTY;\n        }\n        return str.substring(start);\n    }\n\n    /**\n     * <p>Gets a substring from the specified String avoiding exceptions.</p>\n     *\n     * <p>A negative start position can be used to start/end <code>n</code>\n     * characters from the end of the String.</p>\n     *\n     * <p>The returned substring starts with the character in the <code>start</code>\n     * position and ends before the <code>end</code> position. All position counting is\n     * zero-based -- i.e., to start at the beginning of the string use\n     * <code>start = 0</code>. Negative start and end positions can be used to\n     * specify offsets relative to the end of the String.</p>\n     *\n     * <p>If <code>start</code> is not strictly to the left of <code>end</code>, \"\"\n     * is returned.</p>\n     *\n     * <pre>\n     * StringUtils.substring(null, *, *)    = null\n     * StringUtils.substring(\"\", * ,  *)    = \"\";\n     * StringUtils.substring(\"abc\", 0, 2)   = \"ab\"\n     * StringUtils.substring(\"abc\", 2, 0)   = \"\"\n     * StringUtils.substring(\"abc\", 2, 4)   = \"c\"\n     * StringUtils.substring(\"abc\", 4, 6)   = \"\"\n     * StringUtils.substring(\"abc\", 2, 2)   = \"\"\n     * StringUtils.substring(\"abc\", -2, -1) = \"b\"\n     * StringUtils.substring(\"abc\", -4, 2)  = \"ab\"\n     * </pre>\n     *\n     * @param str  the String to get the substring from, may be null\n     * @param start  the position to start from, negative means\n     *  count back from the end of the String by this many characters\n     * @param end  the position to end at (exclusive), negative means\n     *  count back from the end of the String by this many characters\n     * @return substring from start position to end positon,\n     *  <code>null</code> if null String input\n     */\n    public static String substring(final String str, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n        // handle negatives\n        if (end < 0) {\n            end = str.length() + end; // remember end is negative\n        }\n        if (start < 0) {\n            start = str.length() + start; // remember start is negative\n        }\n        // check length next\n        if (end > str.length()) {\n            end = str.length();\n        }\n        // if start is greater than end, return \"\"\n        if (start > end) {\n            return StringUtils.EMPTY;\n        }\n        if (start < 0) {\n            start = 0;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n        return str.substring(start, end);\n    }\n    // Left/Right/Mid\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Gets the leftmost <code>len</code> characters of a String.</p>\n     *\n     * <p>If <code>len</code> characters are not available, or the\n     * String is <code>null</code>, the String will be returned without\n     * an exception. An empty String is returned if len is negative.</p>\n     *\n     * <pre>\n     * StringUtils.left(null, *)    = null\n     * StringUtils.left(*, -ve)     = \"\"\n     * StringUtils.left(\"\", *)      = \"\"\n     * StringUtils.left(\"abc\", 0)   = \"\"\n     * StringUtils.left(\"abc\", 2)   = \"ab\"\n     * StringUtils.left(\"abc\", 4)   = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to get the leftmost characters from, may be null\n     * @param len  the length of the required String\n     * @return the leftmost characters, <code>null</code> if null String input\n     */\n    public static String left(final String str, final int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return StringUtils.EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(0, len);\n    }\n\n    /**\n     * <p>Gets the rightmost <code>len</code> characters of a String.</p>\n     *\n     * <p>If <code>len</code> characters are not available, or the String\n     * is <code>null</code>, the String will be returned without an\n     * an exception. An empty String is returned if len is negative.</p>\n     *\n     * <pre>\n     * StringUtils.right(null, *)    = null\n     * StringUtils.right(*, -ve)     = \"\"\n     * StringUtils.right(\"\", *)      = \"\"\n     * StringUtils.right(\"abc\", 0)   = \"\"\n     * StringUtils.right(\"abc\", 2)   = \"bc\"\n     * StringUtils.right(\"abc\", 4)   = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to get the rightmost characters from, may be null\n     * @param len  the length of the required String\n     * @return the rightmost characters, <code>null</code> if null String input\n     */\n    public static String right(final String str, final int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0) {\n            return StringUtils.EMPTY;\n        }\n        if (str.length() <= len) {\n            return str;\n        }\n        return str.substring(str.length() - len);\n    }\n\n    /**\n     * <p>Gets <code>len</code> characters from the middle of a String.</p>\n     *\n     * <p>If <code>len</code> characters are not available, the remainder\n     * of the String will be returned without an exception. If the\n     * String is <code>null</code>, <code>null</code> will be returned.\n     * An empty String is returned if len is negative or exceeds the\n     * length of <code>str</code>.</p>\n     *\n     * <pre>\n     * StringUtils.mid(null, *, *)    = null\n     * StringUtils.mid(*, *, -ve)     = \"\"\n     * StringUtils.mid(\"\", 0, *)      = \"\"\n     * StringUtils.mid(\"abc\", 0, 2)   = \"ab\"\n     * StringUtils.mid(\"abc\", 0, 4)   = \"abc\"\n     * StringUtils.mid(\"abc\", 2, 4)   = \"c\"\n     * StringUtils.mid(\"abc\", 4, 2)   = \"\"\n     * StringUtils.mid(\"abc\", -2, 2)  = \"ab\"\n     * </pre>\n     *\n     * @param str  the String to get the characters from, may be null\n     * @param pos  the position to start from, negative treated as zero\n     * @param len  the length of the required String\n     * @return the middle characters, <code>null</code> if null String input\n     */\n    public static String mid(final String str, int pos, final int len) {\n        if (str == null) {\n            return null;\n        }\n        if (len < 0 || pos > str.length()) {\n            return StringUtils.EMPTY;\n        }\n        if (pos < 0) {\n            pos = 0;\n        }\n        if (str.length() <= pos + len) {\n            return str.substring(pos);\n        }\n        return str.substring(pos, pos + len);\n    }\n    // SubStringAfter/SubStringBefore\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Gets the substring before the first occurrence of a separator.\n     * The separator is not returned.</p>\n     *\n     * <p>A <code>null</code> string input will return <code>null</code>.\n     * An empty (\"\") string input will return the empty string.\n     * A <code>null</code> separator will return the input string.</p>\n     *\n     * <p>If nothing is found, the string input is returned.</p>\n     *\n     * <pre>\n     * StringUtils.substringBefore(null, *)      = null\n     * StringUtils.substringBefore(\"\", *)        = \"\"\n     * StringUtils.substringBefore(\"abc\", \"a\")   = \"\"\n     * StringUtils.substringBefore(\"abcba\", \"b\") = \"a\"\n     * StringUtils.substringBefore(\"abc\", \"c\")   = \"ab\"\n     * StringUtils.substringBefore(\"abc\", \"d\")   = \"abc\"\n     * StringUtils.substringBefore(\"abc\", \"\")    = \"\"\n     * StringUtils.substringBefore(\"abc\", null)  = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to get a substring from, may be null\n     * @param separator  the String to search for, may be null\n     * @return the substring before the first occurrence of the separator,\n     *  <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String substringBefore(final String str, final String separator) {\n        if (StringUtils.isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (separator.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == StringUtils.INDEX_NOT_FOUND) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }\n\n    /**\n     * <p>Gets the substring after the first occurrence of a separator.\n     * The separator is not returned.</p>\n     *\n     * <p>A <code>null</code> string input will return <code>null</code>.\n     * An empty (\"\") string input will return the empty string.\n     * A <code>null</code> separator will return the empty string if the\n     * input string is not <code>null</code>.</p>\n     *\n     * <p>If nothing is found, the empty string is returned.</p>\n     *\n     * <pre>\n     * StringUtils.substringAfter(null, *)      = null\n     * StringUtils.substringAfter(\"\", *)        = \"\"\n     * StringUtils.substringAfter(*, null)      = \"\"\n     * StringUtils.substringAfter(\"abc\", \"a\")   = \"bc\"\n     * StringUtils.substringAfter(\"abcba\", \"b\") = \"cba\"\n     * StringUtils.substringAfter(\"abc\", \"c\")   = \"\"\n     * StringUtils.substringAfter(\"abc\", \"d\")   = \"\"\n     * StringUtils.substringAfter(\"abc\", \"\")    = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to get a substring from, may be null\n     * @param separator  the String to search for, may be null\n     * @return the substring after the first occurrence of the separator,\n     *  <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String substringAfter(final String str, final String separator) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        if (separator == null) {\n            return StringUtils.EMPTY;\n        }\n        int pos = str.indexOf(separator);\n        if (pos == StringUtils.INDEX_NOT_FOUND) {\n            return StringUtils.EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }\n\n    /**\n     * <p>Gets the substring before the last occurrence of a separator.\n     * The separator is not returned.</p>\n     *\n     * <p>A <code>null</code> string input will return <code>null</code>.\n     * An empty (\"\") string input will return the empty string.\n     * An empty or <code>null</code> separator will return the input string.</p>\n     *\n     * <p>If nothing is found, the string input is returned.</p>\n     *\n     * <pre>\n     * StringUtils.substringBeforeLast(null, *)      = null\n     * StringUtils.substringBeforeLast(\"\", *)        = \"\"\n     * StringUtils.substringBeforeLast(\"abcba\", \"b\") = \"abc\"\n     * StringUtils.substringBeforeLast(\"abc\", \"c\")   = \"ab\"\n     * StringUtils.substringBeforeLast(\"a\", \"a\")     = \"\"\n     * StringUtils.substringBeforeLast(\"a\", \"z\")     = \"a\"\n     * StringUtils.substringBeforeLast(\"a\", null)    = \"a\"\n     * StringUtils.substringBeforeLast(\"a\", \"\")      = \"a\"\n     * </pre>\n     *\n     * @param str  the String to get a substring from, may be null\n     * @param separator  the String to search for, may be null\n     * @return the substring before the last occurrence of the separator,\n     *  <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String substringBeforeLast(final String str, final String separator) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(separator)) {\n            return str;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == StringUtils.INDEX_NOT_FOUND) {\n            return str;\n        }\n        return str.substring(0, pos);\n    }\n\n    /**\n     * <p>Gets the substring after the last occurrence of a separator.\n     * The separator is not returned.</p>\n     *\n     * <p>A <code>null</code> string input will return <code>null</code>.\n     * An empty (\"\") string input will return the empty string.\n     * An empty or <code>null</code> separator will return the empty string if\n     * the input string is not <code>null</code>.</p>\n     *\n     * <p>If nothing is found, the empty string is returned.</p>\n     *\n     * <pre>\n     * StringUtils.substringAfterLast(null, *)      = null\n     * StringUtils.substringAfterLast(\"\", *)        = \"\"\n     * StringUtils.substringAfterLast(*, \"\")        = \"\"\n     * StringUtils.substringAfterLast(*, null)      = \"\"\n     * StringUtils.substringAfterLast(\"abc\", \"a\")   = \"bc\"\n     * StringUtils.substringAfterLast(\"abcba\", \"b\") = \"a\"\n     * StringUtils.substringAfterLast(\"abc\", \"c\")   = \"\"\n     * StringUtils.substringAfterLast(\"a\", \"a\")     = \"\"\n     * StringUtils.substringAfterLast(\"a\", \"z\")     = \"\"\n     * </pre>\n     *\n     * @param str  the String to get a substring from, may be null\n     * @param separator  the String to search for, may be null\n     * @return the substring after the last occurrence of the separator,\n     *  <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String substringAfterLast(final String str, final String separator) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        if (StringUtils.isEmpty(separator)) {\n            return StringUtils.EMPTY;\n        }\n        int pos = str.lastIndexOf(separator);\n        if (pos == StringUtils.INDEX_NOT_FOUND || pos == str.length() - separator.length()) {\n            return StringUtils.EMPTY;\n        }\n        return str.substring(pos + separator.length());\n    }\n    // Substring between\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Gets the String that is nested in between two instances of the\n     * same String.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> tag returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.substringBetween(null, *)            = null\n     * StringUtils.substringBetween(\"\", \"\")             = \"\"\n     * StringUtils.substringBetween(\"\", \"tag\")          = null\n     * StringUtils.substringBetween(\"tagabctag\", null)  = null\n     * StringUtils.substringBetween(\"tagabctag\", \"\")    = \"\"\n     * StringUtils.substringBetween(\"tagabctag\", \"tag\") = \"abc\"\n     * </pre>\n     *\n     * @param str  the String containing the substring, may be null\n     * @param tag  the String before and after the substring, may be null\n     * @return the substring, <code>null</code> if no match\n     * @since 2.0\n     */\n    public static String substringBetween(final String str, final String tag) {\n        return StringUtils.substringBetween(str, tag, tag);\n    }\n\n    /**\n     * <p>Gets the String that is nested in between two Strings.\n     * Only the first match is returned.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> open/close returns <code>null</code> (no match).\n     * An empty (\"\") open and close returns an empty string.</p>\n     *\n     * <pre>\n     * StringUtils.substringBetween(\"wx[b]yz\", \"[\", \"]\") = \"b\"\n     * StringUtils.substringBetween(null, *, *)          = null\n     * StringUtils.substringBetween(*, null, *)          = null\n     * StringUtils.substringBetween(*, *, null)          = null\n     * StringUtils.substringBetween(\"\", \"\", \"\")          = \"\"\n     * StringUtils.substringBetween(\"\", \"\", \"]\")         = null\n     * StringUtils.substringBetween(\"\", \"[\", \"]\")        = null\n     * StringUtils.substringBetween(\"yabcz\", \"\", \"\")     = \"\"\n     * StringUtils.substringBetween(\"yabcz\", \"y\", \"z\")   = \"abc\"\n     * StringUtils.substringBetween(\"yabczyabcz\", \"y\", \"z\")   = \"abc\"\n     * </pre>\n     *\n     * @param str  the String containing the substring, may be null\n     * @param open  the String before the substring, may be null\n     * @param close  the String after the substring, may be null\n     * @return the substring, <code>null</code> if no match\n     * @since 2.0\n     */\n    public static String substringBetween(final String str, final String open, final String close) {\n        if (str == null || open == null || close == null) {\n            return null;\n        }\n        int start = str.indexOf(open);\n        if (start != StringUtils.INDEX_NOT_FOUND) {\n            int end = str.indexOf(close, start + open.length());\n            if (end != StringUtils.INDEX_NOT_FOUND) {\n                return str.substring(start + open.length(), end);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * <p>Searches a String for substrings delimited by a start and end tag,\n     * returning all matching substrings in an array.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> open/close returns <code>null</code> (no match).\n     * An empty (\"\") open/close returns <code>null</code> (no match).</p>\n     *\n     * <pre>\n     * StringUtils.substringsBetween(\"[a][b][c]\", \"[\", \"]\") = [\"a\",\"b\",\"c\"]\n     * StringUtils.substringsBetween(null, *, *)            = null\n     * StringUtils.substringsBetween(*, null, *)            = null\n     * StringUtils.substringsBetween(*, *, null)            = null\n     * StringUtils.substringsBetween(\"\", \"[\", \"]\")          = []\n     * </pre>\n     *\n     * @param str  the String containing the substrings, null returns null, empty returns empty\n     * @param open  the String identifying the start of the substring, empty returns null\n     * @param close  the String identifying the end of the substring, empty returns null\n     * @return a String Array of substrings, or <code>null</code> if no match\n     * @since 2.3\n     */\n    public static String[] substringsBetween(final String str, final String open, final String close) {\n        if (str == null || StringUtils.isEmpty(open) || StringUtils.isEmpty(close)) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        int closeLen = close.length();\n        int openLen = open.length();\n        List<String> list = new ArrayList<String>();\n        int pos = 0;\n        while (pos < strLen - closeLen) {\n            int start = str.indexOf(open, pos);\n            if (start < 0) {\n                break;\n            }\n            start += openLen;\n            int end = str.indexOf(close, start);\n            if (end < 0) {\n                break;\n            }\n            list.add(str.substring(start, end));\n            pos = end + closeLen;\n        }\n        if (list.isEmpty()) {\n            return null;\n        }\n        return list.toArray(new String[list.size()]);\n    }\n    // Splitting\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Splits the provided text into an array, using whitespace as the separator. but keep separator.</p>\n     *\n     * <pre>\n     * StringUtils.splitKeep(null)          = null\n     * StringUtils.splitKeep(\"\")            = []\n     * StringUtils.splitKeep(\"a b c\", \" \")  = [\"a\", \" \", \"b\", \" \", \"c\"]\n     * StringUtils.splitKeep(\"abc def\", \" \")= [\"abc\", \" \", \"def\"]\n     * StringUtils.splitKeep(\" abc \", \" \")  = [\" \", \"abc\", \" \"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    public static String[] splitKeep(String str, char separatorChar) {\n        return splitKeep(str, String.valueOf(separatorChar));\n    }\n\n    /**\n     * <p>Splits the provided text into an array, using whitespace as the separator. but keep separator.</p>\n     *\n     * <pre>\n     * StringUtils.splitKeep(null)          = null\n     * StringUtils.splitKeep(\"\")            = []\n     * StringUtils.splitKeep(\"a b c\", \" \")  = [\"a\", \" \", \"b\", \" \", \"c\"]\n     * StringUtils.splitKeep(\"abc def\", \" \")= [\"abc\", \" \", \"def\"]\n     * StringUtils.splitKeep(\" abc \", \" \")  = [\" \", \"abc\", \" \"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    public static String[] splitKeep(String str, String separatorStr) {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        int CHARS = separatorStr.length();\n        if (CHARS == 0) {\n            throw new IllegalArgumentException(\"chars must be > 0\");\n        }\n        int lastIndex = 0;\n        ArrayList<String> dat = new ArrayList<>();\n        while (true) {\n            int lookIndex = str.indexOf(separatorStr, lastIndex);\n            if (lookIndex == -1) {\n                String substring = str.substring(lastIndex);\n                if (substring.length() > 0) {\n                    dat.add(substring);\n                }\n                break;\n            } else {\n                if (lastIndex != lookIndex) {\n                    String term = str.substring(lastIndex, lookIndex);\n                    dat.add(term);\n                }\n                dat.add(separatorStr);\n                lastIndex = lookIndex + CHARS;\n            }\n        }\n        return dat.toArray(new String[0]);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, using whitespace as the\n     * separator.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as one separator.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.split(null)       = null\n     * StringUtils.split(\"\")         = []\n     * StringUtils.split(\"abc def\")  = [\"abc\", \"def\"]\n     * StringUtils.split(\"abc  def\") = [\"abc\", \"def\"]\n     * StringUtils.split(\" abc \")    = [\"abc\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    public static String[] split(final String str) {\n        return StringUtils.split(str, null, -1);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, separator specified.\n     * This is an alternative to using StringTokenizer.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as one separator.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.split(null, *)         = null\n     * StringUtils.split(\"\", *)           = []\n     * StringUtils.split(\"a.b.c\", '.')    = [\"a\", \"b\", \"c\"]\n     * StringUtils.split(\"a..b.c\", '.')   = [\"a\", \"b\", \"c\"]\n     * StringUtils.split(\"a:b:c\", '.')    = [\"a:b:c\"]\n     * StringUtils.split(\"a b c\", ' ')    = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separatorChar  the character used as the delimiter\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String[] split(final String str, final char separatorChar) {\n        return StringUtils.splitWorker(str, separatorChar, false);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, separators specified.\n     * This is an alternative to using StringTokenizer.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as one separator.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separatorChars splits on whitespace.</p>\n     *\n     * <pre>\n     * StringUtils.split(null, *)         = null\n     * StringUtils.split(\"\", *)           = []\n     * StringUtils.split(\"abc def\", null) = [\"abc\", \"def\"]\n     * StringUtils.split(\"abc def\", \" \")  = [\"abc\", \"def\"]\n     * StringUtils.split(\"abc  def\", \" \") = [\"abc\", \"def\"]\n     * StringUtils.split(\"ab:cd:ef\", \":\") = [\"ab\", \"cd\", \"ef\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separatorChars  the characters used as the delimiters,\n     *  <code>null</code> splits on whitespace\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    public static String[] split(final String str, final String separatorChars) {\n        return StringUtils.splitWorker(str, separatorChars, -1, false);\n    }\n\n    /**\n     * <p>Splits the provided text into an array with a maximum length,\n     * separators specified.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as one separator.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separatorChars splits on whitespace.</p>\n     *\n     * <p>If more than <code>max</code> delimited substrings are found, the last\n     * returned string includes all characters after the first <code>max - 1</code>\n     * returned strings (including separator characters).</p>\n     *\n     * <pre>\n     * StringUtils.split(null, *, *)            = null\n     * StringUtils.split(\"\", *, *)              = []\n     * StringUtils.split(\"ab de fg\", null, 0)   = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.split(\"ab   de fg\", null, 0) = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.split(\"ab:cd:ef\", \":\", 0)    = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.split(\"ab:cd:ef\", \":\", 2)    = [\"ab\", \"cd:ef\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separatorChars  the characters used as the delimiters,\n     *  <code>null</code> splits on whitespace\n     * @param max  the maximum number of elements to include in the\n     *  array. A zero or negative value implies no limit\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    public static String[] split(final String str, final String separatorChars, final int max) {\n        return StringUtils.splitWorker(str, separatorChars, max, false);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, separator string specified.</p>\n     *\n     * <p>The separator(s) will not be included in the returned String array.\n     * Adjacent separators are treated as one separator.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separator splits on whitespace.</p>\n     *\n     * <pre>\n     * StringUtils.splitByWholeSeparator(null, *)               = null\n     * StringUtils.splitByWholeSeparator(\"\", *)                 = []\n     * StringUtils.splitByWholeSeparator(\"ab de fg\", null)      = [\"ab\", \"de\", \"fg\"]\n     * StringUtils.splitByWholeSeparator(\"ab   de fg\", null)    = [\"ab\", \"de\", \"fg\"]\n     * StringUtils.splitByWholeSeparator(\"ab:cd:ef\", \":\")       = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\") = [\"ab\", \"cd\", \"ef\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separator  String containing the String to be used as a delimiter,\n     *  <code>null</code> splits on whitespace\n     * @return an array of parsed Strings, <code>null</code> if null String was input\n     */\n    public static String[] splitByWholeSeparator(final String str, final String separator) {\n        return StringUtils.splitByWholeSeparatorWorker(str, separator, -1, false);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, separator string specified.\n     * Returns a maximum of <code>max</code> substrings.</p>\n     *\n     * <p>The separator(s) will not be included in the returned String array.\n     * Adjacent separators are treated as one separator.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separator splits on whitespace.</p>\n     *\n     * <pre>\n     * StringUtils.splitByWholeSeparator(null, *, *)               = null\n     * StringUtils.splitByWholeSeparator(\"\", *, *)                 = []\n     * StringUtils.splitByWholeSeparator(\"ab de fg\", null, 0)      = [\"ab\", \"de\", \"fg\"]\n     * StringUtils.splitByWholeSeparator(\"ab   de fg\", null, 0)    = [\"ab\", \"de\", \"fg\"]\n     * StringUtils.splitByWholeSeparator(\"ab:cd:ef\", \":\", 2)       = [\"ab\", \"cd:ef\"]\n     * StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\", 5) = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\", 2) = [\"ab\", \"cd-!-ef\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separator  String containing the String to be used as a delimiter,\n     *  <code>null</code> splits on whitespace\n     * @param max  the maximum number of elements to include in the returned\n     *  array. A zero or negative value implies no limit.\n     * @return an array of parsed Strings, <code>null</code> if null String was input\n     */\n    public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {\n        return StringUtils.splitByWholeSeparatorWorker(str, separator, max, false);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, separator string specified. </p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as separators for empty tokens.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separator splits on whitespace.</p>\n     *\n     * <pre>\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *)               = null\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"\", *)                 = []\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab de fg\", null)      = [\"ab\", \"de\", \"fg\"]\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab   de fg\", null)    = [\"ab\", \"\", \"\", \"de\", \"fg\"]\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab:cd:ef\", \":\")       = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\") = [\"ab\", \"cd\", \"ef\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separator  String containing the String to be used as a delimiter,\n     *  <code>null</code> splits on whitespace\n     * @return an array of parsed Strings, <code>null</code> if null String was input\n     * @since 2.4\n     */\n    public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator) {\n        return StringUtils.splitByWholeSeparatorWorker(str, separator, -1, true);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, separator string specified.\n     * Returns a maximum of <code>max</code> substrings.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as separators for empty tokens.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separator splits on whitespace.</p>\n     *\n     * <pre>\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *, *)               = null\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"\", *, *)                 = []\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab de fg\", null, 0)      = [\"ab\", \"de\", \"fg\"]\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab   de fg\", null, 0)    = [\"ab\", \"\", \"\", \"de\", \"fg\"]\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab:cd:ef\", \":\", 2)       = [\"ab\", \"cd:ef\"]\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\", 5) = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\", 2) = [\"ab\", \"cd-!-ef\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be null\n     * @param separator  String containing the String to be used as a delimiter,\n     *  <code>null</code> splits on whitespace\n     * @param max  the maximum number of elements to include in the returned\n     *  array. A zero or negative value implies no limit.\n     * @return an array of parsed Strings, <code>null</code> if null String was input\n     * @since 2.4\n     */\n    public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {\n        return StringUtils.splitByWholeSeparatorWorker(str, separator, max, true);\n    }\n\n    /**\n     * Performs the logic for the <code>splitByWholeSeparatorPreserveAllTokens</code> methods.\n     *\n     * @param str  the String to parse, may be <code>null</code>\n     * @param separator  String containing the String to be used as a delimiter,\n     *  <code>null</code> splits on whitespace\n     * @param max  the maximum number of elements to include in the returned\n     *  array. A zero or negative value implies no limit.\n     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n     * treated as empty token separators; if <code>false</code>, adjacent\n     * separators are treated as one separator.\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.4\n     */\n    private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        if (separator == null || StringUtils.EMPTY.equals(separator)) {\n            // Split on whitespace.\n            return StringUtils.splitWorker(str, null, max, preserveAllTokens);\n        }\n        int separatorLength = separator.length();\n        ArrayList<String> substrings = new ArrayList<>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(StringUtils.EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n        return substrings.toArray(new String[0]);\n    }\n    // -----------------------------------------------------------------------\n\n    /**\n     * <p>Splits the provided text into an array, using whitespace as the\n     * separator, preserving all tokens, including empty tokens created by\n     * adjacent separators. This is an alternative to using StringTokenizer.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as separators for empty tokens.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.splitPreserveAllTokens(null)       = null\n     * StringUtils.splitPreserveAllTokens(\"\")         = []\n     * StringUtils.splitPreserveAllTokens(\"abc def\")  = [\"abc\", \"def\"]\n     * StringUtils.splitPreserveAllTokens(\"abc  def\") = [\"abc\", \"\", \"def\"]\n     * StringUtils.splitPreserveAllTokens(\" abc \")    = [\"\", \"abc\", \"\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be <code>null</code>\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String[] splitPreserveAllTokens(final String str) {\n        return StringUtils.splitWorker(str, null, -1, true);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, separator specified,\n     * preserving all tokens, including empty tokens created by adjacent\n     * separators. This is an alternative to using StringTokenizer.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as separators for empty tokens.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.splitPreserveAllTokens(null, *)         = null\n     * StringUtils.splitPreserveAllTokens(\"\", *)           = []\n     * StringUtils.splitPreserveAllTokens(\"a.b.c\", '.')    = [\"a\", \"b\", \"c\"]\n     * StringUtils.splitPreserveAllTokens(\"a..b.c\", '.')   = [\"a\", \"\", \"b\", \"c\"]\n     * StringUtils.splitPreserveAllTokens(\"a:b:c\", '.')    = [\"a:b:c\"]\n     * StringUtils.splitPreserveAllTokens(\"a\\tb\\nc\", null) = [\"a\", \"b\", \"c\"]\n     * StringUtils.splitPreserveAllTokens(\"a b c\", ' ')    = [\"a\", \"b\", \"c\"]\n     * StringUtils.splitPreserveAllTokens(\"a b c \", ' ')   = [\"a\", \"b\", \"c\", \"\"]\n     * StringUtils.splitPreserveAllTokens(\"a b c  \", ' ')   = [\"a\", \"b\", \"c\", \"\", \"\"]\n     * StringUtils.splitPreserveAllTokens(\" a b c\", ' ')   = [\"\", a\", \"b\", \"c\"]\n     * StringUtils.splitPreserveAllTokens(\"  a b c\", ' ')  = [\"\", \"\", a\", \"b\", \"c\"]\n     * StringUtils.splitPreserveAllTokens(\" a b c \", ' ')  = [\"\", a\", \"b\", \"c\", \"\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be <code>null</code>\n     * @param separatorChar  the character used as the delimiter,\n     *  <code>null</code> splits on whitespace\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String[] splitPreserveAllTokens(final String str, final char separatorChar) {\n        return StringUtils.splitWorker(str, separatorChar, true);\n    }\n\n    /**\n     * Performs the logic for the <code>split</code> and\n     * <code>splitPreserveAllTokens</code> methods that do not return a\n     * maximum array length.\n     *\n     * @param str  the String to parse, may be <code>null</code>\n     * @param separatorChar the separate character\n     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n     * treated as empty token separators; if <code>false</code>, adjacent\n     * separators are treated as one separator.\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<>();\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        while (i < len) {\n            if (str.charAt(i) == separatorChar) {\n                if (match || preserveAllTokens) {\n                    list.add(str.substring(start, i));\n                    match = false;\n                    lastMatch = true;\n                }\n                start = ++i;\n                continue;\n            }\n            lastMatch = false;\n            match = true;\n            i++;\n        }\n        if (match || preserveAllTokens && lastMatch) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[0]);\n    }\n\n    /**\n     * <p>Splits the provided text into an array, separators specified,\n     * preserving all tokens, including empty tokens created by adjacent\n     * separators. This is an alternative to using StringTokenizer.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as separators for empty tokens.\n     * For more control over the split use the StrTokenizer class.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separatorChars splits on whitespace.</p>\n     *\n     * <pre>\n     * StringUtils.splitPreserveAllTokens(null, *)           = null\n     * StringUtils.splitPreserveAllTokens(\"\", *)             = []\n     * StringUtils.splitPreserveAllTokens(\"abc def\", null)   = [\"abc\", \"def\"]\n     * StringUtils.splitPreserveAllTokens(\"abc def\", \" \")    = [\"abc\", \"def\"]\n     * StringUtils.splitPreserveAllTokens(\"abc  def\", \" \")   = [\"abc\", \"\", def\"]\n     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\")   = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef:\", \":\")  = [\"ab\", \"cd\", \"ef\", \"\"]\n     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef::\", \":\") = [\"ab\", \"cd\", \"ef\", \"\", \"\"]\n     * StringUtils.splitPreserveAllTokens(\"ab::cd:ef\", \":\")  = [\"ab\", \"\", cd\", \"ef\"]\n     * StringUtils.splitPreserveAllTokens(\":cd:ef\", \":\")     = [\"\", cd\", \"ef\"]\n     * StringUtils.splitPreserveAllTokens(\"::cd:ef\", \":\")    = [\"\", \"\", cd\", \"ef\"]\n     * StringUtils.splitPreserveAllTokens(\":cd:ef:\", \":\")    = [\"\", cd\", \"ef\", \"\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be <code>null</code>\n     * @param separatorChars  the characters used as the delimiters,\n     *  <code>null</code> splits on whitespace\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String[] splitPreserveAllTokens(final String str, final String separatorChars) {\n        return StringUtils.splitWorker(str, separatorChars, -1, true);\n    }\n\n    /**\n     * <p>Splits the provided text into an array with a maximum length,\n     * separators specified, preserving all tokens, including empty tokens\n     * created by adjacent separators.</p>\n     *\n     * <p>The separator is not included in the returned String array.\n     * Adjacent separators are treated as separators for empty tokens.\n     * Adjacent separators are treated as one separator.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * A <code>null</code> separatorChars splits on whitespace.</p>\n     *\n     * <p>If more than <code>max</code> delimited substrings are found, the last\n     * returned string includes all characters after the first <code>max - 1</code>\n     * returned strings (including separator characters).</p>\n     *\n     * <pre>\n     * StringUtils.splitPreserveAllTokens(null, *, *)            = null\n     * StringUtils.splitPreserveAllTokens(\"\", *, *)              = []\n     * StringUtils.splitPreserveAllTokens(\"ab de fg\", null, 0)   = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 0) = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 0)    = [\"ab\", \"cd\", \"ef\"]\n     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 2)    = [\"ab\", \"cd:ef\"]\n     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 2) = [\"ab\", \"  de fg\"]\n     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 3) = [\"ab\", \"\", \" de fg\"]\n     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 4) = [\"ab\", \"\", \"\", \"de fg\"]\n     * </pre>\n     *\n     * @param str  the String to parse, may be <code>null</code>\n     * @param separatorChars  the characters used as the delimiters,\n     *  <code>null</code> splits on whitespace\n     * @param max  the maximum number of elements to include in the\n     *  array. A zero or negative value implies no limit\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {\n        return StringUtils.splitWorker(str, separatorChars, max, true);\n    }\n\n    /**\n     * Performs the logic for the <code>split</code> and\n     * <code>splitPreserveAllTokens</code> methods that return a maximum array\n     * length.\n     *\n     * @param str  the String to parse, may be <code>null</code>\n     * @param separatorChars the separate character\n     * @param max  the maximum number of elements to include in the\n     *  array. A zero or negative value implies no limit.\n     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n     * treated as empty token separators; if <code>false</code>, adjacent\n     * separators are treated as one separator.\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     */\n    private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n        // Direct code is quicker than StringTokenizer.\n        // Also, StringTokenizer uses isSpace() not isWhitespace()\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<>();\n        int sizePlus1 = 1;\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        if (separatorChars == null) {\n            // Null separator means use whitespace\n            while (i < len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else if (separatorChars.length() == 1) {\n            // Optimise 1 character case\n            char sep = separatorChars.charAt(0);\n            while (i < len) {\n                if (str.charAt(i) == sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            // standard case\n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || preserveAllTokens && lastMatch) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[0]);\n    }\n\n    /**\n     * <p>Splits a String by Character type as returned by\n     * <code>java.lang.Character.getType(char)</code>. Groups of contiguous\n     * characters of the same type are returned as complete tokens.\n     * <pre>\n     * StringUtils.splitByCharacterType(null)         = null\n     * StringUtils.splitByCharacterType(\"\")           = []\n     * StringUtils.splitByCharacterType(\"ab de fg\")   = [\"ab\", \" \", \"de\", \" \", \"fg\"]\n     * StringUtils.splitByCharacterType(\"ab   de fg\") = [\"ab\", \"   \", \"de\", \" \", \"fg\"]\n     * StringUtils.splitByCharacterType(\"ab:cd:ef\")   = [\"ab\", \":\", \"cd\", \":\", \"ef\"]\n     * StringUtils.splitByCharacterType(\"number5\")    = [\"number\", \"5\"]\n     * StringUtils.splitByCharacterType(\"fooBar\")     = [\"foo\", \"B\", \"ar\"]\n     * StringUtils.splitByCharacterType(\"foo200Bar\")  = [\"foo\", \"200\", \"B\", \"ar\"]\n     * StringUtils.splitByCharacterType(\"ASFRules\")   = [\"ASFR\", \"ules\"]\n     * </pre>\n     * @param str the String to split, may be <code>null</code>\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.4\n     */\n    public static String[] splitByCharacterType(final String str) {\n        return StringUtils.splitByCharacterType(str, false);\n    }\n\n    /**\n     * <p>Splits a String by Character type as returned by\n     * <code>java.lang.Character.getType(char)</code>. Groups of contiguous\n     * characters of the same type are returned as complete tokens, with the\n     * following exception: the character of type\n     * <code>Character.UPPERCASE_LETTER</code>, if any, immediately\n     * preceding a token of type <code>Character.LOWERCASE_LETTER</code>\n     * will belong to the following token rather than to the preceding, if any,\n     * <code>Character.UPPERCASE_LETTER</code> token.\n     * <pre>\n     * StringUtils.splitByCharacterTypeCamelCase(null)         = null\n     * StringUtils.splitByCharacterTypeCamelCase(\"\")           = []\n     * StringUtils.splitByCharacterTypeCamelCase(\"ab de fg\")   = [\"ab\", \" \", \"de\", \" \", \"fg\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"ab   de fg\") = [\"ab\", \"   \", \"de\", \" \", \"fg\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"ab:cd:ef\")   = [\"ab\", \":\", \"cd\", \":\", \"ef\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"number5\")    = [\"number\", \"5\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"fooBar\")     = [\"foo\", \"Bar\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"foo200Bar\")  = [\"foo\", \"200\", \"Bar\"]\n     * StringUtils.splitByCharacterTypeCamelCase(\"ASFRules\")   = [\"ASF\", \"Rules\"]\n     * </pre>\n     * @param str the String to split, may be <code>null</code>\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.4\n     */\n    public static String[] splitByCharacterTypeCamelCase(final String str) {\n        return StringUtils.splitByCharacterType(str, true);\n    }\n\n    /**\n     * <p>Splits a String by Character type as returned by\n     * <code>java.lang.Character.getType(char)</code>. Groups of contiguous\n     * characters of the same type are returned as complete tokens, with the\n     * following exception: if <code>camelCase</code> is <code>true</code>,\n     * the character of type <code>Character.UPPERCASE_LETTER</code>, if any,\n     * immediately preceding a token of type <code>Character.LOWERCASE_LETTER</code>\n     * will belong to the following token rather than to the preceding, if any,\n     * <code>Character.UPPERCASE_LETTER</code> token.\n     * @param str the String to split, may be <code>null</code>\n     * @param camelCase whether to use so-called \"camel-case\" for letter types\n     * @return an array of parsed Strings, <code>null</code> if null String input\n     * @since 2.4\n     */\n    private static String[] splitByCharacterType(final String str, final boolean camelCase) {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        char[] c = str.toCharArray();\n        List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(c[tokenStart]);\n        for (int pos = tokenStart + 1; pos < c.length; pos++) {\n            int type = Character.getType(c[pos]);\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(c, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(new String(c, tokenStart, c.length - tokenStart));\n        return list.toArray(new String[0]);\n    }\n    // Joining\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Joins the elements of the provided array into a single String\n     * containing the provided list of elements.</p>\n     *\n     * <p>No separator is added to the joined String.\n     * Null objects or empty strings within the array are represented by\n     * empty strings.</p>\n     *\n     * <pre>\n     * StringUtils.join(null)            = null\n     * StringUtils.join([])              = \"\"\n     * StringUtils.join([null])          = \"\"\n     * StringUtils.join([\"a\", \"b\", \"c\"]) = \"abc\"\n     * StringUtils.join([null, \"\", \"a\"]) = \"a\"\n     * </pre>\n     *\n     * @param array  the array of values to join together, may be null\n     * @return the joined String, <code>null</code> if null array input\n     * @since 2.0\n     */\n    public static String join(final Object[] array) {\n        return StringUtils.join(array, null);\n    }\n\n    /**\n     * <p>Joins the elements of the provided array into a single String\n     * containing the provided list of elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * Null objects or empty strings within the array are represented by\n     * empty strings.</p>\n     *\n     * <pre>\n     * StringUtils.join(null, *)               = null\n     * StringUtils.join([], *)                 = \"\"\n     * StringUtils.join([null], *)             = \"\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], ';')  = \"a;b;c\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"\n     * StringUtils.join([null, \"\", \"a\"], ';')  = \";;a\"\n     * </pre>\n     *\n     * @param array  the array of values to join together, may be null\n     * @param separator  the separator character to use\n     * @return the joined String, <code>null</code> if null array input\n     * @since 2.0\n     */\n    public static String join(final Object[] array, final char separator) {\n        if (array == null) {\n            return null;\n        }\n        return StringUtils.join(array, separator, 0, array.length);\n    }\n\n    /**\n     * <p>Joins the elements of the provided array into a single String\n     * containing the provided list of elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * Null objects or empty strings within the array are represented by\n     * empty strings.</p>\n     *\n     * <pre>\n     * StringUtils.join(null, *)               = null\n     * StringUtils.join([], *)                 = \"\"\n     * StringUtils.join([null], *)             = \"\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], ';')  = \"a;b;c\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"\n     * StringUtils.join([null, \"\", \"a\"], ';')  = \";;a\"\n     * </pre>\n     *\n     * @param array  the array of values to join together, may be null\n     * @param separator  the separator character to use\n     * @param startIndex the first index to start joining from.  It is\n     * an error to pass in an end index past the end of the array\n     * @param endIndex the index to stop joining from (exclusive). It is\n     * an error to pass in an end index past the end of the array\n     * @return the joined String, <code>null</code> if null array input\n     * @since 2.0\n     */\n    public static String join(final Object[] array, final char separator, final int startIndex, final int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        int bufSize = endIndex - startIndex;\n        if (bufSize <= 0) {\n            return StringUtils.EMPTY;\n        }\n        bufSize *= (array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1;\n        StringBuilder buf = new StringBuilder(bufSize);\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * <p>Joins the elements of the provided array into a single String\n     * containing the provided list of elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * A <code>null</code> separator is the same as an empty String (\"\").\n     * Null objects or empty strings within the array are represented by\n     * empty strings.</p>\n     *\n     * <pre>\n     * StringUtils.join(null, *)                = null\n     * StringUtils.join([], *)                  = \"\"\n     * StringUtils.join([null], *)              = \"\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], \"--\")  = \"a--b--c\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], null)  = \"abc\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], \"\")    = \"abc\"\n     * StringUtils.join([null, \"\", \"a\"], ',')   = \",,a\"\n     * </pre>\n     *\n     * @param array  the array of values to join together, may be null\n     * @param separator  the separator character to use, null treated as \"\"\n     * @return the joined String, <code>null</code> if null array input\n     */\n    public static String join(final Object[] array, final String separator) {\n        if (array == null) {\n            return null;\n        }\n        return StringUtils.join(array, separator, 0, array.length);\n    }\n\n    /**\n     * <p>Joins the elements of the provided array into a single String\n     * containing the provided list of elements.</p>\n     *\n     * <p>No delimiter is added before or after the list.\n     * A <code>null</code> separator is the same as an empty String (\"\").\n     * Null objects or empty strings within the array are represented by\n     * empty strings.</p>\n     *\n     * <pre>\n     * StringUtils.join(null, *)                = null\n     * StringUtils.join([], *)                  = \"\"\n     * StringUtils.join([null], *)              = \"\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], \"--\")  = \"a--b--c\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], null)  = \"abc\"\n     * StringUtils.join([\"a\", \"b\", \"c\"], \"\")    = \"abc\"\n     * StringUtils.join([null, \"\", \"a\"], ',')   = \",,a\"\n     * </pre>\n     *\n     * @param array  the array of values to join together, may be null\n     * @param separator  the separator character to use, null treated as \"\"\n     * @param startIndex the first index to start joining from.  It is\n     * an error to pass in an end index past the end of the array\n     * @param endIndex the index to stop joining from (exclusive). It is\n     * an error to pass in an end index past the end of the array\n     * @return the joined String, <code>null</code> if null array input\n     */\n    public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) {\n        if (array == null) {\n            return null;\n        }\n        if (separator == null) {\n            separator = StringUtils.EMPTY;\n        }\n        // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))\n        //           (Assuming that all Strings are roughly equally long)\n        int bufSize = endIndex - startIndex;\n        if (bufSize <= 0) {\n            return StringUtils.EMPTY;\n        }\n        bufSize *= (array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length();\n        StringBuilder buf = new StringBuilder(bufSize);\n        for (int i = startIndex; i < endIndex; i++) {\n            if (i > startIndex) {\n                buf.append(separator);\n            }\n            if (array[i] != null) {\n                buf.append(array[i]);\n            }\n        }\n        return buf.toString();\n    }\n    // Delete\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Deletes all whitespaces from a String as defined by\n     * {@link Character#isWhitespace(char)}.</p>\n     *\n     * <pre>\n     * StringUtils.deleteWhitespace(null)         = null\n     * StringUtils.deleteWhitespace(\"\")           = \"\"\n     * StringUtils.deleteWhitespace(\"abc\")        = \"abc\"\n     * StringUtils.deleteWhitespace(\"   ab  c  \") = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to delete whitespace from, may be null\n     * @return the String without whitespaces, <code>null</code> if null String input\n     */\n    public static String deleteWhitespace(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        int sz = str.length();\n        char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }\n    // Remove\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Removes a substring only if it is at the begining of a source string,\n     * otherwise returns the source string.</p>\n     *\n     * <p>A <code>null</code> source string will return <code>null</code>.\n     * An empty (\"\") source string will return the empty string.\n     * A <code>null</code> search string will return the source string.</p>\n     *\n     * <pre>\n     * StringUtils.removeStart(null, *)      = null\n     * StringUtils.removeStart(\"\", *)        = \"\"\n     * StringUtils.removeStart(*, null)      = *\n     * StringUtils.removeStart(\"www.domain.com\", \"www.\")   = \"domain.com\"\n     * StringUtils.removeStart(\"domain.com\", \"www.\")       = \"domain.com\"\n     * StringUtils.removeStart(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n     * StringUtils.removeStart(\"abc\", \"\")    = \"abc\"\n     * </pre>\n     *\n     * @param str  the source String to search, may be null\n     * @param remove  the String to search for and remove, may be null\n     * @return the substring with the string removed if found,\n     *  <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String removeStart(final String str, final String remove) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(remove)) {\n            return str;\n        }\n        if (str.startsWith(remove)) {\n            return str.substring(remove.length());\n        }\n        return str;\n    }\n\n    /**\n     * <p>Case insensitive removal of a substring if it is at the begining of a source string,\n     * otherwise returns the source string.</p>\n     *\n     * <p>A <code>null</code> source string will return <code>null</code>.\n     * An empty (\"\") source string will return the empty string.\n     * A <code>null</code> search string will return the source string.</p>\n     *\n     * <pre>\n     * StringUtils.removeStartIgnoreCase(null, *)      = null\n     * StringUtils.removeStartIgnoreCase(\"\", *)        = \"\"\n     * StringUtils.removeStartIgnoreCase(*, null)      = *\n     * StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"www.\")   = \"domain.com\"\n     * StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"WWW.\")   = \"domain.com\"\n     * StringUtils.removeStartIgnoreCase(\"domain.com\", \"www.\")       = \"domain.com\"\n     * StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n     * StringUtils.removeStartIgnoreCase(\"abc\", \"\")    = \"abc\"\n     * </pre>\n     *\n     * @param str  the source String to search, may be null\n     * @param remove  the String to search for (case insensitive) and remove, may be null\n     * @return the substring with the string removed if found,\n     *  <code>null</code> if null String input\n     * @since 2.4\n     */\n    public static String removeStartIgnoreCase(final String str, final String remove) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(remove)) {\n            return str;\n        }\n        if (StringUtils.startsWithIgnoreCase(str, remove)) {\n            return str.substring(remove.length());\n        }\n        return str;\n    }\n\n    /**\n     * <p>Removes a substring only if it is at the end of a source string,\n     * otherwise returns the source string.</p>\n     *\n     * <p>A <code>null</code> source string will return <code>null</code>.\n     * An empty (\"\") source string will return the empty string.\n     * A <code>null</code> search string will return the source string.</p>\n     *\n     * <pre>\n     * StringUtils.removeEnd(null, *)      = null\n     * StringUtils.removeEnd(\"\", *)        = \"\"\n     * StringUtils.removeEnd(*, null)      = *\n     * StringUtils.removeEnd(\"www.domain.com\", \".com.\")  = \"www.domain.com\"\n     * StringUtils.removeEnd(\"www.domain.com\", \".com\")   = \"www.domain\"\n     * StringUtils.removeEnd(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n     * StringUtils.removeEnd(\"abc\", \"\")    = \"abc\"\n     * </pre>\n     *\n     * @param str  the source String to search, may be null\n     * @param remove  the String to search for and remove, may be null\n     * @return the substring with the string removed if found,\n     *  <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String removeEnd(final String str, final String remove) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(remove)) {\n            return str;\n        }\n        if (str.endsWith(remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    /**\n     * <p>Case insensitive removal of a substring if it is at the end of a source string,\n     * otherwise returns the source string.</p>\n     *\n     * <p>A <code>null</code> source string will return <code>null</code>.\n     * An empty (\"\") source string will return the empty string.\n     * A <code>null</code> search string will return the source string.</p>\n     *\n     * <pre>\n     * StringUtils.removeEndIgnoreCase(null, *)      = null\n     * StringUtils.removeEndIgnoreCase(\"\", *)        = \"\"\n     * StringUtils.removeEndIgnoreCase(*, null)      = *\n     * StringUtils.removeEndIgnoreCase(\"www.domain.com\", \".com.\")  = \"www.domain.com\"\n     * StringUtils.removeEndIgnoreCase(\"www.domain.com\", \".com\")   = \"www.domain\"\n     * StringUtils.removeEndIgnoreCase(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n     * StringUtils.removeEndIgnoreCase(\"abc\", \"\")    = \"abc\"\n     * StringUtils.removeEndIgnoreCase(\"www.domain.com\", \".COM\") = \"www.domain\")\n     * StringUtils.removeEndIgnoreCase(\"www.domain.COM\", \".com\") = \"www.domain\")\n     * </pre>\n     *\n     * @param str  the source String to search, may be null\n     * @param remove  the String to search for (case insensitive) and remove, may be null\n     * @return the substring with the string removed if found,\n     *  <code>null</code> if null String input\n     * @since 2.4\n     */\n    public static String removeEndIgnoreCase(final String str, final String remove) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(remove)) {\n            return str;\n        }\n        if (StringUtils.endsWithIgnoreCase(str, remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    /**\n     * <p>Removes all occurrences of a substring from within the source string.</p>\n     *\n     * <p>A <code>null</code> source string will return <code>null</code>.\n     * An empty (\"\") source string will return the empty string.\n     * A <code>null</code> remove string will return the source string.\n     * An empty (\"\") remove string will return the source string.</p>\n     *\n     * <pre>\n     * StringUtils.remove(null, *)        = null\n     * StringUtils.remove(\"\", *)          = \"\"\n     * StringUtils.remove(*, null)        = *\n     * StringUtils.remove(*, \"\")          = *\n     * StringUtils.remove(\"queued\", \"ue\") = \"qd\"\n     * StringUtils.remove(\"queued\", \"zz\") = \"queued\"\n     * </pre>\n     *\n     * @param str  the source String to search, may be null\n     * @param remove  the String to search for and remove, may be null\n     * @return the substring with the string removed if found,\n     *  <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String remove(final String str, final String remove) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(remove)) {\n            return str;\n        }\n        return StringUtils.replace(str, remove, StringUtils.EMPTY, -1);\n    }\n\n    /**\n     * <p>Removes all occurrences of a character from within the source string.</p>\n     *\n     * <p>A <code>null</code> source string will return <code>null</code>.\n     * An empty (\"\") source string will return the empty string.</p>\n     *\n     * <pre>\n     * StringUtils.remove(null, *)       = null\n     * StringUtils.remove(\"\", *)         = \"\"\n     * StringUtils.remove(\"queued\", 'u') = \"qeed\"\n     * StringUtils.remove(\"queued\", 'z') = \"queued\"\n     * </pre>\n     *\n     * @param str  the source String to search, may be null\n     * @param remove  the char to search for and remove, may be null\n     * @return the substring with the char removed if found,\n     *  <code>null</code> if null String input\n     * @since 2.1\n     */\n    public static String remove(final String str, final char remove) {\n        if (StringUtils.isEmpty(str) || str.indexOf(remove) == StringUtils.INDEX_NOT_FOUND) {\n            return str;\n        }\n        char[] chars = str.toCharArray();\n        int pos = 0;\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] != remove) {\n                chars[pos++] = chars[i];\n            }\n        }\n        return new String(chars, 0, pos);\n    }\n    // Replacing\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Replaces a String with another String inside a larger String, once.</p>\n     *\n     * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n     *\n     * <pre>\n     * StringUtils.replaceOnce(null, *, *)        = null\n     * StringUtils.replaceOnce(\"\", *, *)          = \"\"\n     * StringUtils.replaceOnce(\"any\", null, *)    = \"any\"\n     * StringUtils.replaceOnce(\"any\", *, null)    = \"any\"\n     * StringUtils.replaceOnce(\"any\", \"\", *)      = \"any\"\n     * StringUtils.replaceOnce(\"aba\", \"a\", null)  = \"aba\"\n     * StringUtils.replaceOnce(\"aba\", \"a\", \"\")    = \"ba\"\n     * StringUtils.replaceOnce(\"aba\", \"a\", \"z\")   = \"zba\"\n     * </pre>\n     *\n     * @see #replace(String text, String searchString, String replacement, int max)\n     * @param text  text to search and replace in, may be null\n     * @param searchString  the String to search for, may be null\n     * @param replacement  the String to replace with, may be null\n     * @return the text with any replacements processed,\n     *  <code>null</code> if null String input\n     */\n    public static String replaceOnce(final String text, final String searchString, final String replacement) {\n        return StringUtils.replace(text, searchString, replacement, 1);\n    }\n\n    /**\n     * <p>Replaces all occurrences of a String within another String.</p>\n     *\n     * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n     *\n     * <pre>\n     * StringUtils.replace(null, *, *)        = null\n     * StringUtils.replace(\"\", *, *)          = \"\"\n     * StringUtils.replace(\"any\", null, *)    = \"any\"\n     * StringUtils.replace(\"any\", *, null)    = \"any\"\n     * StringUtils.replace(\"any\", \"\", *)      = \"any\"\n     * StringUtils.replace(\"aba\", \"a\", null)  = \"aba\"\n     * StringUtils.replace(\"aba\", \"a\", \"\")    = \"b\"\n     * StringUtils.replace(\"aba\", \"a\", \"z\")   = \"zbz\"\n     * </pre>\n     *\n     * @see #replace(String text, String searchString, String replacement, int max)\n     * @param text  text to search and replace in, may be null\n     * @param searchString  the String to search for, may be null\n     * @param replacement  the String to replace it with, may be null\n     * @return the text with any replacements processed,\n     *  <code>null</code> if null String input\n     */\n    public static String replace(final String text, final String searchString, final String replacement) {\n        return StringUtils.replace(text, searchString, replacement, -1);\n    }\n\n    /**\n     * <p>Replaces a String with another String inside a larger String,\n     * for the first <code>max</code> values of the search String.</p>\n     *\n     * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n     *\n     * <pre>\n     * StringUtils.replace(null, *, *, *)         = null\n     * StringUtils.replace(\"\", *, *, *)           = \"\"\n     * StringUtils.replace(\"any\", null, *, *)     = \"any\"\n     * StringUtils.replace(\"any\", *, null, *)     = \"any\"\n     * StringUtils.replace(\"any\", \"\", *, *)       = \"any\"\n     * StringUtils.replace(\"any\", *, *, 0)        = \"any\"\n     * StringUtils.replace(\"abaa\", \"a\", null, -1) = \"abaa\"\n     * StringUtils.replace(\"abaa\", \"a\", \"\", -1)   = \"b\"\n     * StringUtils.replace(\"abaa\", \"a\", \"z\", 0)   = \"abaa\"\n     * StringUtils.replace(\"abaa\", \"a\", \"z\", 1)   = \"zbaa\"\n     * StringUtils.replace(\"abaa\", \"a\", \"z\", 2)   = \"zbza\"\n     * StringUtils.replace(\"abaa\", \"a\", \"z\", -1)  = \"zbzz\"\n     * </pre>\n     *\n     * @param text  text to search and replace in, may be null\n     * @param searchString  the String to search for, may be null\n     * @param replacement  the String to replace it with, may be null\n     * @param max  maximum number of values to replace, or <code>-1</code> if no maximum\n     * @return the text with any replacements processed,\n     *  <code>null</code> if null String input\n     */\n    public static String replace(final String text, final String searchString, final String replacement, int max) {\n        if (StringUtils.isEmpty(text) || StringUtils.isEmpty(searchString) || replacement == null || max == 0) {\n            return text;\n        }\n        int start = 0;\n        int end = text.indexOf(searchString, start);\n        if (end == StringUtils.INDEX_NOT_FOUND) {\n            return text;\n        }\n        int replLength = searchString.length();\n        int increase = replacement.length() - replLength;\n        increase = Math.max(increase, 0);\n        increase *= max < 0 ? 16 : Math.min(max, 64);\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n        while (end != StringUtils.INDEX_NOT_FOUND) {\n            buf.append(text.substring(start, end)).append(replacement);\n            start = end + replLength;\n            if (--max == 0) {\n                break;\n            }\n            end = text.indexOf(searchString, start);\n        }\n        buf.append(text.substring(start));\n        return buf.toString();\n    }\n\n    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     *\n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. This will not repeat. For repeating replaces, call the\n     * overloaded method.\n     * </p>\n     *\n     * <pre>\n     *  StringUtils.replaceEach(null, *, *)        = null\n     *  StringUtils.replaceEach(\"\", *, *)          = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0]) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null)  = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"})  = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"})  = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"})  = \"wcte\"\n     *  (example of how it does not repeat)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"})  = \"dcte\"\n     * </pre>\n     *\n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) {\n        return StringUtils.replaceEach(text, searchList, replacementList, false, 0);\n    }\n\n    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     *\n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. This will not repeat. For repeating replaces, call the\n     * overloaded method.\n     * </p>\n     *\n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n     *  (example of how it repeats)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, true) = IllegalArgumentException\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, false) = \"dcabe\"\n     * </pre>\n     *\n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IllegalArgumentException\n     *             if the search is repeating and there is an endless loop due\n     *             to outputs of one being inputs to another\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {\n        // timeToLive should be 0 if not used or nothing to replace, else it's\n        // the length of the replace array\n        int timeToLive = searchList == null ? 0 : searchList.length;\n        return StringUtils.replaceEach(text, searchList, replacementList, true, timeToLive);\n    }\n\n    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     *\n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored.\n     * </p>\n     *\n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n     *  (example of how it repeats)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n     * </pre>\n     *\n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @param repeat if true, then replace repeatedly\n     *       until there are no more possible replacements or timeToLive < 0\n     * @param timeToLive\n     *            if less than 0 then there is a circular reference and endless\n     *            loop\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IllegalArgumentException\n     *             if the search is repeating and there is an endless loop due\n     *             to outputs of one being inputs to another\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n        if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n            return text;\n        }\n        // if recursing, this shouldnt be less than 0\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n        // make sure lengths are ok, these need to be equal\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n        }\n        // keep track of which still have matches\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n        // index on index that the match was found\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n        // index of replace array that will replace the search string found\n        // NOTE: logic duplicated below START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic mostly below END\n        // no search strings found, we are done\n        if (textIndex == -1) {\n            return text;\n        }\n        int start = 0;\n        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n        int increase = 0;\n        // count the replacement text elements that are larger than their corresponding text being replaced\n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; // assume 3 matches\n            }\n        }\n        // have upper-bound at 20% increase, then let Java take over\n        increase = Math.min(increase, text.length() / 5);\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n        while (textIndex != -1) {\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n            start = textIndex + searchList[replaceIndex].length();\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            // find the next earliest match\n            // NOTE: logic mostly duplicated above START\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n                // see if we need to keep searching for this\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            // NOTE: logic duplicated above END\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n        return StringUtils.replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n    // Replace, character based\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Replaces all occurrences of a character in a String with another.\n     * This is a null-safe version of {@link String#replace(char, char)}.</p>\n     *\n     * <p>A <code>null</code> string input returns <code>null</code>.\n     * An empty (\"\") string input returns an empty string.</p>\n     *\n     * <pre>\n     * StringUtils.replaceChars(null, *, *)        = null\n     * StringUtils.replaceChars(\"\", *, *)          = \"\"\n     * StringUtils.replaceChars(\"abcba\", 'b', 'y') = \"aycya\"\n     * StringUtils.replaceChars(\"abcba\", 'z', 'y') = \"abcba\"\n     * </pre>\n     *\n     * @param str  String to replace characters in, may be null\n     * @param searchChar  the character to search for, may be null\n     * @param replaceChar  the character to replace, may be null\n     * @return modified String, <code>null</code> if null string input\n     * @since 2.0\n     */\n    public static String replaceChars(final String str, final char searchChar, final char replaceChar) {\n        if (str == null) {\n            return null;\n        }\n        return str.replace(searchChar, replaceChar);\n    }\n\n    /**\n     * <p>Replaces multiple characters in a String in one go.\n     * This method can also be used to delete characters.</p>\n     *\n     * <p>For example:<br />\n     * <code>replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly</code>.</p>\n     *\n     * <p>A <code>null</code> string input returns <code>null</code>.\n     * An empty (\"\") string input returns an empty string.\n     * A null or empty set of search characters returns the input string.</p>\n     *\n     * <p>The length of the search characters should normally equal the length\n     * of the replace characters.\n     * If the search characters is longer, then the extra search characters\n     * are deleted.\n     * If the search characters is shorter, then the extra replace characters\n     * are ignored.</p>\n     *\n     * <pre>\n     * StringUtils.replaceChars(null, *, *)           = null\n     * StringUtils.replaceChars(\"\", *, *)             = \"\"\n     * StringUtils.replaceChars(\"abc\", null, *)       = \"abc\"\n     * StringUtils.replaceChars(\"abc\", \"\", *)         = \"abc\"\n     * StringUtils.replaceChars(\"abc\", \"b\", null)     = \"ac\"\n     * StringUtils.replaceChars(\"abc\", \"b\", \"\")       = \"ac\"\n     * StringUtils.replaceChars(\"abcba\", \"bc\", \"yz\")  = \"ayzya\"\n     * StringUtils.replaceChars(\"abcba\", \"bc\", \"y\")   = \"ayya\"\n     * StringUtils.replaceChars(\"abcba\", \"bc\", \"yzx\") = \"ayzya\"\n     * </pre>\n     *\n     * @param str  String to replace characters in, may be null\n     * @param searchChars  a set of characters to search for, may be null\n     * @param replaceChars  a set of characters to replace, may be null\n     * @return modified String, <code>null</code> if null string input\n     * @since 2.0\n     */\n    public static String replaceChars(final String str, final String searchChars, String replaceChars) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(searchChars)) {\n            return str;\n        }\n        if (replaceChars == null) {\n            replaceChars = StringUtils.EMPTY;\n        }\n        boolean modified = false;\n        int replaceCharsLength = replaceChars.length();\n        int strLength = str.length();\n        StringBuilder buf = new StringBuilder(strLength);\n        for (int i = 0; i < strLength; i++) {\n            char ch = str.charAt(i);\n            int index = searchChars.indexOf(ch);\n            if (index >= 0) {\n                modified = true;\n                if (index < replaceCharsLength) {\n                    buf.append(replaceChars.charAt(index));\n                }\n            } else {\n                buf.append(ch);\n            }\n        }\n        if (modified) {\n            return buf.toString();\n        }\n        return str;\n    }\n    // Overlay\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Overlays part of a String with another String.</p>\n     *\n     * <p>A <code>null</code> string input returns <code>null</code>.\n     * A negative index is treated as zero.\n     * An index greater than the string length is treated as the string length.\n     * The start index is always the smaller of the two indices.</p>\n     *\n     * <pre>\n     * StringUtils.overlay(null, *, *, *)            = null\n     * StringUtils.overlay(\"\", \"abc\", 0, 0)          = \"abc\"\n     * StringUtils.overlay(\"abcdef\", null, 2, 4)     = \"abef\"\n     * StringUtils.overlay(\"abcdef\", \"\", 2, 4)       = \"abef\"\n     * StringUtils.overlay(\"abcdef\", \"\", 4, 2)       = \"abef\"\n     * StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 4)   = \"abzzzzef\"\n     * StringUtils.overlay(\"abcdef\", \"zzzz\", 4, 2)   = \"abzzzzef\"\n     * StringUtils.overlay(\"abcdef\", \"zzzz\", -1, 4)  = \"zzzzef\"\n     * StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 8)   = \"abzzzz\"\n     * StringUtils.overlay(\"abcdef\", \"zzzz\", -2, -3) = \"zzzzabcdef\"\n     * StringUtils.overlay(\"abcdef\", \"zzzz\", 8, 10)  = \"abcdefzzzz\"\n     * </pre>\n     *\n     * @param str  the String to do overlaying in, may be null\n     * @param overlay  the String to overlay, may be null\n     * @param start  the position to start overlaying at\n     * @param end  the position to stop overlaying before\n     * @return overlayed String, <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String overlay(final String str, String overlay, int start, int end) {\n        if (str == null) {\n            return null;\n        }\n        if (overlay == null) {\n            overlay = StringUtils.EMPTY;\n        }\n        int len = str.length();\n        if (start < 0) {\n            start = 0;\n        }\n        if (start > len) {\n            start = len;\n        }\n        if (end < 0) {\n            end = 0;\n        }\n        if (end > len) {\n            end = len;\n        }\n        if (start > end) {\n            int temp = start;\n            start = end;\n            end = temp;\n        }\n        return str.substring(0, start) + overlay + str.substring(end);\n    }\n    // Chomping\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Removes one newline from end of a String if it's there,\n     * otherwise leave it alone.  A newline is &quot;<code>\\n</code>&quot;,\n     * &quot;<code>\\r</code>&quot;, or &quot;<code>\\r\\n</code>&quot;.</p>\n     *\n     * <p>NOTE: This method changed in 2.0.\n     * It now more closely matches Perl chomp.</p>\n     *\n     * <pre>\n     * StringUtils.chomp(null)          = null\n     * StringUtils.chomp(\"\")            = \"\"\n     * StringUtils.chomp(\"abc \\r\")      = \"abc \"\n     * StringUtils.chomp(\"abc\\n\")       = \"abc\"\n     * StringUtils.chomp(\"abc\\r\\n\")     = \"abc\"\n     * StringUtils.chomp(\"abc\\r\\n\\r\\n\") = \"abc\\r\\n\"\n     * StringUtils.chomp(\"abc\\n\\r\")     = \"abc\\n\"\n     * StringUtils.chomp(\"abc\\n\\rabc\")  = \"abc\\n\\rabc\"\n     * StringUtils.chomp(\"\\r\")          = \"\"\n     * StringUtils.chomp(\"\\n\")          = \"\"\n     * StringUtils.chomp(\"\\r\\n\")        = \"\"\n     * </pre>\n     *\n     * @param str  the String to chomp a newline from, may be null\n     * @return String without newline, <code>null</code> if null String input\n     */\n    public static String chomp(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        if (str.length() == 1) {\n            char ch = str.charAt(0);\n            if (ch == CharUtils.CR || ch == CharUtils.LF) {\n                return StringUtils.EMPTY;\n            }\n            return str;\n        }\n        int lastIdx = str.length() - 1;\n        char last = str.charAt(lastIdx);\n        if (last == CharUtils.LF) {\n            if (str.charAt(lastIdx - 1) == CharUtils.CR) {\n                lastIdx--;\n            }\n        } else if (last != CharUtils.CR) {\n            lastIdx++;\n        }\n        return str.substring(0, lastIdx);\n    }\n\n    /**\n     * <p>Removes <code>separator</code> from the end of\n     * <code>str</code> if it's there, otherwise leave it alone.</p>\n     *\n     * <p>NOTE: This method changed in version 2.0.\n     * It now more closely matches Perl chomp.\n     * For the previous behavior, use {@link #substringBeforeLast(String, String)}.\n     * This method uses {@link String#endsWith(String)}.</p>\n     *\n     * <pre>\n     * StringUtils.chomp(null, *)         = null\n     * StringUtils.chomp(\"\", *)           = \"\"\n     * StringUtils.chomp(\"foobar\", \"bar\") = \"foo\"\n     * StringUtils.chomp(\"foobar\", \"baz\") = \"foobar\"\n     * StringUtils.chomp(\"foo\", \"foo\")    = \"\"\n     * StringUtils.chomp(\"foo \", \"foo\")   = \"foo \"\n     * StringUtils.chomp(\" foo\", \"foo\")   = \" \"\n     * StringUtils.chomp(\"foo\", \"foooo\")  = \"foo\"\n     * StringUtils.chomp(\"foo\", \"\")       = \"foo\"\n     * StringUtils.chomp(\"foo\", null)     = \"foo\"\n     * </pre>\n     *\n     * @param str  the String to chomp from, may be null\n     * @param separator  separator String, may be null\n     * @return String without trailing separator, <code>null</code> if null String input\n     */\n    public static String chomp(final String str, final String separator) {\n        if (StringUtils.isEmpty(str) || separator == null) {\n            return str;\n        }\n        if (str.endsWith(separator)) {\n            return str.substring(0, str.length() - separator.length());\n        }\n        return str;\n    }\n    // Chopping\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Remove the last character from a String.</p>\n     *\n     * <p>If the String ends in <code>\\r\\n</code>, then remove both\n     * of them.</p>\n     *\n     * <pre>\n     * StringUtils.chop(null)          = null\n     * StringUtils.chop(\"\")            = \"\"\n     * StringUtils.chop(\"abc \\r\")      = \"abc \"\n     * StringUtils.chop(\"abc\\n\")       = \"abc\"\n     * StringUtils.chop(\"abc\\r\\n\")     = \"abc\"\n     * StringUtils.chop(\"abc\")         = \"ab\"\n     * StringUtils.chop(\"abc\\nabc\")    = \"abc\\nab\"\n     * StringUtils.chop(\"a\")           = \"\"\n     * StringUtils.chop(\"\\r\")          = \"\"\n     * StringUtils.chop(\"\\n\")          = \"\"\n     * StringUtils.chop(\"\\r\\n\")        = \"\"\n     * </pre>\n     *\n     * @param str  the String to chop last character from, may be null\n     * @return String without last character, <code>null</code> if null String input\n     */\n    public static String chop(final String str) {\n        if (str == null) {\n            return null;\n        }\n        int strLen = str.length();\n        if (strLen < 2) {\n            return StringUtils.EMPTY;\n        }\n        int lastIdx = strLen - 1;\n        String ret = str.substring(0, lastIdx);\n        char last = str.charAt(lastIdx);\n        if (last == CharUtils.LF) {\n            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {\n                return ret.substring(0, lastIdx - 1);\n            }\n        }\n        return ret;\n    }\n    // Padding\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Repeat a String <code>repeat</code> times to form a\n     * new String.</p>\n     *\n     * <pre>\n     * StringUtils.repeat(null, 2) = null\n     * StringUtils.repeat(\"\", 0)   = \"\"\n     * StringUtils.repeat(\"\", 2)   = \"\"\n     * StringUtils.repeat(\"a\", 3)  = \"aaa\"\n     * StringUtils.repeat(\"ab\", 2) = \"abab\"\n     * StringUtils.repeat(\"a\", -2) = \"\"\n     * </pre>\n     *\n     * @param character  the Character to to repeat, may be null\n     * @param repeat  number of times to repeat str, negative treated as zero\n     * @return a new String consisting of the original String repeated,\n     *  <code>null</code> if null String input\n     */\n    public static String repeat(final char character, final int repeat) {\n        return repeat(character + \"\", repeat);\n    }\n\n    /**\n     * <p>Repeat a String <code>repeat</code> times to form a\n     * new String.</p>\n     *\n     * <pre>\n     * StringUtils.repeat(null, 2) = null\n     * StringUtils.repeat(\"\", 0)   = \"\"\n     * StringUtils.repeat(\"\", 2)   = \"\"\n     * StringUtils.repeat(\"a\", 3)  = \"aaa\"\n     * StringUtils.repeat(\"ab\", 2) = \"abab\"\n     * StringUtils.repeat(\"a\", -2) = \"\"\n     * </pre>\n     *\n     * @param str  the String to repeat, may be null\n     * @param repeat  number of times to repeat str, negative treated as zero\n     * @return a new String consisting of the original String repeated,\n     *  <code>null</code> if null String input\n     */\n    public static String repeat(final String str, final int repeat) {\n        // Performance tuned for 2.0 (JDK1.4)\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return StringUtils.EMPTY;\n        }\n        int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= StringUtils.PAD_LIMIT) {\n            return StringUtils.padding(repeat, str.charAt(0));\n        }\n        int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1:\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i >= 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2:\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default:\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n\n    /**\n     * <p>Repeat a String <code>repeat</code> times to form a\n     * new String, with a String separator injected each time. </p>\n     *\n     * <pre>\n     * StringUtils.repeat(null, null, 2) = null\n     * StringUtils.repeat(null, \"x\", 2)  = null\n     * StringUtils.repeat(\"\", null, 0)   = \"\"\n     * StringUtils.repeat(\"\", \"\", 2)     = \"\"\n     * StringUtils.repeat(\"\", \"x\", 3)    = \"xxx\"\n     * StringUtils.repeat(\"?\", \", \", 3)  = \"?, ?, ?\"\n     * </pre>\n     *\n     * @param str        the String to repeat, may be null\n     * @param separator  the String to inject, may be null\n     * @param repeat     number of times to repeat str, negative treated as zero\n     * @return a new String consisting of the original String repeated,\n     *  <code>null</code> if null String input\n     * @since 2.5\n     */\n    public static String repeat(final String str, final String separator, final int repeat) {\n        if (str == null || separator == null) {\n            return StringUtils.repeat(str, repeat);\n        } else {\n            // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it\n            String result = StringUtils.repeat(str + separator, repeat);\n            return StringUtils.removeEnd(result, separator);\n        }\n    }\n\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead.\n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(final int repeat, final char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final char[] buf = new char[repeat];\n        Arrays.fill(buf, padChar);\n        return new String(buf);\n    }\n\n    /**\n     * <p>Right pad a String with spaces (' ').</p>\n     *\n     * <p>The String is padded to the size of <code>size</code>.</p>\n     *\n     * <pre>\n     * StringUtils.rightPad(null, *)   = null\n     * StringUtils.rightPad(\"\", 3)     = \"   \"\n     * StringUtils.rightPad(\"bat\", 3)  = \"bat\"\n     * StringUtils.rightPad(\"bat\", 5)  = \"bat  \"\n     * StringUtils.rightPad(\"bat\", 1)  = \"bat\"\n     * StringUtils.rightPad(\"bat\", -1) = \"bat\"\n     * </pre>\n     *\n     * @param str  the String to pad out, may be null\n     * @param size  the size to pad to\n     * @return right padded String or original String if no padding is necessary,\n     *  <code>null</code> if null String input\n     */\n    public static String rightPad(final String str, final int size) {\n        return StringUtils.rightPad(str, size, ' ');\n    }\n\n    /**\n     * <p>Right pad a String with a specified character.</p>\n     *\n     * <p>The String is padded to the size of <code>size</code>.</p>\n     *\n     * <pre>\n     * StringUtils.rightPad(null, *, *)     = null\n     * StringUtils.rightPad(\"\", 3, 'z')     = \"zzz\"\n     * StringUtils.rightPad(\"bat\", 3, 'z')  = \"bat\"\n     * StringUtils.rightPad(\"bat\", 5, 'z')  = \"batzz\"\n     * StringUtils.rightPad(\"bat\", 1, 'z')  = \"bat\"\n     * StringUtils.rightPad(\"bat\", -1, 'z') = \"bat\"\n     * </pre>\n     *\n     * @param str  the String to pad out, may be null\n     * @param size  the size to pad to\n     * @param padChar  the character to pad with\n     * @return right padded String or original String if no padding is necessary,\n     *  <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String rightPad(final String str, final int size, final char padChar) {\n        if (str == null) {\n            return null;\n        }\n        int pads = size - str.length();\n        if (pads <= 0) {\n            return str; // returns original String when possible\n        }\n        if (pads > StringUtils.PAD_LIMIT) {\n            return StringUtils.rightPad(str, size, String.valueOf(padChar));\n        }\n        return str.concat(StringUtils.padding(pads, padChar));\n    }\n\n    /**\n     * <p>Right pad a String with a specified String.</p>\n     *\n     * <p>The String is padded to the size of <code>size</code>.</p>\n     *\n     * <pre>\n     * StringUtils.rightPad(null, *, *)      = null\n     * StringUtils.rightPad(\"\", 3, \"z\")      = \"zzz\"\n     * StringUtils.rightPad(\"bat\", 3, \"yz\")  = \"bat\"\n     * StringUtils.rightPad(\"bat\", 5, \"yz\")  = \"batyz\"\n     * StringUtils.rightPad(\"bat\", 8, \"yz\")  = \"batyzyzy\"\n     * StringUtils.rightPad(\"bat\", 1, \"yz\")  = \"bat\"\n     * StringUtils.rightPad(\"bat\", -1, \"yz\") = \"bat\"\n     * StringUtils.rightPad(\"bat\", 5, null)  = \"bat  \"\n     * StringUtils.rightPad(\"bat\", 5, \"\")    = \"bat  \"\n     * </pre>\n     *\n     * @param str  the String to pad out, may be null\n     * @param size  the size to pad to\n     * @param padStr  the String to pad with, null or empty treated as single space\n     * @return right padded String or original String if no padding is necessary,\n     *  <code>null</code> if null String input\n     */\n    public static String rightPad(final String str, final int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int padLen = padStr.length();\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str; // returns original String when possible\n        }\n        if (padLen == 1 && pads <= StringUtils.PAD_LIMIT) {\n            return StringUtils.rightPad(str, size, padStr.charAt(0));\n        }\n        if (pads == padLen) {\n            return str.concat(padStr);\n        } else if (pads < padLen) {\n            return str.concat(padStr.substring(0, pads));\n        } else {\n            char[] padding = new char[pads];\n            char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return str.concat(new String(padding));\n        }\n    }\n\n    /**\n     * <p>Left pad a String with spaces (' ').</p>\n     *\n     * <p>The String is padded to the size of <code>size</code>.</p>\n     *\n     * <pre>\n     * StringUtils.leftPad(null, *)   = null\n     * StringUtils.leftPad(\"\", 3)     = \"   \"\n     * StringUtils.leftPad(\"bat\", 3)  = \"bat\"\n     * StringUtils.leftPad(\"bat\", 5)  = \"  bat\"\n     * StringUtils.leftPad(\"bat\", 1)  = \"bat\"\n     * StringUtils.leftPad(\"bat\", -1) = \"bat\"\n     * </pre>\n     *\n     * @param str  the String to pad out, may be null\n     * @param size  the size to pad to\n     * @return left padded String or original String if no padding is necessary,\n     *  <code>null</code> if null String input\n     */\n    public static String leftPad(final String str, final int size) {\n        return StringUtils.leftPad(str, size, ' ');\n    }\n\n    /**\n     * <p>Left pad a String with a specified character.</p>\n     *\n     * <p>Pad to a size of <code>size</code>.</p>\n     *\n     * <pre>\n     * StringUtils.leftPad(null, *, *)     = null\n     * StringUtils.leftPad(\"\", 3, 'z')     = \"zzz\"\n     * StringUtils.leftPad(\"bat\", 3, 'z')  = \"bat\"\n     * StringUtils.leftPad(\"bat\", 5, 'z')  = \"zzbat\"\n     * StringUtils.leftPad(\"bat\", 1, 'z')  = \"bat\"\n     * StringUtils.leftPad(\"bat\", -1, 'z') = \"bat\"\n     * </pre>\n     *\n     * @param str  the String to pad out, may be null\n     * @param size  the size to pad to\n     * @param padChar  the character to pad with\n     * @return left padded String or original String if no padding is necessary,\n     *  <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String leftPad(final String str, final int size, final char padChar) {\n        if (str == null) {\n            return null;\n        }\n        int pads = size - str.length();\n        if (pads <= 0) {\n            return str; // returns original String when possible\n        }\n        if (pads > StringUtils.PAD_LIMIT) {\n            return StringUtils.leftPad(str, size, String.valueOf(padChar));\n        }\n        return StringUtils.padding(pads, padChar).concat(str);\n    }\n\n    /**\n     * <p>Left pad a String with a specified String.</p>\n     *\n     * <p>Pad to a size of <code>size</code>.</p>\n     *\n     * <pre>\n     * StringUtils.leftPad(null, *, *)      = null\n     * StringUtils.leftPad(\"\", 3, \"z\")      = \"zzz\"\n     * StringUtils.leftPad(\"bat\", 3, \"yz\")  = \"bat\"\n     * StringUtils.leftPad(\"bat\", 5, \"yz\")  = \"yzbat\"\n     * StringUtils.leftPad(\"bat\", 8, \"yz\")  = \"yzyzybat\"\n     * StringUtils.leftPad(\"bat\", 1, \"yz\")  = \"bat\"\n     * StringUtils.leftPad(\"bat\", -1, \"yz\") = \"bat\"\n     * StringUtils.leftPad(\"bat\", 5, null)  = \"  bat\"\n     * StringUtils.leftPad(\"bat\", 5, \"\")    = \"  bat\"\n     * </pre>\n     *\n     * @param str  the String to pad out, may be null\n     * @param size  the size to pad to\n     * @param padStr  the String to pad with, null or empty treated as single space\n     * @return left padded String or original String if no padding is necessary,\n     *  <code>null</code> if null String input\n     */\n    public static String leftPad(final String str, final int size, String padStr) {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int padLen = padStr.length();\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str; // returns original String when possible\n        }\n        if (padLen == 1 && pads <= StringUtils.PAD_LIMIT) {\n            return StringUtils.leftPad(str, size, padStr.charAt(0));\n        }\n        if (pads == padLen) {\n            return padStr.concat(str);\n        } else if (pads < padLen) {\n            return padStr.substring(0, pads).concat(str);\n        } else {\n            char[] padding = new char[pads];\n            char[] padChars = padStr.toCharArray();\n            for (int i = 0; i < pads; i++) {\n                padding[i] = padChars[i % padLen];\n            }\n            return new String(padding).concat(str);\n        }\n    }\n\n    /**\n     * Gets a String's length or <code>0</code> if the String is <code>null</code>.\n     *\n     * @param str\n     *            a String or <code>null</code>\n     * @return String length or <code>0</code> if the String is <code>null</code>.\n     * @since 2.4\n     */\n    public static int length(final String str) {\n        return str == null ? 0 : str.length();\n    }\n    // Centering\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Centers a String in a larger String of size <code>size</code>\n     * using the space character (' ').<p>\n     *\n     * <p>If the size is less than the String length, the String is returned.\n     * A <code>null</code> String returns <code>null</code>.\n     * A negative size is treated as zero.</p>\n     *\n     * <p>Equivalent to <code>center(str, size, \" \")</code>.</p>\n     *\n     * <pre>\n     * StringUtils.center(null, *)   = null\n     * StringUtils.center(\"\", 4)     = \"    \"\n     * StringUtils.center(\"ab\", -1)  = \"ab\"\n     * StringUtils.center(\"ab\", 4)   = \" ab \"\n     * StringUtils.center(\"abcd\", 2) = \"abcd\"\n     * StringUtils.center(\"a\", 4)    = \" a  \"\n     * </pre>\n     *\n     * @param str  the String to center, may be null\n     * @param size  the int size of new String, negative treated as zero\n     * @return centered String, <code>null</code> if null String input\n     */\n    public static String center(final String str, final int size) {\n        return StringUtils.center(str, size, ' ');\n    }\n\n    /**\n     * <p>Centers a String in a larger String of size <code>size</code>.\n     * Uses a supplied character as the value to pad the String with.</p>\n     *\n     * <p>If the size is less than the String length, the String is returned.\n     * A <code>null</code> String returns <code>null</code>.\n     * A negative size is treated as zero.</p>\n     *\n     * <pre>\n     * StringUtils.center(null, *, *)     = null\n     * StringUtils.center(\"\", 4, ' ')     = \"    \"\n     * StringUtils.center(\"ab\", -1, ' ')  = \"ab\"\n     * StringUtils.center(\"ab\", 4, ' ')   = \" ab\"\n     * StringUtils.center(\"abcd\", 2, ' ') = \"abcd\"\n     * StringUtils.center(\"a\", 4, ' ')    = \" a  \"\n     * StringUtils.center(\"a\", 4, 'y')    = \"yayy\"\n     * </pre>\n     *\n     * @param str  the String to center, may be null\n     * @param size  the int size of new String, negative treated as zero\n     * @param padChar  the character to pad the new String with\n     * @return centered String, <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String center(String str, final int size, final char padChar) {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = StringUtils.leftPad(str, strLen + pads / 2, padChar);\n        str = StringUtils.rightPad(str, size, padChar);\n        return str;\n    }\n\n    /**\n     * <p>Centers a String in a larger String of size <code>size</code>.\n     * Uses a supplied String as the value to pad the String with.</p>\n     *\n     * <p>If the size is less than the String length, the String is returned.\n     * A <code>null</code> String returns <code>null</code>.\n     * A negative size is treated as zero.</p>\n     *\n     * <pre>\n     * StringUtils.center(null, *, *)     = null\n     * StringUtils.center(\"\", 4, \" \")     = \"    \"\n     * StringUtils.center(\"ab\", -1, \" \")  = \"ab\"\n     * StringUtils.center(\"ab\", 4, \" \")   = \" ab\"\n     * StringUtils.center(\"abcd\", 2, \" \") = \"abcd\"\n     * StringUtils.center(\"a\", 4, \" \")    = \" a  \"\n     * StringUtils.center(\"a\", 4, \"yz\")   = \"yayz\"\n     * StringUtils.center(\"abc\", 7, null) = \"  abc  \"\n     * StringUtils.center(\"abc\", 7, \"\")   = \"  abc  \"\n     * </pre>\n     *\n     * @param str  the String to center, may be null\n     * @param size  the int size of new String, negative treated as zero\n     * @param padStr  the String to pad the new String with, must not be null or empty\n     * @return centered String, <code>null</code> if null String input\n     * @throws IllegalArgumentException if padStr is <code>null</code> or empty\n     */\n    public static String center(String str, final int size, String padStr) {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        if (StringUtils.isEmpty(padStr)) {\n            padStr = \" \";\n        }\n        int strLen = str.length();\n        int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = StringUtils.leftPad(str, strLen + pads / 2, padStr);\n        str = StringUtils.rightPad(str, size, padStr);\n        return str;\n    }\n    // Case conversion\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts a String to upper case as per {@link String#toUpperCase()}.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.upperCase(null)  = null\n     * StringUtils.upperCase(\"\")    = \"\"\n     * StringUtils.upperCase(\"aBc\") = \"ABC\"\n     * </pre>\n     *\n     * <p><strong>Note:</strong> As described in the documentation for {@link String#toUpperCase()},\n     * the result of this method is affected by the current locale.\n     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}\n     * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>\n     *\n     * @param str  the String to upper case, may be null\n     * @return the upper cased String, <code>null</code> if null String input\n     */\n    public static String upperCase(final String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase();\n    }\n\n    /**\n     * <p>Converts a String to upper case as per {@link String#toUpperCase(Locale)}.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.upperCase(null, Locale.ENGLISH)  = null\n     * StringUtils.upperCase(\"\", Locale.ENGLISH)    = \"\"\n     * StringUtils.upperCase(\"aBc\", Locale.ENGLISH) = \"ABC\"\n     * </pre>\n     *\n     * @param str  the String to upper case, may be null\n     * @param locale  the locale that defines the case transformation rules, must not be null\n     * @return the upper cased String, <code>null</code> if null String input\n     * @since 2.5\n     */\n    public static String upperCase(final String str, final Locale locale) {\n        if (str == null) {\n            return null;\n        }\n        return str.toUpperCase(locale);\n    }\n\n    /**\n     * <p>Converts a String to lower case as per {@link String#toLowerCase()}.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.lowerCase(null)  = null\n     * StringUtils.lowerCase(\"\")    = \"\"\n     * StringUtils.lowerCase(\"aBc\") = \"abc\"\n     * </pre>\n     *\n     * <p><strong>Note:</strong> As described in the documentation for {@link String#toLowerCase()},\n     * the result of this method is affected by the current locale.\n     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}\n     * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>\n     *\n     * @param str  the String to lower case, may be null\n     * @return the lower cased String, <code>null</code> if null String input\n     */\n    public static String lowerCase(final String str) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase();\n    }\n\n    /**\n     * <p>Converts a String to lower case as per {@link String#toLowerCase(Locale)}.</p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.lowerCase(null, Locale.ENGLISH)  = null\n     * StringUtils.lowerCase(\"\", Locale.ENGLISH)    = \"\"\n     * StringUtils.lowerCase(\"aBc\", Locale.ENGLISH) = \"abc\"\n     * </pre>\n     *\n     * @param str  the String to lower case, may be null\n     * @param locale  the locale that defines the case transformation rules, must not be null\n     * @return the lower cased String, <code>null</code> if null String input\n     * @since 2.5\n     */\n    public static String lowerCase(final String str, final Locale locale) {\n        if (str == null) {\n            return null;\n        }\n        return str.toLowerCase(locale);\n    }\n\n    /**\n     * <p>Capitalizes a String changing the first letter to title case as\n     * per {@link Character#toTitleCase(char)}. No other letters are changed.</p>\n     *\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.capitalize(null)  = null\n     * StringUtils.capitalize(\"\")    = \"\"\n     * StringUtils.capitalize(\"cat\") = \"Cat\"\n     * StringUtils.capitalize(\"cAt\") = \"CAt\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @return the capitalized String, <code>null</code> if null String input\n     * @see #uncapitalize(String)\n     * @since 2.0\n     */\n    public static String capitalize(final String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        return Character.toTitleCase(str.charAt(0)) + str.substring(1);\n    }\n\n    /**\n     * <p>Uncapitalizes a String changing the first letter to title case as\n     * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>\n     *\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.uncapitalize(null)  = null\n     * StringUtils.uncapitalize(\"\")    = \"\"\n     * StringUtils.uncapitalize(\"Cat\") = \"cat\"\n     * StringUtils.uncapitalize(\"CAT\") = \"cAT\"\n     * </pre>\n     *\n     * @param str  the String to uncapitalize, may be null\n     * @return the uncapitalized String, <code>null</code> if null String input\n     * @see #capitalize(String)\n     * @since 2.0\n     */\n    public static String uncapitalize(final String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        return Character.toLowerCase(str.charAt(0)) + str.substring(1);\n    }\n\n    /**\n     * <p>Swaps the case of a String changing upper and title case to\n     * lower case, and lower case to upper case.</p>\n     *\n     * <ul>\n     *  <li>Upper case character converts to Lower case</li>\n     *  <li>Title case character converts to Lower case</li>\n     *  <li>Lower case character converts to Upper case</li>\n     * </ul>\n     *\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.swapCase(null)                 = null\n     * StringUtils.swapCase(\"\")                   = \"\"\n     * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n     * </pre>\n     *\n     * <p>NOTE: This method changed in Lang version 2.0.\n     * It no longer performs a word based algorithm.\n     * If you only use ASCII, you will notice no change.\n     * That functionality is available in WordUtils.</p>\n     *\n     * @param str  the String to swap case, may be null\n     * @return the changed String, <code>null</code> if null String input\n     */\n    public static String swapCase(final String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return str;\n        }\n        StringBuilder buffer = new StringBuilder(strLen);\n        char ch = 0;\n        for (int i = 0; i < strLen; i++) {\n            ch = str.charAt(i);\n            if (Character.isUpperCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isTitleCase(ch)) {\n                ch = Character.toLowerCase(ch);\n            } else if (Character.isLowerCase(ch)) {\n                ch = Character.toUpperCase(ch);\n            }\n            buffer.append(ch);\n        }\n        return buffer.toString();\n    }\n    // Count matches\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Counts how many times the substring appears in the larger String.</p>\n     *\n     * <p>A <code>null</code> or empty (\"\") String input returns <code>0</code>.</p>\n     *\n     * <pre>\n     * StringUtils.countMatches(null, *)       = 0\n     * StringUtils.countMatches(\"\", *)         = 0\n     * StringUtils.countMatches(\"abba\", null)  = 0\n     * StringUtils.countMatches(\"abba\", \"\")    = 0\n     * StringUtils.countMatches(\"abba\", \"a\")   = 2\n     * StringUtils.countMatches(\"abba\", \"ab\")  = 1\n     * StringUtils.countMatches(\"abba\", \"xxx\") = 0\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param sub  the substring to count, may be null\n     * @return the number of occurrences, 0 if either String is <code>null</code>\n     */\n    public static int countMatches(final String str, final String sub) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(sub)) {\n            return 0;\n        }\n        int count = 0;\n        int idx = 0;\n        while ((idx = str.indexOf(sub, idx)) != StringUtils.INDEX_NOT_FOUND) {\n            count++;\n            idx += sub.length();\n        }\n        return count;\n    }\n    // Character Tests\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Checks if the String contains only unicode letters.</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isAlpha(null)   = false\n     * StringUtils.isAlpha(\"\")     = true\n     * StringUtils.isAlpha(\"  \")   = false\n     * StringUtils.isAlpha(\"abc\")  = true\n     * StringUtils.isAlpha(\"ab2c\") = false\n     * StringUtils.isAlpha(\"ab-c\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains letters, and is non-null\n     */\n    public static boolean isAlpha(final String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isLetter(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the String contains only unicode letters and\n     * space (' ').</p>\n     *\n     * <p><code>null</code> will return <code>false</code>\n     * An empty String (length()=0) will return <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isAlphaSpace(null)   = false\n     * StringUtils.isAlphaSpace(\"\")     = true\n     * StringUtils.isAlphaSpace(\"  \")   = true\n     * StringUtils.isAlphaSpace(\"abc\")  = true\n     * StringUtils.isAlphaSpace(\"ab c\") = true\n     * StringUtils.isAlphaSpace(\"ab2c\") = false\n     * StringUtils.isAlphaSpace(\"ab-c\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains letters and space,\n     *  and is non-null\n     */\n    public static boolean isAlphaSpace(final String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isLetter(str.charAt(i)) && str.charAt(i) != ' ') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the String contains only unicode letters or digits.</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isAlphanumeric(null)   = false\n     * StringUtils.isAlphanumeric(\"\")     = true\n     * StringUtils.isAlphanumeric(\"  \")   = false\n     * StringUtils.isAlphanumeric(\"abc\")  = true\n     * StringUtils.isAlphanumeric(\"ab c\") = false\n     * StringUtils.isAlphanumeric(\"ab2c\") = true\n     * StringUtils.isAlphanumeric(\"ab-c\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains letters or digits,\n     *  and is non-null\n     */\n    public static boolean isAlphanumeric(final String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isLetterOrDigit(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the String contains only unicode letters, digits\n     * or space (<code>' '</code>).</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isAlphanumeric(null)   = false\n     * StringUtils.isAlphanumeric(\"\")     = true\n     * StringUtils.isAlphanumeric(\"  \")   = true\n     * StringUtils.isAlphanumeric(\"abc\")  = true\n     * StringUtils.isAlphanumeric(\"ab c\") = true\n     * StringUtils.isAlphanumeric(\"ab2c\") = true\n     * StringUtils.isAlphanumeric(\"ab-c\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains letters, digits or space,\n     *  and is non-null\n     */\n    public static boolean isAlphanumericSpace(final String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isLetterOrDigit(str.charAt(i)) && str.charAt(i) != ' ') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the string contains only ASCII printable characters.</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isAsciiPrintable(null)     = false\n     * StringUtils.isAsciiPrintable(\"\")       = true\n     * StringUtils.isAsciiPrintable(\" \")      = true\n     * StringUtils.isAsciiPrintable(\"Ceki\")   = true\n     * StringUtils.isAsciiPrintable(\"ab2c\")   = true\n     * StringUtils.isAsciiPrintable(\"!ab-c~\") = true\n     * StringUtils.isAsciiPrintable(\"\\u0020\") = true\n     * StringUtils.isAsciiPrintable(\"\\u0021\") = true\n     * StringUtils.isAsciiPrintable(\"\\u007e\") = true\n     * StringUtils.isAsciiPrintable(\"\\u007f\") = false\n     * StringUtils.isAsciiPrintable(\"Ceki G\\u00fclc\\u00fc\") = false\n     * </pre>\n     *\n     * @param str the string to check, may be null\n     * @return <code>true</code> if every character is in the range\n     *  32 thru 126\n     * @since 2.1\n     */\n    public static boolean isAsciiPrintable(final String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!CharUtils.isAsciiPrintable(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the String contains only unicode digits.\n     * A decimal point is not a unicode digit and returns false.</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isNumeric(null)   = false\n     * StringUtils.isNumeric(\"\")     = true\n     * StringUtils.isNumeric(\"  \")   = false\n     * StringUtils.isNumeric(\"123\")  = true\n     * StringUtils.isNumeric(\"12 3\") = false\n     * StringUtils.isNumeric(\"ab2c\") = false\n     * StringUtils.isNumeric(\"12-3\") = false\n     * StringUtils.isNumeric(\"12.3\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains digits, and is non-null\n     */\n    public static boolean isNumeric(final String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isDigit(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the String contains only unicode digits or space\n     * (<code>' '</code>).\n     * A decimal point is not a unicode digit and returns false.</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isNumeric(null)   = false\n     * StringUtils.isNumeric(\"\")     = true\n     * StringUtils.isNumeric(\"  \")   = true\n     * StringUtils.isNumeric(\"123\")  = true\n     * StringUtils.isNumeric(\"12 3\") = true\n     * StringUtils.isNumeric(\"ab2c\") = false\n     * StringUtils.isNumeric(\"12-3\") = false\n     * StringUtils.isNumeric(\"12.3\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains digits or space,\n     *  and is non-null\n     */\n    public static boolean isNumericSpace(final String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isDigit(str.charAt(i)) && str.charAt(i) != ' ') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the String contains only whitespace.</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>true</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isWhitespace(null)   = false\n     * StringUtils.isWhitespace(\"\")     = true\n     * StringUtils.isWhitespace(\"  \")   = true\n     * StringUtils.isWhitespace(\"abc\")  = false\n     * StringUtils.isWhitespace(\"ab2c\") = false\n     * StringUtils.isWhitespace(\"ab-c\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains whitespace, and is non-null\n     * @since 2.0\n     */\n    public static boolean isWhitespace(final String str) {\n        if (str == null) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the String contains only lowercase characters.</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isAllLowerCase(null)   = false\n     * StringUtils.isAllLowerCase(\"\")     = false\n     * StringUtils.isAllLowerCase(\"  \")   = false\n     * StringUtils.isAllLowerCase(\"abc\")  = true\n     * StringUtils.isAllLowerCase(\"abC\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains lowercase characters, and is non-null\n     * @since 2.5\n     */\n    public static boolean isAllLowerCase(final String str) {\n        if (str == null || StringUtils.isEmpty(str)) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isLowerCase(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the String contains only uppercase characters.</p>\n     *\n     * <p><code>null</code> will return <code>false</code>.\n     * An empty String (length()=0) will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.isAllUpperCase(null)   = false\n     * StringUtils.isAllUpperCase(\"\")     = false\n     * StringUtils.isAllUpperCase(\"  \")   = false\n     * StringUtils.isAllUpperCase(\"ABC\")  = true\n     * StringUtils.isAllUpperCase(\"aBC\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return <code>true</code> if only contains uppercase characters, and is non-null\n     * @since 2.5\n     */\n    public static boolean isAllUpperCase(final String str) {\n        if (str == null || StringUtils.isEmpty(str)) {\n            return false;\n        }\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isUpperCase(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Defaults\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Returns either the passed in String,\n     * or if the String is <code>null</code>, an empty String (\"\").</p>\n     *\n     * <pre>\n     * StringUtils.defaultString(null)  = \"\"\n     * StringUtils.defaultString(\"\")    = \"\"\n     * StringUtils.defaultString(\"bat\") = \"bat\"\n     * </pre>\n     *\n     * @see ObjectUtils#toString(Object)\n     * @see String#valueOf(Object)\n     * @param str  the String to check, may be null\n     * @return the passed in String, or the empty String if it\n     *  was <code>null</code>\n     */\n    public static String defaultString(final String str) {\n        return str == null ? StringUtils.EMPTY : str;\n    }\n\n    /**\n     * <p>Returns either the passed in String, or if the String is\n     * <code>null</code>, the value of <code>defaultStr</code>.</p>\n     *\n     * <pre>\n     * StringUtils.defaultString(null, \"NULL\")  = \"NULL\"\n     * StringUtils.defaultString(\"\", \"NULL\")    = \"\"\n     * StringUtils.defaultString(\"bat\", \"NULL\") = \"bat\"\n     * </pre>\n     *\n     * @see ObjectUtils#toString(Object, String)\n     * @see String#valueOf(Object)\n     * @param str  the String to check, may be null\n     * @param defaultStr  the default String to return\n     *  if the input is <code>null</code>, may be null\n     * @return the passed in String, or the default if it was <code>null</code>\n     */\n    public static String defaultString(final String str, final String defaultStr) {\n        return str == null ? defaultStr : str;\n    }\n\n    /**\n     * <p>Returns either the passed in String, or if the String is\n     * whitespace, empty (\"\") or <code>null</code>, the value of <code>defaultStr</code>.</p>\n     *\n     * <pre>\n     * StringUtils.defaultIfBlank(null, \"NULL\")  = \"NULL\"\n     * StringUtils.defaultIfBlank(\"\", \"NULL\")    = \"NULL\"\n     * StringUtils.defaultIfBlank(\" \", \"NULL\")   = \"NULL\"\n     * StringUtils.defaultIfBlank(\"bat\", \"NULL\") = \"bat\"\n     * StringUtils.defaultIfBlank(\"\", null)      = null\n     * </pre>\n     * @param str the String to check, may be null\n     * @param defaultStr  the default String to return\n     *  if the input is whitespace, empty (\"\") or <code>null</code>, may be null\n     * @return the passed in String, or the default\n     * @see StringUtils#defaultString(String, String)\n     * @since 2.6\n     */\n    public static String defaultIfBlank(final String str, final String defaultStr) {\n        return StringUtils.isBlank(str) ? defaultStr : str;\n    }\n\n    /**\n     * <p>Returns either the passed in String, or if the String is\n     * empty or <code>null</code>, the value of <code>defaultStr</code>.</p>\n     *\n     * <pre>\n     * StringUtils.defaultIfEmpty(null, \"NULL\")  = \"NULL\"\n     * StringUtils.defaultIfEmpty(\"\", \"NULL\")    = \"NULL\"\n     * StringUtils.defaultIfEmpty(\"bat\", \"NULL\") = \"bat\"\n     * StringUtils.defaultIfEmpty(\"\", null)      = null\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param defaultStr  the default String to return\n     *  if the input is empty (\"\") or <code>null</code>, may be null\n     * @return the passed in String, or the default\n     * @see StringUtils#defaultString(String, String)\n     */\n    public static String defaultIfEmpty(final String str, final String defaultStr) {\n        return StringUtils.isEmpty(str) ? defaultStr : str;\n    }\n    // Reversing\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Reverses a String as per {@link StringBuilder#reverse()}.</p>\n     *\n     * <p>A <code>null</code> String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.reverse(null)  = null\n     * StringUtils.reverse(\"\")    = \"\"\n     * StringUtils.reverse(\"bat\") = \"tab\"\n     * </pre>\n     *\n     * @param str  the String to reverse, may be null\n     * @return the reversed String, <code>null</code> if null String input\n     */\n    public static String reverse(final String str) {\n        if (str == null) {\n            return null;\n        }\n        return new StringBuilder(str).reverse().toString();\n    }\n\n    /**\n     * <p>Reverses a String that is delimited by a specific character.</p>\n     *\n     * <p>The Strings between the delimiters are not reversed.\n     * Thus java.lang.String becomes String.lang.java (if the delimiter\n     * is <code>'.'</code>).</p>\n     *\n     * <pre>\n     * StringUtils.reverseDelimited(null, *)      = null\n     * StringUtils.reverseDelimited(\"\", *)        = \"\"\n     * StringUtils.reverseDelimited(\"a.b.c\", 'x') = \"a.b.c\"\n     * StringUtils.reverseDelimited(\"a.b.c\", \".\") = \"c.b.a\"\n     * </pre>\n     *\n     * @param str  the String to reverse, may be null\n     * @param separatorChar  the separator character to use\n     * @return the reversed String, <code>null</code> if null String input\n     * @since 2.0\n     */\n    public static String reverseDelimited(final String str, final char separatorChar) {\n        if (str == null) {\n            return null;\n        }\n        // could implement manually, but simple way is to reuse other,\n        // probably slower, methods.\n        String[] strs = StringUtils.split(str, separatorChar);\n        ArrayUtils.reverse(strs);\n        return StringUtils.join(strs, separatorChar);\n    }\n    // Abbreviating\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Abbreviates a String using ellipses. This will turn\n     * \"Now is the time for all good men\" into \"Now is the time for...\"</p>\n     *\n     * <p>Specifically:\n     * <ul>\n     *   <li>If <code>str</code> is less than <code>maxWidth</code> characters\n     *       long, return it.</li>\n     *   <li>Else abbreviate it to <code>(substring(str, 0, max-3) + \"...\")</code>.</li>\n     *   <li>If <code>maxWidth</code> is less than <code>4</code>, throw an\n     *       <code>IllegalArgumentException</code>.</li>\n     *   <li>In no case will it return a String of length greater than\n     *       <code>maxWidth</code>.</li>\n     * </ul>\n     * </p>\n     *\n     * <pre>\n     * StringUtils.abbreviate(null, *)      = null\n     * StringUtils.abbreviate(\"\", 4)        = \"\"\n     * StringUtils.abbreviate(\"abcdefg\", 6) = \"abc...\"\n     * StringUtils.abbreviate(\"abcdefg\", 7) = \"abcdefg\"\n     * StringUtils.abbreviate(\"abcdefg\", 8) = \"abcdefg\"\n     * StringUtils.abbreviate(\"abcdefg\", 4) = \"a...\"\n     * StringUtils.abbreviate(\"abcdefg\", 3) = IllegalArgumentException\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param maxWidth  maximum length of result String, must be at least 4\n     * @return abbreviated String, <code>null</code> if null String input\n     * @throws IllegalArgumentException if the width is too small\n     * @since 2.0\n     */\n    public static String abbreviate(final String str, final int maxWidth) {\n        return StringUtils.abbreviate(str, 0, maxWidth);\n    }\n\n    /**\n     * <p>Abbreviates a String using ellipses. This will turn\n     * \"Now is the time for all good men\" into \"...is the time for...\"</p>\n     *\n     * <p>Works like <code>abbreviate(String, int)</code>, but allows you to specify\n     * a \"left edge\" offset.  Note that this left edge is not necessarily going to\n     * be the leftmost character in the result, or the first character following the\n     * ellipses, but it will appear somewhere in the result.\n     *\n     * <p>In no case will it return a String of length greater than\n     * <code>maxWidth</code>.</p>\n     *\n     * <pre>\n     * StringUtils.abbreviate(null, *, *)                = null\n     * StringUtils.abbreviate(\"\", 0, 4)                  = \"\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", -1, 10) = \"abcdefg...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 0, 10)  = \"abcdefg...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 1, 10)  = \"abcdefg...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 4, 10)  = \"abcdefg...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 5, 10)  = \"...fghi...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 6, 10)  = \"...ghij...\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 8, 10)  = \"...ijklmno\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 10, 10) = \"...ijklmno\"\n     * StringUtils.abbreviate(\"abcdefghijklmno\", 12, 10) = \"...ijklmno\"\n     * StringUtils.abbreviate(\"abcdefghij\", 0, 3)        = IllegalArgumentException\n     * StringUtils.abbreviate(\"abcdefghij\", 5, 6)        = IllegalArgumentException\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param offset  left edge of source String\n     * @param maxWidth  maximum length of result String, must be at least 4\n     * @return abbreviated String, <code>null</code> if null String input\n     * @throws IllegalArgumentException if the width is too small\n     * @since 2.0\n     */\n    public static String abbreviate(final String str, int offset, final int maxWidth) {\n        if (str == null) {\n            return null;\n        }\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n        if (str.length() - offset < maxWidth - 3) {\n            offset = str.length() - (maxWidth - 3);\n        }\n        if (offset <= 4) {\n            return str.substring(0, maxWidth - 3) + \"...\";\n        }\n        if (maxWidth < 7) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n        }\n        if (offset + maxWidth - 3 < str.length()) {\n            return \"...\" + StringUtils.abbreviate(str.substring(offset), maxWidth - 3);\n        }\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n\n    /**\n     * <p>Abbreviates a String to the length passed, replacing the middle characters with the supplied\n     * replacement String.</p>\n     *\n     * <p>This abbreviation only occurs if the following criteria is met:\n     * <ul>\n     * <li>Neither the String for abbreviation nor the replacement String are null or empty </li>\n     * <li>The length to truncate to is less than the length of the supplied String</li>\n     * <li>The length to truncate to is greater than 0</li>\n     * <li>The abbreviated String will have enough room for the length supplied replacement String\n     * and the first and last characters of the supplied String for abbreviation</li>\n     * </ul>\n     * Otherwise, the returned String will be the same as the supplied String for abbreviation.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.abbreviateMiddle(null, null, 0)      = null\n     * StringUtils.abbreviateMiddle(\"abc\", null, 0)      = \"abc\"\n     * StringUtils.abbreviateMiddle(\"abc\", \".\", 0)      = \"abc\"\n     * StringUtils.abbreviateMiddle(\"abc\", \".\", 3)      = \"abc\"\n     * StringUtils.abbreviateMiddle(\"abcdef\", \".\", 4)     = \"ab.f\"\n     * </pre>\n     *\n     * @param str  the String to abbreviate, may be null\n     * @param middle the String to replace the middle characters with, may be null\n     * @param length the length to abbreviate <code>str</code> to.\n     * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.\n     * @since 2.5\n     */\n    public static String abbreviateMiddle(final String str, final String middle, final int length) {\n        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(middle)) {\n            return str;\n        }\n        if (length >= str.length() || length < middle.length() + 2) {\n            return str;\n        }\n        int targetSting = length - middle.length();\n        int startOffset = targetSting / 2 + targetSting % 2;\n        int endOffset = str.length() - targetSting / 2;\n        return str.substring(0, startOffset) + middle + str.substring(endOffset);\n    }\n    // Difference\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Compares two Strings, and returns the portion where they differ.\n     * (More precisely, return the remainder of the second String,\n     * starting from where it's different from the first.)</p>\n     *\n     * <p>For example,\n     * <code>difference(\"i am a machine\", \"i am a robot\") -> \"robot\"</code>.</p>\n     *\n     * <pre>\n     * StringUtils.difference(null, null) = null\n     * StringUtils.difference(\"\", \"\") = \"\"\n     * StringUtils.difference(\"\", \"abc\") = \"abc\"\n     * StringUtils.difference(\"abc\", \"\") = \"\"\n     * StringUtils.difference(\"abc\", \"abc\") = \"\"\n     * StringUtils.difference(\"ab\", \"abxyz\") = \"xyz\"\n     * StringUtils.difference(\"abcde\", \"abxyz\") = \"xyz\"\n     * StringUtils.difference(\"abcde\", \"xyz\") = \"xyz\"\n     * </pre>\n     *\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return the portion of str2 where it differs from str1; returns the\n     * empty String if they are equal\n     * @since 2.0\n     */\n    public static String difference(final String str1, final String str2) {\n        if (str1 == null) {\n            return str2;\n        }\n        if (str2 == null) {\n            return str1;\n        }\n        int at = StringUtils.indexOfDifference(str1, str2);\n        if (at == StringUtils.INDEX_NOT_FOUND) {\n            return StringUtils.EMPTY;\n        }\n        return str2.substring(at);\n    }\n\n    /**\n     * <p>Compares two Strings, and returns the index at which the\n     * Strings begin to differ.</p>\n     *\n     * <p>For example,\n     * <code>indexOfDifference(\"i am a machine\", \"i am a robot\") -> 7</code></p>\n     *\n     * <pre>\n     * StringUtils.indexOfDifference(null, null) = -1\n     * StringUtils.indexOfDifference(\"\", \"\") = -1\n     * StringUtils.indexOfDifference(\"\", \"abc\") = 0\n     * StringUtils.indexOfDifference(\"abc\", \"\") = 0\n     * StringUtils.indexOfDifference(\"abc\", \"abc\") = -1\n     * StringUtils.indexOfDifference(\"ab\", \"abxyz\") = 2\n     * StringUtils.indexOfDifference(\"abcde\", \"abxyz\") = 2\n     * StringUtils.indexOfDifference(\"abcde\", \"xyz\") = 0\n     * </pre>\n     *\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return the index where str2 and str1 begin to differ; -1 if they are equal\n     * @since 2.0\n     */\n    public static int indexOfDifference(final String str1, final String str2) {\n        if (str1 != null && str1.equals(str2)) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        if (str1 == null || str2 == null) {\n            return 0;\n        }\n        int i;\n        for (i = 0; i < str1.length() && i < str2.length(); ++i) {\n            if (str1.charAt(i) != str2.charAt(i)) {\n                break;\n            }\n        }\n        if (i < str2.length() || i < str1.length()) {\n            return i;\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Compares all Strings in an array and returns the index at which the\n     * Strings begin to differ.</p>\n     *\n     * <p>For example,\n     * <code>indexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}) -> 7</code></p>\n     *\n     * <pre>\n     * StringUtils.indexOfDifference(null) = -1\n     * StringUtils.indexOfDifference(new String[] {}) = -1\n     * StringUtils.indexOfDifference(new String[] {\"abc\"}) = -1\n     * StringUtils.indexOfDifference(new String[] {null, null}) = -1\n     * StringUtils.indexOfDifference(new String[] {\"\", \"\"}) = -1\n     * StringUtils.indexOfDifference(new String[] {\"\", null}) = 0\n     * StringUtils.indexOfDifference(new String[] {\"abc\", null, null}) = 0\n     * StringUtils.indexOfDifference(new String[] {null, null, \"abc\"}) = 0\n     * StringUtils.indexOfDifference(new String[] {\"\", \"abc\"}) = 0\n     * StringUtils.indexOfDifference(new String[] {\"abc\", \"\"}) = 0\n     * StringUtils.indexOfDifference(new String[] {\"abc\", \"abc\"}) = -1\n     * StringUtils.indexOfDifference(new String[] {\"abc\", \"a\"}) = 1\n     * StringUtils.indexOfDifference(new String[] {\"ab\", \"abxyz\"}) = 2\n     * StringUtils.indexOfDifference(new String[] {\"abcde\", \"abxyz\"}) = 2\n     * StringUtils.indexOfDifference(new String[] {\"abcde\", \"xyz\"}) = 0\n     * StringUtils.indexOfDifference(new String[] {\"xyz\", \"abcde\"}) = 0\n     * StringUtils.indexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}) = 7\n     * </pre>\n     *\n     * @param strs  array of strings, entries may be null\n     * @return the index where the strings begin to differ; -1 if they are all equal\n     * @since 2.4\n     */\n    public static int indexOfDifference(final String[] strs) {\n        if (strs == null || strs.length <= 1) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        boolean anyStringNull = false;\n        boolean allStringsNull = true;\n        int arrayLen = strs.length;\n        int shortestStrLen = Integer.MAX_VALUE;\n        int longestStrLen = 0;\n        // find the min and max string lengths; this avoids checking to make\n        // sure we are not exceeding the length of the string each time through\n        // the bottom loop.\n        for (int i = 0; i < arrayLen; i++) {\n            if (strs[i] == null) {\n                anyStringNull = true;\n                shortestStrLen = 0;\n            } else {\n                allStringsNull = false;\n                shortestStrLen = Math.min(strs[i].length(), shortestStrLen);\n                longestStrLen = Math.max(strs[i].length(), longestStrLen);\n            }\n        }\n        // handle lists containing all nulls or all empty strings\n        if (allStringsNull || longestStrLen == 0 && !anyStringNull) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        // handle lists containing some nulls or some empty strings\n        if (shortestStrLen == 0) {\n            return 0;\n        }\n        // find the position with the first difference across all strings\n        int firstDiff = -1;\n        for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {\n            char comparisonChar = strs[0].charAt(stringPos);\n            for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {\n                if (strs[arrayPos].charAt(stringPos) != comparisonChar) {\n                    firstDiff = stringPos;\n                    break;\n                }\n            }\n            if (firstDiff != -1) {\n                break;\n            }\n        }\n        if (firstDiff == -1 && shortestStrLen != longestStrLen) {\n            // we compared all of the characters up to the length of the\n            // shortest string and didn't find a match, but the string lengths\n            // vary, so return the length of the shortest string.\n            return shortestStrLen;\n        }\n        return firstDiff;\n    }\n\n    /**\n     * <p>Compares all Strings in an array and returns the initial sequence of\n     * characters that is common to all of them.</p>\n     *\n     * <p>For example,\n     * <code>getCommonPrefix(new String[] {\"i am a machine\", \"i am a robot\"}) -> \"i am a \"</code></p>\n     *\n     * <pre>\n     * StringUtils.getCommonPrefix(null) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"abc\"}) = \"abc\"\n     * StringUtils.getCommonPrefix(new String[] {null, null}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"\", \"\"}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"\", null}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"abc\", null, null}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {null, null, \"abc\"}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"\", \"abc\"}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"abc\", \"\"}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"abc\", \"abc\"}) = \"abc\"\n     * StringUtils.getCommonPrefix(new String[] {\"abc\", \"a\"}) = \"a\"\n     * StringUtils.getCommonPrefix(new String[] {\"ab\", \"abxyz\"}) = \"ab\"\n     * StringUtils.getCommonPrefix(new String[] {\"abcde\", \"abxyz\"}) = \"ab\"\n     * StringUtils.getCommonPrefix(new String[] {\"abcde\", \"xyz\"}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"xyz\", \"abcde\"}) = \"\"\n     * StringUtils.getCommonPrefix(new String[] {\"i am a machine\", \"i am a robot\"}) = \"i am a \"\n     * </pre>\n     *\n     * @param strs  array of String objects, entries may be null\n     * @return the initial sequence of characters that are common to all Strings\n     * in the array; empty String if the array is null, the elements are all null\n     * or if there is no common prefix.\n     * @since 2.4\n     */\n    public static String getCommonPrefix(final String[] strs) {\n        if (strs == null || strs.length == 0) {\n            return StringUtils.EMPTY;\n        }\n        int smallestIndexOfDiff = StringUtils.indexOfDifference(strs);\n        if (smallestIndexOfDiff == StringUtils.INDEX_NOT_FOUND) {\n            // all strings were identical\n            if (strs[0] == null) {\n                return StringUtils.EMPTY;\n            }\n            return strs[0];\n        } else if (smallestIndexOfDiff == 0) {\n            // there were no common initial characters\n            return StringUtils.EMPTY;\n        } else {\n            // we found a common initial character sequence\n            return strs[0].substring(0, smallestIndexOfDiff);\n        }\n    }\n    // Misc\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Find the Levenshtein distance between two Strings.</p>\n     *\n     * <p>This is the number of changes needed to change one String into\n     * another, where each change is a single character modification (deletion,\n     * insertion or substitution).</p>\n     *\n     * <p>The previous implementation of the Levenshtein distance algorithm\n     * was from <a href=\"http://www.merriampark.com/ld.htm\">http://www.merriampark.com/ld.htm</a></p>\n     *\n     * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError\n     * which can occur when my Java implementation is used with very large strings.<br>\n     * This implementation of the Levenshtein distance algorithm\n     * is from <a href=\"http://www.merriampark.com/ldjava.htm\">http://www.merriampark.com/ldjava.htm</a></p>\n     *\n     * <pre>\n     * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException\n     * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException\n     * StringUtils.getLevenshteinDistance(\"\",\"\")               = 0\n     * StringUtils.getLevenshteinDistance(\"\",\"a\")              = 1\n     * StringUtils.getLevenshteinDistance(\"aaapppp\", \"\")       = 7\n     * StringUtils.getLevenshteinDistance(\"frog\", \"fog\")       = 1\n     * StringUtils.getLevenshteinDistance(\"fly\", \"ant\")        = 3\n     * StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\") = 7\n     * StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\") = 7\n     * StringUtils.getLevenshteinDistance(\"hippo\", \"zzzzzzzz\") = 8\n     * StringUtils.getLevenshteinDistance(\"hello\", \"hallo\")    = 1\n     * </pre>\n     *\n     * @param s  the first String, must not be null\n     * @param t  the second String, must not be null\n     * @return result distance\n     * @throws IllegalArgumentException if either String input <code>null</code>\n     */\n    public static int getLevenshteinDistance(String s, String t) {\n        if (s == null || t == null) {\n            throw new IllegalArgumentException(\"Strings must not be null\");\n        }\n        /*\n           The difference between this impl. and the previous is that, rather\n           than creating and retaining a matrix of size s.length()+1 by t.length()+1,\n           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,\n           is the 'current working' distance array that maintains the newest distance cost\n           counts as we iterate through the characters of String s.  Each time we increment\n           the index of String t we are comparing, d is copied to p, the second int[].  Doing so\n           allows us to retain the previous cost counts as required by the algorithm (taking\n           the minimum of the cost count to the left, up one, and diagonally up and to the left\n           of the current cost count being calculated).  (Note that the arrays aren't really\n           copied anymore, just switched...this is clearly much better than cloning an array\n           or doing a System.arraycopy() each time  through the outer loop.)\n\n           Effectively, the difference between the two implementations is this one does not\n           cause an out of memory condition when calculating the LD over two very large strings.\n         */\n        int n = s.length(); // length of s\n        int m = t.length(); // length of t\n        if (n == 0) {\n            return m;\n        } else if (m == 0) {\n            return n;\n        }\n        if (n > m) {\n            // swap the input strings to consume less memory\n            String tmp = s;\n            s = t;\n            t = tmp;\n            n = m;\n            m = t.length();\n        }\n        int[] p = new int[n + 1]; //'previous' cost array, horizontally\n        int[] d = new int[n + 1]; // cost array, horizontally\n        int[] _d; //placeholder to assist in swapping p and d\n        // indexes into strings s and t\n        int i; // iterates through s\n        int j; // iterates through t\n        char t_j; // jth character of t\n        int cost; // cost\n        for (i = 0; i <= n; i++) {\n            p[i] = i;\n        }\n        for (j = 1; j <= m; j++) {\n            t_j = t.charAt(j - 1);\n            d[0] = j;\n            for (i = 1; i <= n; i++) {\n                cost = s.charAt(i - 1) == t_j ? 0 : 1;\n                // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n                d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);\n            }\n            // copy current distance counts to 'previous row' distance counts\n            _d = p;\n            p = d;\n            d = _d;\n        }\n        // our last action in the above loop was to switch d and p, so p now\n        // actually has the most recent cost counts\n        return p[n];\n    }\n    // startsWith\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Check if a String starts with a specified prefix.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered to be equal. The comparison is case sensitive.</p>\n     *\n     * <pre>\n     * StringUtils.startsWith(null, null)      = true\n     * StringUtils.startsWith(null, \"abc\")     = false\n     * StringUtils.startsWith(\"abcdef\", null)  = false\n     * StringUtils.startsWith(\"abcdef\", \"abc\") = true\n     * StringUtils.startsWith(\"ABCDEF\", \"abc\") = false\n     * </pre>\n     *\n     * @see String#startsWith(String)\n     * @param str  the String to check, may be null\n     * @param prefix the prefix to find, may be null\n     * @return <code>true</code> if the String starts with the prefix, case sensitive, or\n     *  both <code>null</code>\n     * @since 2.4\n     */\n    public static boolean startsWith(final String str, final String prefix) {\n        return StringUtils.startsWith(str, prefix, false);\n    }\n\n    /**\n     * <p>Case insensitive check if a String starts with a specified prefix.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered to be equal. The comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.startsWithIgnoreCase(null, null)      = true\n     * StringUtils.startsWithIgnoreCase(null, \"abc\")     = false\n     * StringUtils.startsWithIgnoreCase(\"abcdef\", null)  = false\n     * StringUtils.startsWithIgnoreCase(\"abcdef\", \"abc\") = true\n     * StringUtils.startsWithIgnoreCase(\"ABCDEF\", \"abc\") = true\n     * </pre>\n     *\n     * @see String#startsWith(String)\n     * @param str  the String to check, may be null\n     * @param prefix the prefix to find, may be null\n     * @return <code>true</code> if the String starts with the prefix, case insensitive, or\n     *  both <code>null</code>\n     * @since 2.4\n     */\n    public static boolean startsWithIgnoreCase(final String str, final String prefix) {\n        return StringUtils.startsWith(str, prefix, true);\n    }\n\n    /**\n     * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n     *\n     * @see String#startsWith(String)\n     * @param str  the String to check, may be null\n     * @param prefix the prefix to find, may be null\n     * @param ignoreCase inidicates whether the compare should ignore case\n     *  (case insensitive) or not.\n     * @return <code>true</code> if the String starts with the prefix or\n     *  both <code>null</code>\n     */\n    private static boolean startsWith(final String str, final String prefix, final boolean ignoreCase) {\n        if (str == null || prefix == null) {\n            return str == null && prefix == null;\n        }\n        if (prefix.length() > str.length()) {\n            return false;\n        }\n        return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n    }\n\n    /**\n     * <p>Check if a String starts with any of an array of specified strings.</p>\n     *\n     * <pre>\n     * StringUtils.startsWithAny(null, null)      = false\n     * StringUtils.startsWithAny(null, new String[] {\"abc\"})  = false\n     * StringUtils.startsWithAny(\"abcxyz\", null)     = false\n     * StringUtils.startsWithAny(\"abcxyz\", new String[] {\"\"}) = false\n     * StringUtils.startsWithAny(\"abcxyz\", new String[] {\"abc\"}) = true\n     * StringUtils.startsWithAny(\"abcxyz\", new String[] {null, \"xyz\", \"abc\"}) = true\n     * </pre>\n     *\n     * @see #startsWith(String, String)\n     * @param string  the String to check, may be null\n     * @param searchStrings the Strings to find, may be null or empty\n     * @return <code>true</code> if the String starts with any of the the prefixes, case insensitive, or\n     *  both <code>null</code>\n     * @since 2.5\n     */\n    public static boolean startsWithAny(final String string, final String[] searchStrings) {\n        if (StringUtils.isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n            return false;\n        }\n        for (String searchString : searchStrings) {\n            if (StringUtils.startsWith(string, searchString)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // endsWith\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Check if a String ends with a specified suffix.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered to be equal. The comparison is case sensitive.</p>\n     *\n     * <pre>\n     * StringUtils.endsWith(null, null)      = true\n     * StringUtils.endsWith(null, \"def\")     = false\n     * StringUtils.endsWith(\"abcdef\", null)  = false\n     * StringUtils.endsWith(\"abcdef\", \"def\") = true\n     * StringUtils.endsWith(\"ABCDEF\", \"def\") = false\n     * StringUtils.endsWith(\"ABCDEF\", \"cde\") = false\n     * </pre>\n     *\n     * @see String#endsWith(String)\n     * @param str  the String to check, may be null\n     * @param suffix the suffix to find, may be null\n     * @return <code>true</code> if the String ends with the suffix, case sensitive, or\n     *  both <code>null</code>\n     * @since 2.4\n     */\n    public static boolean endsWith(final String str, final String suffix) {\n        return StringUtils.endsWith(str, suffix, false);\n    }\n\n    /**\n     * <p>Case insensitive check if a String ends with a specified suffix.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered to be equal. The comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.endsWithIgnoreCase(null, null)      = true\n     * StringUtils.endsWithIgnoreCase(null, \"def\")     = false\n     * StringUtils.endsWithIgnoreCase(\"abcdef\", null)  = false\n     * StringUtils.endsWithIgnoreCase(\"abcdef\", \"def\") = true\n     * StringUtils.endsWithIgnoreCase(\"ABCDEF\", \"def\") = true\n     * StringUtils.endsWithIgnoreCase(\"ABCDEF\", \"cde\") = false\n     * </pre>\n     *\n     * @see String#endsWith(String)\n     * @param str  the String to check, may be null\n     * @param suffix the suffix to find, may be null\n     * @return <code>true</code> if the String ends with the suffix, case insensitive, or\n     *  both <code>null</code>\n     * @since 2.4\n     */\n    public static boolean endsWithIgnoreCase(final String str, final String suffix) {\n        return StringUtils.endsWith(str, suffix, true);\n    }\n\n    /**\n     * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n     *\n     * @see String#endsWith(String)\n     * @param str  the String to check, may be null\n     * @param suffix the suffix to find, may be null\n     * @param ignoreCase inidicates whether the compare should ignore case\n     *  (case insensitive) or not.\n     * @return <code>true</code> if the String starts with the prefix or\n     *  both <code>null</code>\n     */\n    private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {\n        if (str == null || suffix == null) {\n            return str == null && suffix == null;\n        }\n        if (suffix.length() > str.length()) {\n            return false;\n        }\n        int strOffset = str.length() - suffix.length();\n        return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n    }\n\n    /**\n     * <p>\n     * Similar to <a\n     * href=\"http://www.w3.org/TR/xpath/#function-normalize-space\">http://www.w3.org/TR/xpath/#function-normalize\n     * -space</a>\n     * </p>\n     * <p>\n     * The function returns the argument string with whitespace normalized by using\n     * <code>{@link #trim(String)}</code> to remove leading and trailing whitespace\n     * and then replacing sequences of whitespace characters by a single space.\n     * </p>\n     * In XML Whitespace characters are the same as those allowed by the <a\n     * href=\"http://www.w3.org/TR/REC-xml/#NT-S\">S</a> production, which is S ::= (#x20 | #x9 | #xD | #xA)+\n     * <p>\n     * See Java's {@link Character#isWhitespace(char)} for which characters are considered whitespace.\n     * <p>\n     * The difference is that Java's whitespace includes vertical tab and form feed, which this functional will also\n     * normalize. Additonally <code>{@link #trim(String)}</code> removes control characters (char &lt;= 32) from both\n     * ends of this String.\n     * </p>\n     *\n     * @see Character#isWhitespace(char)\n     * @see #trim(String)\n     * @see <ahref=\"http://www.w3.org/TR/xpath/#function-normalize-space\">\n     *              http://www.w3.org/TR/xpath/#function-normalize-space</a>\n     * @param str the source String to normalize whitespaces from, may be null\n     * @return the modified string with whitespace normalized, <code>null</code> if null String input\n     *\n     * @since 2.6\n     */\n    public static String normalizeSpace(String str) {\n        str = StringUtils.strip(str);\n        if (str == null || str.length() <= 2) {\n            return str;\n        }\n        StringBuilder b = new StringBuilder(str.length());\n        for (int i = 0; i < str.length(); i++) {\n            char c = str.charAt(i);\n            if (Character.isWhitespace(c)) {\n                if (i > 0 && !Character.isWhitespace(str.charAt(i - 1))) {\n                    b.append(' ');\n                }\n            } else {\n                b.append(c);\n            }\n        }\n        return b.toString();\n    }\n\n    /**\n     * <p>Check if a String ends with any of an array of specified strings.</p>\n     *\n     * <pre>\n     * StringUtils.endsWithAny(null, null)      = false\n     * StringUtils.endsWithAny(null, new String[] {\"abc\"})  = false\n     * StringUtils.endsWithAny(\"abcxyz\", null)     = false\n     * StringUtils.endsWithAny(\"abcxyz\", new String[] {\"\"}) = true\n     * StringUtils.endsWithAny(\"abcxyz\", new String[] {\"xyz\"}) = true\n     * StringUtils.endsWithAny(\"abcxyz\", new String[] {null, \"xyz\", \"abc\"}) = true\n     * </pre>\n     *\n     * @param string  the String to check, may be null\n     * @param searchStrings the Strings to find, may be null or empty\n     * @return <code>true</code> if the String ends with any of the the prefixes, case insensitive, or\n     *  both <code>null</code>\n     * @since 2.6\n     */\n    public static boolean endsWithAny(final String string, final String[] searchStrings) {\n        if (StringUtils.isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n            return false;\n        }\n        for (String searchString : searchStrings) {\n            if (StringUtils.endsWith(string, searchString)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * \n     * <pre>\n     * StringUtils.firstCharToUpperCase(null)      = null\n     * StringUtils.firstCharToUpperCase(\"\")        = \"\"\n     * StringUtils.firstCharToUpperCase(\"abc\")     = \"Abc\"\n     * StringUtils.firstCharToUpperCase(\"Abc\")     = \"Abc\"\n     * StringUtils.firstCharToUpperCase(\"ABC\")     = \"ABC\"\n     * </pre>\n     */\n    public static String firstCharToUpperCase(final String value) {\n        if (StringUtils.isBlank(value)) {\n            return value;\n        }\n        StringBuilder sb = new StringBuilder(value);\n        char firstChar = sb.charAt(0);\n        sb.delete(0, 1);\n        sb.insert(0, (char) (firstChar >= 97 ? firstChar - 32 : firstChar));\n        return sb.toString();\n    }\n\n    /**\n     * \n     * <pre>\n     * StringUtils.firstCharToLowerCase(null)      = null\n     * StringUtils.firstCharToLowerCase(\"\")        = \"\"\n     * StringUtils.firstCharToLowerCase(\"abc\")     = \"abc\"\n     * StringUtils.firstCharToLowerCase(\"Abc\")     = \"abc\"\n     * StringUtils.firstCharToLowerCase(\"ABC\")     = \"aBC\"\n     * </pre>\n     */\n    public static String firstCharToLowerCase(final String value) {\n        if (StringUtils.isBlank(value)) {\n            return value;\n        }\n        StringBuilder sb = new StringBuilder(value);\n        char firstChar = sb.charAt(0);\n        sb.delete(0, 1);\n        sb.insert(0, (char) (firstChar <= 90 ? firstChar + 32 : firstChar));\n        return sb.toString();\n    }\n\n    /**\n     * \n     * <pre>\n     * StringUtils.equalsBlankIgnoreCase(null,\"\")         = true\n     * StringUtils.equalsBlankIgnoreCase(\"\",\"\")           = true\n     * StringUtils.equalsBlankIgnoreCase(\" \",\"\")          = true\n     * StringUtils.equalsBlankIgnoreCase(\" \",null)        = true\n     * StringUtils.equalsBlankIgnoreCase(\"bob\",\"\")        = false\n     * StringUtils.equalsBlankIgnoreCase(\"  bob  \",\"bob\") = true\n     * </pre>\n     */\n    public static boolean equalsBlankIgnoreCase(final String str1, final String str2) {\n        return StringUtils.equalsIgnoreCase(StringUtils.trimToEmpty(str1), StringUtils.trimToEmpty(str2));\n    }\n\n    /* ------------------------------------------------------------ */\n    private static final char[] escapes = new char[32];\n\n    static {\n        Arrays.fill(escapes, (char) 0xFFFF);\n        escapes['\\b'] = 'b';\n        escapes['\\t'] = 't';\n        escapes['\\n'] = 'n';\n        escapes['\\f'] = 'f';\n        escapes['\\r'] = 'r';\n    }\n\n    /** Quote a string into an Appendable.\n     * The characters \", \\, \\n, \\r, \\t, \\f and \\b are escaped\n     * @param input The String to quote.\n     */\n    public static String quote(String input) {\n        StringBuilder buffer = new StringBuilder();\n        quote(buffer, input);\n        return buffer.toString();\n    }\n\n    public static void quote(Appendable buffer, String input) {\n        try {\n            buffer.append('\"');\n            for (int i = 0; i < input.length(); ++i) {\n                char c = input.charAt(i);\n                if (c >= 32) {\n                    if (c == '\"' || c == '\\\\')\n                        buffer.append('\\\\');\n                    buffer.append(c);\n                } else {\n                    char escape = escapes[c];\n                    if (escape == 0xFFFF) {\n                        // Unicode escape\n                        buffer.append('\\\\').append('u').append('0').append('0');\n                        if (c < 0x10)\n                            buffer.append('0');\n                        buffer.append(Integer.toString(c, 16));\n                    } else {\n                        buffer.append('\\\\').append(escape);\n                    }\n                }\n            }\n            buffer.append('\"');\n        } catch (IOException x) {\n            throw new RuntimeException(x);\n        }\n    }\n\n    /** Object to String ,when null object then null else return toString(); */\n    public static String toString(Object object) {\n        return (object == null) ? null : object.toString();\n    }\n}",
            "file_name": "StringUtils.java",
            "human_label": "Convert object to string  if the object is not null. Otherwise, null is returned.",
            "level": "self_contained",
            "lineno": "6133",
            "name": "toString",
            "oracle_context": "{ \"apis\" : \"[]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
            "package": "net.hasor.utils",
            "project": "hasor-master"
        },
        {
            "_id": "636767511a6d9265ec017eb6",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.*;\\nimport org.jgrapht.alg.interfaces.*;\\nimport org.jgrapht.alg.util.*;\\nimport org.jgrapht.graph.*;\\nimport org.jgrapht.util.*;\\nimport java.lang.reflect.*;\\nimport java.util.*;\\nimport java.util.function.*;\\nboolean DEBUG;\\nboolean PRINT_CASES;\\nGraph<V,E> graph;\\nint n;\\nEmbedding<V,E> embedding;\\nGraph<V,E> kuratowskiSubdivision;\\nList<Node> nodes;\\nList<Node> dfsTreeRoots;\\nList<Node> componentRoots;\\nList<MergeInfo> stack;\\nNode failedV;\\nboolean tested;\\nboolean planar;\\nNode current;\\nEdge prevEdge;\\nboolean backtrack;\\nV current;\\nV parent;\\nE parentEdge;\\nNode parent;\\nNode parentNext;\\nNode child;\\nNode childPrev;\\nint vIn;\\nint vOut;\\nNode prev;\\nE graphEdge;\\nNode source;\\nNode target;\\nint sign;\\nboolean embedded;\\nboolean shortCircuit;\\nV graphVertex;\\nboolean rootVertex;\\nint dfsIndex;\\nint height;\\nint lowpoint;\\nint leastAncestor;\\nint visited;\\nint backEdgeFlag;\\nint boundaryHeight;\\nboolean marked;\\nEdge parentEdge;\\nEdge edgeToEmbed;\\nNode initialComponentRoot;\\nNode[] outerFaceNeighbors;\\nDoublyLinkedList<Node> separatedDfsChildList;\\nDoublyLinkedList<Node> pertinentRoots;\\nList<Edge> treeEdges;\\nList<Edge> downEdges;\\nList<Edge> backEdges;\\nDoublyLinkedList.ListNode<Node> listNode;\\nDoublyLinkedList<Edge> embedded;\\nBoyerMyrvoldPlanarityInspector(Graph graph);\\norientDfs(Map vertexMap,V startGraphVertex,int currentDfsIndex);\\norient();\\nsortVertices();\\nlazyTestPlanarity();\\nmergeBiconnectedComponent();\\nembedBackEdge(Node root,int entryDir,Edge edge,Node childPrev);\\nembedShortCircuit(Node componentRoot,int entryDir,OuterFaceCirculator circulator);\\nwalkDown(Node componentRoot);\\nwalkUp(Node start,Node end,Edge edge);\\nlazyComputeEmbedding();\\nprintBiconnectedComponent(Node node);\\nprintState();\\nselectOnOuterFace(Predicate predicate,Node start,Node stop,int dir);\\ngetActiveSuccessorOnOuterFace(Node start,Node v,int dir);\\ngetExternallyActiveSuccessorOnOuterFace(Node start,Node stop,Node v,int dir);\\ngetComponentRoot(Node node);\\naddPathEdges(Set edges,Edge startEdge,Node stop);\\naddPathEdges(Set edges,Node start,Node stop);\\nsearchEdge(Node current,int heightMax);\\nsearchEdge(Node current,int heightMax,Edge forbiddenEdge);\\nsearchEdge(Node current,Predicate isNeeded);\\nsearchSubtreeDfs(Node start,Predicate isNeeded);\\nhighest(Node a,Node b);\\nlowest(Node a,Node b);\\nsetBoundaryDepth(Node componentRoot,Node w,int dir,int delta);\\nclearVisited();\\nfindPathDfs(Node start,Edge startPrev,Predicate canGo,Predicate isFinish,List edges);\\nfindHighestObstructingPath(Node componentRoot,Node w);\\nfinish(Set subdivision);\\naddBoundaryEdges(Set edges,Node componentRoot);\\nkuratowskiCleanUp();\\ncleanUpDfs(Node dfsTreeRoot);\\nfixBoundaryOrder(Node componentRoot);\\nremoveUp(Node start,Node end,int dir,Set edges);\\ngetNextOnPath(Node w,Edge backEdge);\\nfindPathToV(List path,Node v);\\nfirstStrictlyHigher(Node a,Node b,Node c);\\ncheckComponentForFailedEdge(Node componentRoot,Node v);\\nfindFailedEdge(Node v);\\nlazyExtractKuratowskiSubdivision();\\nisPlanar();\\ngetEmbedding();\\ngetKuratowskiSubdivision();\\nSearchInfo(Node current,Edge prevEdge,boolean backtrack);\\nOrientDfsStackInfo(V current,V parent,E parentEdge,boolean backtrack);\\nMergeInfo(Node parent,Node parentNext,Node child,Node childPrev,int vIn,int vOut);\\nisInverted();\\ntoString();\\nOuterFaceCirculator(Node current,Node prev);\\nhasNext();\\nnext();\\nedgeToNext();\\ngetCurrent();\\ngetPrev();\\ntoExistingNode(Node node);\\nEdge(Node source,Node target);\\nEdge(E graphEdge,Node source);\\nEdge(E graphEdge,Node source,Node target);\\nisIncidentTo(Node node);\\ngetOpposite(Node node);\\nNode(V graphVertex,int dfsIndex,int height,Node initialComponentRoot,Edge parentEdge);\\nNode(int dfsIndex,Edge parentEdge);\\nNode(V graphVertex,int dfsIndex,Edge parentEdge,boolean rootVertex);\\nisVisitedWrtTo(Node node);\\nisPertinentWrtTo(Node node);\\nhasBackEdgeWrtTo(Node node);\\nisExternallyActiveWrtTo(Node node);\\nisRootVertex();\\nisInternallyActiveWrtTo(Node node);\\nisInactiveWrtTo(Node node);\\nisActiveWrtTo(Node node);\\niterator(int direction);\\nremoveShortCircuitEdges();\\ngetParent();\\ncheckIsAdjacent(Node node);\\nswapNeighbors();\\nsubstitute(Node node,Node newNeighbor);\\nsubstituteAnother(Node node,Node newNeighbor);\\nhasRootNeighbor();\\nnextOnOuterFace(Node prev);\\nembedBackEdge(Edge edge,Node prev);\\nmergeChildEdges(DoublyLinkedList edges,int vIn,int vOut,Node parentNext,Edge parentEdge);\\ntoString(boolean full);\\ncreateNewNode(Map vertexMap,V graphVertex,E edge,Node parent,int dfsIndex);\\n\", \"repo_level\" : \"\" }",
            "class_name": "BoyerMyrvoldPlanarityInspector",
            "code": "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n  OuterFaceCirculator circulator=start.iterator(dir);\n  Node current=circulator.next();\n  while (current != stop && !predicate.test(current)) {\n    current=circulator.next();\n  }\n  return circulator;\n}\n",
            "docstring": "/** \n * Either finds and returns a circulator to the node on the boundary of the component, which satisfies the  {@code predicate} or returns a circulator to the {@code stop} node.\n * @param predicate the condition the desired node should satisfy\n * @param start the node to start the search from\n * @param stop the node to end the search with\n * @param dir the direction to start the traversal in\n * @return a circulator to the node satisfying the {@code predicate} or to the {@code stop} node\n */\n",
            "end_lineno": "687",
            "file_content": "/*\n * (C) Copyright 2018-2021, by Timofey Chudakov and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.alg.planar;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.interfaces.*;\nimport org.jgrapht.alg.util.*;\nimport org.jgrapht.graph.*;\nimport org.jgrapht.util.*;\n\nimport java.lang.reflect.*;\nimport java.util.*;\nimport java.util.function.*;\n\n/**\n * An implementation of the Boyer-Myrvold planarity testing algorithm. This class determines whether\n * an input graph is planar or not. If the graph is planar, the algorithm provides a\n * <a href=\"https://en.wikipedia.org/wiki/Graph_embedding#Combinatorial_embedding\">combinatorial\n * embedding</a> of the graph, which is represented as a clockwise ordering of the edges of the\n * graph. Otherwise, the algorithm provides a\n * <a href=\"https://en.wikipedia.org/wiki/Kuratowski%27s_theorem#Kuratowski_subgraphs\"> Kuratowski\n * subgraph</a> as a certificate. Both embedding of the graph and Kuratowski subdivision are\n * computed lazily, meaning that the call to the {@link BoyerMyrvoldPlanarityInspector#isPlanar()}\n * does spend time only on the planarity testing. All of the operations of this algorithm (testing,\n * embedding and Kuratowski subgraph extraction) run in linear time.\n * <p>\n * A <a href=\"https://en.wikipedia.org/wiki/Planar_graph\">planar graph</a> is a graph, which can be\n * drawn in two-dimensional space without any of its edges crossing. According to the\n * <a href=\"https://en.wikipedia.org/wiki/Kuratowski%27s_theorem\">Kuratowski theorem</a>, a graph is\n * planar if and only if it doesn't contain a subdivision of the $K_{3,3}$ or $K_{5}$ graphs.\n * <p>\n * The Boyer-Myrvold planarity testing algorithm was originally described in: <i>Boyer, John amp;\n * Myrvold, Wendy. (2004). On the Cutting Edge: Simplified O(n) Planarity by Edge Addition. J. Graph\n * Algorithms Appl.. 8. 241-273. 10.7155/jgaa.00091. </i>. We refer to this paper for the complete\n * description of the Boyer-Myrvold algorithm\n *\n * @param <V> the graph vertex type\n * @param <E> the graph edge type\n * @author Timofey Chudakov\n */\npublic class BoyerMyrvoldPlanarityInspector<V, E>\n    implements\n    PlanarityTestingAlgorithm<V, E>\n{\n    /**\n     * Whether to print debug messages\n     */\n    private static final boolean DEBUG = false;\n    /**\n     * Whether to print Kuratowski case distinction messages\n     */\n    private static final boolean PRINT_CASES = false;\n    /**\n     * The graph we're testing planarity of\n     */\n    private Graph<V, E> graph;\n    /**\n     * The number of vertices in the {@code graph}\n     */\n    private int n;\n    /**\n     * The resulting combinatorial embedding. This value is computed only after the first call to\n     * the {@link BoyerMyrvoldPlanarityInspector#getEmbedding()}\n     */\n    private Embedding<V, E> embedding;\n    /**\n     * The subgraph of the {@code graph}, which is a Kuratowski subdivision. This subgraph certifies\n     * the nonplanarity of the graph.\n     */\n    private Graph<V, E> kuratowskiSubdivision;\n    /**\n     * List of the vertices of the {@code graph} in their internal representation. After the\n     * orientation of the {@code graph} and edge sorting, nodes in this list are sorted according to\n     * their dfs indexes\n     */\n    private List<Node> nodes;\n    /**\n     * List of the dfs tree roots of the {@code graph}. This list has length more than 1 if the\n     * input {@code graph} isn't connected\n     */\n    private List<Node> dfsTreeRoots;\n    /**\n     * List of the virtual biconnected component roots. Initially, a virtual biconnected component\n     * root is created for every node in the {@code graph}, except for the dfs roots. These\n     * component roots don't belong to the {@code graph}. At each step of the algorithm, every\n     * biconnected component has its own unique component root.\n     */\n    private List<Node> componentRoots;\n    /**\n     * The stack containing merge information for every consecutive pair of biconnected components\n     * on the path to the back edge source. After all the biconnected components are merged, this\n     * stack is cleared\n     */\n    private List<MergeInfo> stack;\n    /**\n     * The node $v$, which has an unembedded back edge incident to it.\n     */\n    private Node failedV;\n    /**\n     * Whether the planarity of the {@code graph} has been tested already\n     */\n    private boolean tested;\n    /**\n     * Whether the graph is planar or not. Is valid, if {@code tested} is {@code true}\n     */\n    private boolean planar;\n\n    /**\n     * Creates new instance of the planarity testing algorithm for the {@code graph}. The input\n     * graph can't be null.\n     *\n     * @param graph the graph to test the planarity of\n     */\n    public BoyerMyrvoldPlanarityInspector(Graph<V, E> graph)\n    {\n        this.graph = Objects.requireNonNull(graph, \"Graph can't be null\");\n        this.n = graph.vertexSet().size();\n        this.nodes = new ArrayList<>(n);\n        this.dfsTreeRoots = new ArrayList<>();\n        this.componentRoots = new ArrayList<>(n);\n        this.stack = new ArrayList<>();\n    }\n\n    /**\n     * Creates a new node by converting the {@code graphVertex} to the internal node representation.\n     *\n     * @param vertexMap the map from vertices of the {@code graph} to their internal representation\n     * @param graphVertex the vertex of the {@code graph} we're processing\n     * @param edge the parent edge of the {@code graphVertex}, is {@code null} for dfs tree roots\n     * @param parent the parent node of the {@code graphVertex}\n     * @param dfsIndex the dfs index of the {@code graphVertex}\n     * @return the newly created node\n     */\n    private Node createNewNode(\n        Map<V, Node> vertexMap, V graphVertex, E edge, Node parent, int dfsIndex)\n    {\n        Node child;\n        if (parent == null) {\n            child = new Node(graphVertex, dfsIndex, 0, null, null);\n            child.outerFaceNeighbors[0] = child.outerFaceNeighbors[1] = child;\n            dfsTreeRoots.add(child);\n        } else {\n            Edge treeEdge = new Edge(edge, parent);\n            Node componentRoot = new Node(parent.dfsIndex, treeEdge);\n            child = new Node(graphVertex, dfsIndex, parent.height + 1, componentRoot, treeEdge);\n            treeEdge.target = child;\n\n            componentRoots.add(componentRoot);\n\n            parent.treeEdges.add(treeEdge);\n\n            child.outerFaceNeighbors[0] = child.outerFaceNeighbors[1] = componentRoot;\n            componentRoot.outerFaceNeighbors[0] = componentRoot.outerFaceNeighbors[1] = child;\n        }\n        nodes.add(child);\n        vertexMap.put(graphVertex, child);\n        return child;\n    }\n\n    /**\n     * Orients the input graph according to its dfs traversal by creating a dfs tree. Computes the\n     * least ancestors and lowpoints of the nodes\n     *\n     * @param vertexMap the map from {@code graph} vertices to their internal representatives\n     * @param startGraphVertex the node to start the traversal from (this is a dfs tree root).\n     * @param currentDfsIndex the dfs index of the {@code startGraphVertex}\n     * @return the {@code currentDfsIndex} + number of nodes in the traversed subtree\n     */\n    private int orientDfs(Map<V, Node> vertexMap, V startGraphVertex, int currentDfsIndex)\n    {\n        List<OrientDfsStackInfo> stack = new ArrayList<>();\n        stack.add(new OrientDfsStackInfo(startGraphVertex, null, null, false));\n        while (!stack.isEmpty()) {\n            OrientDfsStackInfo info = stack.remove(stack.size() - 1);\n\n            if (info.backtrack) {\n                Node current = vertexMap.get(info.current);\n                current.leastAncestor = current.lowpoint = current.dfsIndex;\n                for (Edge backEdge : current.backEdges) {\n                    current.leastAncestor =\n                        Math.min(current.leastAncestor, backEdge.target.dfsIndex);\n                }\n                for (Edge treeEdge : current.treeEdges) {\n                    current.lowpoint = Math.min(current.lowpoint, treeEdge.target.lowpoint);\n                }\n                current.lowpoint = Math.min(current.lowpoint, current.leastAncestor);\n            } else {\n                if (vertexMap.containsKey(info.current)) {\n                    // other dfs branch has reached this vertex earlier\n                    continue;\n                }\n                stack.add(new OrientDfsStackInfo(info.current, info.parent, info.parentEdge, true));\n                Node current = createNewNode(\n                    vertexMap, info.current, info.parentEdge, vertexMap.get(info.parent),\n                    currentDfsIndex);\n                ++currentDfsIndex;\n                for (E e : graph.edgesOf(info.current)) {\n                    V opposite = Graphs.getOppositeVertex(graph, e, info.current);\n                    if (vertexMap.containsKey(opposite)) {\n                        // back edge or parent edge\n                        Node oppositeNode = vertexMap.get(opposite);\n                        if (opposite.equals(info.parent)) {\n                            continue;\n                        }\n                        Edge backEdge = new Edge(e, current, oppositeNode);\n                        oppositeNode.downEdges.add(backEdge);\n                        current.backEdges.add(backEdge);\n                    } else {\n                        // possible tree edge\n                        stack.add(new OrientDfsStackInfo(opposite, current.graphVertex, e, false));\n                    }\n                }\n            }\n        }\n        return currentDfsIndex;\n    }\n\n    /**\n     * Iteratively start an orienting dfs from every {@code graph} vertex that hasn't been visited\n     * yet. After orienting the graph, sorts the nodes by their lowpoints and adds them to the\n     * {@code separatedDfsChildList}\n     */\n    private void orient()\n    {\n        Map<V, Node> visited = new HashMap<>();\n        int currentDfsIndex = 0;\n        for (V vertex : graph.vertexSet()) {\n            if (!visited.containsKey(vertex)) {\n                currentDfsIndex = orientDfs(visited, vertex, currentDfsIndex);\n            }\n        }\n        sortVertices();\n    }\n\n    /**\n     * Performs sorting of the vertices by their lowpoints and adding them to the\n     * {@code separatedDfsChildList}\n     */\n    private void sortVertices()\n    {\n        List<List<Node>> sorted = new ArrayList<>(Collections.nCopies(n, null));\n        for (Node node : nodes) {\n            int lowpoint = node.lowpoint;\n            if (sorted.get(lowpoint) == null) {\n                sorted.set(lowpoint, new ArrayList<>());\n            }\n            sorted.get(lowpoint).add(node);\n        }\n        int i = 0;\n        for (List<Node> list : sorted) {\n            if (i >= n) {\n                break;\n            }\n            if (list != null) {\n                for (Node node : list) {\n                    nodes.set(i++, node);\n                    if (node.parentEdge != null) {\n                        node.listNode =\n                            node.parentEdge.source.separatedDfsChildList.addElementLast(node);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Lazily tests the planarity of the graph. The implementation below is close to the code\n     * presented in the original paper\n     *\n     * @return true if the graph is planar, false otherwise\n     */\n    private boolean lazyTestPlanarity()\n    {\n        if (!tested) {\n            tested = true;\n\n            orient();\n            if (DEBUG) {\n                printState();\n                System.out.println(\"Start testing planarity\");\n            }\n            for (int currentNode = n - 1; currentNode >= 0; currentNode--) {\n                Node current = nodes.get(currentNode);\n                if (DEBUG) {\n                    System.out.printf(\"Current vertex is %s\\n\", current.toString(false));\n                }\n                for (Edge downEdge : current.downEdges) {\n                    walkUp(downEdge.source, current, downEdge);\n                }\n                for (Edge treeEdge : current.treeEdges) {\n                    walkDown(treeEdge.target.initialComponentRoot);\n                }\n\n                for (Edge downEdge : current.downEdges) {\n                    if (!downEdge.embedded) {\n                        failedV = current;\n                        return planar = false;\n                    }\n                }\n            }\n            planar = true;\n        }\n        return planar;\n    }\n\n    /**\n     * Merges the last two biconnected components using the info stored on top of the stack. The key\n     * goal of this method is to merge the outer faces of the two components and to merge the\n     * embedded edges of the child component root with the embedded edges of the component parent\n     * node.\n     */\n    private void mergeBiconnectedComponent()\n    {\n        MergeInfo info = stack.get(stack.size() - 1);\n        stack.remove(stack.size() - 1);\n        if (DEBUG) {\n            System.out.printf(\"\\nMerging biconnected component, info: %s\\n\", info.toString());\n        }\n        Node virtualRoot = info.child;\n        if (info.isInverted()) {\n            virtualRoot.swapNeighbors();\n        }\n        Node root = info.parent;\n        Node virtualRootChild = virtualRoot.parentEdge.target;\n\n        root.pertinentRoots.removeNode(virtualRoot.listNode);\n        root.separatedDfsChildList.removeNode(virtualRootChild.listNode);\n\n        root\n            .mergeChildEdges(\n                virtualRoot.embedded, info.vIn, info.vOut, info.parentNext, virtualRoot.parentEdge);\n\n        root.substituteAnother(info.parentNext, info.childPrev);\n        info.childPrev.substitute(virtualRoot, root);\n        virtualRoot.outerFaceNeighbors[0] = virtualRoot.outerFaceNeighbors[1] = null;\n    }\n\n    /**\n     * Embeds the back edge {@code edge} into the list of embedded edges of the source and the\n     * virtual target of the edge such that the {@code childPrev} belongs to the new inner face.\n     * This method also takes care of modifying the boundary of the outer face accordingly\n     *\n     * @param root the component root\n     * @param entryDir the component entry direction\n     * @param edge the edge to embed\n     * @param childPrev the neighbor of the source of the edge that should belong to the inner face\n     * @return a circulator starting from the edge's source\n     */\n    private OuterFaceCirculator embedBackEdge(Node root, int entryDir, Edge edge, Node childPrev)\n    {\n        if (DEBUG) {\n            System.out.printf(\"Embedding back edge %s\\n\", edge.toString());\n        }\n        assert !edge.embedded;\n        if (entryDir == 0) {\n            root.embedded.addLast(edge);\n        } else {\n            root.embedded.addFirst(edge);\n        }\n        Node child = edge.source;\n        child.embedBackEdge(edge, childPrev);\n        child.edgeToEmbed = null;\n        child.backEdgeFlag = n;\n        edge.embedded = true;\n\n        child.substitute(childPrev, root);\n        root.outerFaceNeighbors[entryDir] = child;\n        Node next = child.nextOnOuterFace(root);\n        return new OuterFaceCirculator(next, child);\n    }\n\n    /**\n     * Embeds a short-circuit edge from the {@code componentRoot} to the current node of the\n     * {@code circulator}. Changes the outer face accordingly\n     *\n     * @param componentRoot the component root\n     * @param entryDir the direction used to enter the component\n     * @param circulator a circulator to the source of the new edge\n     */\n    private void embedShortCircuit(Node componentRoot, int entryDir, OuterFaceCirculator circulator)\n    {\n        Node current = circulator.getCurrent(), prev = circulator.getPrev();\n        Edge shortCircuit = new Edge(current, componentRoot.getParent());\n        if (entryDir == 0) {\n            componentRoot.embedded.addLast(shortCircuit);\n            componentRoot.outerFaceNeighbors[0] = current;\n        } else {\n            componentRoot.embedded.addFirst(shortCircuit);\n            componentRoot.outerFaceNeighbors[1] = current;\n        }\n        current.embedBackEdge(shortCircuit, prev);\n        current.substitute(prev, componentRoot);\n        if (DEBUG) {\n            System.out.printf(\"Embedding short circuit edge: %s\\n\", shortCircuit.toString());\n            printState();\n        }\n    }\n\n    /**\n     * The walkdown procedure from the original paper. Either embeds all of the back edges in the\n     * subtree rooted at the child of the {@code componentRoot} or identifies the back edges which\n     * can be used to extract a Kuratowski subdivision. Iteratively traverses the tree of the\n     * biconnected component and descends only to the pertinent components. This procedure is also\n     * responsible for embedding short-circuit edges to make the algorithm run in linear time in the\n     * worst case.\n     *\n     * @param componentRoot the root of the component to start the walkdown from\n     */\n    private void walkDown(Node componentRoot)\n    {\n        if (DEBUG) {\n            System.out.printf(\"\\nStart walk down on node %s\\n\", componentRoot.toString(true));\n        }\n        for (int componentEntryDir = 0; componentEntryDir < 2 && stack.isEmpty();\n            componentEntryDir++)\n        {\n            if (DEBUG) {\n                System.out.println(\"\\nNew traversal direction = \" + componentEntryDir);\n            }\n            int currentComponentEntryDir = componentEntryDir;\n            OuterFaceCirculator circulator = componentRoot.iterator(currentComponentEntryDir);\n            for (Node current = circulator.next(); current != componentRoot;) {\n                if (DEBUG) {\n                    System.out.printf(\"Current = %s\\n\", current.toString());\n                }\n                if (current.hasBackEdgeWrtTo(componentRoot)) {\n                    Node childPrev = circulator.getPrev();\n                    while (!stack.isEmpty()) {\n                        mergeBiconnectedComponent();\n                        if (DEBUG) {\n                            printState();\n                        }\n                    }\n                    circulator = embedBackEdge(\n                        componentRoot, componentEntryDir, current.edgeToEmbed, childPrev);\n                    if (DEBUG) {\n                        printState();\n                        printBiconnectedComponent(current);\n                    }\n                }\n                if (!current.pertinentRoots.isEmpty()) {\n                    int parentComponentEntryDir = currentComponentEntryDir;\n                    Node root = current.pertinentRoots.getFirst();\n\n                    if (DEBUG) {\n                        System.out.printf(\"Descending to the root = %s\\n\", root.toString());\n                    }\n                    OuterFaceCirculator ccwCirculator =\n                        getActiveSuccessorOnOuterFace(root, componentRoot, 0);\n                    Node ccwActiveNode = ccwCirculator.getCurrent();\n                    OuterFaceCirculator cwCirculator =\n                        getActiveSuccessorOnOuterFace(root, componentRoot, 1);\n                    Node cwActiveNode = cwCirculator.getCurrent();\n\n                    if (ccwActiveNode.isInternallyActiveWrtTo(componentRoot)) {\n                        currentComponentEntryDir = 0;\n                    } else if (cwActiveNode.isInternallyActiveWrtTo(componentRoot)) {\n                        currentComponentEntryDir = 1;\n                    } else if (ccwActiveNode.isPertinentWrtTo(componentRoot)) {\n                        currentComponentEntryDir = 0;\n                    } else {\n                        currentComponentEntryDir = 1;\n                    }\n\n                    if (currentComponentEntryDir == 0) {\n                        stack\n                            .add(\n                                new MergeInfo(\n                                    current, circulator.next(), root, root.outerFaceNeighbors[1],\n                                    parentComponentEntryDir, currentComponentEntryDir));\n                        current = ccwActiveNode;\n                        circulator = ccwCirculator;\n\n                        if (!cwActiveNode.hasRootNeighbor()) {\n                            embedShortCircuit(root, 1, cwCirculator);\n                        }\n                    } else {\n                        stack\n                            .add(\n                                new MergeInfo(\n                                    current, circulator.next(), root, root.outerFaceNeighbors[0],\n                                    parentComponentEntryDir, currentComponentEntryDir));\n                        current = cwActiveNode;\n                        circulator = cwCirculator;\n\n                        if (!ccwActiveNode.hasRootNeighbor()) {\n                            embedShortCircuit(root, 0, ccwCirculator);\n                        }\n                    }\n\n                } else if (current.isInactiveWrtTo(componentRoot)) {\n                    current = circulator.next();\n                } else {\n                    // current vertex is externally active\n                    if (DEBUG) {\n                        System.out.println(\"Current vertex is externally active, stop\\n\");\n                    }\n                    if (!current.hasRootNeighbor() && stack.isEmpty()) {\n                        embedShortCircuit(componentRoot, componentEntryDir, circulator);\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * The walkup procedure from the original paper. Identifies the pertinent subgraph of the graph\n     * by going up the dfs tree from the {@code start} node to the {@code end} node using the edge\n     * {@code edge}\n     *\n     * @param start the node to start the walkup from\n     * @param end the node currently processed by the main loop of the algorithm\n     * @param edge a back edge to embed\n     */\n    private void walkUp(Node start, Node end, Edge edge)\n    {\n        if (DEBUG) {\n            System.out.printf(\"\\nStart walk up on edge = %s\\n\", edge.toString());\n        }\n        int visited = end.dfsIndex;\n\n        start.backEdgeFlag = visited;\n        start.edgeToEmbed = edge;\n\n        Node x = start.outerFaceNeighbors[0], y = start.outerFaceNeighbors[1], xPrev = start,\n            yPrev = start;\n        start.visited = visited;\n        while (x != end && !x.isVisitedWrtTo(end) && !y.isVisitedWrtTo(end)) {\n            if (DEBUG) {\n                System.out.printf(\"Current x = %s\\nCurrent y = %s\\n\", x.toString(), y.toString());\n            }\n            x.visited = y.visited = visited;\n\n            Node root = null;\n            if (x.isRootVertex()) {\n                root = x;\n            } else if (y.isRootVertex()) {\n                root = y;\n            }\n            if (root != null) {\n                if (DEBUG) {\n                    System.out.printf(\"Found root = %s\\n\", root.toString());\n                }\n                Node rootChild = root.parentEdge.target;\n                Node newStart = root.parentEdge.source;\n                if (newStart != end) {\n                    if (rootChild.lowpoint < end.dfsIndex) {\n                        // the component in externally active\n                        root.listNode = newStart.pertinentRoots.addElementLast(root);\n                    } else {\n                        // the component is internally active\n                        root.listNode = newStart.pertinentRoots.addElementFirst(root);\n                    }\n                } else {\n                    break;\n                }\n                newStart.visited = visited;\n                xPrev = yPrev = newStart;\n                x = newStart.outerFaceNeighbors[0];\n                y = newStart.outerFaceNeighbors[1];\n\n            } else {\n                Node t = x;\n                x = x.nextOnOuterFace(xPrev);\n                xPrev = t;\n\n                t = y;\n                y = y.nextOnOuterFace(yPrev);\n                yPrev = t;\n            }\n        }\n    }\n\n    /**\n     * Lazily computes a combinatorial embedding of the {@code graph} by removing all the\n     * short-circuit edges and properly orienting the edges around the nodes.\n     *\n     * @return a combinatorial embedding of the {@code graph}\n     */\n    private Embedding<V, E> lazyComputeEmbedding()\n    {\n        lazyTestPlanarity();\n        if (!planar) {\n            throw new IllegalArgumentException(\n                \"Input graph is not planar, can't compute graph embedding\");\n        }\n        if (embedding == null) {\n            for (Node dfsTreeRoot : dfsTreeRoots) {\n                cleanUpDfs(dfsTreeRoot);\n            }\n            Map<V, List<E>> embeddingMap = new HashMap<>();\n            for (Node node : nodes) {\n                for (Node child : node.separatedDfsChildList) {\n                    Node virtualRoot = child.initialComponentRoot;\n                    node.embedded.append(virtualRoot.embedded);\n                }\n                List<E> embeddedEdges = new ArrayList<>(node.embedded.size());\n                for (Edge edge : node.embedded) {\n                    embeddedEdges.add(edge.graphEdge);\n                }\n                embeddingMap.put(node.graphVertex, embeddedEdges);\n            }\n            embedding = new EmbeddingImpl<>(graph, embeddingMap);\n        }\n        return embedding;\n    }\n\n    /**\n     * Method for debug purposes, prints the boundary the {@code node} belongs to\n     *\n     * @param node a node on the outer face\n     */\n    private void printBiconnectedComponent(Node node)\n    {\n        StringBuilder builder = new StringBuilder(node.toString(false));\n        OuterFaceCirculator circulator = node.iterator(0);\n        Node current = circulator.next();\n        Node stop = current;\n        do {\n            builder.append(\" -> \").append(current.toString(false));\n            current = circulator.next();\n        } while (current != stop);\n        System.out.println(\"Biconnected component after merge: \" + builder.toString());\n    }\n\n    /**\n     * Method for debug purposes, prints the state of the algorithm\n     */\n    private void printState()\n    {\n        System.out.println(\"\\nPrinting state:\");\n        System.out.println(\"Dfs roots: \" + dfsTreeRoots);\n        System.out.println(\"Nodes:\");\n        for (Node node : nodes) {\n            System.out.println(node.toString(true));\n        }\n        System.out.println(\"Virtual nodes:\");\n        for (Node node : componentRoots) {\n            System.out.println(node.toString(true));\n        }\n        List<Edge> inverted = new ArrayList<>();\n        for (Node node : nodes) {\n            for (Edge edge : node.treeEdges) {\n                if (edge.sign < 0) {\n                    inverted.add(edge);\n                }\n            }\n        }\n        System.out.println(\"Inverted edges = \" + inverted);\n    }\n\n    /**\n     * Either finds and returns a circulator to the node on the boundary of the component, which\n     * satisfies the {@code predicate} or returns a circulator to the {@code stop} node.\n     *\n     * @param predicate the condition the desired node should satisfy\n     * @param start the node to start the search from\n     * @param stop the node to end the search with\n     * @param dir the direction to start the traversal in\n     * @return a circulator to the node satisfying the {@code predicate} or to the {@code stop} node\n     */\n    private OuterFaceCirculator selectOnOuterFace(\n        Predicate<Node> predicate, Node start, Node stop, int dir)\n    {\n        OuterFaceCirculator circulator = start.iterator(dir);\n        Node current = circulator.next();\n        while (current != stop && !predicate.test(current)) {\n            current = circulator.next();\n        }\n        return circulator;\n    }\n\n    /**\n     * Returns an active node on the outer face in the direction {@code dir} starting from the\n     * {@code start} node\n     *\n     * @param start the node to start the search from\n     * @param v an ancestor of the {@code start}\n     * @param dir the direction of the search\n     * @return a circulator to the found node\n     */\n    private OuterFaceCirculator getActiveSuccessorOnOuterFace(Node start, Node v, int dir)\n    {\n        return selectOnOuterFace(n -> n.isActiveWrtTo(v), start, start, dir);\n    }\n\n    /**\n     * Returns acirculator to the externally active node on the outer face between the {@code start}\n     * and {@code end} nodes in the direction {@code dir}.\n     *\n     * @param start the node to start the search from\n     * @param stop the node to end the search with\n     * @param v an ancestor of the {@code start} and the {@code end}\n     * @param dir the direction of the search\n     * @return a circulator to the found node\n     */\n    private OuterFaceCirculator getExternallyActiveSuccessorOnOuterFace(\n        Node start, Node stop, Node v, int dir)\n    {\n        return selectOnOuterFace(n -> n.isExternallyActiveWrtTo(v), start, stop, dir);\n    }\n\n    /**\n     * Returns a component root of component the {@code node} is contained in.\n     *\n     * @param node a node in the partially embedded graph\n     * @return a component root of the component the {@code node} belongs to\n     */\n    private Node getComponentRoot(Node node)\n    {\n        return selectOnOuterFace(Node::isRootVertex, node, node, 0).getCurrent();\n    }\n\n    /**\n     * Adds the edges on the path from the {@code startEdge} up to the node {@code stop} to the set\n     * {@code edges}\n     *\n     * @param edges the set to add the path edges to\n     * @param startEdge the edge to start from\n     * @param stop the last node on the path\n     */\n    private void addPathEdges(Set<Edge> edges, Edge startEdge, Node stop)\n    {\n        edges.add(startEdge);\n        Node current = startEdge.source;\n        while (current != stop) {\n            edges.add(current.parentEdge);\n            current = current.getParent();\n        }\n    }\n\n    /**\n     * Adds the edges between the {@code start} and the {@code end} to the set {@code edges}\n     *\n     * @param edges the set to add the path edges to to\n     * @param start the node to start from\n     * @param stop the node to end with\n     */\n    private void addPathEdges(Set<Edge> edges, Node start, Node stop)\n    {\n        if (start != stop) {\n            addPathEdges(edges, start.parentEdge, stop);\n        }\n    }\n\n    /**\n     * Searches a back edge which target has a height smaller than {@code heightMax}\n     *\n     * @param current the node to start from\n     * @param heightMax an upper bound on the height of the desired back edge\n     * @return the desired back edge or null, if no such edge exist\n     */\n    private Edge searchEdge(Node current, int heightMax)\n    {\n        return searchEdge(current, heightMax, null);\n    }\n\n    /**\n     * Searches a back edge which target has a height smaller than {@code heightMax}\n     *\n     * @param current the node to start from\n     * @param heightMax an upper bound on the height of the desired back edge\n     * @param forbiddenEdge an edge the desired edge should not be equal to\n     * @return the desired back edge or null, if no such edge exist\n     */\n    private Edge searchEdge(Node current, int heightMax, Edge forbiddenEdge)\n    {\n        Predicate<Edge> isNeeded = e -> {\n            if (forbiddenEdge == e) {\n                return false;\n            }\n            return e.target.height < heightMax;\n        };\n        return searchEdge(current, isNeeded);\n    }\n\n    /**\n     * Generically searches an edge in the subtree rooted at the {@code current}, which doesn't\n     * include the children of the {@code current} that have beem merged to the parent biconnected\n     * component.\n     *\n     * @param current the node to start the searh from\n     * @param isNeeded the predicate which the desired edge should satisfy\n     * @return an edge which satisfies the {@code predicate}, or null if such an edge doesn't exist\n     */\n    private Edge searchEdge(Node current, Predicate<Edge> isNeeded)\n    {\n        for (Node node : current.separatedDfsChildList) {\n            Edge result = searchSubtreeDfs(node, isNeeded);\n            if (result != null) {\n                return result;\n            }\n        }\n        for (Edge edge : current.backEdges) {\n            if (isNeeded.test(edge)) {\n                return edge;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Recursively searches all the subtree root at the node {@code start} to find an edge\n     * satisfying the {@code predicate}.\n     *\n     * @param start the node to start the search from.\n     * @param isNeeded a predicate, which the desired edge should satisfy\n     * @return a desired edge, or null if no such edge exist.\n     */\n    private Edge searchSubtreeDfs(Node start, Predicate<Edge> isNeeded)\n    {\n        List<Node> stack = new ArrayList<>();\n        stack.add(start);\n        while (!stack.isEmpty()) {\n            Node current = stack.remove(stack.size() - 1);\n\n            for (Edge edge : current.backEdges) {\n                if (isNeeded.test(edge)) {\n                    return edge;\n                }\n            }\n            for (Edge edge : current.treeEdges) {\n                stack.add(edge.target);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the highest of the two input node, i.e. the node with the greater height\n     *\n     * @param a a node in the dfs tree\n     * @param b a node in the dfs tree\n     * @return the highest of the two nodes\n     */\n    private Node highest(Node a, Node b)\n    {\n        return a.height > b.height ? a : b;\n    }\n\n    /**\n     * Returns the lowest of the two input node, i.e. the node with the least height.\n     *\n     * @param a a node in the dfs tree\n     * @param b a node in the dfs tree\n     * @return the lowest of the two nodes\n     */\n    private Node lowest(Node a, Node b)\n    {\n        return a.height < b.height ? a : b;\n    }\n\n    /**\n     * Iteratively sets a boundary height for the nodes on the outer face branch ending at the node\n     * {@code w}.\n     *\n     * @param componentRoot the root of the component\n     * @param w the end of the outer face branch\n     * @param dir the direction to start the traversal in\n     * @param delta a value in $\\{+1, -1\\}$ to set either positive or negative boundary height\n     */\n    private void setBoundaryDepth(Node componentRoot, Node w, int dir, int delta)\n    {\n        OuterFaceCirculator circulator = componentRoot.iterator(dir);\n        Node current = circulator.next();\n        int currentHeight = delta;\n        while (current != w) {\n            current.boundaryHeight = currentHeight;\n            currentHeight += delta;\n            current = circulator.next();\n        }\n    }\n\n    /**\n     * Clears the visited variable of all the nodes and component roots\n     */\n    private void clearVisited()\n    {\n        nodes.forEach(n -> n.visited = 0);\n        componentRoots.forEach(n -> n.visited = 0);\n    }\n\n    /**\n     * Generically searches a path from the {@code current} node to the first node satisfying the\n     * {@code isFinish} predicate consisting of all the nodes satisfying the {@code canGo}\n     * predicate. The key property of this method is that it searches the next edge on the path in\n     * the clockwise order starting from the previous edge. The edges of the resulting path are\n     * added to the {@code edges}.\n     *\n     * @param start the start node of the traversal\n     * @param startPrev the previous edge of the start node\n     * @param canGo specifies where the search can go\n     * @param isFinish specifies what nodes are finish nodes\n     * @param edges the list containing the resulting path\n     * @return true if the search was successful, false otherwise\n     */\n    private boolean findPathDfs(\n        Node start, Edge startPrev, Predicate<Node> canGo, Predicate<Node> isFinish,\n        List<Edge> edges)\n    {\n        List<SearchInfo> stack = new ArrayList<>();\n        stack.add(new SearchInfo(start, startPrev, false));\n        while (!stack.isEmpty()) {\n            SearchInfo info = stack.remove(stack.size() - 1);\n            if (isFinish.test(info.current)) {\n                edges.add(info.prevEdge);\n                edges.remove(0);\n                return true;\n            }\n            if (info.backtrack) {\n                edges.remove(edges.size() - 1);\n            } else {\n                if (info.current.visited != 0) {\n                    continue;\n                }\n                info.current.visited = 1;\n                stack.add(new SearchInfo(info.current, info.prevEdge, true));\n                edges.add(info.prevEdge);\n                /*\n                 * The iteration is performed in the reverse order since the infos are pushed on the\n                 * stack and therefore will be processed in the again reverse order\n                 */\n                Iterator<Edge> iterator =\n                    info.current.embedded.reverseCircularIterator(info.prevEdge);\n                while (iterator.hasNext()) {\n                    Edge currentEdge = iterator.next();\n                    Node opposite = currentEdge.getOpposite(info.current);\n                    if ((!canGo.test(opposite) || opposite.visited != 0)\n                        && !isFinish.test(opposite))\n                    {\n                        continue;\n                    }\n                    stack.add(new SearchInfo(opposite, currentEdge, false));\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Finds the highest obstructing path in the component rooted at {@code componentRoot}. See the\n     * original paper for the definition of the obstructing path. This method heavily relies on the\n     * fact that the method\n     * {@link BoyerMyrvoldPlanarityInspector#findPathDfs(Node, Edge, Predicate, Predicate, List)}\n     * chooses the edges in the clockwise order.\n     *\n     * @param componentRoot the root of the component\n     * @param w the node called {@code w} in the Kuratowski subdivision extraction phase.\n     * @return the edges of the desired path as a list\n     */\n    private List<Edge> findHighestObstructingPath(Node componentRoot, Node w)\n    {\n        clearVisited();\n        List<Edge> result = new ArrayList<>();\n        OuterFaceCirculator circulator = componentRoot.iterator(0);\n        Node current = circulator.next();\n        while (current != w) {\n            if (findPathDfs(\n                current, current.embedded.getFirst(), n -> !n.marked, n -> n.boundaryHeight < 0,\n                result))\n            {\n                return result;\n            }\n            current = circulator.next();\n        }\n        return result;\n    }\n\n    /**\n     * Finishes the Kuratowski subdivision extraction by constructing the desired subgraph\n     *\n     * @param subdivision the edges in the Kuratowski subdivision\n     * @return the Kuratowski subgraph of the {@code graph}\n     */\n    private Graph<V, E> finish(Set<Edge> subdivision)\n    {\n        Set<E> edgeSubset = new HashSet<>();\n        Set<V> vertexSubset = new HashSet<>();\n        subdivision.forEach(e -> {\n            edgeSubset.add(e.graphEdge);\n            vertexSubset.add(e.target.graphVertex);\n            vertexSubset.add(e.source.graphVertex);\n        });\n        kuratowskiSubdivision = new AsSubgraph<>(graph, vertexSubset, edgeSubset);\n        return kuratowskiSubdivision;\n    }\n\n    /**\n     * Adds the edges on the outer face of the component rooted at {@code componentRoot} to the set\n     * {@code edges}\n     *\n     * @param edges the set to add the edges to\n     * @param componentRoot the root of the biconnected component\n     */\n    private void addBoundaryEdges(Set<Edge> edges, Node componentRoot)\n    {\n        OuterFaceCirculator circulator = componentRoot.iterator(0);\n        Node current;\n        do {\n            Edge edge = circulator.edgeToNext();\n            edge.source.marked = edge.target.marked = true;\n            edges.add(edge);\n            current = circulator.next();\n        } while (current != componentRoot);\n    }\n\n    /**\n     * Cleans up the dfs trees before the Kuratowski subdivision extraction phase\n     */\n    private void kuratowskiCleanUp()\n    {\n        for (Node dfsTreeRoot : dfsTreeRoots) {\n            cleanUpDfs(dfsTreeRoot);\n        }\n        for (Node node : componentRoots) {\n            if (node.outerFaceNeighbors[0] != null) {\n                node.removeShortCircuitEdges();\n                fixBoundaryOrder(node);\n            }\n        }\n    }\n\n    /**\n     * Recursively cleans up the dfs tree rooted at the {@code dfsTreeRoot} my removing all the\n     * short-circuit edges and properly orienting other embedded edges\n     *\n     * @param dfsTreeRoot the root of the dfs tree to clean up\n     */\n    private void cleanUpDfs(Node dfsTreeRoot)\n    {\n        List<Pair<Node, Integer>> stack = new ArrayList<>();\n        stack.add(Pair.of(dfsTreeRoot, 1));\n        while (!stack.isEmpty()) {\n            Pair<Node, Integer> entry = stack.remove(stack.size() - 1);\n            Node current = entry.getFirst();\n            int sign = entry.getSecond();\n            if (sign < 0) {\n                current.embedded.invert();\n            }\n            current.removeShortCircuitEdges();\n            for (Node node : current.separatedDfsChildList) {\n                // all the components, that aren't merged, aren't inverted\n                node.parentEdge.sign = sign;\n            }\n\n            for (Edge treeEdge : current.treeEdges) {\n                stack.add(Pair.of(treeEdge.target, sign * treeEdge.sign));\n            }\n        }\n\n    }\n\n    /**\n     * Orient the connections on the outer face of the component rooted at {@code componentRoot}\n     * such that they are ordered\n     *\n     * @param componentRoot the root of the component to process\n     */\n    private void fixBoundaryOrder(Node componentRoot)\n    {\n        if (componentRoot.embedded.size() < 2) {\n            return;\n        }\n        Node componentParent = componentRoot.getParent();\n        Edge edgeToNext = componentRoot.embedded.getLast(),\n            edgeToPrev = componentRoot.embedded.getFirst();\n        Node next = edgeToNext.getOpposite(componentParent),\n            prev = edgeToPrev.getOpposite(componentParent);\n\n        componentRoot.outerFaceNeighbors[0] = next;\n        componentRoot.outerFaceNeighbors[1] = prev;\n        next.outerFaceNeighbors[1] = componentRoot;\n        prev.outerFaceNeighbors[0] = componentRoot;\n        Node current = componentRoot.outerFaceNeighbors[0];\n        do {\n            edgeToNext = current.embedded.getLast();\n            edgeToPrev = current.embedded.getFirst();\n            next = edgeToNext.getOpposite(current);\n            prev = edgeToPrev.getOpposite(current);\n            if (prev != componentParent) {\n                current.outerFaceNeighbors[1] = prev;\n            }\n            if (next != componentParent) {\n                current.outerFaceNeighbors[0] = next;\n            }\n            current = next;\n        } while (current != componentParent);\n    }\n\n    /**\n     * Removes the edges from the outer face from the {@code start} node to the {@code end} node in\n     * the direction {@code dir} from the set {@code edges}\n     *\n     * @param start the start of the boundary path\n     * @param end the end of the boundary path\n     * @param dir the direction to take from the {@code start} node\n     * @param edges the set of edges to modify\n     */\n    private void removeUp(Node start, Node end, int dir, Set<Edge> edges)\n    {\n        if (start == end) {\n            return;\n        }\n        OuterFaceCirculator circulator = start.iterator(dir);\n        Node next;\n        do {\n            Edge edge = circulator.edgeToNext();\n            edges.remove(edge);\n            next = circulator.next();\n        } while (next != end);\n    }\n\n    /**\n     * Effectively is a method for finding node {@code z} in the notations of the original paper.\n     * The search proceeds in the reverse order of the path from the {@code backEdge} to the node\n     * {@code w}\n     *\n     * @param w the start of the path down\n     * @param backEdge the last edge on the path\n     * @return the desired node {@code z} or null if the source of the {@code backEdge} is equal to\n     *         {@code w}\n     */\n    private Node getNextOnPath(Node w, Edge backEdge)\n    {\n        if (backEdge.source == w) {\n            return null;\n        }\n        Node prev = backEdge.source, current = backEdge.source.getParent();\n        while (current != w) {\n            prev = current;\n            current = current.getParent();\n        }\n        return prev;\n    }\n\n    /**\n     * Finds a path from some intermediate nodes on the path represented by the list {@code path} to\n     * the node {@code v}. The path to {@code v} certainly doesn't exist if the list {@code path}\n     * has size 1, because we're looking for a path from some intermediate node\n     *\n     * @param path the path between left and right outer face branches\n     * @param v the parent of the biconnected component\n     * @return the path edges in a list, which can be empty\n     */\n    private List<Edge> findPathToV(List<Edge> path, Node v)\n    {\n        clearVisited();\n        int i = 0;\n        Edge currentEdge = path.get(i);\n        Node current =\n            currentEdge.source.boundaryHeight != 0 ? currentEdge.target : currentEdge.source;\n        List<Edge> result = new ArrayList<>();\n        while (i < path.size() - 1) {\n            if (findPathDfs(current, currentEdge, n -> !n.marked, n -> n == v, result)) {\n                return result;\n            }\n            ++i;\n            currentEdge = path.get(i);\n            current = currentEdge.getOpposite(current);\n        }\n        return result;\n    }\n\n    /**\n     * Checks whether the first node {@code a} is strictly higher than nodes {@code b} and {@code c}\n     *\n     * @param a a node in the dfs tree\n     * @param b a node in the dfs tree\n     * @param c a node in the dfs tree\n     * @return true if the first node in strictly higher that other node, false otherwise\n     */\n    private boolean firstStrictlyHigher(Node a, Node b, Node c)\n    {\n        return a.height > b.height && a.height > c.height;\n    }\n\n    /**\n     * Checks whether the biconnected component rooted at {@code componentRoot} can be used to\n     * extract a Kuratowski subdivision. It can be used in the case there is one externally active\n     * node on each branch of the outer face and there is a pertinent node on the lower part of the\n     * outer face between these two externally active nodes.\n     *\n     * @param componentRoot the root of the biconnected component\n     * @param v an ancestor of the nodes in the biconnected component\n     * @return an unembedded back edge, which target is {@code v} and which can be used to extract a\n     *         Kuratowski subdivision, or {@code null} is no such edge exist for this biconnected\n     *         component\n     */\n    private Edge checkComponentForFailedEdge(Node componentRoot, Node v)\n    {\n        OuterFaceCirculator firstDir =\n            getExternallyActiveSuccessorOnOuterFace(componentRoot, componentRoot, v, 0);\n        Node firstDirNode = firstDir.getCurrent();\n        OuterFaceCirculator secondDir =\n            getExternallyActiveSuccessorOnOuterFace(componentRoot, componentRoot, v, 1);\n        Node secondDirNode = secondDir.getCurrent();\n        if (firstDirNode != componentRoot && firstDirNode != secondDirNode) {\n            Node current = firstDir.next();\n            while (current != secondDirNode) {\n                if (current.isPertinentWrtTo(v)) {\n                    return searchEdge(current, e -> e.target == v && !e.embedded);\n                }\n                current = firstDir.next();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Finds an unembedded back edge to {@code v}, which can be used to extract the Kuratowski\n     * subdivision. If the merge stack isn't empty, the last biconnected component processed by the\n     * walkdown can be used to find such an edge, because walkdown descended to that component\n     * (which means that component is pertinent) and couldn't reach a pertinent node. This can only\n     * happen by encountering externally active nodes on both branches of the traversal. Otherwise,\n     * be have look in all the child biconnected components to find an unembedded back edge. We're\n     * guided by the fact that an edge can not be embedded only in the case both traversals of the\n     * walkdown could reach all off the pertinent nodes. This in turn can happen only if both\n     * traversals get stuck on externally active nodes.\n     * <p>\n     * <b>Note:</b> not every unembedded back edge can be used to extract a Kuratowski subdivision\n     *\n     * @param v the vertex which has an unembedded back edge incident to it\n     * @return the found unembedded back edge which can be used to extract a Kuratowski subdivision\n     */\n    private Edge findFailedEdge(Node v)\n    {\n        if (stack.isEmpty()) {\n            for (Node child : v.separatedDfsChildList) {\n                Node componentRoot = child.initialComponentRoot;\n                Edge result = checkComponentForFailedEdge(componentRoot, v);\n                if (result != null) {\n                    return result;\n                }\n            }\n            return null; // should not happen in case node v has an incident unembedded back edge\n        } else {\n            MergeInfo info = stack.get(stack.size() - 1);\n            return checkComponentForFailedEdge(info.child, v);\n        }\n    }\n\n    /**\n     * Lazily extracts a Kuratowski subdivision from the {@code graph}. The process of adding the\n     * edges of the subdivision to the resulting set of edges had been made explicit for every case.\n     *\n     * @return a Kuratowski subgraph of the {@code graph}\n     */\n    private Graph<V, E> lazyExtractKuratowskiSubdivision()\n    {\n        if (kuratowskiSubdivision == null) {\n            // remove short-circuit edges and orient all embedded lists clockwise\n            kuratowskiCleanUp();\n            if (DEBUG) {\n                printState();\n            }\n            Set<Edge> subdivision = new HashSet<>();\n            // find the needed unembedded back edge which can be used to find Kuratowski subgraph\n            Edge failedEdge = findFailedEdge(failedV);\n            assert failedEdge != null;\n            /*\n             * We're iteratively moving up traversing the outer faces of the biconnected components\n             * to find externally active nodes x and y, which are on different branches of the outer\n             * face. The way we're finding the nodes x and y helps us eliminate the case E_1\n             * described in the original paper. This can be done because we always find the closest\n             * to the node w externally active nodes x and y.\n             */\n            Node x, y, v = failedEdge.target, w = failedEdge.source, componentRoot;\n            while (true) {\n                componentRoot = getComponentRoot(w);\n                x = getExternallyActiveSuccessorOnOuterFace(w, componentRoot, v, 1).getCurrent();\n                y = getExternallyActiveSuccessorOnOuterFace(w, componentRoot, v, 0).getCurrent();\n                if (x.isRootVertex()) {\n                    w = x.getParent();\n                } else if (y.isRootVertex()) {\n                    w = y.getParent();\n                } else {\n                    componentRoot = getComponentRoot(w);\n                    break;\n                }\n            }\n            Edge xBackEdge = searchEdge(x, v.height);\n            Edge yBackEdge = searchEdge(y, v.height);\n            if (DEBUG) {\n                System.out\n                    .printf(\n                        \"Failed v = %s, failed edge = %s\\n\", failedV.toString(false),\n                        failedEdge.toString());\n                System.out.printf(\"x = %s, y = %s\\n\", x.toString(false), y.toString(false));\n                System.out\n                    .printf(\n                        \"xBackEdge = %s, yBackEdge = %s\\n\", xBackEdge.toString(),\n                        yBackEdge.toString());\n            }\n            Node backLower = lowest(xBackEdge.target, yBackEdge.target);\n            Node backHigher = highest(xBackEdge.target, yBackEdge.target);\n            addPathEdges(subdivision, xBackEdge, x);\n            addPathEdges(subdivision, yBackEdge, y);\n            addBoundaryEdges(subdivision, componentRoot);\n\n            if (componentRoot.getParent() != v) {\n                // case A, v isn't a parent of the component we've found\n                if (PRINT_CASES) {\n                    System.out.println(\"Case A\");\n                }\n                addPathEdges(subdivision, componentRoot.getParent(), backLower);\n                addPathEdges(subdivision, failedEdge, w);\n                return finish(subdivision);\n            }\n            // node z will be null only if the tree path from w to failedEdge is failedEdge itself\n            Node z = getNextOnPath(w, failedEdge);\n            Edge backEdge = null;\n            if (z != null) {\n                backEdge = searchSubtreeDfs(z, e -> e.target.height < v.height && e != failedEdge);\n            }\n            if (backEdge != null) {\n                // case B\n                if (PRINT_CASES) {\n                    System.out.println(\"Case B\");\n                }\n                addPathEdges(subdivision, backEdge, w);\n                addPathEdges(subdivision, failedEdge, w);\n                Node highest =\n                    highest(xBackEdge.target, highest(yBackEdge.target, backEdge.target));\n                Node lowest = lowest(xBackEdge.target, lowest(yBackEdge.target, backEdge.target));\n                addPathEdges(subdivision, highest, lowest);\n                return finish(subdivision);\n            }\n            /*\n             * If we failed to either case A or B, we have to find a highest obstructing path and\n             * then deal with cases C - E\n             */\n            setBoundaryDepth(componentRoot, w, 0, 1);\n            setBoundaryDepth(componentRoot, w, 1, -1);\n\n            assert x.boundaryHeight > 0;\n            List<Edge> path = findHighestObstructingPath(componentRoot, w);\n            assert !path.isEmpty();\n            if (DEBUG) {\n                System.out.println(\"Path = \" + path);\n            }\n\n            Edge firstEdge = path.get(0);\n            Edge lastEdge = path.get(path.size() - 1);\n            Node firstNode =\n                firstEdge.source.boundaryHeight > 0 ? firstEdge.source : firstEdge.target;\n            Node lastNode = lastEdge.source.boundaryHeight < 0 ? lastEdge.source : lastEdge.target;\n            if (firstNode.boundaryHeight < x.boundaryHeight\n                || lastNode.boundaryHeight > y.boundaryHeight)\n            {\n                // case C, either the first node or the last node of the path is higher than x or y\n                // respectively\n                if (PRINT_CASES) {\n                    System.out.println(\"Case C\");\n                }\n                Node removeStart;\n                if (lastNode.boundaryHeight > y.boundaryHeight) {\n                    removeStart = firstNode.boundaryHeight < x.boundaryHeight ? firstNode : x;\n                    removeUp(removeStart, componentRoot, 1, subdivision);\n                } else {\n                    removeUp(y, componentRoot, 0, subdivision);\n                }\n                addPathEdges(subdivision, failedEdge, w);\n                subdivision.addAll(path);\n                addPathEdges(subdivision, v, backLower);\n                return finish(subdivision);\n            }\n            path.forEach(e -> e.source.marked = e.target.marked = true);\n            List<Edge> pathToV = findPathToV(path, v);\n            if (!pathToV.isEmpty()) {\n                // case D, we have a path to the node v\n                if (PRINT_CASES) {\n                    System.out.println(\"Case D\");\n                }\n                removeUp(x, componentRoot, 1, subdivision);\n                removeUp(y, componentRoot, 0, subdivision);\n                subdivision.addAll(path);\n                subdivision.addAll(pathToV);\n                addPathEdges(subdivision, v, backLower);\n                addPathEdges(subdivision, failedEdge, w);\n                return finish(subdivision);\n            }\n            Edge externallyActive = searchEdge(w, v.height, failedEdge);\n            assert externallyActive != null;\n            if (DEBUG) {\n                System.out.printf(\"Externally active edge = %s\\n\", externallyActive.toString());\n            }\n            addPathEdges(subdivision, externallyActive, w);\n            if (firstStrictlyHigher(externallyActive.target, xBackEdge.target, yBackEdge.target)) {\n                // case E_2, equivalent to A\n                if (PRINT_CASES) {\n                    System.out.println(\"Case E_2\");\n                }\n                addPathEdges(subdivision, componentRoot.getParent(), backLower);\n            } else if (firstStrictlyHigher(\n                xBackEdge.target, yBackEdge.target, externallyActive.target))\n            {\n                // case E_2, u_x is higher\n                if (PRINT_CASES) {\n                    System.out.println(\"Case E_2, u_x is higher\");\n                }\n                removeUp(componentRoot, x, 0, subdivision);\n                removeUp(w, lastNode, 0, subdivision);\n                subdivision.addAll(path);\n                addPathEdges(subdivision, failedEdge, w);\n                addPathEdges(subdivision, v, lowest(backLower, externallyActive.target));\n            } else if (firstStrictlyHigher(\n                yBackEdge.target, xBackEdge.target, externallyActive.target))\n            {\n                // case E_2, u_y is higher\n                if (PRINT_CASES) {\n                    System.out.println(\"Case E_2, u_y is higher\");\n                }\n                removeUp(y, componentRoot, 0, subdivision);\n                removeUp(firstNode, w, 0, subdivision);\n                subdivision.addAll(path);\n                addPathEdges(subdivision, failedEdge, w);\n                addPathEdges(subdivision, v, lowest(backLower, externallyActive.target));\n            } else if (firstNode.boundaryHeight > x.boundaryHeight) {\n                // case E_4, p_x is lower than x\n                if (PRINT_CASES) {\n                    System.out.println(\"Case E_3, p_x is lower than x\");\n                }\n                removeUp(w, lastNode, 0, subdivision);\n                subdivision.addAll(path);\n                addPathEdges(subdivision, failedEdge, w);\n                addPathEdges(\n                    subdivision, highest(backHigher, externallyActive.target),\n                    lowest(backLower, externallyActive.target));\n            } else if (lastNode.boundaryHeight < y.boundaryHeight) {\n                // case E_4, p_y is lower than y\n                if (PRINT_CASES) {\n                    System.out.println(\"Case E_3, p_y is lower than y\");\n                }\n                removeUp(firstNode, w, 0, subdivision);\n                subdivision.addAll(path);\n                addPathEdges(subdivision, failedEdge, w);\n                addPathEdges(\n                    subdivision, highest(backHigher, externallyActive.target),\n                    lowest(backLower, externallyActive.target));\n            } else {\n                // case E, extracting K_5\n                if (PRINT_CASES) {\n                    System.out.println(\"Case E, extracting K_5\");\n                }\n                subdivision.addAll(path);\n                addPathEdges(subdivision, v, lowest(backLower, externallyActive.target));\n                addPathEdges(subdivision, failedEdge, w);\n            }\n            return finish(subdivision);\n        }\n        return kuratowskiSubdivision;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Only the first call to this method does the actual computation, all subsequent calls only\n     * return the previously computed value.\n     */\n    @Override\n    public boolean isPlanar()\n    {\n        return lazyTestPlanarity();\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Only the first call to this method does the actual computation, all subsequent calls only\n     * return the previously computed value.\n     */\n    @Override\n    public Embedding<V, E> getEmbedding()\n    {\n        if (isPlanar()) {\n            return lazyComputeEmbedding();\n        } else {\n            throw new IllegalArgumentException(\"Graph is not planar\");\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Only the first call to this method does the actual computation, all subsequent calls only\n     * return the previously computed value.\n     */\n    @Override\n    public Graph<V, E> getKuratowskiSubdivision()\n    {\n        if (isPlanar()) {\n            throw new IllegalArgumentException(\"Graph is planar\");\n        } else {\n            return lazyExtractKuratowskiSubdivision();\n        }\n    }\n\n    /**\n     * Represents information needed to search a path within a biconnected component\n     */\n    private class SearchInfo\n    {\n        /**\n         * The current node of the dfs traversal\n         */\n        Node current;\n        /**\n         * The edge used to go to the {@code current} vertex\n         */\n        Edge prevEdge;\n        /**\n         * Whether dfs is in a forward or a backtracking phase\n         */\n        boolean backtrack;\n\n        /**\n         * Creates a new search info\n         *\n         * @param current the current node of the traversal\n         * @param prevEdge the edge used to go to the {@code current} vertex\n         * @param backtrack whether dfs is in a forward or a backtracking phase\n         */\n        SearchInfo(Node current, Edge prevEdge, boolean backtrack)\n        {\n            this.current = current;\n            this.prevEdge = prevEdge;\n            this.backtrack = backtrack;\n        }\n    }\n\n    /**\n     * Represents information needed to store in the stack during the input {@code graph}\n     * orientation.\n     */\n    private class OrientDfsStackInfo\n    {\n        /**\n         * The current vertex of the dfs traversal\n         */\n        V current;\n        /**\n         * The parent vertex of the {@code current} vertex, which is null for dfs tree roots\n         */\n        V parent;\n        /**\n         * The edge connecting {@code parent} and {@code current} vertices\n         */\n        E parentEdge;\n        /**\n         * Whether dfs is moving forward or backtracking on the {@code current} node\n         */\n        boolean backtrack;\n\n        /**\n         * Creates new instance of the information stored on the stack during the orientation of the\n         * {@code graph}\n         *\n         * @param current the vertex dfs is currently processing\n         * @param parent the parent of the {@code current} vertex\n         * @param parentEdge the edge between {@code current} and {@code parent} vertices\n         * @param backtrack whether dfs is moving forward or backtracking on the {@code current}\n         *        vertex\n         */\n        OrientDfsStackInfo(V current, V parent, E parentEdge, boolean backtrack)\n        {\n            this.current = current;\n            this.parent = parent;\n            this.parentEdge = parentEdge;\n            this.backtrack = backtrack;\n        }\n    }\n\n    /**\n     * The information needed to merge two consecutive biconnected components\n     */\n    private class MergeInfo\n    {\n        /**\n         * The node current traversal descended from. This node belongs to the parent biconnected\n         * component\n         */\n        Node parent;\n        /**\n         * The next node along the traversal of the parent biconnected component\n         */\n        Node parentNext;\n        /**\n         * The virtual root of the child biconnected component\n         */\n        Node child;\n        /**\n         * The previous node along the traversal of the child biconnected component\n         */\n        Node childPrev;\n        /**\n         * The direction used to enter the parent biconnected component.\n         * <p>\n         * <b>Note:</b> this value doesn't specify the direction from {@code parent} node to the\n         * {@code parentNext} node, i.e. {@code parent.outerFaceNeighbors[vIn]} may not be equal to\n         * the {@code parentNext}. Instead, this value specifies the direction used to start the\n         * traversal from the parent's biconnected component virtual root.\n         */\n        int vIn;\n        /**\n         * The direction used to start the traversal of the child biconnected component. Since the\n         * {@code child} is the component root, {@code child.outerFaceNeighbors[|1-vOut|]} is equal\n         * to the {@code childPrev}\n         */\n        int vOut;\n\n        /**\n         * Creates new instance of the infromation needed to merge to biconnected components\n         *\n         * @param parent the node current traversal descended from\n         * @param parentNext the next node along the traversal of the parent component\n         * @param child the virtual root of the child biconnected component\n         * @param childPrev the previous node along the traversal of the child component\n         * @param vIn the direction used to enter the parent biconnected component\n         * @param vOut the direction used to enter the child biconnected component\n         */\n        MergeInfo(Node parent, Node parentNext, Node child, Node childPrev, int vIn, int vOut)\n        {\n            this.parent = parent;\n            this.parentNext = parentNext;\n            this.child = child;\n            this.childPrev = childPrev;\n            this.vIn = vIn;\n            this.vOut = vOut;\n        }\n\n        /**\n         * Returns true if the traversal was inverted when descending to the child biconnected\n         * component, false otherwise\n         *\n         * @return true if the traversal was inverted when descending to the child biconnected\n         *         component, false otherwise\n         */\n        boolean isInverted()\n        {\n            return vIn != vOut;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            return String\n                .format(\n                    \"Parent dir = {%s -> %s}, child_dir = {%s -> %s}, inverted = %b, vIn = %d, vOut = %d\",\n                    parent.toString(false), parentNext.toString(false), childPrev.toString(false),\n                    child.toString(false), isInverted(), vIn, vOut);\n        }\n    }\n\n    /**\n     * A circulator over the nodes on the boundary of the biconnected component. Traverses the nodes\n     * in the cyclic manner, i.e. it doesn't stop when all the nodes are traversed\n     */\n    private class OuterFaceCirculator\n        implements\n        Iterator<Node>\n    {\n        /**\n         * The node this circulator will return next\n         */\n        private Node current;\n        /**\n         * The previous node along the traversal of the component boundary. This node is needed\n         * because the component boundary nodes aren't connected in an ordered way.\n         */\n        private Node prev;\n\n        /**\n         * Creates a new instance of the circulator over the biconnected component boundary nodes.\n         * The {@code prev} node is considered to be just traversed\n         *\n         * @param current the node this circulator will return next\n         * @param prev the previous node along the traversal\n         */\n        OuterFaceCirculator(Node current, Node prev)\n        {\n            this.current = current;\n            this.prev = prev;\n        }\n\n        /**\n         * {@inheritDoc}\n         * <p>\n         * Always returns true since this is a circulator\n         */\n        @Override\n        public boolean hasNext()\n        {\n            return true;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Node next()\n        {\n            Node t = current;\n            current = current.nextOnOuterFace(prev);\n            prev = t;\n            return prev;\n        }\n\n        /**\n         * Returns an edge connecting previously returned node with node, which will be returned\n         * next. If either of the mentioned nodes is virtual, the edge will be incident to its real\n         * counterpart.\n         *\n         * @return an edge from the current node to the next node\n         */\n        Edge edgeToNext()\n        {\n            Edge edge = prev.embedded.getFirst();\n            Node target = toExistingNode(current);\n            Node source = toExistingNode(prev);\n            if (edge.getOpposite(source) == target) {\n                return edge;\n            } else {\n                return prev.embedded.getLast();\n            }\n        }\n\n        /**\n         * Returns the node this circulator has just traversed\n         *\n         * @return the node this circulator has just traversed\n         */\n        Node getCurrent()\n        {\n            return prev;\n        }\n\n        /**\n         * Returns a node adjacent to the current node along the boundary, which is not equal to the\n         * next node along the traversal. If the component consist of just one real node, returns\n         * the only neighbor the the current node.\n         *\n         * @return node before the current node along the traversal\n         */\n        Node getPrev()\n        {\n            return prev.nextOnOuterFace(current);\n        }\n\n        /**\n         * Returns either {@code node} or its real counterpart in the case the {@code node} is a\n         * component root.\n         *\n         * @param node the input argument\n         * @return the real counterpath of the {@code node}\n         */\n        private Node toExistingNode(Node node)\n        {\n            return node.isRootVertex() ? node.getParent() : node;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            return String.format(\"%s -> %s\", prev.toString(false), current.toString(false));\n        }\n    }\n\n    /**\n     * Internal representation of the edges of the input {@code graph}.\n     */\n    private class Edge\n    {\n        /**\n         * The counterpart of this edge in the {@code graph}. This value can be null if the edge was\n         * created as a short-circuit edge.\n         */\n        E graphEdge;\n        /**\n         * The source node of this edge. For tree edges the {@code source} is lower than the\n         * {@code target}, for back edges the {@code target} is lower (having smaller height)\n         */\n        Node source;\n        /**\n         * The target of this edge\n         */\n        Node target;\n        /**\n         * Either $+1$ or $-1$ for regular and inverted edges respectively. This value is set to\n         * $-1$ to flip a biconnected component in $\\mathcal{O}(1)$ time. <b>Note:</b> this\n         * operation doesn't flip any of the child biconnected components of this biconnected\n         * component\n         */\n        int sign;\n        /**\n         * Whether the edge is embedded or not. This value is important for\n         */\n        boolean embedded;\n        /**\n         * Whether the edge is real or short-circuit. See the original paper for the definition of\n         * the short-circuit edges.\n         */\n        boolean shortCircuit;\n\n        /**\n         * Creates a new short-circuit edge with no counterpart in {@code graph}. The {@code source}\n         * of this edge is always a real node on the boundary of some biconnected component, and the\n         * {@code target} node is the parent node of the biconnected component the source node\n         * belongs to, so the edge resembles a regular back edge except for that it doesn't have a\n         * counterpart in the {@code graph}\n         *\n         * @param source the source of the short-circuit edge\n         * @param target the target of the short-circuit edge\n         */\n        Edge(Node source, Node target)\n        {\n            this(null, source, target);\n            this.shortCircuit = true;\n            this.embedded = true;\n        }\n\n        /**\n         * Creates a new tree edge.\n         *\n         * @param graphEdge the counterpart of this edge in the {@code graph}\n         * @param source the source node of this edge\n         */\n        Edge(E graphEdge, Node source)\n        {\n            this(graphEdge, source, null);\n        }\n\n        /**\n         * Creates a new edge. This constructor is used directly for the creation of the back edges\n         *\n         * @param graphEdge the counterpart of this edge in the {@code graph}\n         * @param source the source node of this edge\n         * @param target the target node of this edge\n         */\n        Edge(E graphEdge, Node source, Node target)\n        {\n            this.graphEdge = graphEdge;\n            this.source = source;\n            this.target = target;\n            this.sign = 1;\n        }\n\n        /**\n         * True if this edge is incident to the node {@code node}, false otherwise\n         *\n         * @param node the node to test\n         * @return true if this edge is incident to the node {@code node}, false otherwise\n         */\n        boolean isIncidentTo(Node node)\n        {\n            return source == node || target == node;\n        }\n\n        /**\n         * Returns the opposite node of the {@code node}\n         *\n         * @param node an endpoint of this edge\n         * @return the other endpoint of this edge\n         */\n        Node getOpposite(Node node)\n        {\n            assert isIncidentTo(node); // debug purpose assertion\n            return source == node ? target : source;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            String formatString = \"%s -> %s\";\n            if (shortCircuit) {\n                formatString = \"%s ~ %s\";\n            }\n            return String.format(formatString, source.toString(false), target.toString(false));\n        }\n    }\n\n    /**\n     * The internal representation of the vertices of the graph. Contains necessary information to\n     * perform dfs traversals, biconnected component boundary traversals, to embed edges, etc.\n     */\n    private class Node\n    {\n        /**\n         * The counterpart of this node in the {@code graph}. For the component roots this value is\n         * {@code null}.\n         */\n        V graphVertex;\n        /**\n         * Whether this node is a root of the biconnected component or not.\n         */\n        boolean rootVertex;\n        /**\n         * The dfs index of this node in the graph. Every node has a unique dfs index in the range\n         * $[0,|V| - 1]$. This value is used to order the nodes for the embedding of the edges\n         * incident to them. The index of the first dfs root is $1$\n         */\n        int dfsIndex;\n        /**\n         * The height of the node in the created dfs tree. The root of the tree has height $0$. The\n         * smaller this value is, the lower the node is considered to be.\n         */\n        int height;\n        /**\n         * The least <b>dfs index</b> of the nodes' least ancestors in the subtree rooted at this\n         * node. If the subtree doesn't contain a node with a back edge, that ends lower that this\n         * node, this value is equal to the dfs index of this node.\n         */\n        int lowpoint;\n        /**\n         * The least dfs index of the nodes adjacent to this node. If the node doesn't have incident\n         * back edges, this value is equal to the dfs index of the node itself.\n         */\n        int leastAncestor;\n        /**\n         * Stores some value to indicate whether this node is visited in the current context or not.\n         * During the testing phase, if this value if equal to the dfs index of the currently\n         * processed node $v$, then this node is visited, otherwise not. During the Kuratowski\n         * subdivision extraction phase, the value of $0$ indicates that the node isn't visited,\n         * otherwise, the node is considered to be visited.\n         */\n        int visited;\n        /**\n         * During the process of embedding of the down edges of the node $v$, this variable is set\n         * to the dfs index of $v$ to indicate that this node has a back edge incident to $v$, which\n         * needs to be embedded.\n         */\n        int backEdgeFlag;\n        /**\n         * The height of this node on the boundary of the biconnected component, which is used to\n         * extract the Kuratowski subdivision. The height of the component root is $0$, the heights\n         * on the left side are positive, on the right side - negative. This value is used to\n         * quickly determine for two nodes on the same boundary branch which one is higher (closer\n         * to the component root).\n         */\n        int boundaryHeight;\n        /**\n         * Used to mark the boundary nodes of the biconnected\n         */\n        boolean marked;\n        /**\n         * Edge to the parent node of this node in the dfs tree. For tree roots this value is\n         * {@code null}\n         */\n        Edge parentEdge;\n        /**\n         * If this node has a back edge incident to the currently processed node $v$, then this\n         * variable stores this edge\n         */\n        Edge edgeToEmbed;\n        /**\n         * The component root the node is created in. For dfs tree roots this value is {@code null}\n         */\n        Node initialComponentRoot;\n        /**\n         * Two neighbors on the outer face of the biconnected component. Their order is completely\n         * irrelevant for the algorithm to traverse the outer face.\n         */\n        Node[] outerFaceNeighbors;\n        /**\n         * The list containing the dfs children of this node, which are in the different child\n         * biconnected component, i.e. their weren't merged in the parent component.\n         */\n        DoublyLinkedList<Node> separatedDfsChildList;\n        /**\n         * The roots of the pertinent components during the processing of the node $v$. These are\n         * the components that have pertinent descendant nodes, i.e. nodes incident to the node $v$\n         * via a back edge\n         */\n        DoublyLinkedList<Node> pertinentRoots;\n        /**\n         * The list of tree edges incident to this node in the dfs tree. This list doesn't contain a\n         * parent edge of this node\n         */\n        List<Edge> treeEdges;\n        /**\n         * The list containing the edges from descendants of this node in the dfs tree. For each\n         * such descendant the corresponding edge is a back edge.\n         */\n        List<Edge> downEdges;\n        /**\n         * The list of back edges incident to this node.\n         */\n        List<Edge> backEdges;\n        /**\n         * Stores the list node from the {@code separatedDfsChildList} of the parent node this node\n         * is stored in. This enable deleting of this node from the {@code separatedDfsChildList}\n         * list in $\\mathcal{O}(1)$ time\n         */\n        DoublyLinkedList.ListNode<Node> listNode;\n        /**\n         * The list of the embedded edges incident to this node in a clockwise or a counterclockwise\n         * order. The order is counterclockwise if the product of the signs of the parent edges\n         * along the path from the root of the component this node is contained in to this node is\n         * equal to $-1$. Otherwise, the order is clockwise.\n         */\n        DoublyLinkedList<Edge> embedded;\n\n        /**\n         * Creates a new real node with the specified parameters.\n         *\n         * @param graphVertex the counterpart of this node in the {@code graph}\n         * @param dfsIndex the dfs index of this node\n         * @param height the height of this node in the dfs tree\n         * @param initialComponentRoot the component root of this node.\n         * @param parentEdge the parent edge of this node\n         */\n        Node(V graphVertex, int dfsIndex, int height, Node initialComponentRoot, Edge parentEdge)\n        {\n            this(graphVertex, dfsIndex, parentEdge, false);\n            this.height = height;\n            this.initialComponentRoot = initialComponentRoot;\n        }\n\n        /**\n         * Creates a new component root. Dfs index of the component root is equal to dfs index of\n         * its parent.\n         *\n         * @param dfsIndex the dfs index of this node\n         * @param parentEdge the parent edge of this component root\n         */\n        Node(int dfsIndex, Edge parentEdge)\n        {\n            this(null, dfsIndex, parentEdge, true);\n        }\n\n        /**\n         * Creates a new node with the specified parameters\n         *\n         * @param graphVertex the vertex in the {@code graph} corresponding to this node\n         * @param dfsIndex the dfs index of this node\n         * @param parentEdge the parent edge of this node\n         * @param rootVertex whether this is real or virtual node\n         */\n        Node(V graphVertex, int dfsIndex, Edge parentEdge, boolean rootVertex)\n        {\n            this.graphVertex = graphVertex;\n            this.dfsIndex = dfsIndex;\n            this.parentEdge = parentEdge;\n            this.rootVertex = rootVertex;\n            this.outerFaceNeighbors = TypeUtil.uncheckedCast(Array.newInstance(Node.class, 2));\n            this.embedded = new DoublyLinkedList<>();\n            if (parentEdge != null) {\n                embedded.add(parentEdge);\n            }\n            this.visited = this.backEdgeFlag = n;\n            if (!rootVertex) {\n                separatedDfsChildList = new DoublyLinkedList<>();\n                pertinentRoots = new DoublyLinkedList<>();\n                treeEdges = new ArrayList<>();\n                downEdges = new ArrayList<>();\n                backEdges = new ArrayList<>();\n            }\n        }\n\n        /**\n         * Checks whether this node is visited in the context of processing the node {@code node}\n         *\n         * @param node the node that is currently been processed\n         * @return true if this node is visited, false otherwise\n         */\n        boolean isVisitedWrtTo(Node node)\n        {\n            return node.dfsIndex == visited;\n        }\n\n        /**\n         * Checks whether this node is pertinent in the context of processing the node {@code node}.\n         * During the processing of the node {@code node}, a node is pertinent if it has a back edge\n         * to {@code node} or it has a child biconnected component, which has a pertinent node.\n         *\n         * @param node the node that is currently been processed\n         * @return true if this node is pertinent, false otherwise\n         */\n        boolean isPertinentWrtTo(Node node)\n        {\n            return backEdgeFlag == node.dfsIndex || !pertinentRoots.isEmpty();\n        }\n\n        /**\n         * Checks whether this node has a back edge to the {@code node}.\n         *\n         * @param node the other endpoint of the edge we're looking for\n         * @return true if the edge between this node and {@code node} exists, false otherwise\n         */\n        boolean hasBackEdgeWrtTo(Node node)\n        {\n            return backEdgeFlag == node.dfsIndex;\n        }\n\n        /**\n         * Checks whether this node is externally active with respect to the {@code node}. A node is\n         * externally active, if it is incident to the edge ending higher than {@code node}, or it\n         * has a child biconnected component with a pertinent node\n         *\n         * @param node an ancestor of this node\n         * @return true if this node is externally active with respect to the {@code node}, false\n         *         otherwise\n         */\n        boolean isExternallyActiveWrtTo(Node node)\n        {\n            return leastAncestor < node.dfsIndex || (!separatedDfsChildList.isEmpty()\n                && separatedDfsChildList.getFirst().lowpoint < node.dfsIndex);\n        }\n\n        /**\n         * Returns true if the node is a component root, false otherwise\n         *\n         * @return true if the node is a component root, false otherwise\n         */\n        boolean isRootVertex()\n        {\n            return rootVertex;\n        }\n\n        /**\n         * Check whether this node is internally active. A node is internally active if it's\n         * pertinent and not externally active\n         *\n         * @param node an ancestor of this node\n         * @return true if this node is internally active, false otherwise\n         */\n        boolean isInternallyActiveWrtTo(Node node)\n        {\n            return isPertinentWrtTo(node) && !isExternallyActiveWrtTo(node);\n        }\n\n        /**\n         * Check whether this node is inactive. A node is inactive it is neither pertinent nor\n         * externally active\n         *\n         * @param node an ancestor of this node\n         * @return true if this node is inactive, false otherwise\n         */\n        boolean isInactiveWrtTo(Node node)\n        {\n            return !isExternallyActiveWrtTo(node) && !isPertinentWrtTo(node);\n        }\n\n        /**\n         * Check whether this node is active. A node is active it is either pertinent or externally\n         * active\n         *\n         * @param node an ancestor of this node\n         * @return true if this node is active, false otherwise\n         */\n        boolean isActiveWrtTo(Node node)\n        {\n            return !isInactiveWrtTo(node);\n        }\n\n        /**\n         * Returns a circulator, that moves in the direction {@code direction}. The next node along\n         * the traversal will be {@code this.outerFaceNeighbor[direction]}.\n         *\n         * @param direction the direction to move in\n         * @return an iterator over the boundary nodes in the direction {@code direction}\n         */\n        OuterFaceCirculator iterator(int direction)\n        {\n            return new OuterFaceCirculator(outerFaceNeighbors[direction], this);\n        }\n\n        void removeShortCircuitEdges()\n        {\n            embedded.removeIf(e -> e.shortCircuit);\n        }\n\n        /**\n         * Returns the parent of this node in the dfs tree. Tree parent of the dfs root node is\n         * {@code null}\n         *\n         * @return the parent of this node in the dfs tree\n         */\n        Node getParent()\n        {\n            return parentEdge == null ? null : parentEdge.source;\n        }\n\n        /**\n         * Checks whether this node has a neighbor {@code node} on the boundary of the biconnected\n         * component\n         *\n         * @param node a possible neighbor of this node\n         */\n        void checkIsAdjacent(Node node)\n        {\n            assert node == outerFaceNeighbors[0] || node == outerFaceNeighbors[1];\n        }\n\n        /**\n         * Swaps the outer face neighbors of this node\n         */\n        void swapNeighbors()\n        {\n            Node t = outerFaceNeighbors[0];\n            outerFaceNeighbors[0] = outerFaceNeighbors[1];\n            outerFaceNeighbors[1] = t;\n        }\n\n        /**\n         * Substitutes the neighbor {@code node} with a {@code newNeighbor}\n         *\n         * @param node an old neighbor\n         * @param newNeighbor a new neighbor\n         */\n        void substitute(Node node, Node newNeighbor)\n        {\n            checkIsAdjacent(node);\n            if (outerFaceNeighbors[0] == node) {\n                outerFaceNeighbors[0] = newNeighbor;\n            } else {\n                outerFaceNeighbors[1] = newNeighbor;\n            }\n        }\n\n        /**\n         * Substitutes a neighbor of this node, which is not equal to the {@code node}, with the\n         * {@code newNeighbor}\n         *\n         * @param node the remaining neighbor\n         * @param newNeighbor a new neighbor\n         */\n        void substituteAnother(Node node, Node newNeighbor)\n        {\n            checkIsAdjacent(node);\n            if (outerFaceNeighbors[0] == node) {\n                outerFaceNeighbors[1] = newNeighbor;\n            } else {\n                outerFaceNeighbors[0] = newNeighbor;\n            }\n        }\n\n        /**\n         * Checks whether this node has a neighbor, which is a root of a biconnected component\n         *\n         * @return true, if this node has a root node neighbor, false otherwise\n         */\n        boolean hasRootNeighbor()\n        {\n            return outerFaceNeighbors[0].isRootVertex() || outerFaceNeighbors[1].isRootVertex();\n        }\n\n        /**\n         * Returns a neighbor of this node which is not equal to the {@code prev}\n         *\n         * @param prev a neighbor of this node\n         * @return a neightbor, which is not equal to the {@code prev}\n         */\n        Node nextOnOuterFace(Node prev)\n        {\n            checkIsAdjacent(prev);\n            if (outerFaceNeighbors[0] == prev) {\n                return outerFaceNeighbors[1];\n            } else {\n                return outerFaceNeighbors[0];\n            }\n        }\n\n        /**\n         * Adds {@code edge} to the list of the embedded edges such that the {@code prev} node\n         * becomes an inner node.\n         *\n         * @param edge an edge to embed\n         * @param prev the node which should be on the new inner face\n         */\n        void embedBackEdge(Edge edge, Node prev)\n        {\n            assert !embedded.isEmpty();\n            if (prev.isRootVertex()) {\n                prev = prev.getParent();\n            }\n            Edge firstEdge = embedded.getFirst();\n            if (firstEdge.getOpposite(this) == prev) {\n                // edge on the new inner face is at the beginning of the list\n                embedded.addFirst(edge);\n            } else {\n                embedded.addLast(edge);\n            }\n        }\n\n        /**\n         * Merges the embedded edges of the child component root into this node's embedded edges.\n         * Note, that the edges in the {@code edges} list are always in the clockwise order. There\n         * are 3 parameters which determine how the {@code edges} list is merged: the {@code vIn}\n         * direction, the {@code vOut} direction and the orientation of the edges around this node\n         * (clockwise or counterclockwise). The edges in the {@code edges} list should have the same\n         * orientation. If this list is inverted, the sign of the {@code parentEdge} is set to $-1$.\n         *\n         * @param edges the edges from the child component root\n         * @param vIn the direction used to enter the parent component\n         * @param vOut the direction used to enter the child component\n         * @param parentNext the next node along the traversal of the parent biconnected component\n         * @param parentEdge the parent edge if the child component\n         */\n        void mergeChildEdges(\n            DoublyLinkedList<Edge> edges, int vIn, int vOut, Node parentNext, Edge parentEdge)\n        {\n            assert !embedded.isEmpty();\n            Node firstOpposite = embedded.getFirst().getOpposite(this);\n            boolean alongParentTraversal = firstOpposite != parentNext;\n            boolean actionAppend = false, invert = false;\n            if (vIn == 0) {\n                if (vOut == 0) {\n                    if (!alongParentTraversal) {\n                        invert = actionAppend = true;\n                    }\n                } else {\n                    if (alongParentTraversal) {\n                        invert = true;\n                    } else {\n                        actionAppend = true;\n                    }\n                }\n            } else {\n                if (vOut == 0) {\n                    if (!alongParentTraversal) {\n                        invert = actionAppend = true;\n                    }\n                } else {\n                    if (alongParentTraversal) {\n                        invert = true;\n                    } else {\n                        actionAppend = true;\n                    }\n                }\n            }\n            if (invert) {\n                parentEdge.sign = -1;\n                edges.invert();\n            }\n            if (actionAppend) {\n                embedded.append(edges);\n            } else {\n                embedded.prepend(edges);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            String neighbor1 =\n                outerFaceNeighbors[0] == null ? \"null\" : outerFaceNeighbors[0].toString(false);\n            String neighbor2 =\n                outerFaceNeighbors[1] == null ? \"null\" : outerFaceNeighbors[1].toString(false);\n            String childListString = \"null\";\n            if (separatedDfsChildList != null) {\n                StringBuilder builder = new StringBuilder(\"{\");\n                separatedDfsChildList.forEach(n -> builder.append(n.toString(false)).append(\", \"));\n                childListString = builder.append(\"}\").toString();\n            }\n            if (rootVertex) {\n                return String\n                    .format(\n                        \"R {%s}: neighbors = [%s, %s], embedded = %s, visited = %d, back_edge_flag = %d, dfs_index = %d\",\n                        toString(false), neighbor1, neighbor2, embedded.toString(), visited,\n                        backEdgeFlag, dfsIndex);\n            } else {\n                return String\n                    .format(\n                        \"{%s}:  neighbors = [%s, %s], embedded = %s, visited = %d, back_edge_flag = %d, dfs_index = %d, separated = %s, tree_edges = %s, down_edges = %s, back_edges = %s, parent = %s, lowpoint = %d, least_ancestor = %d\",\n                        toString(false), neighbor1, neighbor2, embedded.toString(), visited,\n                        backEdgeFlag, dfsIndex, childListString, treeEdges.toString(),\n                        downEdges.toString(), backEdges.toString(),\n                        parentEdge == null ? \"null\" : parentEdge.source.toString(false), lowpoint,\n                        leastAncestor);\n            }\n        }\n\n        /**\n         * Returns a full or a partial string representation of this node\n         *\n         * @param full whether to return full or partial string representation of this node\n         * @return either full or partial string representation of this node\n         */\n        public String toString(boolean full)\n        {\n            if (!full) {\n                if (rootVertex) {\n                    return String\n                        .format(\n                            \"%s^%s\", parentEdge.source.graphVertex.toString(),\n                            parentEdge.target.graphVertex.toString());\n                } else {\n                    return graphVertex.toString();\n                }\n            } else {\n                return toString();\n            }\n        }\n    }\n}\n",
            "file_name": "BoyerMyrvoldPlanarityInspector.java",
            "human_label": "Find a circulator to the node that satisfies the Interface predicate.",
            "level": "class_runnable",
            "lineno": "668",
            "name": "selectOnOuterFace",
            "oracle_context": "{ \"apis\" : \"[iterator, next, test, OuterFaceCirculator, Node]\", \"classes\" : \"[OuterFaceCirculator, Node]\", \"vars\" : \"[]\" }",
            "package": "org.jgrapht.alg.planar",
            "project": "jgrapht-master"
        },
        {
            "_id": "636766a91a6d9265ec0175ae",
            "all_context": "{ \"class_level\" : \"byte[] data;\\nint length;\\nByteVector(int initialCapacity);\\nput11(int byteValue1,int byteValue2);\\nputShort(int shortValue);\\nput12(int byteValue,int shortValue);\\nputInt(int intValue);\\nput122(int byteValue,int shortValue1,int shortValue2);\\nputLong(long longValue);\\nputUTF8(String stringValue);\\nencodeUtf8(String stringValue,int offset,int maxByteLength);\\nputByteArray(byte[] byteArrayValue,int byteOffset,int byteLength);\\nenlarge(int size);\\nputByte(int byteValue);\\n\", \"repo_level\" : \"\" }",
            "class_name": "ByteVector",
            "code": "public ByteVector putByteArray(final byte[] byteArrayValue,final int byteOffset,final int byteLength){\n  if (length + byteLength > data.length) {\n    enlarge(byteLength);\n  }\n  if (byteArrayValue != null) {\n    System.arraycopy(byteArrayValue,byteOffset,data,length,byteLength);\n  }\n  length+=byteLength;\n  return this;\n}\n",
            "docstring": "/** \n * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} nullbytes into this byte vector.\n * @param byteOffset     index of the first byte of byteArrayValue that must be copied.\n * @param byteLength     number of bytes of byteArrayValue that must be copied.\n * @return this byte vector.\n */\n",
            "end_lineno": "319",
            "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage com.alibaba.fastjson2.internal.asm;\n\n/**\n * A dynamically extensible vector of bytes. This class is roughly equivalent to a DataOutputStream\n * on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n */\npublic class ByteVector {\n    /**\n     * The content of this vector. Only the first {@link #length} bytes contain real data.\n     */\n    byte[] data;\n\n    /**\n     * The actual number of bytes in this vector.\n     */\n    int length;\n//\n//    /**\n//     * Constructs a new {@link ByteVector} with a default initial capacity.\n//     */\n//    public ByteVector() {\n//        data = new byte[64];\n//    }\n\n    /**\n     * Constructs a new {@link ByteVector} with the given initial capacity.\n     *\n     * @param initialCapacity the initial capacity of the byte vector to be constructed.\n     */\n    public ByteVector(final int initialCapacity) {\n        data = new byte[initialCapacity];\n    }\n\n    /**\n     * Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue a byte.\n     * @return this byte vector.\n     */\n    public ByteVector putByte(final int byteValue) {\n        int currentLength = length;\n        if (currentLength + 1 > data.length) {\n            enlarge(1);\n        }\n        data[currentLength++] = (byte) byteValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue1 a byte.\n     * @param byteValue2 another byte.\n     * @return this byte vector.\n     */\n    final ByteVector put11(final int byteValue1, final int byteValue2) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue1;\n        currentData[currentLength++] = (byte) byteValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    public ByteVector putShort(final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteValue  a byte.\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    final ByteVector put12(final int byteValue, final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 3 > data.length) {\n            enlarge(3);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param intValue an int.\n     * @return this byte vector.\n     */\n    public ByteVector putInt(final int intValue) {\n        int currentLength = length;\n        if (currentLength + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\n     * if necessary.\n     *\n     * @param byteValue   a byte.\n     * @param shortValue1 a short.\n     * @param shortValue2 another short.\n     * @return this byte vector.\n     */\n    final ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) {\n        int currentLength = length;\n        if (currentLength + 5 > data.length) {\n            enlarge(5);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue1 >>> 8);\n        currentData[currentLength++] = (byte) shortValue1;\n        currentData[currentLength++] = (byte) (shortValue2 >>> 8);\n        currentData[currentLength++] = (byte) shortValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param longValue a long.\n     * @return this byte vector.\n     */\n    public ByteVector putLong(final long longValue) {\n        int currentLength = length;\n        if (currentLength + 8 > data.length) {\n            enlarge(8);\n        }\n        byte[] currentData = data;\n        int intValue = (int) (longValue >>> 32);\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        intValue = (int) longValue;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param stringValue a String whose UTF8 encoded length must be less than 65536.\n     * @return this byte vector.\n     */\n    // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\n    public ByteVector putUTF8(final String stringValue) {\n        int charLength = stringValue.length();\n        if (charLength > 65535) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        int currentLength = length;\n        if (currentLength + 2 + charLength > data.length) {\n            enlarge(2 + charLength);\n        }\n        byte[] currentData = data;\n        // Optimistic algorithm: instead of computing the byte length and then serializing the string\n        // (which requires two loops), we assume the byte length is equal to char length (which is the\n        // most frequent case), and we start serializing the string right away. During the\n        // serialization, if we find that this assumption is wrong, we continue with the general method.\n        currentData[currentLength++] = (byte) (charLength >>> 8);\n        currentData[currentLength++] = (byte) charLength;\n        for (int i = 0; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= '\\u0001' && charValue <= '\\u007F') {\n                currentData[currentLength++] = (byte) charValue;\n            } else {\n                length = currentLength;\n                return encodeUtf8(stringValue, i, 65535);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary. The string length is encoded in two bytes before the encoded characters, if there is\n     * space for that (i.e. if this.length - offset - 2 &gt;= 0).\n     *\n     * @param stringValue   the String to encode.\n     * @param offset        the index of the first character to encode. The previous characters are supposed\n     *                      to have already been encoded, using only one byte per character.\n     * @param maxByteLength the maximum byte length of the encoded string, including the already\n     *                      encoded characters.\n     * @return this byte vector.\n     */\n    final ByteVector encodeUtf8(final String stringValue, final int offset, final int maxByteLength) {\n        int charLength = stringValue.length();\n        int byteLength = offset;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                byteLength++;\n            } else if (charValue <= 0x07FF) {\n                byteLength += 2;\n            } else {\n                byteLength += 3;\n            }\n        }\n        if (byteLength > maxByteLength) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        // Compute where 'byteLength' must be stored in 'data', and store it at this location.\n        int byteLengthOffset = length - offset - 2;\n        if (byteLengthOffset >= 0) {\n            data[byteLengthOffset] = (byte) (byteLength >>> 8);\n            data[byteLengthOffset + 1] = (byte) byteLength;\n        }\n        if (length + byteLength - offset > data.length) {\n            enlarge(byteLength - offset);\n        }\n        int currentLength = length;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                data[currentLength++] = (byte) charValue;\n            } else if (charValue <= 0x07FF) {\n                data[currentLength++] = (byte) (0xC0 | charValue >> 6 & 0x1F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            } else {\n                data[currentLength++] = (byte) (0xE0 | charValue >> 12 & 0xF);\n                data[currentLength++] = (byte) (0x80 | charValue >> 6 & 0x3F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\n     *                       bytes into this byte vector.\n     * @param byteOffset     index of the first byte of byteArrayValue that must be copied.\n     * @param byteLength     number of bytes of byteArrayValue that must be copied.\n     * @return this byte vector.\n     */\n    public ByteVector putByteArray(\n            final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n        if (length + byteLength > data.length) {\n            enlarge(byteLength);\n        }\n        if (byteArrayValue != null) {\n            System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength);\n        }\n        length += byteLength;\n        return this;\n    }\n\n    /**\n     * Enlarges this byte vector so that it can receive 'size' more bytes.\n     *\n     * @param size number of additional bytes that this byte vector should be able to receive.\n     */\n    private void enlarge(final int size) {\n        int doubleCapacity = 2 * data.length;\n        int minimalCapacity = length + size;\n        byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\n        System.arraycopy(data, 0, newData, 0, length);\n        data = newData;\n    }\n}\n",
            "file_name": "ByteVector.java",
            "human_label": "Add a byte array into the byte vector.",
            "level": "class_runnable",
            "lineno": "299",
            "name": "putByteArray",
            "oracle_context": "{ \"apis\" : \"[enlarge, arraycopy, ByteVector]\", \"classes\" : \"[data]\", \"vars\" : \"[length, data]\" }",
            "package": "com.alibaba.fastjson2.internal.asm",
            "project": "fastjson2-main"
        },
        {
            "_id": "636766f11a6d9265ec01764f",
            "all_context": "{ \"class_level\" : \"import net.hasor.utils.BeanUtils;\\nimport java.beans.BeanInfo;\\nimport java.beans.IntrospectionException;\\nimport java.beans.Introspector;\\nimport java.beans.PropertyDescriptor;\\nimport java.lang.reflect.Constructor;\\nimport java.lang.reflect.InvocationTargetException;\\nimport java.lang.reflect.Method;\\nimport java.util.*;\\nObject bean;\\nMap<String,Method> readMethods;\\nMap<String,Method> writeMethods;\\nMap<String,Class<?>> types;\\nObject[] NULL_ARGUMENTS;\\nMap<Class<?>,Transformer> typeTransformers;\\nBeanMap owner;\\ncreateTypeTransformers();\\nBeanMap();\\nBeanMap(Object bean);\\nclone();\\nputAllWriteable(BeanMap map);\\nclear();\\ncontainsKey(Object name);\\ncontainsValue(Object value);\\nget(Object name);\\nput(String name,Object value);\\nsize();\\nkeySet();\\nentrySet();\\niterator();\\nvalues();\\ngetType(String name);\\nkeyIterator();\\nvalueIterator();\\nhasNext();\\nnext();\\nremove();\\nentryIterator();\\ngetBean();\\nsetBean(Object newBean);\\ngetReadMethod(String name);\\ngetWriteMethod(String name);\\ngetReadMethod(Object name);\\ngetWriteMethod(Object name);\\nreinitialise();\\ninitialise();\\nfirePropertyChange(Object key,Object oldValue,Object newValue);\\nEntry(BeanMap owner,String key,Object value);\\nsetValue(Object value);\\ncreateWriteMethodArguments(Method method,Object value);\\nconvertType(Class newType,Object value);\\ngetTypeTransformer(Class aType);\\nlogInfo(Exception ex);\\nlogWarn(Exception ex);\\ntoString();\\n\", \"repo_level\" : \"public interface BeanUtils {static Object getDefaultValue(Class returnType);\\nstatic Object[] getDefaultValue(Class<?>[] paramArray);\\nstatic Object invokeMethod(Object target,String methodName,Object objects);\\nstatic List<Field> findALLFields(Class target);\\nstatic List<Method> findALLMethods(Class target);\\nstatic List<Field> getFields(Class type);\\nstatic List<Method> getMethods(Class type);\\nstatic Field getField(String fieldName,Class type);\\nstatic Method getMethod(Class atClass,String name,Class<?>[] paramType);\\nstatic List<String> getPropertiesAndFields(Class target);\\nstatic List<String> getProperties(Class target);\\nstatic PropertyDescriptor[] getPropertyDescriptors(Class defineType);\\nstatic Method getReadMethod(String property,Class target);\\nstatic Method getWriteMethod(String property,Class target);\\nstatic boolean hasProperty(String propertyName,Class target);\\nstatic boolean hasField(String propertyName,Class target);\\nstatic boolean hasPropertyOrField(String name,Class target);\\nstatic boolean canReadProperty(String propertyName,Class target);\\nstatic boolean canReadPropertyOrField(String propertyName,Class target);\\nstatic boolean canWriteProperty(String propertyName,Class target);\\nstatic boolean canWriteField(String propertyName,Class target);\\nstatic boolean canWritePropertyOrField(String propertyName,Class target);\\nstatic boolean writeProperty(Object object,String attName,Object value);\\nstatic boolean writeField(Object object,String fieldName,Object value);\\nstatic boolean writePropertyOrField(Object object,String attName,Object value);\\nstatic Object readProperty(Object object,String attName);\\nstatic Object readField(Object object,String fieldName);\\nstatic Object readPropertyOrField(Object object,String attName);\\nstatic Class<?> getPropertyType(Class defineType,String attName);\\nstatic Class<?> getFieldType(Class defineType,String attName);\\nstatic Class<?> getPropertyOrFieldType(Class defineType,String attName);\\nstatic void copyProperties(Object dest,Object orig);\\nstatic void copyProperty(Object dest,Object orig,String propertyName);\\n }\\n\" }",
            "class_name": "BeanMap",
            "code": "public Collection<Object> values(){\n  ArrayList<Object> answer=new ArrayList<>(readMethods.size());\n  for (Iterator<Object> iter=valueIterator(); iter.hasNext(); ) {\n    answer.add(iter.next());\n  }\n  return Collections.unmodifiableList(answer);\n}\n",
            "docstring": "/** \n * Returns the values for the BeanMap.\n * @return values for the BeanMap. The returned collection is not modifiable.\n */\n",
            "end_lineno": "316",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.ref;\nimport net.hasor.utils.BeanUtils;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.*;\n\n/**\n * An implementation of Map for JavaBeans which uses introspection to\n * get and put properties in the bean.\n * <p>\n * If an exception occurs during attempts to get or set a property then the\n * property is considered non existent in the Map\n *\n * @version $Revision: 812176 $ $Date: 2009-09-07 15:59:25 +0100 (Mon, 07 Sep 2009) $\n *\n * @author James Strachan\n * @author Stephen Colebourne\n */\npublic class BeanMap extends AbstractMap<String, Object> implements Cloneable {\n    private transient    Object                     bean;\n    private transient    Map<String, Method>        readMethods      = new LinkedHashMap<>();\n    private transient    Map<String, Method>        writeMethods     = new LinkedHashMap<>();\n    private transient    Map<String, Class<?>>      types            = new LinkedHashMap<>();\n    /** An empty array.  Used to invoke accessors via reflection. */\n    public static final  Object[]                   NULL_ARGUMENTS   = {};\n    /**\n     * Maps primitive Class types to transformers.  The transformer\n     * transform strings into the appropriate primitive wrapper.\n     * N.B. private & unmodifiable replacement for the (public & static) defaultTransformers instance.\n     */\n    private static final Map<Class<?>, Transformer> typeTransformers = Collections.unmodifiableMap(createTypeTransformers());\n\n    private static Map<Class<?>, Transformer> createTypeTransformers() {\n        Map<Class<?>, Transformer> defaultTransformers = new HashMap<>();\n        defaultTransformers.put(Boolean.TYPE, input -> Boolean.valueOf(input.toString()));\n        defaultTransformers.put(Character.TYPE, input -> input.toString().charAt(0));\n        defaultTransformers.put(Byte.TYPE, input -> Byte.valueOf(input.toString()));\n        defaultTransformers.put(Short.TYPE, input -> Short.valueOf(input.toString()));\n        defaultTransformers.put(Integer.TYPE, input -> Integer.valueOf(input.toString()));\n        defaultTransformers.put(Long.TYPE, input -> Long.valueOf(input.toString()));\n        defaultTransformers.put(Float.TYPE, input -> Float.valueOf(input.toString()));\n        defaultTransformers.put(Double.TYPE, input -> Double.valueOf(input.toString()));\n        return defaultTransformers;\n    }\n    // Constructors\n    //-------------------------------------------------------------------------\n\n    /** Constructs a new empty <code>BeanMap</code>. */\n    public BeanMap() {\n    }\n\n    /**\n     * Constructs a new <code>BeanMap</code> that operates on the specified bean.\n     * If the given bean is <code>null</code>, then this map will be empty.\n     * @param bean  the bean for this map to operate on\n     */\n    public BeanMap(Object bean) {\n        this.bean = bean;\n        initialise();\n    }\n    // Map interface\n    //-------------------------------------------------------------------------\n\n    /**\n     * Renders a string representation of this object.\n     * @return a <code>String</code> representation of this object\n     */\n    public String toString() {\n        return \"BeanMap<\" + bean + \">\";\n    }\n\n    /**\n     * Clone this bean map using the following process: \n     * <ul>\n     * <li>If there is no underlying bean, return a cloned BeanMap without a bean.\n     *\n     * <li>Since there is an underlying bean, try to instantiate a new bean of\n     * the same type using Class.newInstance().\n     *\n     * <li>If the instantiation fails, throw a CloneNotSupportedException\n     *\n     * <li>Clone the bean map and set the newly instantiated bean as the\n     * underlying bean for the bean map.\n     *\n     * <li>Copy each property that is both readable and writable from the\n     * existing object to a cloned bean map.  \n     *\n     * <li>If anything fails along the way, throw a CloneNotSupportedException.\n     * <ul>\n     *\n     * @return a cloned instance of this bean map\n     * @throws CloneNotSupportedException if the underlying bean cannot be cloned\n     */\n    public Object clone() throws CloneNotSupportedException {\n        BeanMap newMap = (BeanMap) super.clone();\n        if (bean == null) {\n            // no bean, just an empty bean map at the moment.  return a newly\n            // cloned and empty bean map.\n            return newMap;\n        }\n        Object newBean = null;\n        Class<?> beanClass = bean.getClass(); // Cannot throw Exception\n        try {\n            newBean = beanClass.newInstance();\n        } catch (Exception e) {\n            // unable to instantiate\n            throw new CloneNotSupportedException(\"Unable to instantiate the underlying bean \\\"\" + beanClass.getName() + \"\\\": \" + e);\n        }\n        try {\n            newMap.setBean(newBean);\n        } catch (Exception exception) {\n            throw new CloneNotSupportedException(\"Unable to set bean in the cloned bean map: \" + exception);\n        }\n        try {\n            // copy only properties that are readable and writable.  If its\n            // not readable, we can't get the value from the old map.  If\n            // its not writable, we can't write a value into the new map.\n            Iterator<String> readableKeys = readMethods.keySet().iterator();\n            while (readableKeys.hasNext()) {\n                String key = readableKeys.next();\n                if (getWriteMethod(key) != null) {\n                    newMap.put(key, get(key));\n                }\n            }\n        } catch (Exception exception) {\n            throw new CloneNotSupportedException(\"Unable to copy bean values to cloned bean map: \" + exception);\n        }\n        return newMap;\n    }\n\n    /**\n     * Puts all of the writable properties from the given BeanMap into this\n     * BeanMap. Read-only and Write-only properties will be ignored.\n     * @param map  the BeanMap whose properties to put\n     */\n    public void putAllWriteable(BeanMap map) {\n        Iterator<String> readableKeys = map.readMethods.keySet().iterator();\n        while (readableKeys.hasNext()) {\n            String key = readableKeys.next();\n            if (getWriteMethod(key) != null) {\n                this.put(key, map.get(key));\n            }\n        }\n    }\n\n    /**\n     * This method reinitializes the bean map to have default values for the\n     * bean's properties.  This is accomplished by constructing a new instance\n     * of the bean which the map uses as its underlying data source.\n     * This behavior for <code>clear()</code> differs from the Map contract in that\n     * the mappings are not actually removed from the map (the mappings for a BeanMap are fixed).\n     */\n    public void clear() {\n        if (bean == null) {\n            return;\n        }\n        Class<?> beanClass = null;\n        try {\n            beanClass = bean.getClass();\n            bean = beanClass.newInstance();\n        } catch (Exception e) {\n            throw new UnsupportedOperationException(\"Could not create new instance of class: \" + beanClass);\n        }\n    }\n\n    /**\n     * Returns true if the bean defines a property with the given name. <p>\n     * The given name must be a <code>String</code>; if not, this method\n     * returns false. This method will also return false if the bean\n     * does not define a property with that name. <p>\n     * Write-only properties will not be matched as the test operates against property read methods.\n     *\n     * @param name  the name of the property to check\n     * @return false if the given name is null or is not a <code>String</code>;\n     *   false if the bean does not define a property with that name; or\n     *   true if the bean does define a property with that name\n     */\n    public boolean containsKey(Object name) {\n        Method method = getReadMethod(name);\n        return method != null;\n    }\n\n    /**\n     * Returns true if the bean defines a property whose current value is the given object.\n     * @param value  the value to check\n     * @return false  true if the bean has at least one property whose current value is that object, false otherwise\n     */\n    public boolean containsValue(Object value) {\n        // use default implementation\n        return super.containsValue(value);\n    }\n\n    /**\n     * Returns the value of the bean's property with the given name. <p>\n     * The given name must be a {@link String} and must not be \n     * null; otherwise, this method returns <code>null</code>.\n     * If the bean defines a property with the given name, the value of\n     * that property is returned.  Otherwise, <code>null</code> is returned. <p>\n     * Write-only properties will not be matched as the test operates against property read methods.\n     *\n     * @param name  the name of the property whose value to return\n     * @return the value of the property with that name\n     */\n    public Object get(Object name) {\n        if (bean != null) {\n            Method method = getReadMethod(name);\n            if (method != null) {\n                try {\n                    return method.invoke(bean, NULL_ARGUMENTS);\n                } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | NullPointerException e) {\n                    logWarn(e);\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Sets the bean property with the given name to the given value.\n     * @param name  the name of the property to set\n     * @param value  the value to set that property to\n     * @return the previous value of that property\n     * @throws IllegalArgumentException  if the given name is null; \n     *   if the given name is not a {@link String}; if the bean doesn't\n     *   define a property with that name; or if the bean property with that name is read-only\n     * @throws ClassCastException if an error occurs creating the method args\n     */\n    public Object put(String name, Object value) throws IllegalArgumentException, ClassCastException {\n        if (bean != null) {\n            Object oldValue = get(name);\n            Method method = getWriteMethod(name);\n            if (method == null) {\n                throw new IllegalArgumentException(\"The bean of type: \" + bean.getClass().getName() + \" has no property called: \" + name);\n            }\n            try {\n                Object[] arguments = createWriteMethodArguments(method, value);\n                method.invoke(bean, arguments);\n                Object newValue = get(name);\n                firePropertyChange(name, oldValue, newValue);\n            } catch (InvocationTargetException | IllegalAccessException e) {\n                logInfo(e);\n                throw new IllegalArgumentException(e.getMessage());\n            }\n            return oldValue;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the number of properties defined by the bean.\n     * @return the number of properties defined by the bean\n     */\n    public int size() {\n        return readMethods.size();\n    }\n\n    /**\n     * Get the keys for this BeanMap. <p>\n     * Write-only properties are <b>not</b> included in the returned set of\n     * property names, although it is possible to set their value and to get their type.\n     * @return BeanMap keys.  The Set returned by this method is not modifiable.\n     */\n    public Set<String> keySet() {\n        return Collections.unmodifiableSet(readMethods.keySet());\n    }\n\n    /**\n     * Gets a Set of MapEntry objects that are the mappings for this BeanMap. <p>\n     * Each MapEntry can be set but not removed.\n     * @return the unmodifiable set of mappings\n     */\n    public Set<Map.Entry<String, Object>> entrySet() {\n        return Collections.unmodifiableSet(new AbstractSet<Map.Entry<String, Object>>() {\n            public Iterator<Map.Entry<String, Object>> iterator() {\n                return entryIterator();\n            }\n\n            public int size() {\n                return BeanMap.this.readMethods.size();\n            }\n        });\n    }\n\n    /**\n     * Returns the values for the BeanMap.\n     * @return values for the BeanMap. The returned collection is not modifiable.\n     */\n    public Collection<Object> values() {\n        ArrayList<Object> answer = new ArrayList<>(readMethods.size());\n        for (Iterator<Object> iter = valueIterator(); iter.hasNext(); ) {\n            answer.add(iter.next());\n        }\n        return Collections.unmodifiableList(answer);\n    }\n    // Helper methods\n    //-------------------------------------------------------------------------\n\n    /**\n     * Returns the type of the property with the given name.\n     * @param name  the name of the property\n     * @return the type of the property, or <code>null</code> if no such property exists\n     */\n    public Class<?> getType(String name) {\n        return types.get(name);\n    }\n\n    /**\n     * Convenience method for getting an iterator over the keys. <p>\n     * Write-only properties will not be returned in the iterator.\n     * @return an iterator over the keys\n     */\n    public Iterator<String> keyIterator() {\n        return readMethods.keySet().iterator();\n    }\n\n    /**\n     * Convenience method for getting an iterator over the values.\n     * @return an iterator over the values\n     */\n    public Iterator<Object> valueIterator() {\n        final Iterator<String> iter = keyIterator();\n        return new Iterator<Object>() {\n            public boolean hasNext() {\n                return iter.hasNext();\n            }\n\n            public Object next() {\n                Object key = iter.next();\n                return get(key);\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException(\"remove() not supported for BeanMap\");\n            }\n        };\n    }\n\n    /**\n     * Convenience method for getting an iterator over the entries.\n     * @return an iterator over the entries\n     */\n    public Iterator<Map.Entry<String, Object>> entryIterator() {\n        final Iterator<String> iter = keyIterator();\n        return new Iterator<Map.Entry<String, Object>>() {\n            public boolean hasNext() {\n                return iter.hasNext();\n            }\n\n            public Map.Entry<String, Object> next() {\n                String key = iter.next();\n                Object value = get(key);\n                return new Entry(BeanMap.this, key, value);\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException(\"remove() not supported for BeanMap\");\n            }\n        };\n    }\n    // Properties\n    //-------------------------------------------------------------------------\n\n    /**\n     * Returns the bean currently being operated on.  The return value may be null if this map is empty.\n     * @return the bean being operated on by this map\n     */\n    public Object getBean() {\n        return bean;\n    }\n\n    /**\n     * Sets the bean to be operated on by this map.  The given value may be null, in which case this map will be empty.\n     * @param newBean  the new bean to operate on\n     */\n    public void setBean(Object newBean) {\n        bean = newBean;\n        reinitialise();\n    }\n\n    /**\n     * Returns the accessor for the property with the given name.\n     * @param name  the name of the property \n     * @return the accessor method for the property, or null\n     */\n    public Method getReadMethod(String name) {\n        return readMethods.get(name);\n    }\n\n    /**\n     * Returns the mutator for the property with the given name.\n     * @param name  the name of the property\n     * @return the mutator method for the property, or null\n     */\n    public Method getWriteMethod(String name) {\n        return writeMethods.get(name);\n    }\n    // Implementation methods\n    //-------------------------------------------------------------------------\n\n    /**\n     * Returns the accessor for the property with the given name.\n     * @param name  the name of the property \n     * @return null if the name is null; null if the name is not a {@link String};\n     *      null if no such property exists; or the accessor method for that property\n     */\n    protected Method getReadMethod(Object name) {\n        return readMethods.get(name);\n    }\n\n    /**\n     * Returns the mutator for the property with the given name.\n     * @param name  the name of the \n     * @return null if the name is null; null if the name is not a {@link String};\n     *      null if no such property exists; null if the property is read-only; or the mutator method for that property\n     */\n    protected Method getWriteMethod(Object name) {\n        return writeMethods.get(name);\n    }\n\n    /** Reinitializes this bean.  Called during {@link #setBean(Object)}. Does introspection to find properties. */\n    protected void reinitialise() {\n        readMethods.clear();\n        writeMethods.clear();\n        types.clear();\n        initialise();\n    }\n\n    private void initialise() {\n        if (getBean() == null) {\n            return;\n        }\n        Class<?> beanClass = getBean().getClass();\n        try {\n            Map<String, PropertyDescriptor> pd = new LinkedHashMap<>();\n            // \n            BeanInfo beanInfo = Introspector.getBeanInfo(beanClass);\n            PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();\n            BeanUtils.getProperties(beanClass).forEach(s -> pd.put(s, null));\n            if (propertyDescriptors != null) {\n                for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {\n                    pd.put(propertyDescriptor.getName(), propertyDescriptor);\n                }\n            }\n            // \n            pd.forEach((name, propertyDescriptor) -> {\n                if (propertyDescriptor == null) {\n                    return;\n                }\n                Method readMethod = propertyDescriptor.getReadMethod();\n                Method writeMethod = propertyDescriptor.getWriteMethod();\n                Class<?> aType = propertyDescriptor.getPropertyType();\n                if (readMethod != null) {\n                    readMethods.put(name, readMethod);\n                }\n                if (writeMethod != null) {\n                    writeMethods.put(name, writeMethod);\n                }\n                types.put(name, aType);\n            });\n        } catch (IntrospectionException e) {\n            logWarn(e);\n        }\n    }\n\n    /**\n     * Called during a successful {@link #put(String, Object)} operation.\n     * Default implementation does nothing.  Override to be notified of\n     * property changes in the bean caused by this map.\n     *\n     * @param key  the name of the property that changed\n     * @param oldValue  the old value for that property\n     * @param newValue  the new value for that property\n     */\n    protected void firePropertyChange(Object key, Object oldValue, Object newValue) {\n    }\n    // Implementation classes\n    //-------------------------------------------------------------------------\n\n    /** Map entry used by {@link BeanMap}. */\n    protected static class Entry extends AbstractMapEntry<String, Object> {\n        private BeanMap owner;\n\n        /**\n         * Constructs a new <code>Entry</code>.\n         * @param owner  the BeanMap this entry belongs to\n         * @param key  the key for this entry\n         * @param value  the value for this entry\n         */\n        protected Entry(BeanMap owner, String key, Object value) {\n            super(key, value);\n            this.owner = owner;\n        }\n\n        /**\n         * Sets the value.\n         * @param value  the new value for the entry\n         * @return the old value for the entry\n         */\n        public Object setValue(Object value) {\n            String key = getKey();\n            Object oldValue = owner.get(key);\n            owner.put(key, value);\n            super.value = owner.get(key);\n            return oldValue;\n        }\n    }\n\n    /**\n     * Creates an array of parameters to pass to the given mutator method.\n     * If the given object is not the right type to pass to the method \n     * directly, it will be converted using {@link #convertType(Class, Object)}.\n     *\n     * @param method  the mutator method\n     * @param value  the value to pass to the mutator method\n     * @return an array containing one object that is either the given value or a transformed value\n     * @throws IllegalAccessException if {@link #convertType(Class, Object)} raises it\n     * @throws IllegalArgumentException if any other exception is raised by {@link #convertType(Class, Object)}\n     * @throws ClassCastException if an error occurs creating the method args\n     */\n    protected Object[] createWriteMethodArguments(Method method, Object value) throws IllegalAccessException, ClassCastException {\n        try {\n            if (value != null) {\n                Class<?>[] types = method.getParameterTypes();\n                if (types != null && types.length > 0) {\n                    Class<?> paramType = types[0];\n                    if (!paramType.isAssignableFrom(value.getClass())) {\n                        value = convertType(paramType, value);\n                    }\n                }\n            }\n            Object[] answer = { value };\n            return answer;\n        } catch (InvocationTargetException | InstantiationException e) {\n            logInfo(e);\n            throw new IllegalArgumentException(e.getMessage());\n        }\n    }\n\n    /**\n     * Converts the given value to the given type.  First, reflection is\n     * is used to find a public constructor declared by the given class \n     * that takes one argument, which must be the precise type of the \n     * given value.  If such a constructor is found, a new object is\n     * created by passing the given value to that constructor, and the\n     * newly constructed object is returned.<P>\n     *\n     * If no such constructor exists, and the given type is a primitive\n     * type, then the given value is converted to a string using its \n     * {@link Object#toString() toString()} method, and that string is\n     * parsed into the correct primitive type using, for instance, \n     * {@link Integer#valueOf(String)} to convert the string into an\n     * <code>int</code>.<P>\n     *\n     * If no special constructor exists and the given type is not a \n     * primitive type, this method returns the original value.\n     *\n     * @param newType  the type to convert the value to\n     * @param value  the value to convert\n     * @return the converted value\n     * @throws NumberFormatException if newType is a primitive type, and \n     *  the string representation of the given value cannot be converted to that type\n     * @throws InstantiationException  if the constructor found with \n     *  reflection raises it\n     * @throws InvocationTargetException  if the constructor found with\n     *  reflection raises it\n     * @throws IllegalAccessException  never\n     * @throws IllegalArgumentException  never\n     */\n    protected Object convertType(Class<?> newType, Object value) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n        // try call constructor\n        Class<?>[] types = { value.getClass() };\n        try {\n            Constructor<?> constructor = newType.getConstructor(types);\n            Object[] arguments = { value };\n            return constructor.newInstance(arguments);\n        } catch (NoSuchMethodException e) {\n            // try using the transformers\n            Transformer transformer = getTypeTransformer(newType);\n            if (transformer != null) {\n                return transformer.transform(value);\n            }\n            return value;\n        }\n    }\n\n    /**\n     * Returns a transformer for the given primitive type.\n     *\n     * @param aType  the primitive type whose transformer to return\n     * @return a transformer that will convert strings into that type,\n     *  or null if the given type is not a primitive type\n     */\n    protected Transformer getTypeTransformer(Class<?> aType) {\n        return typeTransformers.get(aType);\n    }\n\n    /**\n     * Logs the given exception to <code>System.out</code>.  Used to display\n     * warnings while accessing/mutating the bean.\n     *\n     * @param ex  the exception to log\n     */\n    protected void logInfo(Exception ex) {\n        // Deliberately do not use LOG4J or Commons Logging to avoid dependencies\n        System.out.println(\"INFO: Exception: \" + ex);\n    }\n\n    /**\n     * Logs the given exception to <code>System.err</code>.  Used to display\n     * errors while accessing/mutating the bean.\n     *\n     * @param ex  the exception to log\n     */\n    protected void logWarn(Exception ex) {\n        // Deliberately do not use LOG4J or Commons Logging to avoid dependencies\n        System.out.println(\"WARN: Exception: \" + ex);\n        ex.printStackTrace();\n    }\n}\n",
            "file_name": "BeanMap.java",
            "human_label": "Return an unmodifiable list that contains all methods in the BeanMap.",
            "level": "class_runnable",
            "lineno": "306",
            "name": "values",
            "oracle_context": "{ \"apis\" : \"[size, valueIterator, hasNext, add, next, unmodifiableList]\", \"classes\" : \"[ArrayList<Object>]\", \"vars\" : \"[readMethods]\" }",
            "package": "net.hasor.utils.ref",
            "project": "hasor-master"
        },
        {
            "_id": "6367676c1a6d9265ec01820b",
            "all_context": "{ \"class_level\" : \"import java.nio.charset.Charset;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nimport java.util.Enumeration;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Locale;\\nimport java.util.Properties;\\nimport java.util.Set;\\nimport java.util.StringTokenizer;\\nimport java.util.TreeSet;\\nString FOLDER_SEPARATOR;\\nString WINDOWS_FOLDER_SEPARATOR;\\nString TOP_PATH;\\nString CURRENT_PATH;\\nchar EXTENSION_SEPARATOR;\\nCharset UTF_8;\\nStrings();\\nhasLength(String str);\\nhasText(CharSequence str);\\nhasText(String str);\\ncontainsWhitespace(CharSequence str);\\ncontainsWhitespace(String str);\\ntrimWhitespace(String str);\\ntrimWhitespace(CharSequence str);\\nclean(String str);\\nclean(CharSequence str);\\ntrimAllWhitespace(String str);\\ntrimLeadingWhitespace(String str);\\ntrimTrailingWhitespace(String str);\\ntrimLeadingCharacter(String str,char leadingCharacter);\\ntrimTrailingCharacter(String str,char trailingCharacter);\\nstartsWithIgnoreCase(String str,String prefix);\\nendsWithIgnoreCase(String str,String suffix);\\nsubstringMatch(CharSequence str,int index,CharSequence substring);\\ncountOccurrencesOf(String str,String sub);\\nreplace(String inString,String oldPattern,String newPattern);\\ndelete(String inString,String pattern);\\ndeleteAny(String inString,String charsToDelete);\\nquote(String str);\\nquoteIfString(Object obj);\\nunqualify(String qualifiedName);\\nunqualify(String qualifiedName,char separator);\\ncapitalize(String str);\\nuncapitalize(String str);\\nchangeFirstCharacterCase(String str,boolean capitalize);\\ngetFilename(String path);\\ngetFilenameExtension(String path);\\nstripFilenameExtension(String path);\\napplyRelativePath(String path,String relativePath);\\ncleanPath(String path);\\npathEquals(String path1,String path2);\\nparseLocaleString(String localeString);\\nvalidateLocalePart(String localePart);\\ntoLanguageTag(Locale locale);\\naddStringToArray(String[] array,String str);\\nconcatenateStringArrays(String[] array1,String[] array2);\\nmergeStringArrays(String[] array1,String[] array2);\\nsortStringArray(String[] array);\\ntoStringArray(Collection collection);\\ntoStringArray(Enumeration enumeration);\\ntrimArrayElements(String[] array);\\nremoveDuplicateStrings(String[] array);\\nsplit(String toSplit,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter,String charsToDelete);\\ntokenizeToStringArray(String str,String delimiters);\\ntokenizeToStringArray(String str,String delimiters,boolean trimTokens,boolean ignoreEmptyTokens);\\ndelimitedListToStringArray(String str,String delimiter);\\ndelimitedListToStringArray(String str,String delimiter,String charsToDelete);\\ncommaDelimitedListToStringArray(String str);\\ncommaDelimitedListToSet(String str);\\ncollectionToDelimitedString(Collection coll,String delim,String prefix,String suffix);\\ncollectionToDelimitedString(Collection coll,String delim);\\ncollectionToCommaDelimitedString(Collection coll);\\narrayToDelimitedString(Object[] arr,String delim);\\narrayToCommaDelimitedString(Object[] arr);\\nhasLength(CharSequence str);\\n\", \"repo_level\" : \"\" }",
            "class_name": "Strings",
            "code": "public static String deleteAny(String inString,String charsToDelete){\n  if (!hasLength(inString) || !hasLength(charsToDelete)) {\n    return inString;\n  }\n  StringBuilder sb=new StringBuilder();\n  for (int i=0; i < inString.length(); i++) {\n    char c=inString.charAt(i);\n    if (charsToDelete.indexOf(c) == -1) {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}\n",
            "docstring": "/** \n * Delete any character in a given String.\n * @param inString the original String\n * @param charsToDelete a set of characters to delete.E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n * @return the resulting String\n */\n",
            "end_lineno": "429",
            "file_content": "/*\n * Copyright (C) 2014 jsonwebtoken.io\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.jsonwebtoken.lang;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic final class Strings {\n\n    private static final String FOLDER_SEPARATOR = \"/\";\n\n    private static final String WINDOWS_FOLDER_SEPARATOR = \"\\\\\";\n\n    private static final String TOP_PATH = \"..\";\n\n    private static final String CURRENT_PATH = \".\";\n\n    private static final char EXTENSION_SEPARATOR = '.';\n\n    public static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    private Strings(){} //prevent instantiation\n\n    //---------------------------------------------------------------------\n    // General convenience methods for working with Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Check that the given CharSequence is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a CharSequence that purely consists of whitespace.\n     * <pre>\n     * Strings.hasLength(null) = false\n     * Strings.hasLength(\"\") = false\n     * Strings.hasLength(\" \") = true\n     * Strings.hasLength(\"Hello\") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(CharSequence str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasLength(CharSequence)\n     */\n    public static boolean hasLength(String str) {\n        return hasLength((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <pre>\n     * Strings.hasText(null) = false\n     * Strings.hasText(\"\") = false\n     * Strings.hasText(\" \") = false\n     * Strings.hasText(\"12345\") = true\n     * Strings.hasText(\" 12345 \") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not <code>null</code>,\n     * its length is greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     * greater than 0, and it does not contain whitespace only\n     * @see #hasText(CharSequence)\n     */\n    public static boolean hasText(String str) {\n        return hasText((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence contains any whitespace characters.\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not empty and\n     * contains at least 1 whitespace character\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean containsWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String contains any whitespace characters.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not empty and\n     * contains at least 1 whitespace character\n     * @see #containsWhitespace(CharSequence)\n     */\n    public static boolean containsWhitespace(String str) {\n        return containsWhitespace((CharSequence) str);\n    }\n\n    /**\n     * Trim leading and trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimWhitespace(String str) {\n        return (String) trimWhitespace((CharSequence)str);\n    }\n    \n    \n    private static CharSequence trimWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        final int length = str.length();\n\n        int start = 0;\n\t\twhile (start < length && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        \n\t\tint end = length;\n        while (start < length && Character.isWhitespace(str.charAt(end - 1))) {\n            end--;\n        }\n        \n        return ((start > 0) || (end < length)) ? str.subSequence(start, end) : str;\n    }\n\n    public static String clean(String str) {\n    \tCharSequence result = clean((CharSequence) str);\n        \n        return result!=null?result.toString():null;\n    }\n    \n    public static CharSequence clean(CharSequence str) {\n        str = trimWhitespace(str);\n        if (!hasLength(str)) {\n            return null;\n        }\n        return str;\n    }\n\n    /**\n     * Trim <i>all</i> whitespace from the given String:\n     * leading, trailing, and intermediate characters.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimAllWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        int index = 0;\n        while (sb.length() > index) {\n            if (Character.isWhitespace(sb.charAt(index))) {\n                sb.deleteCharAt(index);\n            }\n            else {\n                index++;\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim leading whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimLeadingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimTrailingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied leading character from the given String.\n     * @param str the String to check\n     * @param leadingCharacter the leading character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimLeadingCharacter(String str, char leadingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied trailing character from the given String.\n     * @param str the String to check\n     * @param trailingCharacter the trailing character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimTrailingCharacter(String str, char trailingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n\n    /**\n     * Returns {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @param str the String to check\n     * @param prefix the prefix to look for\n     * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @param str the String to check\n     * @param suffix the suffix to look for\n     * @return {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @see java.lang.String#endsWith\n     */\n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        if (str == null || suffix == null) {\n            return false;\n        }\n        if (str.endsWith(suffix)) {\n            return true;\n        }\n        if (str.length() < suffix.length()) {\n            return false;\n        }\n\n        String lcStr = str.substring(str.length() - suffix.length()).toLowerCase();\n        String lcSuffix = suffix.toLowerCase();\n        return lcStr.equals(lcSuffix);\n    }\n\n    /**\n     * Returns {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     * @param str the original string (or StringBuilder)\n     * @param index the index in the original string to start matching against\n     * @param substring the substring to match at the given index\n     * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     */\n    public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n        for (int j = 0; j < substring.length(); j++) {\n            int i = index + j;\n            if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the number of occurrences the substring {@code sub} appears in string {@code str}.\n     * @param str string to search in. Return 0 if this is null.\n     * @param sub string to search for. Return 0 if this is null.\n     * @return the number of occurrences the substring {@code sub} appears in string {@code str}.\n     */\n    public static int countOccurrencesOf(String str, String sub) {\n        if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n            return 0;\n        }\n        int count = 0;\n        int pos = 0;\n        int idx;\n        while ((idx = str.indexOf(sub, pos)) != -1) {\n            ++count;\n            pos = idx + sub.length();\n        }\n        return count;\n    }\n\n    /**\n     * Replace all occurrences of a substring within a string with\n     * another string.\n     * @param inString String to examine\n     * @param oldPattern String to replace\n     * @param newPattern String to insert\n     * @return a String with the replacements\n     */\n    public static String replace(String inString, String oldPattern, String newPattern) {\n        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        int pos = 0; // our position in the old string\n        int index = inString.indexOf(oldPattern);\n        // the index of an occurrence we've found, or -1\n        int patLen = oldPattern.length();\n        while (index >= 0) {\n            sb.append(inString.substring(pos, index));\n            sb.append(newPattern);\n            pos = index + patLen;\n            index = inString.indexOf(oldPattern, pos);\n        }\n        sb.append(inString.substring(pos));\n        // remember to append any characters to the right of a match\n        return sb.toString();\n    }\n\n    /**\n     * Delete all occurrences of the given substring.\n     * @param inString the original String\n     * @param pattern the pattern to delete all occurrences of\n     * @return the resulting String\n     */\n    public static String delete(String inString, String pattern) {\n        return replace(inString, pattern, \"\");\n    }\n\n    /**\n     * Delete any character in a given String.\n     * @param inString the original String\n     * @param charsToDelete a set of characters to delete.\n     * E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n     * @return the resulting String\n     */\n    public static String deleteAny(String inString, String charsToDelete) {\n        if (!hasLength(inString) || !hasLength(charsToDelete)) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < inString.length(); i++) {\n            char c = inString.charAt(i);\n            if (charsToDelete.indexOf(c) == -1) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with formatted Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Quote the given String with single quotes.\n     * @param str the input String (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or <code>null</code> if the input was <code>null</code>\n     */\n    public static String quote(String str) {\n        return (str != null ? \"'\" + str + \"'\" : null);\n    }\n\n    /**\n     * Turn the given Object into a String with single quotes\n     * if it is a String; keeping the Object as-is else.\n     * @param obj the input Object (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or the input object as-is if not a String\n     */\n    public static Object quoteIfString(Object obj) {\n        return (obj instanceof String ? quote((String) obj) : obj);\n    }\n\n    /**\n     * Unqualify a string qualified by a '.' dot character. For example,\n     * \"this.name.is.qualified\", returns \"qualified\".\n     * @param qualifiedName the qualified name\n     * @return an unqualified string by stripping all previous text before (and including) the last period character.\n     */\n    public static String unqualify(String qualifiedName) {\n        return unqualify(qualifiedName, '.');\n    }\n\n    /**\n     * Unqualify a string qualified by a separator character. For example,\n     * \"this:name:is:qualified\" returns \"qualified\" if using a ':' separator.\n     * @param qualifiedName the qualified name\n     * @param separator the separator\n     * @return an unqualified string by stripping all previous text before and including the last {@code separator} character.\n     */\n    public static String unqualify(String qualifiedName, char separator) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);\n    }\n\n    /**\n     * Capitalize a <code>String</code>, changing the first letter to\n     * upper case as per {@link Character#toUpperCase(char)}.\n     * No other letters are changed.\n     * @param str the String to capitalize, may be <code>null</code>\n     * @return the capitalized String, <code>null</code> if null\n     */\n    public static String capitalize(String str) {\n        return changeFirstCharacterCase(str, true);\n    }\n\n    /**\n     * Uncapitalize a <code>String</code>, changing the first letter to\n     * lower case as per {@link Character#toLowerCase(char)}.\n     * No other letters are changed.\n     * @param str the String to uncapitalize, may be <code>null</code>\n     * @return the uncapitalized String, <code>null</code> if null\n     */\n    public static String uncapitalize(String str) {\n        return changeFirstCharacterCase(str, false);\n    }\n\n    private static String changeFirstCharacterCase(String str, boolean capitalize) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str.length());\n        if (capitalize) {\n            sb.append(Character.toUpperCase(str.charAt(0)));\n        }\n        else {\n            sb.append(Character.toLowerCase(str.charAt(0)));\n        }\n        sb.append(str.substring(1));\n        return sb.toString();\n    }\n\n    /**\n     * Extract the filename from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"myfile.txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename, or <code>null</code> if none\n     */\n    public static String getFilename(String path) {\n        if (path == null) {\n            return null;\n        }\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);\n    }\n\n    /**\n     * Extract the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename extension, or <code>null</code> if none\n     */\n    public static String getFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return null;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return null;\n        }\n        return path.substring(extIndex + 1);\n    }\n\n    /**\n     * Strip the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"mypath/myfile\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the path with stripped filename extension,\n     * or <code>null</code> if none\n     */\n    public static String stripFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return path;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return path;\n        }\n        return path.substring(0, extIndex);\n    }\n\n    /**\n     * Apply the given relative path to the given path,\n     * assuming standard Java folder separation (i.e. \"/\" separators).\n     * @param path the path to start from (usually a full file path)\n     * @param relativePath the relative path to apply\n     * (relative to the full file path above)\n     * @return the full file path that results from applying the relative path\n     */\n    public static String applyRelativePath(String path, String relativePath) {\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (separatorIndex != -1) {\n            String newPath = path.substring(0, separatorIndex);\n            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n                newPath += FOLDER_SEPARATOR;\n            }\n            return newPath + relativePath;\n        }\n        else {\n            return relativePath;\n        }\n    }\n\n    /**\n     * Normalize the path by suppressing sequences like \"path/..\" and\n     * inner simple dots.\n     * <p>The result is convenient for path comparison. For other uses,\n     * notice that Windows separators (\"\\\") are replaced by simple slashes.\n     * @param path the original path\n     * @return the normalized path\n     */\n    public static String cleanPath(String path) {\n        if (path == null) {\n            return null;\n        }\n        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);\n\n        // Strip prefix from path to analyze, to not treat it as part of the\n        // first path element. This is necessary to correctly parse paths like\n        // \"file:core/../core/io/Resource.class\", where the \"..\" should just\n        // strip the first \"core\" directory while keeping the \"file:\" prefix.\n        int prefixIndex = pathToUse.indexOf(\":\");\n        String prefix = \"\";\n        if (prefixIndex != -1) {\n            prefix = pathToUse.substring(0, prefixIndex + 1);\n            pathToUse = pathToUse.substring(prefixIndex + 1);\n        }\n        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {\n            prefix = prefix + FOLDER_SEPARATOR;\n            pathToUse = pathToUse.substring(1);\n        }\n\n        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);\n        List<String> pathElements = new LinkedList<String>();\n        int tops = 0;\n\n        for (int i = pathArray.length - 1; i >= 0; i--) {\n            String element = pathArray[i];\n            if (CURRENT_PATH.equals(element)) {\n                // Points to current directory - drop it.\n            }\n            else if (TOP_PATH.equals(element)) {\n                // Registering top path found.\n                tops++;\n            }\n            else {\n                if (tops > 0) {\n                    // Merging path element with element corresponding to top path.\n                    tops--;\n                }\n                else {\n                    // Normal path element found.\n                    pathElements.add(0, element);\n                }\n            }\n        }\n\n        // Remaining top paths need to be retained.\n        for (int i = 0; i < tops; i++) {\n            pathElements.add(0, TOP_PATH);\n        }\n\n        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);\n    }\n\n    /**\n     * Compare two paths after normalization of them.\n     * @param path1 first path for comparison\n     * @param path2 second path for comparison\n     * @return whether the two paths are equivalent after normalization\n     */\n    public static boolean pathEquals(String path1, String path2) {\n        return cleanPath(path1).equals(cleanPath(path2));\n    }\n\n    /**\n     * Parse the given <code>localeString</code> value into a {@link java.util.Locale}.\n     * <p>This is the inverse operation of {@link java.util.Locale#toString Locale's toString}.\n     * @param localeString the locale string, following <code>Locale's</code>\n     * <code>toString()</code> format (\"en\", \"en_UK\", etc);\n     * also accepts spaces as separators, as an alternative to underscores\n     * @return a corresponding <code>Locale</code> instance\n     */\n    public static Locale parseLocaleString(String localeString) {\n        String[] parts = tokenizeToStringArray(localeString, \"_ \", false, false);\n        String language = (parts.length > 0 ? parts[0] : \"\");\n        String country = (parts.length > 1 ? parts[1] : \"\");\n        validateLocalePart(language);\n        validateLocalePart(country);\n        String variant = \"\";\n        if (parts.length >= 2) {\n            // There is definitely a variant, and it is everything after the country\n            // code sans the separator between the country code and the variant.\n            int endIndexOfCountryCode = localeString.indexOf(country) + country.length();\n            // Strip off any leading '_' and whitespace, what's left is the variant.\n            variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));\n            if (variant.startsWith(\"_\")) {\n                variant = trimLeadingCharacter(variant, '_');\n            }\n        }\n        return (language.length() > 0 ? new Locale(language, country, variant) : null);\n    }\n\n    private static void validateLocalePart(String localePart) {\n        for (int i = 0; i < localePart.length(); i++) {\n            char ch = localePart.charAt(i);\n            if (ch != '_' && ch != ' ' && !Character.isLetterOrDigit(ch)) {\n                throw new IllegalArgumentException(\n                    \"Locale part \\\"\" + localePart + \"\\\" contains invalid characters\");\n            }\n        }\n    }\n\n    /**\n     * Determine the RFC 3066 compliant language tag,\n     * as used for the HTTP \"Accept-Language\" header.\n     * @param locale the Locale to transform to a language tag\n     * @return the RFC 3066 compliant language tag as String\n     */\n    public static String toLanguageTag(Locale locale) {\n        return locale.getLanguage() + (hasText(locale.getCountry()) ? \"-\" + locale.getCountry() : \"\");\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with String arrays\n    //---------------------------------------------------------------------\n\n    /**\n     * Append the given String to the given String array, returning a new array\n     * consisting of the input array contents plus the given String.\n     * @param array the array to append to (can be <code>null</code>)\n     * @param str the String to append\n     * @return the new array (never <code>null</code>)\n     */\n    public static String[] addStringToArray(String[] array, String str) {\n        if (Objects.isEmpty(array)) {\n            return new String[] {str};\n        }\n        String[] newArr = new String[array.length + 1];\n        System.arraycopy(array, 0, newArr, 0, array.length);\n        newArr[array.length] = str;\n        return newArr;\n    }\n\n    /**\n     * Concatenate the given String arrays into one,\n     * with overlapping array elements included twice.\n     * <p>The order of elements in the original arrays is preserved.\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        String[] newArr = new String[array1.length + array2.length];\n        System.arraycopy(array1, 0, newArr, 0, array1.length);\n        System.arraycopy(array2, 0, newArr, array1.length, array2.length);\n        return newArr;\n    }\n\n    /**\n     * Merge the given String arrays into one, with overlapping\n     * array elements only included once.\n     * <p>The order of elements in the original arrays is preserved\n     * (with the exception of overlapping elements, which are only\n     * included on their first occurrence).\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] mergeStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        List<String> result = new ArrayList<String>();\n        result.addAll(Arrays.asList(array1));\n        for (String str : array2) {\n            if (!result.contains(str)) {\n                result.add(str);\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Turn given source String array into sorted array.\n     * @param array the source array\n     * @return the sorted array (never <code>null</code>)\n     */\n    public static String[] sortStringArray(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        Arrays.sort(array);\n        return array;\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Collection was <code>null</code>)\n     */\n    public static String[] toStringArray(Collection<String> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new String[collection.size()]);\n    }\n\n    /**\n     * Copy the given Enumeration into a String array.\n     * The Enumeration must contain String elements only.\n     * @param enumeration the Enumeration to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Enumeration was <code>null</code>)\n     */\n    public static String[] toStringArray(Enumeration<String> enumeration) {\n        if (enumeration == null) {\n            return null;\n        }\n        List<String> list = java.util.Collections.list(enumeration);\n        return list.toArray(new String[list.size()]);\n    }\n\n    /**\n     * Trim the elements of the given String array,\n     * calling <code>String.trim()</code> on each of them.\n     * @param array the original String array\n     * @return the resulting array (of the same size) with trimmed elements\n     */\n    public static String[] trimArrayElements(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        String[] result = new String[array.length];\n        for (int i = 0; i < array.length; i++) {\n            String element = array[i];\n            result[i] = (element != null ? element.trim() : null);\n        }\n        return result;\n    }\n\n    /**\n     * Remove duplicate Strings from the given array.\n     * Also sorts the array, as it uses a TreeSet.\n     * @param array the String array\n     * @return an array without duplicates, in natural sort order\n     */\n    public static String[] removeDuplicateStrings(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return array;\n        }\n        Set<String> set = new TreeSet<String>();\n        for (String element : array) {\n            set.add(element);\n        }\n        return toStringArray(set);\n    }\n\n    /**\n     * Split a String at the first occurrence of the delimiter.\n     * Does not include the delimiter in the result.\n     * @param toSplit the string to split\n     * @param delimiter to split the string up with\n     * @return a two element array with index 0 being before the delimiter, and\n     * index 1 being after the delimiter (neither element includes the delimiter);\n     * or <code>null</code> if the delimiter wasn't found in the given input String\n     */\n    public static String[] split(String toSplit, String delimiter) {\n        if (!hasLength(toSplit) || !hasLength(delimiter)) {\n            return null;\n        }\n        int offset = toSplit.indexOf(delimiter);\n        if (offset < 0) {\n            return null;\n        }\n        String beforeDelimiter = toSplit.substring(0, offset);\n        String afterDelimiter = toSplit.substring(offset + delimiter.length());\n        return new String[] {beforeDelimiter, afterDelimiter};\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was null or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {\n        return splitArrayElementsIntoProperties(array, delimiter, null);\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @param charsToDelete one or more characters to remove from each element\n     * prior to attempting the split operation (typically the quotation mark\n     * symbol), or <code>null</code> if no removal should occur\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was <code>null</code> or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(\n        String[] array, String delimiter, String charsToDelete) {\n\n        if (Objects.isEmpty(array)) {\n            return null;\n        }\n        Properties result = new Properties();\n        for (String element : array) {\n            if (charsToDelete != null) {\n                element = deleteAny(element, charsToDelete);\n            }\n            String[] splittedElement = split(element, delimiter);\n            if (splittedElement == null) {\n                continue;\n            }\n            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n        }\n        return result;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter)\n     * @param trimTokens trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     * (only applies to tokens that are empty after trimming; StringTokenizer\n     * will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     * was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(\n        String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List<String> tokens = new ArrayList<String>();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter) {\n        return delimitedListToStringArray(str, delimiter, null);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @param charsToDelete a set of characters to delete. Useful for deleting unwanted\n     * line breaks: e.g. \"\\r\\n\\f\" will delete all new lines and line feeds in a String.\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {\n        if (str == null) {\n            return new String[0];\n        }\n        if (delimiter == null) {\n            return new String[] {str};\n        }\n        List<String> result = new ArrayList<String>();\n        if (\"\".equals(delimiter)) {\n            for (int i = 0; i < str.length(); i++) {\n                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));\n            }\n        }\n        else {\n            int pos = 0;\n            int delPos;\n            while ((delPos = str.indexOf(delimiter, pos)) != -1) {\n                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));\n                pos = delPos + delimiter.length();\n            }\n            if (str.length() > 0 && pos <= str.length()) {\n                // Add rest of String, but not in case of empty input.\n                result.add(deleteAny(str.substring(pos), charsToDelete));\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Convert a CSV list into an array of Strings.\n     * @param str the input String\n     * @return an array of Strings, or the empty array in case of empty input\n     */\n    public static String[] commaDelimitedListToStringArray(String str) {\n        return delimitedListToStringArray(str, \",\");\n    }\n\n    /**\n     * Convenience method to convert a CSV string list to a set.\n     * Note that this will suppress duplicates.\n     * @param str the input String\n     * @return a Set of String entries in the list\n     */\n    public static Set<String> commaDelimitedListToSet(String str) {\n        Set<String> set = new TreeSet<String>();\n        String[] tokens = commaDelimitedListToStringArray(str);\n        for (String token : tokens) {\n            set.add(token);\n        }\n        return set;\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @param prefix the String to start each element with\n     * @param suffix the String to end each element with\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {\n        if (Collections.isEmpty(coll)) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        Iterator<?> it = coll.iterator();\n        while (it.hasNext()) {\n            sb.append(prefix).append(it.next()).append(suffix);\n            if (it.hasNext()) {\n                sb.append(delim);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim) {\n        return collectionToDelimitedString(coll, delim, \"\", \"\");\n    }\n\n    /**\n     * Convenience method to return a Collection as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @return the delimited String\n     */\n    public static String collectionToCommaDelimitedString(Collection<?> coll) {\n        return collectionToDelimitedString(coll, \",\");\n    }\n\n    /**\n     * Convenience method to return a String array as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String arrayToDelimitedString(Object[] arr, String delim) {\n        if (Objects.isEmpty(arr)) {\n            return \"\";\n        }\n        if (arr.length == 1) {\n            return Objects.nullSafeToString(arr[0]);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < arr.length; i++) {\n            if (i > 0) {\n                sb.append(delim);\n            }\n            sb.append(arr[i]);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a String array as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @return the delimited String\n     */\n    public static String arrayToCommaDelimitedString(Object[] arr) {\n        return arrayToDelimitedString(arr, \",\");\n    }\n\n}\n\n",
            "file_name": "Strings.java",
            "human_label": "Delete characters that exists in the intersection between two character strings of the first character string and return the first character string that is modified.",
            "level": "class_runnable",
            "lineno": "410",
            "name": "deleteAny",
            "oracle_context": "{ \"apis\" : \"[hasLength, length, charAt, indexOf, append, toString]\", \"classes\" : \"[StringBuilder]\", \"vars\" : \"[]\" }",
            "package": "io.jsonwebtoken.lang",
            "project": "jjwt-master"
        },
        {
            "_id": "636766f81a6d9265ec01774b",
            "all_context": "{ \"class_level\" : \"import net.hasor.web.upload.util.Streams;\\nimport java.io.*;\\nimport static java.lang.String.format;\\nimport static net.hasor.web.upload.FileUploadException.UploadErrorCodes.*;\\nbyte CR;\\nbyte LF;\\nbyte DASH;\\nint HEADER_PART_SIZE_MAX;\\nint DEFAULT_BUFSIZE;\\nbyte[] HEADER_SEPARATOR;\\nbyte[] FIELD_SEPARATOR;\\nbyte[] STREAM_TERMINATOR;\\nbyte[] BOUNDARY_PREFIX;\\nInputStream input;\\nint boundaryLength;\\nint keepRegion;\\nbyte[] boundary;\\nint bufSize;\\nbyte[] buffer;\\nint head;\\nint tail;\\nString headerEncoding;\\nlong total;\\nint pad;\\nint pos;\\nboolean closed;\\nint BYTE_POSITIVE_OFFSET;\\nMultipartStream(InputStream input,byte[] boundary,int bufSize);\\nMultipartStream(InputStream input,byte[] boundary);\\ngetHeaderEncoding();\\nsetHeaderEncoding(String encoding);\\nreadBoundary();\\nsetBoundary(byte[] boundary);\\nreadHeaders();\\nreadBodyData(OutputStream output);\\nnewInputStream();\\ndiscardBodyData();\\nskipPreamble();\\narrayequals(byte[] a,byte[] b,int count);\\nfindByte(byte value,int pos);\\nfindSeparator();\\nItemInputStream();\\ngetBytesRead();\\navailable();\\nread();\\nread(byte[] b,int off,int len);\\nclose();\\nclose(boolean pCloseUnderlying);\\nskip(long bytes);\\nmakeAvailable();\\nisClosed();\\n\", \"repo_level\" : \"public interface Streams {static long copy(InputStream inputStream,OutputStream outputStream,boolean closeOutputStream);\\nstatic long copy(InputStream inputStream,OutputStream outputStream,boolean closeOutputStream,byte[] buffer);\\nstatic String asString(InputStream inputStream);\\nstatic String asString(InputStream inputStream,String encoding);\\nstatic String checkFileName(String fileName);\\n }\\n\" }",
            "class_name": "MultipartStream",
            "code": "public byte readByte() throws IOException {\n  if (head == tail) {\n    head=0;\n    tail=input.read(buffer,head,bufSize);\n    if (tail == -1) {\n      throw new IOException(\"No more data is available\");\n    }\n  }\n  return buffer[head++];\n}\n",
            "docstring": "/** \n * Reads a byte from the <code>buffer</code>, and refills it as necessary.\n * @return The next byte from the input stream.\n * @throws IOException if there is no more data available.\n */\n",
            "end_lineno": "203",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.web.upload;\nimport net.hasor.web.upload.util.Streams;\n\nimport java.io.*;\n\nimport static java.lang.String.format;\nimport static net.hasor.web.upload.FileUploadException.UploadErrorCodes.*;\n\n/**\n * <p> Low level API for processing file uploads.\n *\n * <p> This class can be used to process data streams conforming to MIME\n * 'multipart' format as defined in\n * <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>. Arbitrarily\n * large amounts of data in the stream can be processed under constant\n * memory usage.\n *\n * <p> The format of the stream is defined in the following way:<br>\n *\n * <code>\n *   multipart-body := preamble 1*encapsulation close-delimiter epilogue<br>\n *   encapsulation := delimiter body CRLF<br>\n *   delimiter := \"--\" boundary CRLF<br>\n *   close-delimiter := \"--\" boundary \"--\"<br>\n *   preamble := &lt;ignore&gt;<br>\n *   epilogue := &lt;ignore&gt;<br>\n *   body := header-part CRLF body-part<br>\n *   header-part := 1*header CRLF<br>\n *   header := header-name \":\" header-value<br>\n *   header-name := &lt;printable ascii characters except \":\"&gt;<br>\n *   header-value := &lt;any ascii characters except CR &amp; LF&gt;<br>\n *   body-data := &lt;arbitrary data&gt;<br>\n * </code>\n *\n * <p>Note that body-data can contain another mulipart entity.  There\n * is limited support for single pass processing of such nested\n * streams.  The nested stream is <strong>required</strong> to have a\n * boundary token of the same length as the parent stream (see {@link\n * #setBoundary(byte[])}).\n *\n * <p>Here is an example of usage of this class.<br>\n *\n * <pre>\n *   try {\n *     MultipartStream multipartStream = new MultipartStream(input, boundary);\n *     boolean nextPart = multipartStream.skipPreamble();\n *     OutputStream output;\n *     while(nextPart) {\n *       String header = multipartStream.readHeaders();\n *       // process headers\n *       // create some output stream\n *       multipartStream.readBodyData(output);\n *       nextPart = multipartStream.readBoundary();\n *     }\n *   } catch(MultipartStream.MalformedStreamException e) {\n *     // the stream failed to follow required syntax\n *   } catch(IOException e) {\n *     // a read or write error occurred\n *   }\n * </pre>\n *\n * @version $Id: MultipartStream.java 1745065 2016-05-22 14:56:37Z britter $\n */\nclass MultipartStream {\n    // ----------------------------------------------------- Manifest constants\n    /** The Carriage Return ASCII character value. */\n    public static final    byte        CR                   = 0x0D;\n    /** The Line Feed ASCII character value. */\n    public static final    byte        LF                   = 0x0A;\n    /** The dash (-) ASCII character value. */\n    public static final    byte        DASH                 = 0x2D;\n    /** The maximum length of <code>header-part</code> that will be processed (10 kilobytes = 10240 bytes.). */\n    public static final    int         HEADER_PART_SIZE_MAX = 10240;\n    /** The default length of the buffer used for processing a request. */\n    protected static final int         DEFAULT_BUFSIZE      = 4096;\n    /** A byte sequence that marks the end of <code>header-part</code> (<code>CRLFCRLF</code>). */\n    protected static final byte[]      HEADER_SEPARATOR     = { CR, LF, CR, LF };\n    /** A byte sequence that that follows a delimiter that will be followed by an encapsulation (<code>CRLF</code>). */\n    protected static final byte[]      FIELD_SEPARATOR      = { CR, LF };\n    /** A byte sequence that that follows a delimiter of the last encapsulation in the stream (<code>--</code>). */\n    protected static final byte[]      STREAM_TERMINATOR    = { DASH, DASH };\n    /** A byte sequence that precedes a boundary (<code>CRLF--</code>). */\n    protected static final byte[]      BOUNDARY_PREFIX      = { CR, LF, DASH, DASH };\n    // ----------------------------------------------------------- Data members\n    /** The input stream from which data is read. */\n    private final          InputStream input;\n    /** The length of the boundary token plus the leading <code>CRLF--</code>. */\n    private                int         boundaryLength;\n    /** The amount of data, in bytes, that must be kept in the buffer in order to detect delimiters reliably. */\n    private                int         keepRegion;\n    /** The byte sequence that partitions the stream. */\n    private                byte[]      boundary;\n    /** The length of the buffer used for processing the request. */\n    private final          int         bufSize;\n    /** The buffer used for processing the request. */\n    private final          byte[]      buffer;\n    /** The index of first valid character in the buffer. <br> 0 <= head < bufSize */\n    private                int         head;\n    /** The index of last valid character in the buffer + 1. <br> 0 <= tail <= bufSize */\n    private                int         tail;\n    /** The content encoding to use when reading headers. */\n    private                String      headerEncoding;\n    // ----------------------------------------------------------- Constructors\n\n    /**\n     * <p> Constructs a <code>MultipartStream</code> with a custom size buffer.\n     *\n     * <p> Note that the buffer must be at least big enough to contain the\n     * boundary string, plus 4 characters for CR/LF and double dash, plus at\n     * least one byte of data.  Too small a buffer size setting will degrade\n     * performance.\n     *\n     * @param input    The <code>InputStream</code> to serve as a data source.\n     * @param boundary The token used for dividing the stream into\n     *                 <code>encapsulations</code>.\n     * @param bufSize  The size of the buffer to be used, in bytes.\n     * @throws IllegalArgumentException If the buffer size is too small\n     * @since 1.3.1\n     */\n    public MultipartStream(InputStream input, byte[] boundary, int bufSize) {\n        if (boundary == null) {\n            throw new IllegalArgumentException(\"boundary may not be null\");\n        }\n        // We prepend CR/LF to the boundary to chop trailing CR/LF from body-data tokens.\n        this.boundaryLength = boundary.length + BOUNDARY_PREFIX.length;\n        if (bufSize < this.boundaryLength + 1) {\n            throw new IllegalArgumentException(\"The buffer size specified for the MultipartStream is too small\");\n        }\n        this.input = input;\n        this.bufSize = Math.max(bufSize, boundaryLength * 2);\n        this.buffer = new byte[this.bufSize];\n        this.boundary = new byte[this.boundaryLength];\n        this.keepRegion = this.boundary.length;\n        System.arraycopy(BOUNDARY_PREFIX, 0, this.boundary, 0, BOUNDARY_PREFIX.length);\n        System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length, boundary.length);\n        head = 0;\n        tail = 0;\n    }\n\n    /**\n     * <p> Constructs a <code>MultipartStream</code> with a default size buffer.\n     * @param input    The <code>InputStream</code> to serve as a data source.\n     * @param boundary The token used for dividing the stream into <code>encapsulations</code>.\n     * @see #MultipartStream(InputStream, byte[], int)\n     */\n    MultipartStream(InputStream input, byte[] boundary) {\n        this(input, boundary, DEFAULT_BUFSIZE);\n    }\n    // --------------------------------------------------------- Public methods\n\n    /**\n     * Retrieves the character encoding used when reading the headers of an\n     * individual part. When not specified, or <code>null</code>, the platform default encoding is used.\n     * @return The encoding used to read part headers.\n     */\n    public String getHeaderEncoding() {\n        return headerEncoding;\n    }\n\n    /**\n     * Specifies the character encoding to be used when reading the headers of\n     * individual parts. When not specified, or <code>null</code>, the platform\n     * default encoding is used.\n     * @param encoding The encoding used to read part headers.\n     */\n    public void setHeaderEncoding(String encoding) {\n        headerEncoding = encoding;\n    }\n\n    /**\n     * Reads a byte from the <code>buffer</code>, and refills it as necessary.\n     * @return The next byte from the input stream.\n     * @throws IOException if there is no more data available.\n     */\n    public byte readByte() throws IOException {\n        // Buffer depleted ?\n        if (head == tail) {\n            head = 0;\n            // Refill.\n            tail = input.read(buffer, head, bufSize);\n            if (tail == -1) {\n                // No more data available.\n                throw new IOException(\"No more data is available\");\n            }\n        }\n        return buffer[head++];\n    }\n\n    /**\n     * Skips a <code>boundary</code> token, and checks whether more\n     * <code>encapsulations</code> are contained in the stream.\n     * @return <code>true</code> if there are more encapsulations in this stream; <code>false</code> otherwise.\n     * @throws FileUploadException if the stream ends unexpectedly or fails to follow required syntax.\n     */\n    public boolean readBoundary() throws IOException {\n        byte[] marker = new byte[2];\n        boolean nextChunk = false;\n        head += boundaryLength;\n        marker[0] = readByte();\n        if (marker[0] == LF) {\n            // Work around IE5 Mac bug with input type=image.\n            // Because the boundary delimiter, not including the trailing CRLF, \n            // must not appear within any file (RFC 2046, section 5.1.1),\n            // we know the missing CR is due to a buggy browser rather than a file \n            // containing something similar to a boundary.\n            return true;\n        }\n        marker[1] = readByte();\n        if (arrayequals(marker, STREAM_TERMINATOR, 2)) {\n            nextChunk = false;\n        } else if (arrayequals(marker, FIELD_SEPARATOR, 2)) {\n            nextChunk = true;\n        } else {\n            throw new FileUploadException(MalformedStreamException, \"Unexpected characters follow a boundary\");\n        }\n        return nextChunk;\n    }\n\n    /**\n     * <p>Changes the boundary token used for partitioning the stream.\n     * <p>This method allows single pass processing of nested multipart streams.\n     * <p>The boundary token of the nested stream is <code>required</code> to be of the same length as the boundary token in parent stream.\n     * <p>Restoring the parent stream boundary token after processing of a nested stream is left to the application.\n     * @param boundary The boundary to be used for parsing of the nested stream.\n     * @throws FileUploadException if the <code>boundary</code> has a different length than the one being currently parsed.\n     */\n    public void setBoundary(byte[] boundary) throws FileUploadException {\n        if (boundary.length != boundaryLength - BOUNDARY_PREFIX.length) {\n            throw new FileUploadException(IllegalBoundaryException, \"The length of a boundary token can not be changed\");\n        }\n        System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length, boundary.length);\n    }\n\n    /**\n     * <p>Reads the <code>header-part</code> of the current\n     * <code>encapsulation</code>.\n     * <p>Headers are returned verbatim to the input stream, including the\n     * trailing <code>CRLF</code> marker. Parsing is left to the application.\n     * <p><strong>TODO</strong> allow limiting maximum header size to protect against abuse.\n     *\n     * @return The <code>header-part</code> of the current encapsulation.\n     * @throws FileUploadException if the stream ends unexpectedly.\n     */\n    public String readHeaders() throws IOException {\n        int i = 0;\n        byte b;\n        // to support multi-byte characters\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        int size = 0;\n        while (i < HEADER_SEPARATOR.length) {\n            try {\n                b = readByte();\n            } catch (IOException e) {\n                throw e;\n            }\n            if (++size > HEADER_PART_SIZE_MAX) {\n                String logMEssage = format(\"Header section has more than %s bytes (maybe it is not properly terminated)\", Integer.valueOf(HEADER_PART_SIZE_MAX));\n                throw new FileUploadException(MalformedStreamException, logMEssage);\n            }\n            if (b == HEADER_SEPARATOR[i]) {\n                i++;\n            } else {\n                i = 0;\n            }\n            baos.write(b);\n        }\n        String headers = null;\n        if (headerEncoding != null) {\n            try {\n                headers = baos.toString(headerEncoding);\n            } catch (UnsupportedEncodingException e) {\n                // Fall back to platform default if specified encoding is not supported.\n                headers = baos.toString();\n            }\n        } else {\n            headers = baos.toString();\n        }\n        return headers;\n    }\n\n    /**\n     * <p>Reads <code>body-data</code> from the current <code>encapsulation</code> and writes its contents into the output <code>Stream</code>.\n     * <p>Arbitrary large amounts of data can be processed by this method using a constant size buffer. \n     * @param output The <code>Stream</code> to write data into. May be null, in which case this method is equivalent to {@link #discardBodyData()}.\n     * @return the amount of data written.\n     * @throws FileUploadException if the stream ends unexpectedly.\n     * @throws IOException              if an i/o error occurs.\n     */\n    public int readBodyData(OutputStream output) throws IOException {\n        final InputStream istream = newInputStream();\n        return (int) Streams.copy(istream, output, false);\n    }\n\n    /**\n     * Creates a new {@link ItemInputStream}.\n     * @return A new instance of {@link ItemInputStream}.\n     */\n    ItemInputStream newInputStream() {\n        return new ItemInputStream();\n    }\n\n    /**\n     * <p> Reads <code>body-data</code> from the current\n     * <code>encapsulation</code> and discards it.\n     *\n     * <p>Use this method to skip encapsulations you don't need or don't understand.\n     *\n     * @return The amount of data discarded.\n     * @throws FileUploadException if the stream ends unexpectedly.\n     * @throws IOException         if an i/o error occurs.\n     */\n    public int discardBodyData() throws IOException {\n        return readBodyData(null);\n    }\n\n    /**\n     * Finds the beginning of the first <code>encapsulation</code>.\n     * @return <code>true</code> if an <code>encapsulation</code> was found in the stream.\n     *\n     * @throws IOException if an i/o error occurs.\n     */\n    public boolean skipPreamble() throws IOException {\n        // First delimiter may be not preceeded with a CRLF.\n        System.arraycopy(boundary, 2, boundary, 0, boundary.length - 2);\n        boundaryLength = boundary.length - 2;\n        try {\n            // Discard all data up to the delimiter.\n            discardBodyData();\n            // Read boundary - if succeeded, the stream contains an encapsulation.\n            return readBoundary();\n        } catch (FileUploadException e) {\n            if (e.getErrorCode() == MalformedStreamException) {\n                return false;\n            }\n            throw e;\n        } finally {\n            // Restore delimiter.\n            System.arraycopy(boundary, 0, boundary, 2, boundary.length - 2);\n            boundaryLength = boundary.length;\n            boundary[0] = CR;\n            boundary[1] = LF;\n        }\n    }\n\n    /**\n     * Compares <code>count</code> first bytes in the arrays <code>a</code> and <code>b</code>.\n     * @param a     The first array to compare.\n     * @param b     The second array to compare.\n     * @param count How many bytes should be compared.\n     *\n     * @return <code>true</code> if <code>count</code> first bytes in arrays\n     *         <code>a</code> and <code>b</code> are equal.\n     */\n    public static boolean arrayequals(byte[] a, byte[] b, int count) {\n        for (int i = 0; i < count; i++) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Searches for a byte of specified value in the <code>buffer</code>,\n     * starting at the specified <code>position</code>.\n     *\n     * @param value The value to find.\n     * @param pos   The starting position for searching.\n     *\n     * @return The position of byte found, counting from beginning of the\n     *         <code>buffer</code>, or <code>-1</code> if not found.\n     */\n    protected int findByte(byte value, int pos) {\n        for (int i = pos; i < tail; i++) {\n            if (buffer[i] == value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Searches for the <code>boundary</code> in the <code>buffer</code>\n     * region delimited by <code>head</code> and <code>tail</code>.\n     *\n     * @return The position of the boundary found, counting from the\n     *         beginning of the <code>buffer</code>, or <code>-1</code> if not found.\n     */\n    protected int findSeparator() {\n        int first;\n        int match = 0;\n        int maxpos = tail - boundaryLength;\n        for (first = head; first <= maxpos && match != boundaryLength; first++) {\n            first = findByte(boundary[0], first);\n            if (first == -1 || first > maxpos) {\n                return -1;\n            }\n            for (match = 1; match < boundaryLength; match++) {\n                if (buffer[first + match] != boundary[match]) {\n                    break;\n                }\n            }\n        }\n        if (match == boundaryLength) {\n            return first - 1;\n        }\n        return -1;\n    }\n\n    /** An {@link InputStream} for reading an items contents. */\n    public class ItemInputStream extends InputStream implements net.hasor.web.upload.util.Closeable {\n        /** The number of bytes, which have been read so far. */\n        private long    total;\n        /** The number of bytes, which must be hold, because they might be a part of the boundary. */\n        private int     pad;\n        /** The current offset in the buffer. */\n        private int     pos;\n        /** Whether the stream is already closed. */\n        private boolean closed;\n\n        /** Creates a new instance. */\n        ItemInputStream() {\n            findSeparator();\n        }\n\n        /** Called for finding the separator. */\n        private void findSeparator() {\n            pos = MultipartStream.this.findSeparator();\n            if (pos == -1) {\n                if (tail - head > keepRegion) {\n                    pad = keepRegion;\n                } else {\n                    pad = tail - head;\n                }\n            }\n        }\n\n        /** Returns the number of bytes, which have been read by the stream.\n         * @return Number of bytes, which have been read so far.\n         */\n        public long getBytesRead() {\n            return total;\n        }\n\n        /**\n         * Returns the number of bytes, which are currently available, without blocking.\n         * @return Number of bytes in the buffer.\n         */\n        @Override\n        public int available() {\n            if (pos == -1) {\n                return tail - head - pad;\n            }\n            return pos - head;\n        }\n\n        /** Offset when converting negative bytes to integers. */\n        private static final int BYTE_POSITIVE_OFFSET = 256;\n\n        /**\n         * Returns the next byte in the stream.\n         * @return The next byte in the stream, as a non-negative integer, or -1 for EOF.\n         * @throws IOException An I/O error occurred.\n         */\n        @Override\n        public int read() throws IOException {\n            if (closed) {\n                throw new FileUploadException(ItemSkippedException);\n            }\n            if (available() == 0 && makeAvailable() == 0) {\n                return -1;\n            }\n            ++total;\n            int b = buffer[head++];\n            if (b >= 0) {\n                return b;\n            }\n            return b + BYTE_POSITIVE_OFFSET;\n        }\n\n        /**\n         * Reads bytes into the given buffer.\n         * @param b The destination buffer, where to write to.\n         * @param off Offset of the first byte in the buffer.\n         * @param len Maximum number of bytes to read.\n         * @return Number of bytes, which have been actually read, or -1 for EOF.\n         * @throws IOException An I/O error occurred.\n         */\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (closed) {\n                throw new FileUploadException(ItemSkippedException);\n            }\n            if (len == 0) {\n                return 0;\n            }\n            int res = available();\n            if (res == 0) {\n                res = makeAvailable();\n                if (res == 0) {\n                    return -1;\n                }\n            }\n            res = Math.min(res, len);\n            System.arraycopy(buffer, head, b, off, res);\n            head += res;\n            total += res;\n            return res;\n        }\n\n        /**\n         * Closes the input stream.\n         * @throws IOException An I/O error occurred.\n         */\n        @Override\n        public void close() throws IOException {\n            close(false);\n        }\n\n        /**\n         * Closes the input stream.\n         * @param pCloseUnderlying Whether to close the underlying stream (hard close)\n         * @throws IOException An I/O error occurred.\n         */\n        public void close(boolean pCloseUnderlying) throws IOException {\n            if (closed) {\n                return;\n            }\n            if (pCloseUnderlying) {\n                closed = true;\n                input.close();\n            } else {\n                for (; ; ) {\n                    int av = available();\n                    if (av == 0) {\n                        av = makeAvailable();\n                        if (av == 0) {\n                            break;\n                        }\n                    }\n                    skip(av);\n                }\n            }\n            closed = true;\n        }\n\n        /**\n         * Skips the given number of bytes.\n         * @param bytes Number of bytes to skip.\n         * @return The number of bytes, which have actually been skipped.\n         * @throws IOException An I/O error occurred.\n         */\n        @Override\n        public long skip(long bytes) throws IOException {\n            if (closed) {\n                throw new FileUploadException(ItemSkippedException);\n            }\n            int av = available();\n            if (av == 0) {\n                av = makeAvailable();\n                if (av == 0) {\n                    return 0;\n                }\n            }\n            long res = Math.min(av, bytes);\n            head += res;\n            return res;\n        }\n\n        /**\n         * Attempts to read more data.\n         * @return Number of available bytes\n         * @throws IOException An I/O error occurred.\n         */\n        private int makeAvailable() throws IOException {\n            if (pos != -1) {\n                return 0;\n            }\n            // Move the data to the beginning of the buffer.\n            total += tail - head - pad;\n            System.arraycopy(buffer, tail - pad, buffer, 0, pad);\n            // Refill buffer with new data.\n            head = 0;\n            tail = pad;\n            for (; ; ) {\n                int bytesRead = input.read(buffer, tail, bufSize - tail);\n                if (bytesRead == -1) {\n                    // The last pad amount is left in the buffer. Boundary can't be in there so signal an error condition.\n                    final String msg = \"Stream ended unexpectedly\";\n                    throw new FileUploadException(MalformedStreamException, msg);\n                }\n                tail += bytesRead;\n                findSeparator();\n                int av = available();\n                if (av > 0 || pos != -1) {\n                    return av;\n                }\n            }\n        }\n\n        /**\n         * Returns, whether the stream is closed.\n         * @return True, if the stream is closed, otherwise false.\n         */\n        public boolean isClosed() {\n            return closed;\n        }\n    }\n}",
            "file_name": "MultipartStream.java",
            "human_label": "Read the next buffer in the buffer.",
            "level": "class_runnable",
            "lineno": "186",
            "name": "readByte",
            "oracle_context": "{ \"apis\" : \"[read]\", \"classes\" : \"[]\", \"vars\" : \"[head, tail, input, buffer, bufSize]\" }",
            "package": "net.hasor.web.upload",
            "project": "hasor-master"
        },
        {
            "_id": "636766851a6d9265ec017515",
            "all_context": "{ \"class_level\" : \"import org.atmosphere.cpr.Action;\\nimport org.atmosphere.cpr.AtmosphereConfig;\\nimport org.atmosphere.cpr.AtmosphereInterceptor;\\nimport org.atmosphere.cpr.AtmosphereResource;\\nimport org.atmosphere.cpr.AtmosphereResourceEvent;\\nimport org.atmosphere.cpr.AtmosphereResourceImpl;\\nimport org.atmosphere.util.Utils;\\nimport org.slf4j.Logger;\\nimport org.slf4j.LoggerFactory;\\nimport java.io.IOException;\\nimport java.util.concurrent.TimeUnit;\\nimport static org.atmosphere.cpr.ApplicationConfig.ATMOSPHERERESOURCE_INTERCEPTOR_METHOD;\\nimport static org.atmosphere.cpr.ApplicationConfig.ATMOSPHERERESOURCE_INTERCEPTOR_TIMEOUT;\\nimport static org.atmosphere.cpr.AtmosphereResource.TRANSPORT.UNDEFINED;\\nimport static org.atmosphere.cpr.AtmosphereResourceEventListenerAdapter.OnBroadcast;\\nString method;\\nInteger timeoutInSeconds;\\nLogger logger;\\nboolean force;\\nlong timeoutInMilli;\\nAtmosphereResourceLifecycleInterceptor();\\nAtmosphereResourceLifecycleInterceptor(boolean force);\\nconfigure(AtmosphereConfig config);\\nmethod();\\ntimeoutInSeconds();\\nmethod(String method);\\ntimeoutInSeconds(int timeoutInSeconds);\\npostInspect(AtmosphereResource r);\\nonBroadcast(AtmosphereResourceEvent event);\\ndestroy();\\ntoString();\\n\", \"repo_level\" : \"public interface Action {public Action.TYPE type();\\npublic Action type(TYPE type);\\npublic long timeout();\\npublic Action timeout(long timeout);\\npublic boolean equals(Object o);\\npublic int hashCode();\\npublic String toString();\\n }\\npublic interface AtmosphereConfig {public List<AtmosphereHandlerConfig> getAtmosphereHandlerConfig();\\npublic AtmosphereFramework framework();\\npublic ServletConfig getServletConfig();\\npublic ServletContext getServletContext();\\npublic String getWebServerName();\\npublic Map<String,AtmosphereFramework.AtmosphereHandlerWrapper> handlers();\\npublic String getInitParameter(String name);\\npublic Enumeration<String> getInitParameterNames();\\npublic boolean isSupportSession();\\npublic void setSupportSession(boolean supportSession);\\npublic boolean isSessionTimeoutRemovalAllowed();\\npublic void setSessionTimeoutRemovalAllowed(boolean sessionTimeoutRemovalAllowed);\\npublic boolean isThrowExceptionOnCloned();\\npublic void setThrowExceptionOnCloned(boolean throwExceptionOnCloned);\\npublic BroadcasterFactory getBroadcasterFactory();\\npublic Map<String,Object> properties();\\nprotected void destroy();\\nprotected void initComplete();\\npublic AtmosphereConfig shutdownHook(ShutdownHook s);\\npublic AtmosphereConfig startupHook(StartupHook s);\\npublic String getInitParameter(String key,String defaultValue);\\npublic boolean getInitParameter(String key,boolean defaultValue);\\npublic int getInitParameter(String key,int defaultValue);\\npublic AtmosphereResourceFactory resourcesFactory();\\npublic MetaBroadcaster metaBroadcaster();\\npublic AtmosphereResourceSessionFactory sessionFactory();\\npublic UUIDProvider uuidProvider();\\npublic WebSocketFactory websocketFactory();\\n void shutdown();\\n void started(AtmosphereFramework framework);\\npublic AtmosphereConfig populate(AtmosphereConfig config);\\n }\\npublic interface AtmosphereInterceptor { Action inspect(AtmosphereResource r);\\n void postInspect(AtmosphereResource r);\\n void destroy();\\n }\\npublic interface AtmosphereResource { TRANSPORT transport();\\n AtmosphereResource resumeOnBroadcast(boolean resumeOnBroadcast);\\n boolean isSuspended();\\n boolean resumeOnBroadcast();\\n boolean isResumed();\\n boolean isCancelled();\\n AtmosphereResource resume();\\n AtmosphereResource suspend();\\n AtmosphereResource suspend(long timeout);\\n AtmosphereResource suspend(long timeout,TimeUnit timeunit);\\n AtmosphereRequest getRequest();\\n AtmosphereResponse getResponse();\\n AtmosphereConfig getAtmosphereConfig();\\n Broadcaster getBroadcaster();\\n List<Broadcaster> broadcasters();\\n AtmosphereResource removeFromAllBroadcasters();\\n AtmosphereResource setBroadcaster(Broadcaster broadcaster);\\n AtmosphereResource addBroadcaster(Broadcaster broadcaster);\\n AtmosphereResource removeBroadcaster(Broadcaster broadcaster);\\n AtmosphereResource setSerializer(Serializer s);\\n AtmosphereResource write(String s);\\n AtmosphereResource write(byte[] s);\\n Serializer getSerializer();\\n AtmosphereResourceEvent getAtmosphereResourceEvent();\\n AtmosphereHandler getAtmosphereHandler();\\n AtmosphereResource writeOnTimeout(Object o);\\n Object writeOnTimeout();\\n String uuid();\\n AtmosphereResource addEventListener(AtmosphereResourceEventListener e);\\n AtmosphereResource removeEventListener(AtmosphereResourceEventListener e);\\n AtmosphereResource removeEventListeners();\\n AtmosphereResource notifyListeners(AtmosphereResourceEvent e);\\n AtmosphereResource notifyListeners();\\n HttpSession session();\\n HttpSession session(boolean create);\\n void close();\\n AtmosphereResource forceBinaryWrite(boolean force);\\n boolean forceBinaryWrite();\\npublic AtmosphereResource initialize(AtmosphereConfig config,Broadcaster broadcaster,AtmosphereRequest req,AtmosphereResponse response,AsyncSupport asyncSupport,AtmosphereHandler atmosphereHandler);\\n }\\npublic interface AtmosphereResourceEvent { Object getMessage();\\n AtmosphereResourceEvent setMessage(Object o);\\n boolean isResumedOnTimeout();\\n boolean isCancelled();\\n boolean isSuspended();\\n boolean isResuming();\\n AtmosphereResource getResource();\\n boolean isClosedByClient();\\n boolean isClosedByApplication();\\n Throwable throwable();\\n Broadcaster broadcaster();\\n }\\npublic interface AtmosphereResourceImpl {public AtmosphereResource initialize(AtmosphereConfig config,Broadcaster broadcaster,AtmosphereRequest req,AtmosphereResponse response,AsyncSupport asyncSupport,AtmosphereHandler atmosphereHandler);\\nprotected void setUUID(String uuid);\\nprotected void register();\\npublic AtmosphereResourceEventImpl getAtmosphereResourceEvent();\\npublic AtmosphereHandler getAtmosphereHandler();\\npublic AtmosphereResource writeOnTimeout(Object o);\\npublic Object writeOnTimeout();\\npublic String uuid();\\npublic TRANSPORT transport();\\npublic AtmosphereResourceImpl transport(TRANSPORT transport);\\npublic AtmosphereResource resumeOnBroadcast(boolean resumeOnBroadcast);\\npublic boolean isSuspended();\\npublic boolean resumeOnBroadcast();\\npublic AtmosphereResource resume();\\npublic AtmosphereResource suspend();\\npublic AtmosphereResource suspend(long timeout,TimeUnit timeunit);\\npublic AtmosphereResource suspend(long timeout);\\npublic AtmosphereRequest getRequest(boolean enforceScope);\\npublic AtmosphereResponse getResponse(boolean enforceScope);\\npublic AtmosphereRequest getRequest();\\npublic AtmosphereResponse getResponse();\\npublic Broadcaster getBroadcaster();\\npublic List<Broadcaster> broadcasters();\\nprotected Broadcaster getBroadcaster(boolean autoCreate);\\npublic AtmosphereResource setBroadcaster(Broadcaster broadcaster);\\npublic AtmosphereResource addBroadcaster(Broadcaster broadcaster);\\npublic AtmosphereResource removeBroadcaster(Broadcaster broadcaster);\\nprotected AtmosphereResource uniqueBroadcaster(Broadcaster newB);\\npublic AtmosphereConfig getAtmosphereConfig();\\npublic Action action();\\npublic void reset();\\npublic void setIsInScope(boolean isInScope);\\npublic boolean isInScope();\\npublic AtmosphereResource setSerializer(Serializer s);\\npublic boolean isResumed();\\npublic boolean isCancelled();\\npublic AtmosphereResource write(String s);\\npublic AtmosphereResource write(byte[] o);\\npublic Serializer getSerializer();\\npublic AtmosphereResource addEventListener(AtmosphereResourceEventListener e);\\npublic AtmosphereResource removeEventListener(AtmosphereResourceEventListener e);\\npublic AtmosphereResource removeEventListeners();\\npublic AtmosphereResource notifyListeners();\\npublic AtmosphereResource notifyListeners(AtmosphereResourceEvent event);\\npublic AtmosphereResource removeFromAllBroadcasters();\\npublic void onThrowable(Throwable t);\\n void onThrowable(AtmosphereResourceEvent e);\\n void onHeartbeat(AtmosphereResourceEvent e);\\n void onSuspend(AtmosphereResourceEvent e);\\n void onPreSuspend(AtmosphereResourceEvent e);\\n void onResume(AtmosphereResourceEvent e);\\n void onDisconnect(AtmosphereResourceEvent e);\\n void onBroadcast(AtmosphereResourceEvent e);\\n void onClose(AtmosphereResourceEvent e);\\npublic ConcurrentLinkedQueue<AtmosphereResourceEventListener> atmosphereResourceEventListener();\\npublic AtmosphereResourceImpl atmosphereHandler(AtmosphereHandler atmosphereHandler);\\npublic void cancel();\\npublic void _destroy();\\npublic String toString();\\npublic AtmosphereResourceImpl disableSuspend(boolean disableSuspend);\\npublic HttpSession session(boolean create);\\npublic void close();\\npublic void dirtyClose();\\npublic AtmosphereResource forceBinaryWrite(boolean forceBinaryWrite);\\npublic boolean forceBinaryWrite();\\npublic HttpSession session();\\npublic AtmosphereResourceImpl session(HttpSession session);\\npublic AtmosphereResourceImpl cloneState(AtmosphereResource r);\\npublic ConcurrentLinkedQueue<AtmosphereResourceEventListener> listeners();\\npublic AtmosphereResourceImpl disableSuspendEvent(boolean disableSuspendEvent);\\npublic boolean disableSuspendEvent();\\npublic WebSocket webSocket();\\npublic AtmosphereResourceImpl webSocket(WebSocket webSocket);\\npublic boolean equals(Object o);\\npublic int hashCode();\\npublic boolean getAndSetInClosingPhase();\\npublic boolean isPendingClose();\\npublic boolean getAndSetPendingClose();\\n }\\npublic interface Utils {static boolean webSocketEnabled(HttpServletRequest request);\\nstatic boolean rawWebSocket(HttpServletRequest request);\\nstatic boolean firefoxWebSocketEnabled(HttpServletRequest request);\\nstatic boolean twoConnectionsTransport(TRANSPORT t);\\nstatic boolean webSocketQueryStringPresentOrNull(HttpServletRequest request);\\nstatic boolean resumableTransport(TRANSPORT t);\\nstatic boolean pollableTransport(TRANSPORT t);\\nstatic boolean pushMessage(TRANSPORT t);\\nstatic boolean atmosphereProtocol(AtmosphereRequest r);\\nstatic boolean webSocketMessage(AtmosphereResource r);\\nstatic boolean properProtocol(HttpServletRequest request);\\nstatic AtmosphereResource websocketResource(AtmosphereResource r);\\nstatic boolean closeMessage(HttpServletRequest request);\\nstatic Object invoke(Object proxiedInstance,Method m,Object o);\\nstatic void inject(AtmosphereResource r);\\nstatic void inject(Object object,Class clazz,AtmosphereResource r);\\nstatic void inject(Object object,Class clazz,AtmosphereConfig config);\\nstatic Set<Field> getInheritedPrivateFields(Class type);\\nstatic Set<Method> getInheritedPrivateMethod(Class type);\\nstatic boolean requestScopedInjection(AtmosphereConfig config,AtmosphereHandler h);\\nstatic boolean requestScopedInjection(AtmosphereConfig config,Object o);\\nstatic void destroyMeteor(AtmosphereRequest req);\\nstatic String pathInfo(AtmosphereRequest request);\\nstatic boolean isRunningTest();\\nstatic boolean isUnderJDK11AndUp();\\n }\\n\" }",
            "class_name": "AtmosphereResourceLifecycleInterceptor",
            "code": "@Override public Action inspect(AtmosphereResource r){\nswitch (r.transport()) {\ncase JSONP:\ncase AJAX:\ncase LONG_POLLING:\n    r.resumeOnBroadcast(true);\n  break;\ndefault :\nbreak;\n}\nreturn Action.CONTINUE;\n}\n",
            "docstring": "/** \n * Automatically suspend the  {@link AtmosphereResource} based on {@link AtmosphereResource.TRANSPORT} value.\n * @param r a {@link AtmosphereResource}\n * @return {@link Action#CONTINUE}\n */\n",
            "end_lineno": "131",
            "file_content": "/*\n * Copyright 2008-2022 Async-IO.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.atmosphere.interceptor;\n\nimport org.atmosphere.cpr.Action;\nimport org.atmosphere.cpr.AtmosphereConfig;\nimport org.atmosphere.cpr.AtmosphereInterceptor;\nimport org.atmosphere.cpr.AtmosphereResource;\nimport org.atmosphere.cpr.AtmosphereResourceEvent;\nimport org.atmosphere.cpr.AtmosphereResourceImpl;\nimport org.atmosphere.util.Utils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\nimport static org.atmosphere.cpr.ApplicationConfig.ATMOSPHERERESOURCE_INTERCEPTOR_METHOD;\nimport static org.atmosphere.cpr.ApplicationConfig.ATMOSPHERERESOURCE_INTERCEPTOR_TIMEOUT;\nimport static org.atmosphere.cpr.AtmosphereResource.TRANSPORT.UNDEFINED;\nimport static org.atmosphere.cpr.AtmosphereResourceEventListenerAdapter.OnBroadcast;\n\n/**\n * <p>This {@link AtmosphereInterceptor} implementation automatically suspends the intercepted\n * {@link AtmosphereResource} and takes care of managing the response's state (flushing, resuming,\n * etc.) when a {@link org.atmosphere.cpr.Broadcaster#broadcast} is invoked. When used, {@link org.atmosphere.cpr.AtmosphereHandler} implementations no longer need to make calls to\n * {@link AtmosphereResource#suspend}.\n * </p>\n * If your application doesn't use {@link org.atmosphere.cpr.Broadcaster}, this interceptor will not work and you need to programmatically\n * resume, flush, etc.\n * <p/>\n * <p>By default, intercepted {@link AtmosphereResource} instances are suspended when a GET\n * request is received. You can change the triggering http method by configuring\n * {@link org.atmosphere.cpr.ApplicationConfig#ATMOSPHERERESOURCE_INTERCEPTOR_METHOD}\n * <p/>\n * <p/>\n * <p>Use this class when you don't want to manage the suspend/resume operation from your\n * particular Atmosphere framework implementation classes ({@link org.atmosphere.cpr.AtmosphereHandler},\n * {@link org.atmosphere.websocket.WebSocketHandler}, or\n * {@link org.atmosphere.cpr.Meteor} instances) or extensions (GWT, Jersey, Wicket, etc...)\n * </p>\n * <strong>For this mechanism to work properly, each client must set the\n * {@link org.atmosphere.cpr.HeaderConfig#X_ATMOSPHERE_TRANSPORT} header. Your AtmosphereHandler must also extends the\n * {@link org.atmosphere.handler.AbstractReflectorAtmosphereHandler} or implements the logic defined inside\n * {@link org.atmosphere.handler.AbstractReflectorAtmosphereHandler#postStateChange(org.atmosphere.cpr.AtmosphereResourceEvent)} </strong>\n *\n * @author Jeanfrancois Arcand\n */\npublic class AtmosphereResourceLifecycleInterceptor implements AtmosphereInterceptor {\n\n    private String method = \"GET\";\n    // For backward compat.\n    private Integer timeoutInSeconds = -1;\n    private static final Logger logger = LoggerFactory.getLogger(AtmosphereResourceLifecycleInterceptor.class);\n    private final boolean force;\n    private long timeoutInMilli = -1;\n\n    public AtmosphereResourceLifecycleInterceptor(){\n        this(false);\n    }\n\n    public AtmosphereResourceLifecycleInterceptor(boolean force){\n        this.force = force;\n    }\n\n    @Override\n    public void configure(AtmosphereConfig config) {\n        String s = config.getInitParameter(ATMOSPHERERESOURCE_INTERCEPTOR_METHOD);\n        if (s != null) {\n            method = s;\n        }\n\n        s = config.getInitParameter(ATMOSPHERERESOURCE_INTERCEPTOR_TIMEOUT);\n        if (s != null) {\n            timeoutInSeconds = Integer.valueOf(s);\n            timeoutInMilli = TimeUnit.MILLISECONDS.convert(timeoutInSeconds, TimeUnit.SECONDS);\n        }\n    }\n\n    public String method() {\n        return method;\n    }\n\n    public int timeoutInSeconds(){\n        return timeoutInSeconds;\n    }\n\n    public AtmosphereResourceLifecycleInterceptor method(String method){\n        this.method = method;\n        return this;\n    }\n\n    public AtmosphereResourceLifecycleInterceptor timeoutInSeconds(int timeoutInSeconds) {\n        this.timeoutInSeconds = timeoutInSeconds;\n        timeoutInMilli = TimeUnit.MILLISECONDS.convert(timeoutInSeconds, TimeUnit.SECONDS);\n        return this;\n    }\n\n    /**\n     * Automatically suspend the {@link AtmosphereResource} based on {@link AtmosphereResource.TRANSPORT} value.\n     *\n     * @param r a {@link AtmosphereResource}\n     * @return {@link Action#CONTINUE}\n     */\n    @Override\n    public Action inspect(AtmosphereResource r) {\n\n        switch (r.transport()) {\n            case JSONP:\n            case AJAX:\n            case LONG_POLLING:\n                r.resumeOnBroadcast(true);\n                break;\n            default:\n                break;\n        }\n        return Action.CONTINUE;\n    }\n\n    @Override\n    public void postInspect(final AtmosphereResource r) {\n\n        if (Utils.pollableTransport(r.transport()) || r.transport().equals(UNDEFINED) || Utils.webSocketMessage(r)) return;\n\n        AtmosphereResourceImpl impl = (AtmosphereResourceImpl) r;\n        if ( (force || impl.getRequest(false).getMethod().equalsIgnoreCase(method))\n            && !impl.action().equals(Action.CANCELLED)\n            && impl.isInScope()) {\n\n            logger.trace(\"Marking AtmosphereResource {} for suspend operation\", r.uuid());\n\n            switch (r.transport()) {\n                case JSONP:\n                case AJAX:\n                case LONG_POLLING:\n                    break;\n                default:\n                    r.addEventListener(new OnBroadcast() {\n                        @Override\n                        public void onBroadcast(AtmosphereResourceEvent event) {\n                            try {\n                                r.getResponse().flushBuffer();\n                            } catch (IOException e) {\n                                logger.trace(\"\", e);\n                            }\n                        }\n                    });\n            }\n\n            r.suspend(timeoutInMilli);\n        }\n    }\n\n    @Override\n    public void destroy() {\n    }\n\n    public String toString() {\n        return \"Atmosphere LifeCycle\";\n    }\n}\n",
            "file_name": "AtmosphereResourceLifecycleInterceptor.java",
            "human_label": "Suspend the AtmosphereResource based on its transport value.",
            "level": "project_runnable",
            "lineno": "112",
            "name": "inspect",
            "oracle_context": "{ \"apis\" : \"[transport, resumeOnBroadcast]\", \"classes\" : \"[Action]\", \"vars\" : \"[CONTINUE]\" }",
            "package": "org.atmosphere.interceptor",
            "project": "atmosphere-atmosphere-2.7.x"
        },
        {
            "_id": "636767611a6d9265ec018106",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.*;\\nimport org.jgrapht.graph.*;\\nimport java.util.*;\\nGraph<Set<V>,DefaultWeightedEdge> workingGraph;\\ndouble bestCutWeight;\\nSet<V> bestCut;\\nSet<V> vertex;\\nDouble weight;\\nboolean active;\\nStoerWagnerMinimumCut(Graph graph);\\nminCutWeight();\\nminCut();\\nmergeVertices(Set s,Set t);\\nvertexWeight(Set v);\\nVertexAndWeight(Set v,double w,boolean active);\\ncompareTo(VertexAndWeight that);\\ntoString();\\nminimumCutPhase(Set a);\\n\", \"repo_level\" : \"\" }",
            "class_name": "StoerWagnerMinimumCut",
            "code": "public double vertexWeight(Set<V> v){\n  double wsum=0.0;\n  for (  DefaultWeightedEdge e : workingGraph.edgesOf(v)) {\n    wsum+=workingGraph.getEdgeWeight(e);\n  }\n  return wsum;\n}\n",
            "docstring": "/** \n * Compute the sum of the weights entering a vertex\n * @param v the vertex\n * @return the sum of the weights entering a vertex\n */\n",
            "end_lineno": "237",
            "file_content": "/*\n * (C) Copyright 2011-2021, by Robby McKilliam, Ernst de Ridder and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.alg;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\nimport java.util.*;\n\n/**\n * Implements the <a href=\"http://dl.acm.org/citation.cfm?id=263872\">Stoer and Wagner minimum cut\n * algorithm</a>. Deterministically computes the minimum cut in $O(|V||E| + |V| \\log |V|)$ time.\n * This implementation uses Java's PriorityQueue and requires $O(|V||E| \\log |E|)$ time. M. Stoer\n * and F. Wagner, \"A Simple Min-Cut Algorithm\", Journal of the ACM, volume 44, number 4. pp 585-591,\n * 1997.\n *\n * @param <V> the graph vertex type\n * @param <E> the graph edge type\n *\n * @author Robby McKilliam\n * @author Ernst de Ridder\n */\npublic class StoerWagnerMinimumCut<V, E>\n{\n    final Graph<Set<V>, DefaultWeightedEdge> workingGraph;\n\n    protected double bestCutWeight = Double.POSITIVE_INFINITY;\n    protected Set<V> bestCut;\n\n    /**\n     * Will compute the minimum cut in graph.\n     *\n     * @param graph graph over which to run algorithm\n     *\n     * @throws IllegalArgumentException if a negative weight edge is found\n     * @throws IllegalArgumentException if graph has less than 2 vertices\n     */\n    public StoerWagnerMinimumCut(Graph<V, E> graph)\n    {\n        GraphTests.requireUndirected(graph, \"Graph must be undirected\");\n\n        if (graph.vertexSet().size() < 2) {\n            throw new IllegalArgumentException(\"Graph has less than 2 vertices\");\n        }\n\n        // get a version of this graph where each vertex is wrapped with a list\n        workingGraph = new SimpleWeightedGraph<>(DefaultWeightedEdge.class);\n        Map<V, Set<V>> vertexMap = new HashMap<>();\n        for (V v : graph.vertexSet()) {\n            Set<V> list = new HashSet<>();\n            list.add(v);\n            vertexMap.put(v, list);\n            workingGraph.addVertex(list);\n        }\n        for (E e : graph.edgeSet()) {\n            if (graph.getEdgeWeight(e) < 0.0) {\n                throw new IllegalArgumentException(\"Negative edge weights not allowed\");\n            }\n\n            V s = graph.getEdgeSource(e);\n            Set<V> sNew = vertexMap.get(s);\n            V t = graph.getEdgeTarget(e);\n            Set<V> tNew = vertexMap.get(t);\n\n            // For multigraphs, we sum the edge weights (either all are\n            // contained in a cut, or none)\n            DefaultWeightedEdge eNew = workingGraph.getEdge(sNew, tNew);\n            if (eNew == null) {\n                eNew = workingGraph.addEdge(sNew, tNew);\n                workingGraph.setEdgeWeight(eNew, graph.getEdgeWeight(e));\n            } else {\n                workingGraph\n                    .setEdgeWeight(eNew, workingGraph.getEdgeWeight(eNew) + graph.getEdgeWeight(e));\n            }\n        }\n\n        // arbitrary vertex used to seed the algorithm.\n        Set<V> a = workingGraph.vertexSet().iterator().next();\n\n        while (workingGraph.vertexSet().size() > 1) {\n            minimumCutPhase(a);\n        }\n    }\n\n    /**\n     * Implements the MinimumCutPhase function of Stoer and Wagner.\n     * \n     * @param a the vertex\n     */\n    protected void minimumCutPhase(Set<V> a)\n    {\n        // The last and before last vertices added to A.\n        Set<V> last = a, beforelast = null;\n\n        // queue contains vertices not in A ordered by max weight of edges to A.\n        PriorityQueue<VertexAndWeight> queue = new PriorityQueue<>();\n\n        // Maps vertices to elements of queue\n        Map<Set<V>, VertexAndWeight> dmap = new HashMap<>();\n\n        // Initialize queue\n        for (Set<V> v : workingGraph.vertexSet()) {\n            if (v == a) {\n                continue;\n            }\n            DefaultWeightedEdge e = workingGraph.getEdge(v, a);\n            Double w = (e == null) ? 0.0 : workingGraph.getEdgeWeight(e);\n            VertexAndWeight vandw = new VertexAndWeight(v, w, e != null);\n            queue.add(vandw);\n            dmap.put(v, vandw);\n        }\n\n        // Now iteratively update the queue to get the required vertex ordering\n\n        while (!queue.isEmpty()) {\n            Set<V> v = queue.poll().vertex;\n            dmap.remove(v);\n\n            beforelast = last;\n            last = v;\n\n            for (DefaultWeightedEdge e : workingGraph.edgesOf(v)) {\n                Set<V> vc = Graphs.getOppositeVertex(workingGraph, e, v);\n                VertexAndWeight vcandw = dmap.get(vc);\n                if (vcandw != null) {\n                    queue.remove(vcandw); // this is O(log n) but could be O(1)?\n                    vcandw.active = true;\n                    vcandw.weight += workingGraph.getEdgeWeight(e);\n                    queue.add(vcandw); // this is O(log n) but could be O(1)?\n                }\n            }\n        }\n\n        // Update the best cut\n        double w = vertexWeight(last);\n        if (w < bestCutWeight) {\n            bestCutWeight = w;\n            bestCut = last;\n        }\n\n        // merge the last added vertices\n        mergeVertices(beforelast, last);\n    }\n\n    /**\n     * Return the weight of the minimum cut\n     * \n     * @return the weight of the minimum cut\n     */\n    public double minCutWeight()\n    {\n        return bestCutWeight;\n    }\n\n    /**\n     * Return a set of vertices on one side of the cut\n     * \n     * @return a set of vertices on one side of the cut\n     */\n    public Set<V> minCut()\n    {\n        return bestCut;\n    }\n\n    /**\n     * Merges vertex $t$ into vertex $s$, summing the weights as required. Returns the merged vertex\n     * and the sum of its weights\n     * \n     * @param s the first vertex\n     * @param t the second vertex\n     * \n     * @return the merged vertex and its weight\n     */\n    protected VertexAndWeight mergeVertices(Set<V> s, Set<V> t)\n    {\n        // construct the new combinedvertex\n        Set<V> set = new HashSet<>();\n        set.addAll(s);\n        set.addAll(t);\n        workingGraph.addVertex(set);\n\n        // add edges and weights to the combined vertex\n        double wsum = 0.0;\n        for (Set<V> v : workingGraph.vertexSet()) {\n            if ((s != v) && (t != v)) {\n                double neww = 0.0;\n                DefaultWeightedEdge etv = workingGraph.getEdge(t, v);\n                DefaultWeightedEdge esv = workingGraph.getEdge(s, v);\n                if (etv != null) {\n                    neww += workingGraph.getEdgeWeight(etv);\n                }\n                if (esv != null) {\n                    neww += workingGraph.getEdgeWeight(esv);\n                }\n                if ((etv != null) || (esv != null)) {\n                    wsum += neww;\n                    workingGraph.setEdgeWeight(workingGraph.addEdge(set, v), neww);\n                }\n            }\n        }\n\n        // remove original vertices\n        workingGraph.removeVertex(t);\n        workingGraph.removeVertex(s);\n\n        return new VertexAndWeight(set, wsum, false);\n    }\n\n    /**\n     * Compute the sum of the weights entering a vertex\n     * \n     * @param v the vertex\n     * @return the sum of the weights entering a vertex\n     */\n    public double vertexWeight(Set<V> v)\n    {\n        double wsum = 0.0;\n        for (DefaultWeightedEdge e : workingGraph.edgesOf(v)) {\n            wsum += workingGraph.getEdgeWeight(e);\n        }\n        return wsum;\n    }\n\n    /**\n     * Class for weighted vertices\n     */\n    protected class VertexAndWeight\n        implements\n        Comparable<VertexAndWeight>\n    {\n        public Set<V> vertex;\n        public Double weight;\n        public boolean active; // active == neighbour in A\n\n        /**\n         * Construct a new weighted vertex.\n         * \n         * @param v the vertex\n         * @param w the weight of the vertex\n         * @param active whether it is active\n         */\n        public VertexAndWeight(Set<V> v, double w, boolean active)\n        {\n            this.vertex = v;\n            this.weight = w;\n            this.active = active;\n        }\n\n        /**\n         * compareTo that sorts in reverse order because we need extract-max and queue provides\n         * extract-min.\n         */\n        @Override\n        public int compareTo(VertexAndWeight that)\n        {\n            if (this.active && that.active) {\n                return -Double.compare(weight, that.weight);\n            }\n            if (this.active && !that.active) {\n                return -1;\n            }\n            if (!this.active && that.active) {\n                return +1;\n            }\n\n            // both inactive\n            return 0;\n        }\n\n        @Override\n        public String toString()\n        {\n            return \"(\" + vertex + \", \" + weight + \")\";\n        }\n    }\n}\n",
            "file_name": "StoerWagnerMinimumCut.java",
            "human_label": "Return the sum of the weights entering a vertex.",
            "level": "class_runnable",
            "lineno": "224",
            "name": "vertexWeight",
            "oracle_context": "{ \"apis\" : \"[edgesOf, getEdgeWeight]\", \"classes\" : \"[]\", \"vars\" : \"[workingGraph]\" }",
            "package": "org.jgrapht.alg",
            "project": "jgrapht-master"
        },
        {
            "_id": "636767841a6d9265ec0183f2",
            "all_context": "{ \"class_level\" : \"import java.text.DateFormat;\\nimport java.util.ArrayList;\\nimport java.util.Comparator;\\nimport java.util.Date;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util.SortedSet;\\nimport java.util.TreeSet;\\nimport javax.swing.table.AbstractTableModel;\\nimport org.apache.log4j.Priority;\\nimport org.apache.log4j.Logger;\\nLogger LOG;\\nComparator MY_COMP;\\nString[] COL_NAMES;\\nEventDetails[] EMPTY_LIST;\\nDateFormat DATE_FORMATTER;\\nObject mLock;\\nSortedSet mAllEvents;\\nEventDetails[] mFilteredEvents;\\nList mPendingEvents;\\nboolean mPaused;\\nString mThreadFilter;\\nString mMessageFilter;\\nString mNDCFilter;\\nString mCategoryFilter;\\nPriority mPriorityFilter;\\nrun();\\nMyTableModel();\\ngetRowCount();\\ngetColumnCount();\\ngetColumnName(int aCol);\\ngetColumnClass(int aCol);\\ngetValueAt(int aRow,int aCol);\\nsetPriorityFilter(Priority aPriority);\\nsetThreadFilter(String aStr);\\nsetMessageFilter(String aStr);\\nsetNDCFilter(String aStr);\\nsetCategoryFilter(String aStr);\\naddEvent(EventDetails aEvent);\\nclear();\\ntoggle();\\nisPaused();\\ngetEventDetails(int aRow);\\nupdateFilteredEvents(boolean aInsertedToFront);\\nmatchFilter(EventDetails aEvent);\\n\", \"repo_level\" : \"public interface Priority {public boolean equals(Object o);\\nfinal int getSyslogEquivalent();\\npublic boolean isGreaterOrEqual(Priority r);\\nstatic Priority[] getAllPossiblePriorities();\\npublic String toString();\\nfinal int toInt();\\nstatic Priority toPriority(String sArg);\\nstatic Priority toPriority(int val);\\nstatic Priority toPriority(int val,Priority defaultPriority);\\nstatic Priority toPriority(String sArg,Priority defaultPriority);\\n }\\npublic interface Logger {public Logger getLogger(String name);\\npublic Logger getLogger(Class clazz);\\nstatic Logger getRootLogger();\\nstatic Logger getLogger(String name,LoggerFactory factory);\\npublic void trace(Object message);\\npublic void trace(Object message,Throwable t);\\npublic boolean isTraceEnabled();\\n }\\n\" }",
            "class_name": "MyTableModel",
            "code": "public int compare(Object aObj1,Object aObj2){\n  if ((aObj1 == null) && (aObj2 == null)) {\n    return 0;\n  }\n else   if (aObj1 == null) {\n    return -1;\n  }\n else   if (aObj2 == null) {\n    return 1;\n  }\n  final EventDetails le1=(EventDetails)aObj1;\n  final EventDetails le2=(EventDetails)aObj2;\n  if (le1.getTimeStamp() < le2.getTimeStamp()) {\n    return 1;\n  }\n  return -1;\n}\n",
            "docstring": "/** \n * @see Comparator \n */\n",
            "end_lineno": "66",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.log4j.chainsaw;\n\nimport java.text.DateFormat;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport javax.swing.table.AbstractTableModel;\nimport org.apache.log4j.Priority;\nimport org.apache.log4j.Logger;\n\n/**\n * Represents a list of <code>EventDetails</code> objects that are sorted on\n * logging time. Methods are provided to filter the events that are visible.\n *\n * @author <a href=\"mailto:oliver@puppycrawl.com\">Oliver Burn</a>\n */\nclass MyTableModel\n    extends AbstractTableModel\n{\n\n    /** used to log messages **/\n    private static final Logger LOG = Logger.getLogger(MyTableModel.class);\n\n    /** use the compare logging events **/\n    private static final Comparator MY_COMP = new Comparator()\n    {\n        /** @see Comparator **/\n        public int compare(Object aObj1, Object aObj2) {\n            if ((aObj1 == null) && (aObj2 == null)) {\n                return 0; // treat as equal\n            } else if (aObj1 == null) {\n                return -1; // null less than everything\n            } else if (aObj2 == null) {\n                return 1; // think about it. :->\n            }\n\n            // will assume only have LoggingEvent\n            final EventDetails le1 = (EventDetails) aObj1;\n            final EventDetails le2 = (EventDetails) aObj2;\n\n            if (le1.getTimeStamp() < le2.getTimeStamp()) {\n                return 1;\n            }\n            // assume not two events are logged at exactly the same time\n            return -1;\n        }\n        };\n\n    /**\n     * Helper that actually processes incoming events.\n     * @author <a href=\"mailto:oliver@puppycrawl.com\">Oliver Burn</a>\n     */\n    private class Processor\n        implements Runnable\n    {\n        /** loops getting the events **/\n        public void run() {\n            while (true) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    // ignore\n                }\n\n                synchronized (mLock) {\n                    if (mPaused) {\n                        continue;\n                    }\n\n                    boolean toHead = true; // were events added to head\n                    boolean needUpdate = false;\n                    final Iterator it = mPendingEvents.iterator();\n                    while (it.hasNext()) {\n                        final EventDetails event = (EventDetails) it.next();\n                        mAllEvents.add(event);\n                        toHead = toHead && (event == mAllEvents.first());\n                        needUpdate = needUpdate || matchFilter(event);\n                    }\n                    mPendingEvents.clear();\n\n                    if (needUpdate) {\n                        updateFilteredEvents(toHead);\n                    }\n                }\n            }\n\n        }\n    }\n\n\n    /** names of the columns in the table **/\n    private static final String[] COL_NAMES = {\n        \"Time\", \"Priority\", \"Trace\", \"Category\", \"NDC\", \"Message\"};\n\n    /** definition of an empty list **/\n    private static final EventDetails[] EMPTY_LIST =  new EventDetails[] {};\n\n    /** used to format dates **/\n    private static final DateFormat DATE_FORMATTER =\n        DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM);\n\n    /** the lock to control access **/\n    private final Object mLock = new Object();\n    /** set of all logged events - not filtered **/\n    private final SortedSet mAllEvents = new TreeSet(MY_COMP);\n    /** events that are visible after filtering **/\n    private EventDetails[] mFilteredEvents = EMPTY_LIST;\n    /** list of events that are buffered for processing **/\n    private final List mPendingEvents = new ArrayList();\n    /** indicates whether event collection is paused to the UI **/\n    private boolean mPaused = false;\n\n    /** filter for the thread **/\n    private String mThreadFilter = \"\";\n    /** filter for the message **/\n    private String mMessageFilter = \"\";\n    /** filter for the NDC **/\n    private String mNDCFilter = \"\";\n    /** filter for the category **/\n    private String mCategoryFilter = \"\";\n    /** filter for the priority **/\n    private Priority mPriorityFilter = Priority.DEBUG;\n\n\n    /**\n     * Creates a new <code>MyTableModel</code> instance.\n     *\n     */\n    MyTableModel() {\n        final Thread t = new Thread(new Processor());\n        t.setDaemon(true);\n        t.start();\n    }\n\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Table Methods\n    ////////////////////////////////////////////////////////////////////////////\n\n    /** @see javax.swing.table.TableModel **/\n    public int getRowCount() {\n        synchronized (mLock) {\n            return mFilteredEvents.length;\n        }\n    }\n\n    /** @see javax.swing.table.TableModel **/\n    public int getColumnCount() {\n        // does not need to be synchronized\n        return COL_NAMES.length;\n    }\n\n    /** @see javax.swing.table.TableModel **/\n    public String getColumnName(int aCol) {\n        // does not need to be synchronized\n        return COL_NAMES[aCol];\n    }\n\n    /** @see javax.swing.table.TableModel **/\n    public Class getColumnClass(int aCol) {\n        // does not need to be synchronized\n        return (aCol == 2) ? Boolean.class : Object.class;\n    }\n\n    /** @see javax.swing.table.TableModel **/\n    public Object getValueAt(int aRow, int aCol) {\n        synchronized (mLock) {\n            final EventDetails event = mFilteredEvents[aRow];\n\n            if (aCol == 0) {\n                return DATE_FORMATTER.format(new Date(event.getTimeStamp()));\n            } else if (aCol == 1) {\n                return event.getPriority();\n            } else if (aCol == 2) {\n                return (event.getThrowableStrRep() == null)\n                    ? Boolean.FALSE : Boolean.TRUE;\n            } else if (aCol == 3) {\n                return event.getCategoryName();\n            } else if (aCol == 4) {\n                return event.getNDC();\n            }\n            return event.getMessage();\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Public Methods\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Sets the priority to filter events on. Only events of equal or higher\n     * property are now displayed.\n     *\n     * @param aPriority the priority to filter on\n     */\n    public void setPriorityFilter(Priority aPriority) {\n        synchronized (mLock) {\n            mPriorityFilter = aPriority;\n            updateFilteredEvents(false);\n        }\n    }\n\n    /**\n     * Set the filter for the thread field.\n     *\n     * @param aStr the string to match\n     */\n    public void setThreadFilter(String aStr) {\n        synchronized (mLock) {\n            mThreadFilter = aStr.trim();\n            updateFilteredEvents(false);\n        }\n    }\n\n    /**\n     * Set the filter for the message field.\n     *\n     * @param aStr the string to match\n     */\n    public void setMessageFilter(String aStr) {\n        synchronized (mLock) {\n            mMessageFilter = aStr.trim();\n            updateFilteredEvents(false);\n        }\n    }\n\n    /**\n     * Set the filter for the NDC field.\n     *\n     * @param aStr the string to match\n     */\n    public void setNDCFilter(String aStr) {\n        synchronized (mLock) {\n            mNDCFilter = aStr.trim();\n            updateFilteredEvents(false);\n        }\n    }\n\n    /**\n     * Set the filter for the category field.\n     *\n     * @param aStr the string to match\n     */\n    public void setCategoryFilter(String aStr) {\n        synchronized (mLock) {\n            mCategoryFilter = aStr.trim();\n            updateFilteredEvents(false);\n        }\n    }\n\n    /**\n     * Add an event to the list.\n     *\n     * @param aEvent a <code>EventDetails</code> value\n     */\n    public void addEvent(EventDetails aEvent) {\n        synchronized (mLock) {\n            mPendingEvents.add(aEvent);\n        }\n    }\n\n    /**\n     * Clear the list of all events.\n     */\n    public void clear() {\n        synchronized (mLock) {\n            mAllEvents.clear();\n            mFilteredEvents = new EventDetails[0];\n            mPendingEvents.clear();\n            fireTableDataChanged();\n        }\n    }\n\n    /** Toggle whether collecting events **/\n    public void toggle() {\n        synchronized (mLock) {\n            mPaused = !mPaused;\n        }\n    }\n\n    /** @return whether currently paused collecting events **/\n    public boolean isPaused() {\n        synchronized (mLock) {\n            return mPaused;\n        }\n    }\n\n    /**\n     * Get the throwable information at a specified row in the filtered events.\n     *\n     * @param aRow the row index of the event\n     * @return the throwable information\n     */\n    public EventDetails getEventDetails(int aRow) {\n        synchronized (mLock) {\n            return mFilteredEvents[aRow];\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Private methods\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Update the filtered events data structure.\n     * @param aInsertedToFront indicates whether events were added to front of\n     *        the events. If true, then the current first event must still exist\n     *        in the list after the filter is applied.\n     */\n    private void updateFilteredEvents(boolean aInsertedToFront) {\n        final long start = System.currentTimeMillis();\n        final List filtered = new ArrayList();\n        final int size = mAllEvents.size();\n        final Iterator it = mAllEvents.iterator();\n\n        while (it.hasNext()) {\n            final EventDetails event = (EventDetails) it.next();\n            if (matchFilter(event)) {\n                filtered.add(event);\n            }\n        }\n\n        final EventDetails lastFirst = (mFilteredEvents.length == 0)\n            ? null\n            : mFilteredEvents[0];\n        mFilteredEvents = (EventDetails[]) filtered.toArray(EMPTY_LIST);\n\n        if (aInsertedToFront && (lastFirst != null)) {\n            final int index = filtered.indexOf(lastFirst);\n            if (index < 1) {\n                LOG.warn(\"In strange state\");\n                fireTableDataChanged();\n            } else {\n                fireTableRowsInserted(0, index - 1);\n            }\n        } else {\n            fireTableDataChanged();\n        }\n\n        final long end = System.currentTimeMillis();\n        LOG.debug(\"Total time [ms]: \" + (end - start)\n                  + \" in update, size: \" + size);\n    }\n\n    /**\n     * Returns whether an event matches the filters.\n     *\n     * @param aEvent the event to check for a match\n     * @return whether the event matches\n     */\n    private boolean matchFilter(EventDetails aEvent) {\n        if (aEvent.getPriority().isGreaterOrEqual(mPriorityFilter) &&\n            (aEvent.getThreadName().indexOf(mThreadFilter) >= 0) &&\n            (aEvent.getCategoryName().indexOf(mCategoryFilter) >= 0) &&\n            ((mNDCFilter.length() == 0) ||\n             ((aEvent.getNDC() != null) &&\n              (aEvent.getNDC().indexOf(mNDCFilter) >= 0))))\n        {\n            final String rm = aEvent.getMessage();\n            if (rm == null) {\n                // only match if we have not filtering in place\n                return (mMessageFilter.length() == 0);\n            } else {\n                return (rm.indexOf(mMessageFilter) >= 0);\n            }\n        }\n\n        return false; // by default not match\n    }\n}\n",
            "file_name": "MyTableModel.java",
            "human_label": "Compare two events by their timeStamp.",
            "level": "project_runnable",
            "lineno": "47",
            "name": "compare",
            "oracle_context": "{ \"apis\" : \"[getTimeStamp]\", \"classes\" : \"[EventDetails]\", \"vars\" : \"[]\" }",
            "package": "org.apache.log4j.chainsaw",
            "project": "logging-log4j1-main"
        },
        {
            "_id": "636767781a6d9265ec018242",
            "all_context": "{ \"class_level\" : \"import org.apache.log4j.spi.AppenderAttachable;\\nimport org.apache.log4j.spi.LoggingEvent;\\nimport org.apache.log4j.Appender;\\nimport java.util.Vector;\\nimport java.util.Enumeration;\\nVector appenderList;\\nappendLoopOnAppenders(LoggingEvent event);\\ngetAllAppenders();\\ngetAppender(String name);\\nisAttached(Appender appender);\\nremoveAllAppenders();\\nremoveAppender(Appender appender);\\nremoveAppender(String name);\\naddAppender(Appender newAppender);\\n\", \"repo_level\" : \"public interface AppenderAttachable {public void addAppender(Appender newAppender);\\npublic Enumeration getAllAppenders();\\npublic Appender getAppender(String name);\\npublic boolean isAttached(Appender appender);\\n void removeAllAppenders();\\n void removeAppender(Appender appender);\\n void removeAppender(String name);\\n }\\npublic interface LoggingEvent {public LocationInfo getLocationInformation();\\npublic Level getLevel();\\npublic String getLoggerName();\\npublic Category getLogger();\\npublic Object getMessage();\\npublic String getNDC();\\npublic Object getMDC(String key);\\npublic void getMDCCopy();\\npublic String getRenderedMessage();\\nstatic long getStartTime();\\npublic String getThreadName();\\npublic ThrowableInformation getThrowableInformation();\\npublic String[] getThrowableStrRep();\\nfinal void setProperty(String propName,String propValue);\\nfinal String getProperty(String key);\\nfinal boolean locationInformationExists();\\nfinal long getTimeStamp();\\npublic Set getPropertyKeySet();\\npublic Map getProperties();\\npublic String getFQNOfLoggerClass();\\npublic Object removeProperty(String propName);\\n }\\npublic interface Appender { void addFilter(Filter newFilter);\\npublic Filter getFilter();\\npublic void clearFilters();\\npublic void close();\\npublic void doAppend(LoggingEvent event);\\npublic String getName();\\npublic void setErrorHandler(ErrorHandler errorHandler);\\npublic ErrorHandler getErrorHandler();\\npublic void setLayout(Layout layout);\\npublic Layout getLayout();\\npublic void setName(String name);\\npublic boolean requiresLayout();\\n }\\n\" }",
            "class_name": "AppenderAttachableImpl",
            "code": "public int appendLoopOnAppenders(LoggingEvent event){\n  int size=0;\n  Appender appender;\n  if (appenderList != null) {\n    size=appenderList.size();\n    for (int i=0; i < size; i++) {\n      appender=(Appender)appenderList.elementAt(i);\n      appender.doAppend(event);\n    }\n  }\n  return size;\n}\n",
            "docstring": "/** \n * Call the <code>doAppend</code> method on all attached appenders.  \n */\n",
            "end_lineno": "70",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j.helpers;\n\nimport org.apache.log4j.spi.AppenderAttachable;\nimport org.apache.log4j.spi.LoggingEvent;\n\nimport org.apache.log4j.Appender;\nimport java.util.Vector;\nimport java.util.Enumeration;\n\n/**\n   A straightforward implementation of the {@link AppenderAttachable}\n   interface.\n\n   @author Ceki G&uuml;lc&uuml;\n   @since version 0.9.1 */\npublic class AppenderAttachableImpl implements AppenderAttachable {\n  \n  /** Array of appenders. */\n  protected Vector  appenderList;\n\n  /**\n     Attach an appender. If the appender is already in the list in\n     won't be added again.\n  */\n  public\n  void addAppender(Appender newAppender) {\n    // Null values for newAppender parameter are strictly forbidden.\n    if(newAppender == null)\n      return;\n    \n    if(appenderList == null) {\n      appenderList = new Vector(1);\n    }\n    if(!appenderList.contains(newAppender))\n      appenderList.addElement(newAppender);\n  }\n\n  /**\n     Call the <code>doAppend</code> method on all attached appenders.  */\n  public\n  int appendLoopOnAppenders(LoggingEvent event) {\n    int size = 0;\n    Appender appender;\n\n    if(appenderList != null) {\n      size = appenderList.size();\n      for(int i = 0; i < size; i++) {\n\tappender = (Appender) appenderList.elementAt(i);\n\tappender.doAppend(event);\n      }\n    }    \n    return size;\n  }\n\n\n  /**\n     Get all attached appenders as an Enumeration. If there are no\n     attached appenders <code>null</code> is returned.\n     \n     @return Enumeration An enumeration of attached appenders.\n   */\n  public\n  Enumeration getAllAppenders() {\n    if(appenderList == null)\n      return null;\n    else \n      return appenderList.elements();    \n  }\n\n  /**\n     Look for an attached appender named as <code>name</code>.\n\n     <p>Return the appender with that name if in the list. Return null\n     otherwise.  \n     \n   */\n  public\n  Appender getAppender(String name) {\n     if(appenderList == null || name == null)\n      return null;\n\n     int size = appenderList.size();\n     Appender appender;\n     for(int i = 0; i < size; i++) {\n       appender = (Appender) appenderList.elementAt(i);\n       if(name.equals(appender.getName()))\n\t  return appender;\n     }\n     return null;    \n  }\n\n\n  /**\n     Returns <code>true</code> if the specified appender is in the\n     list of attached appenders, <code>false</code> otherwise.\n\n     @since 1.2 */\n  public \n  boolean isAttached(Appender appender) {\n    if(appenderList == null || appender == null)\n      return false;\n\n     int size = appenderList.size();\n     Appender a;\n     for(int i = 0; i < size; i++) {\n       a  = (Appender) appenderList.elementAt(i);\n       if(a == appender)\n\t  return true;\n     }\n     return false;    \n  }\n\n\n\n  /**\n   * Remove and close all previously attached appenders.\n   * */\n  public\n  void removeAllAppenders() {\n    if(appenderList != null) {\n      int len = appenderList.size();      \n      for(int i = 0; i < len; i++) {\n\tAppender a = (Appender) appenderList.elementAt(i);\n\ta.close();\n      }\n      appenderList.removeAllElements();\n      appenderList = null;      \n    }\n  }\n\n\n  /**\n     Remove the appender passed as parameter form the list of attached\n     appenders.  */\n  public\n  void removeAppender(Appender appender) {\n    if(appender == null || appenderList == null) \n      return;\n    appenderList.removeElement(appender);    \n  }\n\n\n /**\n    Remove the appender with the name passed as parameter form the\n    list of appenders.  \n  */\n  public\n  void removeAppender(String name) {\n    if(name == null || appenderList == null) return;\n    int size = appenderList.size();\n    for(int i = 0; i < size; i++) {\n      if(name.equals(((Appender)appenderList.elementAt(i)).getName())) {\n\t appenderList.removeElementAt(i);\n\t break;\n      }\n    }\n  }\n\n}\n",
            "file_name": "AppenderAttachableImpl.java",
            "human_label": "Call the doAppend method on all attached appenders. ",
            "level": "project_runnable",
            "lineno": "55",
            "name": "appendLoopOnAppenders",
            "oracle_context": "{ \"apis\" : \"[elementAt, doAppend]\", \"classes\" : \"[Appender]\", \"vars\" : \"[appenderList]\" }",
            "package": "org.apache.log4j.helpers",
            "project": "logging-log4j1-main"
        },
        {
            "_id": "636767041a6d9265ec017911",
            "all_context": "{ \"class_level\" : \"import net.hasor.utils.ClassUtils;\\nimport net.hasor.utils.ObjectUtils;\\nimport java.io.Serializable;\\nimport java.lang.reflect.Array;\\nimport java.util.Collection;\\nimport java.util.Map;\\nimport java.util.WeakHashMap;\\nToStringStyle DEFAULT_STYLE;\\nToStringStyle MULTI_LINE_STYLE;\\nToStringStyle NO_FIELD_NAMES_STYLE;\\nToStringStyle SHORT_PREFIX_STYLE;\\nToStringStyle SIMPLE_STYLE;\\nThreadLocal REGISTRY;\\nboolean useFieldNames;\\nboolean useClassName;\\nboolean useShortClassName;\\nboolean useIdentityHashCode;\\nString contentStart;\\nString contentEnd;\\nString fieldNameValueSeparator;\\nboolean fieldSeparatorAtStart;\\nboolean fieldSeparatorAtEnd;\\nString fieldSeparator;\\nString arrayStart;\\nString arraySeparator;\\nboolean arrayContentDetail;\\nString arrayEnd;\\nboolean defaultFullDetail;\\nString nullText;\\nString sizeStartText;\\nString sizeEndText;\\nString summaryObjectStartText;\\nString summaryObjectEndText;\\nlong serialVersionUID;\\ngetRegistry();\\nregister(Object value);\\nunregister(Object value);\\nToStringStyle();\\nappendSuper(StringBuffer buffer,String superToString);\\nappendToString(StringBuffer buffer,String toString);\\nappendStart(StringBuffer buffer,Object object);\\nappendEnd(StringBuffer buffer,Object object);\\nremoveLastFieldSeparator(StringBuffer buffer);\\nappend(StringBuffer buffer,String fieldName,Object value,Boolean fullDetail);\\nappendInternal(StringBuffer buffer,String fieldName,Object value,boolean detail);\\nappendCyclicObject(StringBuffer buffer,String fieldName,Object value);\\nappendDetail(StringBuffer buffer,String fieldName,Object value);\\nappendDetail(StringBuffer buffer,String fieldName,Collection coll);\\nappendDetail(StringBuffer buffer,String fieldName,Map map);\\nappendSummary(StringBuffer buffer,String fieldName,Object value);\\nappend(StringBuffer buffer,String fieldName,long value);\\nappendDetail(StringBuffer buffer,String fieldName,long value);\\nappend(StringBuffer buffer,String fieldName,int value);\\nappendDetail(StringBuffer buffer,String fieldName,int value);\\nappend(StringBuffer buffer,String fieldName,short value);\\nappendDetail(StringBuffer buffer,String fieldName,short value);\\nappend(StringBuffer buffer,String fieldName,byte value);\\nappendDetail(StringBuffer buffer,String fieldName,byte value);\\nappend(StringBuffer buffer,String fieldName,char value);\\nappendDetail(StringBuffer buffer,String fieldName,char value);\\nappend(StringBuffer buffer,String fieldName,double value);\\nappendDetail(StringBuffer buffer,String fieldName,double value);\\nappend(StringBuffer buffer,String fieldName,float value);\\nappendDetail(StringBuffer buffer,String fieldName,float value);\\nappend(StringBuffer buffer,String fieldName,boolean value);\\nappendDetail(StringBuffer buffer,String fieldName,boolean value);\\nappend(StringBuffer buffer,String fieldName,Object[] array,Boolean fullDetail);\\nappendDetail(StringBuffer buffer,String fieldName,Object[] array);\\nreflectionAppendArrayDetail(StringBuffer buffer,String fieldName,Object array);\\nappendSummary(StringBuffer buffer,String fieldName,Object[] array);\\nappend(StringBuffer buffer,String fieldName,long[] array,Boolean fullDetail);\\nappendDetail(StringBuffer buffer,String fieldName,long[] array);\\nappendSummary(StringBuffer buffer,String fieldName,long[] array);\\nappend(StringBuffer buffer,String fieldName,int[] array,Boolean fullDetail);\\nappendDetail(StringBuffer buffer,String fieldName,int[] array);\\nappendSummary(StringBuffer buffer,String fieldName,int[] array);\\nappend(StringBuffer buffer,String fieldName,short[] array,Boolean fullDetail);\\nappendDetail(StringBuffer buffer,String fieldName,short[] array);\\nappendSummary(StringBuffer buffer,String fieldName,short[] array);\\nappend(StringBuffer buffer,String fieldName,byte[] array,Boolean fullDetail);\\nappendDetail(StringBuffer buffer,String fieldName,byte[] array);\\nappendSummary(StringBuffer buffer,String fieldName,byte[] array);\\nappend(StringBuffer buffer,String fieldName,char[] array,Boolean fullDetail);\\nappendDetail(StringBuffer buffer,String fieldName,char[] array);\\nappendSummary(StringBuffer buffer,String fieldName,char[] array);\\nappend(StringBuffer buffer,String fieldName,double[] array,Boolean fullDetail);\\nappendDetail(StringBuffer buffer,String fieldName,double[] array);\\nappendSummary(StringBuffer buffer,String fieldName,double[] array);\\nappend(StringBuffer buffer,String fieldName,float[] array,Boolean fullDetail);\\nappendDetail(StringBuffer buffer,String fieldName,float[] array);\\nappendSummary(StringBuffer buffer,String fieldName,float[] array);\\nappend(StringBuffer buffer,String fieldName,boolean[] array,Boolean fullDetail);\\nappendDetail(StringBuffer buffer,String fieldName,boolean[] array);\\nappendSummary(StringBuffer buffer,String fieldName,boolean[] array);\\nappendClassName(StringBuffer buffer,Object object);\\nappendIdentityHashCode(StringBuffer buffer,Object object);\\nappendContentStart(StringBuffer buffer);\\nappendContentEnd(StringBuffer buffer);\\nappendNullText(StringBuffer buffer,String fieldName);\\nappendFieldSeparator(StringBuffer buffer);\\nappendFieldStart(StringBuffer buffer,String fieldName);\\nappendFieldEnd(StringBuffer buffer,String fieldName);\\nappendSummarySize(StringBuffer buffer,String fieldName,int size);\\nisFullDetail(Boolean fullDetailRequest);\\ngetShortClassName(Class cls);\\nisUseClassName();\\nsetUseClassName(boolean useClassName);\\nisUseShortClassName();\\nisShortClassName();\\nsetUseShortClassName(boolean useShortClassName);\\nsetShortClassName(boolean shortClassName);\\nisUseIdentityHashCode();\\nsetUseIdentityHashCode(boolean useIdentityHashCode);\\nisUseFieldNames();\\nsetUseFieldNames(boolean useFieldNames);\\nisDefaultFullDetail();\\nsetDefaultFullDetail(boolean defaultFullDetail);\\nisArrayContentDetail();\\nsetArrayContentDetail(boolean arrayContentDetail);\\ngetArrayStart();\\nsetArrayStart(String arrayStart);\\ngetArrayEnd();\\nsetArrayEnd(String arrayEnd);\\ngetArraySeparator();\\nsetArraySeparator(String arraySeparator);\\ngetContentStart();\\nsetContentStart(String contentStart);\\ngetContentEnd();\\nsetContentEnd(String contentEnd);\\ngetFieldNameValueSeparator();\\nsetFieldNameValueSeparator(String fieldNameValueSeparator);\\ngetFieldSeparator();\\nsetFieldSeparator(String fieldSeparator);\\nisFieldSeparatorAtStart();\\nsetFieldSeparatorAtStart(boolean fieldSeparatorAtStart);\\nisFieldSeparatorAtEnd();\\nsetFieldSeparatorAtEnd(boolean fieldSeparatorAtEnd);\\ngetNullText();\\nsetNullText(String nullText);\\ngetSizeStartText();\\nsetSizeStartText(String sizeStartText);\\ngetSizeEndText();\\nsetSizeEndText(String sizeEndText);\\ngetSummaryObjectStartText();\\nsetSummaryObjectStartText(String summaryObjectStartText);\\ngetSummaryObjectEndText();\\nsetSummaryObjectEndText(String summaryObjectEndText);\\nDefaultToStringStyle();\\nreadResolve();\\nNoFieldNameToStringStyle();\\nShortPrefixToStringStyle();\\nSimpleToStringStyle();\\nMultiLineToStringStyle();\\ngetSystemProperty(String property);\\nisRegistered(Object value);\\n\", \"repo_level\" : \"public interface ClassUtils {static String getShortClassName(Object object,String valueIfNull);\\nstatic String getShortClassName(Class cls);\\nstatic String getShortClassName(String className);\\nstatic String getPackageName(Object object,String valueIfNull);\\nstatic String getPackageName(Class cls);\\nstatic String getPackageName(String className);\\nstatic List<Class<?>> getAllSuperclasses(Class cls);\\nstatic List<Class<?>> getAllInterfaces(Class cls);\\nstatic List<Class<?>> convertClassNamesToClasses(List classNames);\\nstatic List<String> convertClassesToClassNames(List classes);\\nstatic boolean isAssignable(Class<?>[] classArray,Class<?>[] toClassArray);\\nstatic boolean isAssignable(Class<?>[] classArray,Class<?>[] toClassArray,boolean autoboxing);\\nstatic boolean isAssignable(Class cls,Class toClass);\\nstatic boolean isAssignable(Class cls,Class toClass,boolean autoboxing);\\nstatic Class<?> primitiveToWrapper(Class cls);\\nstatic Class<?>[] primitivesToWrappers(Class<?>[] classes);\\nstatic Class<?> wrapperToPrimitive(Class cls);\\nstatic Class<?>[] wrappersToPrimitives(Class<?>[] classes);\\nstatic boolean isInnerClass(Class cls);\\nstatic Class<?> getClass(ClassLoader classLoader,String className,boolean initialize);\\nstatic Class<?> getClass(ClassLoader classLoader,String className);\\nstatic Class<?> getClass(String className);\\nstatic Class<?> getClass(String className,boolean initialize);\\nstatic Method getPublicMethod(Class cls,String methodName,Class parameterTypes);\\nstatic Class<?>[] toClass(Object[] array);\\nstatic String getShortCanonicalName(Object object,String valueIfNull);\\nstatic String getShortCanonicalName(Class cls);\\nstatic String getShortCanonicalName(String canonicalName);\\nstatic String getPackageCanonicalName(Object object,String valueIfNull);\\nstatic String getPackageCanonicalName(Class cls);\\nstatic String getPackageCanonicalName(String canonicalName);\\nstatic ClassLoader getClassLoader(ClassLoader classLoader);\\nstatic boolean isLangClass(Class target);\\nstatic String getDescName(Class type);\\nstatic String getDescNameWithOutModifiers(Method method);\\nstatic String getDescName(Method method);\\nstatic Class<?> getSuperClassGenricType(Class clazz,int index);\\nstatic T newInstance(Class clazz);\\n }\\npublic interface ObjectUtils {static Object defaultIfNull(Object object,Object defaultValue);\\nstatic boolean equals(Object object1,Object object2);\\nstatic boolean notEqual(Object object1,Object object2);\\nstatic int hashCode(Object obj);\\nstatic String identityToString(Object object);\\nstatic void identityToString(StringBuffer buffer,Object object);\\nstatic String toString(Object obj);\\nstatic String toString(Object obj,String nullStr);\\nstatic Object min(Comparable c1,Comparable c2);\\nstatic Object max(Comparable c1,Comparable c2);\\nstatic int compare(Comparable c1,Comparable c2);\\nstatic int compare(Comparable c1,Comparable c2,boolean nullGreater);\\n }\\n\" }",
            "class_name": "ToStringStyle",
            "code": "static void register(Object value){\n  if (value != null) {\n    Map m=getRegistry();\n    if (m == null) {\n      m=new WeakHashMap();\n      REGISTRY.set(m);\n    }\n    m.put(value,null);\n  }\n}\n",
            "docstring": "/** \n * <p> Registers the given object. Used by the reflection methods to avoid infinite loops. </p>\n * @param value The object to register.\n */\n",
            "end_lineno": "175",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.builder;\nimport net.hasor.utils.ClassUtils;\nimport net.hasor.utils.ObjectUtils;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Array;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.WeakHashMap;\n\n/**\n * <p>Controls <code>String</code> formatting for {@link ToStringBuilder}.\n * The main public interface is always via <code>ToStringBuilder</code>.</p>\n *\n * <p>These classes are intended to be used as <code>Singletons</code>.\n * There is no need to instantiate a new style each time. A program\n * will generally use one of the predefined constants on this class.\n * Alternatively, the {@link StandardToStringStyle} class can be used\n * to set the individual settings. Thus most styles can be achieved\n * without subclassing.</p>\n *\n * <p>If required, a subclass can override as many or as few of the\n * methods as it requires. Each object type (from <code>boolean</code>\n * to <code>long</code> to <code>Object</code> to <code>int[]</code>) has\n * its own methods to output it. Most have two versions, detail and summary.\n *\n * <p>For example, the detail version of the array based methods will\n * output the whole array, whereas the summary method will just output\n * the array length.</p>\n *\n * <p>If you want to format the output of certain objects, such as dates, you\n * must create a subclass and override a method.\n * <pre>\n * public class MyStyle extends ToStringStyle {\n *   protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\n *     if (value instanceof Date) {\n *       value = new SimpleDateFormat(\"yyyy-MM-dd\").format(value);\n *     }\n *     buffer.append(value);\n *   }\n * }\n * </pre>\n * </p>\n *\n * @author Apache Software Foundation\n * @author Gary Gregory\n * @author Pete Gieser\n * @author Masato Tezuka\n * @since 1.0\n * @version $Id: ToStringStyle.java 907168 2010-02-06 03:33:50Z mbenson $\n */\npublic abstract class ToStringStyle implements Serializable {\n    /**\n     * The default toString style. Using the Using the <code>Person</code>\n     * example from {@link ToStringBuilder}, the output would look like this:\n     *\n     * <pre>\n     * Person@182f0db[name=John Doe,age=33,smoker=false]\n     * </pre>\n     */\n    public static final  ToStringStyle DEFAULT_STYLE        = new DefaultToStringStyle();\n    /**\n     * The multi line toString style. Using the Using the <code>Person</code>\n     * example from {@link ToStringBuilder}, the output would look like this:\n     *\n     * <pre>\n     * Person@182f0db[\n     *   name=John Doe\n     *   age=33\n     *   smoker=false\n     * ]\n     * </pre>\n     */\n    public static final  ToStringStyle MULTI_LINE_STYLE     = new MultiLineToStringStyle();\n    /**\n     * The no field names toString style. Using the Using the\n     * <code>Person</code> example from {@link ToStringBuilder}, the output\n     * would look like this:\n     *\n     * <pre>\n     * Person@182f0db[John Doe,33,false]\n     * </pre>\n     */\n    public static final  ToStringStyle NO_FIELD_NAMES_STYLE = new NoFieldNameToStringStyle();\n    /**\n     * The short prefix toString style. Using the <code>Person</code> example\n     * from {@link ToStringBuilder}, the output would look like this:\n     *\n     * <pre>\n     * Person[name=John Doe,age=33,smoker=false]\n     * </pre>\n     *\n     * @since 2.1\n     */\n    public static final  ToStringStyle SHORT_PREFIX_STYLE   = new ShortPrefixToStringStyle();\n    /**\n     * The simple toString style. Using the Using the <code>Person</code>\n     * example from {@link ToStringBuilder}, the output would look like this:\n     *\n     * <pre>\n     * John Doe,33,false\n     * </pre>\n     */\n    public static final  ToStringStyle SIMPLE_STYLE         = new SimpleToStringStyle();\n    /**\n     * <p>\n     * A registry of objects used by <code>reflectionToString</code> methods\n     * to detect cyclical object references and avoid infinite loops.\n     * </p>\n     */\n    private static final ThreadLocal   REGISTRY             = new ThreadLocal();\n\n    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map getRegistry() {\n        return (Map) REGISTRY.get();\n    }\n\n    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map m = getRegistry();\n        return m != null && m.containsKey(value);\n    }\n\n    /**\n     * <p>\n     * Registers the given object. Used by the reflection methods to avoid\n     * infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to register.\n     */\n    static void register(Object value) {\n        if (value != null) {\n            Map m = getRegistry();\n            if (m == null) {\n                m = new WeakHashMap();\n                REGISTRY.set(m);\n            }\n            m.put(value, null);\n        }\n    }\n\n    /**\n     * <p>\n     * Unregisters the given object.\n     * </p>\n     *\n     * <p>\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to unregister.\n     */\n    static void unregister(Object value) {\n        if (value != null) {\n            Map m = getRegistry();\n            if (m != null) {\n                m.remove(value);\n                if (m.isEmpty()) {\n                    REGISTRY.set(null);\n                }\n            }\n        }\n    }\n\n    /**\n     * Whether to use the field names, the default is <code>true</code>.\n     */\n    private boolean useFieldNames           = true;\n    /**\n     * Whether to use the class name, the default is <code>true</code>.\n     */\n    private boolean useClassName            = true;\n    /**\n     * Whether to use short class names, the default is <code>false</code>.\n     */\n    private boolean useShortClassName       = false;\n    /**\n     * Whether to use the identity hash code, the default is <code>true</code>.\n     */\n    private boolean useIdentityHashCode     = true;\n    /**\n     * The content start <code>'['</code>.\n     */\n    private String  contentStart            = \"[\";\n    /**\n     * The content end <code>']'</code>.\n     */\n    private String  contentEnd              = \"]\";\n    /**\n     * The field name value separator <code>'='</code>.\n     */\n    private String  fieldNameValueSeparator = \"=\";\n    /**\n     * Whether the field separator should be added before any other fields.\n     */\n    private boolean fieldSeparatorAtStart   = false;\n    /**\n     * Whether the field separator should be added after any other fields.\n     */\n    private boolean fieldSeparatorAtEnd     = false;\n    /**\n     * The field separator <code>','</code>.\n     */\n    private String  fieldSeparator          = \",\";\n    /**\n     * The array start <code>'{'</code>.\n     */\n    private String  arrayStart              = \"{\";\n    /**\n     * The array separator <code>','</code>.\n     */\n    private String  arraySeparator          = \",\";\n    /**\n     * The detail for array content.\n     */\n    private boolean arrayContentDetail      = true;\n    /**\n     * The array end <code>'}'</code>.\n     */\n    private String  arrayEnd                = \"}\";\n    /**\n     * The value to use when fullDetail is <code>null</code>,\n     * the default value is <code>true</code>.\n     */\n    private boolean defaultFullDetail       = true;\n    /**\n     * The <code>null</code> text <code>'&lt;null&gt;'</code>.\n     */\n    private String  nullText                = \"<null>\";\n    /**\n     * The summary size text start <code>'<size'</code>.\n     */\n    private String  sizeStartText           = \"<size=\";\n    /**\n     * The summary size text start <code>'&gt;'</code>.\n     */\n    private String  sizeEndText             = \">\";\n    /**\n     * The summary object text start <code>'&lt;'</code>.\n     */\n    private String  summaryObjectStartText  = \"<\";\n    /**\n     * The summary object text start <code>'&gt;'</code>.\n     */\n    private String  summaryObjectEndText    = \">\";\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Constructor.</p>\n     */\n    protected ToStringStyle() {\n        super();\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> the superclass toString.</p>\n     * <p>NOTE: It assumes that the toString has been created from the same ToStringStyle. </p>\n     *\n     * <p>A <code>null</code> <code>superToString</code> is ignored.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param superToString  the <code>super.toString()</code>\n     * @since 2.0\n     */\n    public void appendSuper(StringBuffer buffer, String superToString) {\n        appendToString(buffer, superToString);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> another toString.</p>\n     * <p>NOTE: It assumes that the toString has been created from the same ToStringStyle. </p>\n     *\n     * <p>A <code>null</code> <code>toString</code> is ignored.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param toString  the additional <code>toString</code>\n     * @since 2.0\n     */\n    public void appendToString(StringBuffer buffer, String toString) {\n        if (toString != null) {\n            int pos1 = toString.indexOf(contentStart) + contentStart.length();\n            int pos2 = toString.lastIndexOf(contentEnd);\n            if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) {\n                String data = toString.substring(pos1, pos2);\n                if (fieldSeparatorAtStart) {\n                    removeLastFieldSeparator(buffer);\n                }\n                buffer.append(data);\n                appendFieldSeparator(buffer);\n            }\n        }\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> the start of data indicator.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param object  the <code>Object</code> to build a <code>toString</code> for\n     */\n    public void appendStart(StringBuffer buffer, Object object) {\n        if (object != null) {\n            appendClassName(buffer, object);\n            appendIdentityHashCode(buffer, object);\n            appendContentStart(buffer);\n            if (fieldSeparatorAtStart) {\n                appendFieldSeparator(buffer);\n            }\n        }\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> the end of data indicator.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param object  the <code>Object</code> to build a\n     *  <code>toString</code> for.\n     */\n    public void appendEnd(StringBuffer buffer, Object object) {\n        if (this.fieldSeparatorAtEnd == false) {\n            removeLastFieldSeparator(buffer);\n        }\n        appendContentEnd(buffer);\n        unregister(object);\n    }\n\n    /**\n     * <p>Remove the last field separator from the buffer.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @since 2.0\n     */\n    protected void removeLastFieldSeparator(StringBuffer buffer) {\n        int len = buffer.length();\n        int sepLen = fieldSeparator.length();\n        if (len > 0 && sepLen > 0 && len >= sepLen) {\n            boolean match = true;\n            for (int i = 0; i < sepLen; i++) {\n                if (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\n                    match = false;\n                    break;\n                }\n            }\n            if (match) {\n                buffer.setLength(len - sepLen);\n            }\n        }\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value, printing the full <code>toString</code> of the\n     * <code>Object</code> passed in.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n        if (value == null) {\n            appendNullText(buffer, fieldName);\n        } else {\n            appendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n        }\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n            appendCyclicObject(buffer, fieldName, value);\n            return;\n        }\n        register(value);\n        try {\n            if (value instanceof Collection) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection) value).size());\n                }\n            } else if (value instanceof Map) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map) value).size());\n                }\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n            } else {\n                if (detail) {\n                    appendDetail(buffer, fieldName, value);\n                } else {\n                    appendSummary(buffer, fieldName, value);\n                }\n            }\n        } finally {\n            unregister(value);\n        }\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value that has been detected to participate in a cycle. This\n     * implementation will print the standard string value of the value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     *\n     * @since 2.2\n     */\n    protected void appendCyclicObject(StringBuffer buffer, String fieldName, Object value) {\n        ObjectUtils.identityToString(buffer, value);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value, printing the full detail of the <code>Object</code>.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\n        buffer.append(value);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>Collection</code>.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param coll  the <code>Collection</code> to add to the\n     *  <code>toString</code>, not <code>null</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, Collection<?> coll) {\n        buffer.append(coll);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>Map<code>.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param map  the <code>Map</code> to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, Map map) {\n        buffer.append(map);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value, printing a summary of the <code>Object</code>.</P>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendSummary(StringBuffer buffer, String fieldName, Object value) {\n        buffer.append(summaryObjectStartText);\n        buffer.append(getShortClassName(value.getClass()));\n        buffer.append(summaryObjectEndText);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>long</code>\n     * value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     */\n    public void append(StringBuffer buffer, String fieldName, long value) {\n        appendFieldStart(buffer, fieldName);\n        appendDetail(buffer, fieldName, value);\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>long</code>\n     * value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, long value) {\n        buffer.append(value);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> an <code>int</code>\n     * value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     */\n    public void append(StringBuffer buffer, String fieldName, int value) {\n        appendFieldStart(buffer, fieldName);\n        appendDetail(buffer, fieldName, value);\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> an <code>int</code>\n     * value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, int value) {\n        buffer.append(value);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>short</code>\n     * value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     */\n    public void append(StringBuffer buffer, String fieldName, short value) {\n        appendFieldStart(buffer, fieldName);\n        appendDetail(buffer, fieldName, value);\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>short</code>\n     * value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, short value) {\n        buffer.append(value);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>byte</code>\n     * value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     */\n    public void append(StringBuffer buffer, String fieldName, byte value) {\n        appendFieldStart(buffer, fieldName);\n        appendDetail(buffer, fieldName, value);\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>byte</code>\n     * value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, byte value) {\n        buffer.append(value);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>char</code>\n     * value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     */\n    public void append(StringBuffer buffer, String fieldName, char value) {\n        appendFieldStart(buffer, fieldName);\n        appendDetail(buffer, fieldName, value);\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>char</code>\n     * value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, char value) {\n        buffer.append(value);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>double</code>\n     * value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     */\n    public void append(StringBuffer buffer, String fieldName, double value) {\n        appendFieldStart(buffer, fieldName);\n        appendDetail(buffer, fieldName, value);\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>double</code>\n     * value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, double value) {\n        buffer.append(value);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>float</code>\n     * value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     */\n    public void append(StringBuffer buffer, String fieldName, float value) {\n        appendFieldStart(buffer, fieldName);\n        appendDetail(buffer, fieldName, value);\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>float</code>\n     * value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, float value) {\n        buffer.append(value);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>boolean</code>\n     * value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     */\n    public void append(StringBuffer buffer, String fieldName, boolean value) {\n        appendFieldStart(buffer, fieldName);\n        appendDetail(buffer, fieldName, value);\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>boolean</code>\n     * value.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, boolean value) {\n        buffer.append(value);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param array  the array to add to the toString\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, Object[] array, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n        if (array == null) {\n            appendNullText(buffer, fieldName);\n        } else if (isFullDetail(fullDetail)) {\n            appendDetail(buffer, fieldName, array);\n        } else {\n            appendSummary(buffer, fieldName, array);\n        }\n        appendFieldEnd(buffer, fieldName);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> the detail of an\n     * <code>Object</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, Object[] array) {\n        buffer.append(arrayStart);\n        for (int i = 0; i < array.length; i++) {\n            Object item = array[i];\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a summary of an\n     * <code>Object</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendSummary(StringBuffer buffer, String fieldName, Object[] array) {\n        appendSummarySize(buffer, fieldName, array.length);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>long</code>\n     * array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param array  the array to add to the <code>toString</code>\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, long[] array, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n        if (array == null) {\n            appendNullText(buffer, fieldName);\n        } else if (isFullDetail(fullDetail)) {\n            appendDetail(buffer, fieldName, array);\n        } else {\n            appendSummary(buffer, fieldName, array);\n        }\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> the detail of a\n     * <code>long</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, long[] array) {\n        buffer.append(arrayStart);\n        for (int i = 0; i < array.length; i++) {\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            appendDetail(buffer, fieldName, array[i]);\n        }\n        buffer.append(arrayEnd);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a summary of a\n     * <code>long</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendSummary(StringBuffer buffer, String fieldName, long[] array) {\n        appendSummarySize(buffer, fieldName, array.length);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> an <code>int</code>\n     * array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param array  the array to add to the <code>toString</code>\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, int[] array, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n        if (array == null) {\n            appendNullText(buffer, fieldName);\n        } else if (isFullDetail(fullDetail)) {\n            appendDetail(buffer, fieldName, array);\n        } else {\n            appendSummary(buffer, fieldName, array);\n        }\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> the detail of an\n     * <code>int</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n        buffer.append(arrayStart);\n        for (int i = 0; i < array.length; i++) {\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            appendDetail(buffer, fieldName, array[i]);\n        }\n        buffer.append(arrayEnd);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a summary of an\n     * <code>int</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendSummary(StringBuffer buffer, String fieldName, int[] array) {\n        appendSummarySize(buffer, fieldName, array.length);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>short</code>\n     * array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param array  the array to add to the <code>toString</code>\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, short[] array, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n        if (array == null) {\n            appendNullText(buffer, fieldName);\n        } else if (isFullDetail(fullDetail)) {\n            appendDetail(buffer, fieldName, array);\n        } else {\n            appendSummary(buffer, fieldName, array);\n        }\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> the detail of a\n     * <code>short</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, short[] array) {\n        buffer.append(arrayStart);\n        for (int i = 0; i < array.length; i++) {\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            appendDetail(buffer, fieldName, array[i]);\n        }\n        buffer.append(arrayEnd);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a summary of a\n     * <code>short</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendSummary(StringBuffer buffer, String fieldName, short[] array) {\n        appendSummarySize(buffer, fieldName, array.length);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>byte</code>\n     * array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param array  the array to add to the <code>toString</code>\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, byte[] array, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n        if (array == null) {\n            appendNullText(buffer, fieldName);\n        } else if (isFullDetail(fullDetail)) {\n            appendDetail(buffer, fieldName, array);\n        } else {\n            appendSummary(buffer, fieldName, array);\n        }\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> the detail of a\n     * <code>byte</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n        buffer.append(arrayStart);\n        for (int i = 0; i < array.length; i++) {\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            appendDetail(buffer, fieldName, array[i]);\n        }\n        buffer.append(arrayEnd);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a summary of a\n     * <code>byte</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendSummary(StringBuffer buffer, String fieldName, byte[] array) {\n        appendSummarySize(buffer, fieldName, array.length);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>char</code>\n     * array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param array  the array to add to the <code>toString</code>\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, char[] array, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n        if (array == null) {\n            appendNullText(buffer, fieldName);\n        } else if (isFullDetail(fullDetail)) {\n            appendDetail(buffer, fieldName, array);\n        } else {\n            appendSummary(buffer, fieldName, array);\n        }\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> the detail of a\n     * <code>char</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, char[] array) {\n        buffer.append(arrayStart);\n        for (int i = 0; i < array.length; i++) {\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            appendDetail(buffer, fieldName, array[i]);\n        }\n        buffer.append(arrayEnd);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a summary of a\n     * <code>char</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendSummary(StringBuffer buffer, String fieldName, char[] array) {\n        appendSummarySize(buffer, fieldName, array.length);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>double</code>\n     * array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param array  the array to add to the toString\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, double[] array, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n        if (array == null) {\n            appendNullText(buffer, fieldName);\n        } else if (isFullDetail(fullDetail)) {\n            appendDetail(buffer, fieldName, array);\n        } else {\n            appendSummary(buffer, fieldName, array);\n        }\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> the detail of a\n     * <code>double</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, double[] array) {\n        buffer.append(arrayStart);\n        for (int i = 0; i < array.length; i++) {\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            appendDetail(buffer, fieldName, array[i]);\n        }\n        buffer.append(arrayEnd);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a summary of a\n     * <code>double</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendSummary(StringBuffer buffer, String fieldName, double[] array) {\n        appendSummarySize(buffer, fieldName, array.length);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>float</code>\n     * array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param array  the array to add to the toString\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, float[] array, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n        if (array == null) {\n            appendNullText(buffer, fieldName);\n        } else if (isFullDetail(fullDetail)) {\n            appendDetail(buffer, fieldName, array);\n        } else {\n            appendSummary(buffer, fieldName, array);\n        }\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> the detail of a\n     * <code>float</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, float[] array) {\n        buffer.append(arrayStart);\n        for (int i = 0; i < array.length; i++) {\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            appendDetail(buffer, fieldName, array[i]);\n        }\n        buffer.append(arrayEnd);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a summary of a\n     * <code>float</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendSummary(StringBuffer buffer, String fieldName, float[] array) {\n        appendSummarySize(buffer, fieldName, array.length);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> a <code>boolean</code>\n     * array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param array  the array to add to the toString\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, boolean[] array, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n        if (array == null) {\n            appendNullText(buffer, fieldName);\n        } else if (isFullDetail(fullDetail)) {\n            appendDetail(buffer, fieldName, array);\n        } else {\n            appendSummary(buffer, fieldName, array);\n        }\n        appendFieldEnd(buffer, fieldName);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> the detail of a\n     * <code>boolean</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, boolean[] array) {\n        buffer.append(arrayStart);\n        for (int i = 0; i < array.length; i++) {\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            appendDetail(buffer, fieldName, array[i]);\n        }\n        buffer.append(arrayEnd);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a summary of a\n     * <code>boolean</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendSummary(StringBuffer buffer, String fieldName, boolean[] array) {\n        appendSummarySize(buffer, fieldName, array.length);\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Append to the <code>toString</code> the class name.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param object  the <code>Object</code> whose name to output\n     */\n    protected void appendClassName(StringBuffer buffer, Object object) {\n        if (useClassName && object != null) {\n            register(object);\n            if (useShortClassName) {\n                buffer.append(getShortClassName(object.getClass()));\n            } else {\n                buffer.append(object.getClass().getName());\n            }\n        }\n    }\n\n    /**\n     * <p>Append the {@link System#identityHashCode(java.lang.Object)}.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param object  the <code>Object</code> whose id to output\n     */\n    protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\n        if (this.isUseIdentityHashCode() && object != null) {\n            register(object);\n            buffer.append('@');\n            buffer.append(Integer.toHexString(System.identityHashCode(object)));\n        }\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> the content start.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     */\n    protected void appendContentStart(StringBuffer buffer) {\n        buffer.append(contentStart);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> the content end.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     */\n    protected void appendContentEnd(StringBuffer buffer) {\n        buffer.append(contentEnd);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> an indicator for <code>null</code>.</p>\n     *\n     * <p>The default indicator is <code>'&lt;null&gt;'</code>.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     */\n    protected void appendNullText(StringBuffer buffer, String fieldName) {\n        buffer.append(nullText);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> the field separator.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     */\n    protected void appendFieldSeparator(StringBuffer buffer) {\n        buffer.append(fieldSeparator);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> the field start.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     */\n    protected void appendFieldStart(StringBuffer buffer, String fieldName) {\n        if (useFieldNames && fieldName != null) {\n            buffer.append(fieldName);\n            buffer.append(fieldNameValueSeparator);\n        }\n    }\n\n    /**\n     * <p>Append to the <code>toString<code> the field end.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     */\n    protected void appendFieldEnd(StringBuffer buffer, String fieldName) {\n        appendFieldSeparator(buffer);\n    }\n\n    /**\n     * <p>Append to the <code>toString</code> a size summary.</p>\n     *\n     * <p>The size summary is used to summarize the contents of\n     * <code>Collections</code>, <code>Maps</code> and arrays.</p>\n     *\n     * <p>The output consists of a prefix, the passed in size\n     * and a suffix.</p>\n     *\n     * <p>The default format is <code>'&lt;size=n&gt;'<code>.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param size  the size to append\n     */\n    protected void appendSummarySize(StringBuffer buffer, String fieldName, int size) {\n        buffer.append(sizeStartText);\n        buffer.append(size);\n        buffer.append(sizeEndText);\n    }\n\n    /**\n     * <p>Is this field to be output in full detail.</p>\n     *\n     * <p>This method converts a detail request into a detail level.\n     * The calling code may request full detail (<code>true</code>),\n     * but a subclass might ignore that and always return\n     * <code>false</code>. The calling code may pass in\n     * <code>null</code> indicating that it doesn't care about\n     * the detail level. In this case the default detail level is\n     * used.</p>\n     *\n     * @param fullDetailRequest  the detail level requested\n     * @return whether full detail is to be shown\n     */\n    protected boolean isFullDetail(Boolean fullDetailRequest) {\n        if (fullDetailRequest == null) {\n            return defaultFullDetail;\n        }\n        return fullDetailRequest;\n    }\n\n    /**\n     * <p>Gets the short class name for a class.</p>\n     *\n     * <p>The short class name is the classname excluding\n     * the package name.</p>\n     *\n     * @param cls  the <code>Class</code> to get the short name of\n     * @return the short name\n     */\n    protected String getShortClassName(Class<?> cls) {\n        return ClassUtils.getShortClassName(cls);\n    }\n    // Setters and getters for the customizable parts of the style\n    // These methods are not expected to be overridden, except to make public\n    // (They are not public so that immutable subclasses can be written)\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets whether to use the class name.</p>\n     *\n     * @return the current useClassName flag\n     */\n    protected boolean isUseClassName() {\n        return useClassName;\n    }\n\n    /**\n     * <p>Sets whether to use the class name.</p>\n     *\n     * @param useClassName  the new useClassName flag\n     */\n    protected void setUseClassName(boolean useClassName) {\n        this.useClassName = useClassName;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets whether to output short or long class names.</p>\n     *\n     * @return the current useShortClassName flag\n     * @since 2.0\n     */\n    protected boolean isUseShortClassName() {\n        return useShortClassName;\n    }\n\n    /**\n     * <p>Gets whether to output short or long class names.</p>\n     *\n     * @return the current shortClassName flag\n     * @deprecated Use {@link #isUseShortClassName()}\n     *             Method will be removed in Commons Lang 3.0.\n     */\n    protected boolean isShortClassName() {\n        return useShortClassName;\n    }\n\n    /**\n     * <p>Sets whether to output short or long class names.</p>\n     *\n     * @param useShortClassName  the new useShortClassName flag\n     * @since 2.0\n     */\n    protected void setUseShortClassName(boolean useShortClassName) {\n        this.useShortClassName = useShortClassName;\n    }\n\n    /**\n     * <p>Sets whether to output short or long class names.</p>\n     *\n     * @param shortClassName  the new shortClassName flag\n     * @deprecated Use {@link #setUseShortClassName(boolean)}\n     *             Method will be removed in Commons Lang 3.0.\n     */\n    protected void setShortClassName(boolean shortClassName) {\n        this.useShortClassName = shortClassName;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets whether to use the identity hash code.</p>\n     *\n     * @return the current useIdentityHashCode flag\n     */\n    protected boolean isUseIdentityHashCode() {\n        return useIdentityHashCode;\n    }\n\n    /**\n     * <p>Sets whether to use the identity hash code.</p>\n     *\n     * @param useIdentityHashCode  the new useIdentityHashCode flag\n     */\n    protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\n        this.useIdentityHashCode = useIdentityHashCode;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets whether to use the field names passed in.</p>\n     *\n     * @return the current useFieldNames flag\n     */\n    protected boolean isUseFieldNames() {\n        return useFieldNames;\n    }\n\n    /**\n     * <p>Sets whether to use the field names passed in.</p>\n     *\n     * @param useFieldNames  the new useFieldNames flag\n     */\n    protected void setUseFieldNames(boolean useFieldNames) {\n        this.useFieldNames = useFieldNames;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets whether to use full detail when the caller doesn't\n     * specify.</p>\n     *\n     * @return the current defaultFullDetail flag\n     */\n    protected boolean isDefaultFullDetail() {\n        return defaultFullDetail;\n    }\n\n    /**\n     * <p>Sets whether to use full detail when the caller doesn't\n     * specify.</p>\n     *\n     * @param defaultFullDetail  the new defaultFullDetail flag\n     */\n    protected void setDefaultFullDetail(boolean defaultFullDetail) {\n        this.defaultFullDetail = defaultFullDetail;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets whether to output array content detail.</p>\n     *\n     * @return the current array content detail setting\n     */\n    protected boolean isArrayContentDetail() {\n        return arrayContentDetail;\n    }\n\n    /**\n     * <p>Sets whether to output array content detail.</p>\n     *\n     * @param arrayContentDetail  the new arrayContentDetail flag\n     */\n    protected void setArrayContentDetail(boolean arrayContentDetail) {\n        this.arrayContentDetail = arrayContentDetail;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets the array start text.</p>\n     *\n     * @return the current array start text\n     */\n    protected String getArrayStart() {\n        return arrayStart;\n    }\n\n    /**\n     * <p>Sets the array start text.</p>\n     *\n     * <p><code>null</code> is accepted, but will be converted to\n     * an empty String.</p>\n     *\n     * @param arrayStart  the new array start text\n     */\n    protected void setArrayStart(String arrayStart) {\n        if (arrayStart == null) {\n            arrayStart = \"\";\n        }\n        this.arrayStart = arrayStart;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets the array end text.</p>\n     *\n     * @return the current array end text\n     */\n    protected String getArrayEnd() {\n        return arrayEnd;\n    }\n\n    /**\n     * <p>Sets the array end text.</p>\n     *\n     * <p><code>null</code> is accepted, but will be converted to\n     * an empty String.</p>\n     *\n     * @param arrayEnd  the new array end text\n     */\n    protected void setArrayEnd(String arrayEnd) {\n        if (arrayEnd == null) {\n            arrayEnd = \"\";\n        }\n        this.arrayEnd = arrayEnd;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets the array separator text.</p>\n     *\n     * @return the current array separator text\n     */\n    protected String getArraySeparator() {\n        return arraySeparator;\n    }\n\n    /**\n     * <p>Sets the array separator text.</p>\n     *\n     * <p><code>null</code> is accepted, but will be converted to\n     * an empty String.</p>\n     *\n     * @param arraySeparator  the new array separator text\n     */\n    protected void setArraySeparator(String arraySeparator) {\n        if (arraySeparator == null) {\n            arraySeparator = \"\";\n        }\n        this.arraySeparator = arraySeparator;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets the content start text.</p>\n     *\n     * @return the current content start text\n     */\n    protected String getContentStart() {\n        return contentStart;\n    }\n\n    /**\n     * <p>Sets the content start text.</p>\n     *\n     * <p><code>null</code> is accepted, but will be converted to\n     * an empty String.</p>\n     *\n     * @param contentStart  the new content start text\n     */\n    protected void setContentStart(String contentStart) {\n        if (contentStart == null) {\n            contentStart = \"\";\n        }\n        this.contentStart = contentStart;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets the content end text.</p>\n     *\n     * @return the current content end text\n     */\n    protected String getContentEnd() {\n        return contentEnd;\n    }\n\n    /**\n     * <p>Sets the content end text.</p>\n     *\n     * <p><code>null</code> is accepted, but will be converted to\n     * an empty String.</p>\n     *\n     * @param contentEnd  the new content end text\n     */\n    protected void setContentEnd(String contentEnd) {\n        if (contentEnd == null) {\n            contentEnd = \"\";\n        }\n        this.contentEnd = contentEnd;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets the field name value separator text.</p>\n     *\n     * @return the current field name value separator text\n     */\n    protected String getFieldNameValueSeparator() {\n        return fieldNameValueSeparator;\n    }\n\n    /**\n     * <p>Sets the field name value separator text.</p>\n     *\n     * <p><code>null</code> is accepted, but will be converted to\n     * an empty String.</p>\n     *\n     * @param fieldNameValueSeparator  the new field name value separator text\n     */\n    protected void setFieldNameValueSeparator(String fieldNameValueSeparator) {\n        if (fieldNameValueSeparator == null) {\n            fieldNameValueSeparator = \"\";\n        }\n        this.fieldNameValueSeparator = fieldNameValueSeparator;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets the field separator text.</p>\n     *\n     * @return the current field separator text\n     */\n    protected String getFieldSeparator() {\n        return fieldSeparator;\n    }\n\n    /**\n     * <p>Sets the field separator text.</p>\n     *\n     * <p><code>null</code> is accepted, but will be converted to\n     * an empty String.</p>\n     *\n     * @param fieldSeparator  the new field separator text\n     */\n    protected void setFieldSeparator(String fieldSeparator) {\n        if (fieldSeparator == null) {\n            fieldSeparator = \"\";\n        }\n        this.fieldSeparator = fieldSeparator;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets whether the field separator should be added at the start\n     * of each buffer.</p>\n     *\n     * @return the fieldSeparatorAtStart flag\n     * @since 2.0\n     */\n    protected boolean isFieldSeparatorAtStart() {\n        return fieldSeparatorAtStart;\n    }\n\n    /**\n     * <p>Sets whether the field separator should be added at the start\n     * of each buffer.</p>\n     *\n     * @param fieldSeparatorAtStart  the fieldSeparatorAtStart flag\n     * @since 2.0\n     */\n    protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\n        this.fieldSeparatorAtStart = fieldSeparatorAtStart;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets whether the field separator should be added at the end\n     * of each buffer.</p>\n     *\n     * @return fieldSeparatorAtEnd flag\n     * @since 2.0\n     */\n    protected boolean isFieldSeparatorAtEnd() {\n        return fieldSeparatorAtEnd;\n    }\n\n    /**\n     * <p>Sets whether the field separator should be added at the end\n     * of each buffer.</p>\n     *\n     * @param fieldSeparatorAtEnd  the fieldSeparatorAtEnd flag\n     * @since 2.0\n     */\n    protected void setFieldSeparatorAtEnd(boolean fieldSeparatorAtEnd) {\n        this.fieldSeparatorAtEnd = fieldSeparatorAtEnd;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets the text to output when <code>null</code> found.</p>\n     *\n     * @return the current text to output when null found\n     */\n    protected String getNullText() {\n        return nullText;\n    }\n\n    /**\n     * <p>Sets the text to output when <code>null</code> found.</p>\n     *\n     * <p><code>null</code> is accepted, but will be converted to\n     * an empty String.</p>\n     *\n     * @param nullText  the new text to output when null found\n     */\n    protected void setNullText(String nullText) {\n        if (nullText == null) {\n            nullText = \"\";\n        }\n        this.nullText = nullText;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets the start text to output when a <code>Collection</code>,\n     * <code>Map</code> or array size is output.</p>\n     *\n     * <p>This is output before the size value.</p>\n     *\n     * @return the current start of size text\n     */\n    protected String getSizeStartText() {\n        return sizeStartText;\n    }\n\n    /**\n     * <p>Sets the start text to output when a <code>Collection</code>,\n     * <code>Map</code> or array size is output.</p>\n     *\n     * <p>This is output before the size value.</p>\n     *\n     * <p><code>null</code> is accepted, but will be converted to\n     * an empty String.</p>\n     *\n     * @param sizeStartText  the new start of size text\n     */\n    protected void setSizeStartText(String sizeStartText) {\n        if (sizeStartText == null) {\n            sizeStartText = \"\";\n        }\n        this.sizeStartText = sizeStartText;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets the end text to output when a <code>Collection</code>,\n     * <code>Map</code> or array size is output.</p>\n     *\n     * <p>This is output after the size value.</p>\n     *\n     * @return the current end of size text\n     */\n    protected String getSizeEndText() {\n        return sizeEndText;\n    }\n\n    /**\n     * <p>Sets the end text to output when a <code>Collection</code>,\n     * <code>Map</code> or array size is output.</p>\n     *\n     * <p>This is output after the size value.</p>\n     *\n     * <p><code>null</code> is accepted, but will be converted to\n     * an empty String.</p>\n     *\n     * @param sizeEndText  the new end of size text\n     */\n    protected void setSizeEndText(String sizeEndText) {\n        if (sizeEndText == null) {\n            sizeEndText = \"\";\n        }\n        this.sizeEndText = sizeEndText;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets the start text to output when an <code>Object</code> is\n     * output in summary mode.</p>\n     *\n     * <p>This is output before the size value.</p>\n     *\n     * @return the current start of summary text\n     */\n    protected String getSummaryObjectStartText() {\n        return summaryObjectStartText;\n    }\n\n    /**\n     * <p>Sets the start text to output when an <code>Object</code> is\n     * output in summary mode.</p>\n     *\n     * <p>This is output before the size value.</p>\n     *\n     * <p><code>null</code> is accepted, but will be converted to\n     * an empty String.</p>\n     *\n     * @param summaryObjectStartText  the new start of summary text\n     */\n    protected void setSummaryObjectStartText(String summaryObjectStartText) {\n        if (summaryObjectStartText == null) {\n            summaryObjectStartText = \"\";\n        }\n        this.summaryObjectStartText = summaryObjectStartText;\n    }\n    //---------------------------------------------------------------------\n\n    /**\n     * <p>Gets the end text to output when an <code>Object</code> is\n     * output in summary mode.</p>\n     *\n     * <p>This is output after the size value.</p>\n     *\n     * @return the current end of summary text\n     */\n    protected String getSummaryObjectEndText() {\n        return summaryObjectEndText;\n    }\n\n    /**\n     * <p>Sets the end text to output when an <code>Object</code> is\n     * output in summary mode.</p>\n     *\n     * <p>This is output after the size value.</p>\n     *\n     * <p><code>null</code> is accepted, but will be converted to\n     * an empty String.</p>\n     *\n     * @param summaryObjectEndText  the new end of summary text\n     */\n    protected void setSummaryObjectEndText(String summaryObjectEndText) {\n        if (summaryObjectEndText == null) {\n            summaryObjectEndText = \"\";\n        }\n        this.summaryObjectEndText = summaryObjectEndText;\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p>Default <code>ToStringStyle</code>.</p>\n     *\n     * <p>This is an inner class rather than using\n     * <code>StandardToStringStyle</code> to ensure its immutability.</p>\n     */\n    private static final class DefaultToStringStyle extends ToStringStyle {\n        /**\n         * Required for serialization support.\n         *\n         * @see java.io.Serializable\n         */\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * <p>Constructor.</p>\n         *\n         * <p>Use the static constant rather than instantiating.</p>\n         */\n        DefaultToStringStyle() {\n            super();\n        }\n\n        /**\n         * <p>Ensure <code>Singleton</code> after serialization.</p>\n         *\n         * @return the singleton\n         */\n        private Object readResolve() {\n            return ToStringStyle.DEFAULT_STYLE;\n        }\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p><code>ToStringStyle</code> that does not print out\n     * the field names.</p>\n     *\n     * <p>This is an inner class rather than using\n     * <code>StandardToStringStyle</code> to ensure its immutability.\n     */\n    private static final class NoFieldNameToStringStyle extends ToStringStyle {\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * <p>Constructor.</p>\n         *\n         * <p>Use the static constant rather than instantiating.</p>\n         */\n        NoFieldNameToStringStyle() {\n            super();\n            this.setUseFieldNames(false);\n        }\n\n        /**\n         * <p>Ensure <code>Singleton</code> after serialization.</p>\n         *\n         * @return the singleton\n         */\n        private Object readResolve() {\n            return ToStringStyle.NO_FIELD_NAMES_STYLE;\n        }\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p><code>ToStringStyle</code> that prints out the short\n     * class name and no identity hashcode.</p>\n     *\n     * <p>This is an inner class rather than using\n     * <code>StandardToStringStyle</code> to ensure its immutability.</p>\n     */\n    private static final class ShortPrefixToStringStyle extends ToStringStyle {\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * <p>Constructor.</p>\n         *\n         * <p>Use the static constant rather than instantiating.</p>\n         */\n        ShortPrefixToStringStyle() {\n            super();\n            this.setUseShortClassName(true);\n            this.setUseIdentityHashCode(false);\n        }\n\n        /**\n         * <p>Ensure <code>Singleton</ode> after serialization.</p>\n         * @return the singleton\n         */\n        private Object readResolve() {\n            return ToStringStyle.SHORT_PREFIX_STYLE;\n        }\n    }\n\n    /**\n     * <p><code>ToStringStyle</code> that does not print out the\n     * classname, identity hashcode, content start or field name.</p>\n     *\n     * <p>This is an inner class rather than using\n     * <code>StandardToStringStyle</code> to ensure its immutability.</p>\n     */\n    private static final class SimpleToStringStyle extends ToStringStyle {\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * <p>Constructor.</p>\n         *\n         * <p>Use the static constant rather than instantiating.</p>\n         */\n        SimpleToStringStyle() {\n            super();\n            this.setUseClassName(false);\n            this.setUseIdentityHashCode(false);\n            this.setUseFieldNames(false);\n            this.setContentStart(\"\");\n            this.setContentEnd(\"\");\n        }\n\n        /**\n         * <p>Ensure <code>Singleton</ode> after serialization.</p>\n         * @return the singleton\n         */\n        private Object readResolve() {\n            return ToStringStyle.SIMPLE_STYLE;\n        }\n    }\n    //----------------------------------------------------------------------------\n\n    /**\n     * <p><code>ToStringStyle</code> that outputs on multiple lines.</p>\n     *\n     * <p>This is an inner class rather than using\n     * <code>StandardToStringStyle</code> to ensure its immutability.</p>\n     */\n    private static final class MultiLineToStringStyle extends ToStringStyle {\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * <p>Constructor.</p>\n         *\n         * <p>Use the static constant rather than instantiating.</p>\n         */\n        MultiLineToStringStyle() {\n            super();\n            String separator = getSystemProperty(\"line.separator\");\n            this.setContentStart(\"[\");\n            this.setFieldSeparator(separator + \"  \");\n            this.setFieldSeparatorAtStart(true);\n            this.setContentEnd(separator + \"]\");\n        }\n\n        private String getSystemProperty(final String property) {\n            try {\n                return System.getProperty(property);\n            } catch (SecurityException ex) {\n                // we are not allowed to look at this property\n                System.err.println(\"Caught a SecurityException reading the system property '\" + property + \"'; the SystemUtils property value will default to null.\");\n                return null;\n            }\n        }\n\n        /**\n         * <p>Ensure <code>Singleton</code> after serialization.</p>\n         *\n         * @return the singleton\n         */\n        private Object readResolve() {\n            return ToStringStyle.MULTI_LINE_STYLE;\n        }\n    }\n}",
            "file_name": "ToStringStyle.java",
            "human_label": "Register the value in REGISTRY if the value is not null.",
            "level": "class_runnable",
            "lineno": "157",
            "name": "register",
            "oracle_context": "{ \"apis\" : \"[getRegistry, set, put]\", \"classes\" : \"[Map]\", \"vars\" : \"[REGISTRY]\" }",
            "package": "net.hasor.utils.builder",
            "project": "hasor-master"
        },
        {
            "_id": "6367670b1a6d9265ec0179f2",
            "all_context": "{ \"class_level\" : \"import java.util.*;\\nMap map;\\nboolean fast;\\nMap expected;\\nMap.Entry lastReturned;\\nIterator iterator;\\nWeakFastHashMap();\\nWeakFastHashMap(int capacity);\\nWeakFastHashMap(int capacity,float factor);\\nWeakFastHashMap(Map map);\\ngetFast();\\nsetFast(boolean fast);\\nget(Object key);\\nisEmpty();\\ncontainsKey(Object key);\\ncontainsValue(Object value);\\nput(Object key,Object value);\\nputAll(Map in);\\nremove(Object key);\\nclear();\\nequals(Object o);\\nhashCode();\\nclone();\\nentrySet();\\nkeySet();\\nvalues();\\ncreateMap();\\ncreateMap(int capacity);\\ncreateMap(int capacity,float factor);\\ncreateMap(Map map);\\ncloneMap(Map map);\\nCollectionView();\\nget(Map map);\\niteratorNext(Entry entry);\\nremove(Object o);\\nremoveAll(Collection o);\\nretainAll(Collection o);\\ncontains(Object o);\\ncontainsAll(Collection o);\\ntoArray(Object[] o);\\ntoArray();\\nadd(Object o);\\naddAll(Collection c);\\niterator();\\nCollectionViewIterator();\\nhasNext();\\nnext();\\nremove();\\nsize();\\n\", \"repo_level\" : \"\" }",
            "class_name": "WeakFastHashMap",
            "code": "@Override public boolean containsKey(final Object key){\n  if (this.fast) {\n    return this.map.containsKey(key);\n  }\n else {\nsynchronized (this.map) {\n      return this.map.containsKey(key);\n    }\n  }\n}\n",
            "docstring": "/** \n * Return <code>true</code> if this map contains a mapping for the specified key.\n * @param key  the key to be searched for\n * @return true if the map contains the key\n */\n",
            "end_lineno": "193",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.convert;\nimport java.util.*;\n\n/**\n * <p>A customized implementation of <code>java.util.HashMap</code> designed\n * to operate in a multithreaded environment where the large majority of\n * method calls are read-only, instead of structural changes.  When operating\n * in \"fast\" mode, read calls are non-synchronized and write calls perform the\n * following steps:</p>\n * <ul>\n * <li>Clone the existing collection\n * <li>Perform the modification on the clone\n * <li>Replace the existing collection with the (modified) clone\n * </ul>\n * <p>When first created, objects of this class default to \"slow\" mode, where\n * all accesses of any type are synchronized but no cloning takes place.  This\n * is appropriate for initially populating the collection, followed by a switch\n * to \"fast\" mode (by calling <code>setFast(true)</code>) after initialization\n * is complete.</p>\n *\n * <p><strong>NOTE</strong>: If you are creating and accessing a\n * <code>HashMap</code> only within a single thread, you should use\n * <code>java.util.HashMap</code> directly (with no synchronization), for\n * maximum performance.</p>\n *\n * <p><strong>NOTE</strong>: <i>This class is not cross-platform.  \n * Using it may cause unexpected failures on some architectures.</i>\n * It suffers from the same problems as the double-checked locking idiom.  \n * In particular, the instruction that clones the internal collection and the \n * instruction that sets the internal reference to the clone can be executed \n * or perceived out-of-order.  This means that any read operation might fail \n * unexpectedly, as it may be reading the state of the internal collection\n * before the internal collection is fully formed.\n * For more information on the double-checked locking idiom, see the\n * <a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html\">\n * Double-Checked Locking Idiom Is Broken Declaration</a>.</p>\n *\n * @since Commons Collections 1.0\n * @version $Revision: 687089 $ $Date: 2008-08-19 17:33:30 +0100 (Tue, 19 Aug 2008) $\n *\n * @author Craig R. McClanahan\n * @author Stephen Colebourne\n */\n@SuppressWarnings({ \"rawtypes\", \"serial\", \"unchecked\" })\nclass WeakFastHashMap extends HashMap {\n    /** The underlying map we are managing. */\n    private Map     map  = null;\n    /** Are we currently operating in \"fast\" mode? */\n    private boolean fast = false;\n    // Constructors\n    // ----------------------------------------------------------------------\n\n    /** Construct an empty map. */\n    public WeakFastHashMap() {\n        super();\n        this.map = this.createMap();\n    }\n\n    /**\n     * Construct an empty map with the specified capacity.\n     * @param capacity  the initial capacity of the empty map\n     */\n    public WeakFastHashMap(final int capacity) {\n        super();\n        this.map = this.createMap(capacity);\n    }\n\n    /**\n     * Construct an empty map with the specified capacity and load factor.\n     * @param capacity  the initial capacity of the empty map\n     * @param factor  the load factor of the new map\n     */\n    public WeakFastHashMap(final int capacity, final float factor) {\n        super();\n        this.map = this.createMap(capacity, factor);\n    }\n\n    /**\n     * Construct a new map with the same mappings as the specified map.\n     * @param map  the map whose mappings are to be copied\n     */\n    public WeakFastHashMap(final Map map) {\n        super();\n        this.map = this.createMap(map);\n    }\n    // Property access\n    // ----------------------------------------------------------------------\n\n    /**\n     *  Returns true if this map is operating in fast mode.\n     *  @return true if this map is operating in fast mode\n     */\n    public boolean getFast() {\n        return this.fast;\n    }\n\n    /**\n     *  Sets whether this map is operating in fast mode.\n     *  @param fast true if this map should operate in fast mode\n     */\n    public void setFast(final boolean fast) {\n        this.fast = fast;\n    }\n    // Map access\n    // ----------------------------------------------------------------------\n    // These methods can forward straight to the wrapped Map in 'fast' mode.\n    // (because they are query methods)\n\n    /**\n     * Return the value to which this map maps the specified key.  Returns\n     * <code>null</code> if the map contains no mapping for this key, or if\n     * there is a mapping with a value of <code>null</code>.  Use the\n     * <code>containsKey()</code> method to disambiguate these cases.\n     *\n     * @param key  the key whose value is to be returned\n     * @return the value mapped to that key, or null\n     */\n    @Override\n    public Object get(final Object key) {\n        if (this.fast) {\n            return this.map.get(key);\n        } else {\n            synchronized (this.map) {\n                return this.map.get(key);\n            }\n        }\n    }\n\n    /**\n     * Return the number of key-value mappings in this map.\n     *\n     * @return the current size of the map\n     */\n    @Override\n    public int size() {\n        if (this.fast) {\n            return this.map.size();\n        } else {\n            synchronized (this.map) {\n                return this.map.size();\n            }\n        }\n    }\n\n    /**\n     * Return <code>true</code> if this map contains no mappings.\n     *\n     * @return is the map currently empty\n     */\n    @Override\n    public boolean isEmpty() {\n        if (this.fast) {\n            return this.map.isEmpty();\n        } else {\n            synchronized (this.map) {\n                return this.map.isEmpty();\n            }\n        }\n    }\n\n    /**\n     * Return <code>true</code> if this map contains a mapping for the\n     * specified key.\n     *\n     * @param key  the key to be searched for\n     * @return true if the map contains the key\n     */\n    @Override\n    public boolean containsKey(final Object key) {\n        if (this.fast) {\n            return this.map.containsKey(key);\n        } else {\n            synchronized (this.map) {\n                return this.map.containsKey(key);\n            }\n        }\n    }\n\n    /**\n     * Return <code>true</code> if this map contains one or more keys mapping\n     * to the specified value.\n     *\n     * @param value  the value to be searched for\n     * @return true if the map contains the value\n     */\n    @Override\n    public boolean containsValue(final Object value) {\n        if (this.fast) {\n            return this.map.containsValue(value);\n        } else {\n            synchronized (this.map) {\n                return this.map.containsValue(value);\n            }\n        }\n    }\n    // Map modification\n    // ----------------------------------------------------------------------\n    // These methods perform special behaviour in 'fast' mode.\n    // The map is cloned, updated and then assigned back.\n    // See the comments at the top as to why this won't always work.\n\n    /**\n     * Associate the specified value with the specified key in this map.\n     * If the map previously contained a mapping for this key, the old\n     * value is replaced and returned.\n     *\n     * @param key  the key with which the value is to be associated\n     * @param value  the value to be associated with this key\n     * @return the value previously mapped to the key, or null\n     */\n    @Override\n    public Object put(final Object key, final Object value) {\n        if (this.fast) {\n            synchronized (this) {\n                Map temp = this.cloneMap(this.map);\n                Object result = temp.put(key, value);\n                this.map = temp;\n                return result;\n            }\n        } else {\n            synchronized (this.map) {\n                return this.map.put(key, value);\n            }\n        }\n    }\n\n    /**\n     * Copy all of the mappings from the specified map to this one, replacing\n     * any mappings with the same keys.\n     *\n     * @param in  the map whose mappings are to be copied\n     */\n    @Override\n    public void putAll(final Map in) {\n        if (this.fast) {\n            synchronized (this) {\n                Map temp = this.cloneMap(this.map);\n                temp.putAll(in);\n                this.map = temp;\n            }\n        } else {\n            synchronized (this.map) {\n                this.map.putAll(in);\n            }\n        }\n    }\n\n    /**\n     * Remove any mapping for this key, and return any previously\n     * mapped value.\n     *\n     * @param key  the key whose mapping is to be removed\n     * @return the value removed, or null\n     */\n    @Override\n    public Object remove(final Object key) {\n        if (this.fast) {\n            synchronized (this) {\n                Map temp = this.cloneMap(this.map);\n                Object result = temp.remove(key);\n                this.map = temp;\n                return result;\n            }\n        } else {\n            synchronized (this.map) {\n                return this.map.remove(key);\n            }\n        }\n    }\n\n    /**\n     * Remove all mappings from this map.\n     */\n    @Override\n    public void clear() {\n        if (this.fast) {\n            synchronized (this) {\n                this.map = this.createMap();\n            }\n        } else {\n            synchronized (this.map) {\n                this.map.clear();\n            }\n        }\n    }\n    // Basic object methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * Compare the specified object with this list for equality.  This\n     * implementation uses exactly the code that is used to define the\n     * list equals function in the documentation for the\n     * <code>Map.equals</code> method.\n     *\n     * @param o  the object to be compared to this list\n     * @return true if the two maps are equal\n     */\n    @Override\n    public boolean equals(final Object o) {\n        // Simple tests that require no synchronization\n        if (o == this) {\n            return true;\n        } else if (!(o instanceof Map)) {\n            return false;\n        }\n        Map mo = (Map) o;\n        // Compare the two maps for equality\n        if (this.fast) {\n            if (mo.size() != this.map.size()) {\n                return false;\n            }\n            Iterator i = this.map.entrySet().iterator();\n            while (i.hasNext()) {\n                Map.Entry e = (Map.Entry) i.next();\n                Object key = e.getKey();\n                Object value = e.getValue();\n                if (value == null) {\n                    if (!(mo.get(key) == null && mo.containsKey(key))) {\n                        return false;\n                    }\n                } else {\n                    if (!value.equals(mo.get(key))) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        } else {\n            synchronized (this.map) {\n                if (mo.size() != this.map.size()) {\n                    return false;\n                }\n                Iterator i = this.map.entrySet().iterator();\n                while (i.hasNext()) {\n                    Map.Entry e = (Map.Entry) i.next();\n                    Object key = e.getKey();\n                    Object value = e.getValue();\n                    if (value == null) {\n                        if (!(mo.get(key) == null && mo.containsKey(key))) {\n                            return false;\n                        }\n                    } else {\n                        if (!value.equals(mo.get(key))) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n        }\n    }\n\n    /**\n     * Return the hash code value for this map.  This implementation uses\n     * exactly the code that is used to define the list hash function in the\n     * documentation for the <code>Map.hashCode</code> method.\n     *\n     * @return suitable integer hash code\n     */\n    @Override\n    public int hashCode() {\n        if (this.fast) {\n            int h = 0;\n            Iterator i = this.map.entrySet().iterator();\n            while (i.hasNext()) {\n                h += i.next().hashCode();\n            }\n            return h;\n        } else {\n            synchronized (this.map) {\n                int h = 0;\n                Iterator i = this.map.entrySet().iterator();\n                while (i.hasNext()) {\n                    h += i.next().hashCode();\n                }\n                return h;\n            }\n        }\n    }\n\n    /**\n     * Return a shallow copy of this <code>FastHashMap</code> instance.\n     * The keys and values themselves are not copied.\n     *\n     * @return a clone of this map\n     */\n    @Override\n    public Object clone() {\n        WeakFastHashMap results = null;\n        if (this.fast) {\n            results = new WeakFastHashMap(this.map);\n        } else {\n            synchronized (this.map) {\n                results = new WeakFastHashMap(this.map);\n            }\n        }\n        results.setFast(this.getFast());\n        return results;\n    }\n    // Map views\n    // ----------------------------------------------------------------------\n\n    /**\n     * Return a collection view of the mappings contained in this map.  Each\n     * element in the returned collection is a <code>Map.Entry</code>.\n     * @return the set of map Map entries\n     */\n    @Override\n    public Set entrySet() {\n        return new EntrySet();\n    }\n\n    /**\n     * Return a set view of the keys contained in this map.\n     * @return the set of the Map's keys\n     */\n    @Override\n    public Set keySet() {\n        return new KeySet();\n    }\n\n    /**\n     * Return a collection view of the values contained in this map.\n     * @return the set of the Map's values\n     */\n    @Override\n    public Collection values() {\n        return new Values();\n    }\n\n    // Abstractions on Map creations (for subclasses such as WeakFastHashMap)\n    // ----------------------------------------------------------------------\n    protected Map createMap() {\n        return new WeakHashMap();\n    }\n\n    protected Map createMap(final int capacity) {\n        return new WeakHashMap(capacity);\n    }\n\n    protected Map createMap(final int capacity, final float factor) {\n        return new WeakHashMap(capacity, factor);\n    }\n\n    protected Map createMap(final Map map) {\n        return new WeakHashMap(map);\n    }\n\n    protected Map cloneMap(final Map map) {\n        return this.createMap(map);\n    }\n    // Map view inner classes\n    // ----------------------------------------------------------------------\n\n    /**\n     * Abstract collection implementation shared by keySet(), values() and entrySet().\n     */\n    private abstract class CollectionView implements Collection {\n        public CollectionView() {\n        }\n\n        protected abstract Collection get(Map map);\n\n        protected abstract Object iteratorNext(Map.Entry entry);\n\n        @Override\n        public void clear() {\n            if (WeakFastHashMap.this.fast) {\n                synchronized (WeakFastHashMap.this) {\n                    WeakFastHashMap.this.map = WeakFastHashMap.this.createMap();\n                }\n            } else {\n                synchronized (WeakFastHashMap.this.map) {\n                    this.get(WeakFastHashMap.this.map).clear();\n                }\n            }\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            if (WeakFastHashMap.this.fast) {\n                synchronized (WeakFastHashMap.this) {\n                    Map temp = WeakFastHashMap.this.cloneMap(WeakFastHashMap.this.map);\n                    boolean r = this.get(temp).remove(o);\n                    WeakFastHashMap.this.map = temp;\n                    return r;\n                }\n            } else {\n                synchronized (WeakFastHashMap.this.map) {\n                    return this.get(WeakFastHashMap.this.map).remove(o);\n                }\n            }\n        }\n\n        @Override\n        public boolean removeAll(final Collection o) {\n            if (WeakFastHashMap.this.fast) {\n                synchronized (WeakFastHashMap.this) {\n                    Map temp = WeakFastHashMap.this.cloneMap(WeakFastHashMap.this.map);\n                    boolean r = this.get(temp).removeAll(o);\n                    WeakFastHashMap.this.map = temp;\n                    return r;\n                }\n            } else {\n                synchronized (WeakFastHashMap.this.map) {\n                    return this.get(WeakFastHashMap.this.map).removeAll(o);\n                }\n            }\n        }\n\n        @Override\n        public boolean retainAll(final Collection o) {\n            if (WeakFastHashMap.this.fast) {\n                synchronized (WeakFastHashMap.this) {\n                    Map temp = WeakFastHashMap.this.cloneMap(WeakFastHashMap.this.map);\n                    boolean r = this.get(temp).retainAll(o);\n                    WeakFastHashMap.this.map = temp;\n                    return r;\n                }\n            } else {\n                synchronized (WeakFastHashMap.this.map) {\n                    return this.get(WeakFastHashMap.this.map).retainAll(o);\n                }\n            }\n        }\n\n        @Override\n        public int size() {\n            if (WeakFastHashMap.this.fast) {\n                return this.get(WeakFastHashMap.this.map).size();\n            } else {\n                synchronized (WeakFastHashMap.this.map) {\n                    return this.get(WeakFastHashMap.this.map).size();\n                }\n            }\n        }\n\n        @Override\n        public boolean isEmpty() {\n            if (WeakFastHashMap.this.fast) {\n                return this.get(WeakFastHashMap.this.map).isEmpty();\n            } else {\n                synchronized (WeakFastHashMap.this.map) {\n                    return this.get(WeakFastHashMap.this.map).isEmpty();\n                }\n            }\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            if (WeakFastHashMap.this.fast) {\n                return this.get(WeakFastHashMap.this.map).contains(o);\n            } else {\n                synchronized (WeakFastHashMap.this.map) {\n                    return this.get(WeakFastHashMap.this.map).contains(o);\n                }\n            }\n        }\n\n        @Override\n        public boolean containsAll(final Collection o) {\n            if (WeakFastHashMap.this.fast) {\n                return this.get(WeakFastHashMap.this.map).containsAll(o);\n            } else {\n                synchronized (WeakFastHashMap.this.map) {\n                    return this.get(WeakFastHashMap.this.map).containsAll(o);\n                }\n            }\n        }\n\n        @Override\n        public Object[] toArray(final Object[] o) {\n            if (WeakFastHashMap.this.fast) {\n                return this.get(WeakFastHashMap.this.map).toArray(o);\n            } else {\n                synchronized (WeakFastHashMap.this.map) {\n                    return this.get(WeakFastHashMap.this.map).toArray(o);\n                }\n            }\n        }\n\n        @Override\n        public Object[] toArray() {\n            if (WeakFastHashMap.this.fast) {\n                return this.get(WeakFastHashMap.this.map).toArray();\n            } else {\n                synchronized (WeakFastHashMap.this.map) {\n                    return this.get(WeakFastHashMap.this.map).toArray();\n                }\n            }\n        }\n\n        @Override\n        public boolean equals(final Object o) {\n            if (o.equals(this)) {\n                return true;\n            }\n            if (WeakFastHashMap.this.fast) {\n                return this.get(WeakFastHashMap.this.map).equals(o);\n            } else {\n                synchronized (WeakFastHashMap.this.map) {\n                    return this.get(WeakFastHashMap.this.map).equals(o);\n                }\n            }\n        }\n\n        @Override\n        public int hashCode() {\n            if (WeakFastHashMap.this.fast) {\n                return this.get(WeakFastHashMap.this.map).hashCode();\n            } else {\n                synchronized (WeakFastHashMap.this.map) {\n                    return this.get(WeakFastHashMap.this.map).hashCode();\n                }\n            }\n        }\n\n        @Override\n        public boolean add(final Object o) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean addAll(final Collection c) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public Iterator iterator() {\n            return new CollectionViewIterator();\n        }\n\n        private class CollectionViewIterator implements Iterator {\n            private Map       expected;\n            private Map.Entry lastReturned = null;\n            private Iterator  iterator;\n\n            public CollectionViewIterator() {\n                this.expected = WeakFastHashMap.this.map;\n                this.iterator = this.expected.entrySet().iterator();\n            }\n\n            @Override\n            public boolean hasNext() {\n                if (this.expected != WeakFastHashMap.this.map) {\n                    throw new ConcurrentModificationException();\n                }\n                return this.iterator.hasNext();\n            }\n\n            @Override\n            public Object next() {\n                if (this.expected != WeakFastHashMap.this.map) {\n                    throw new ConcurrentModificationException();\n                }\n                this.lastReturned = (Map.Entry) this.iterator.next();\n                return CollectionView.this.iteratorNext(this.lastReturned);\n            }\n\n            @Override\n            public void remove() {\n                if (this.lastReturned == null) {\n                    throw new IllegalStateException();\n                }\n                if (WeakFastHashMap.this.fast) {\n                    synchronized (WeakFastHashMap.this) {\n                        if (this.expected != WeakFastHashMap.this.map) {\n                            throw new ConcurrentModificationException();\n                        }\n                        WeakFastHashMap.this.remove(this.lastReturned.getKey());\n                        this.lastReturned = null;\n                        this.expected = WeakFastHashMap.this.map;\n                    }\n                } else {\n                    this.iterator.remove();\n                    this.lastReturned = null;\n                }\n            }\n        }\n    }\n\n    /**\n     * Set implementation over the keys of the FastHashMap\n     */\n    private class KeySet extends CollectionView implements Set {\n        @Override\n        protected Collection get(final Map map) {\n            return map.keySet();\n        }\n\n        @Override\n        protected Object iteratorNext(final Map.Entry entry) {\n            return entry.getKey();\n        }\n    }\n\n    /**\n     * Collection implementation over the values of the FastHashMap\n     */\n    private class Values extends CollectionView {\n        @Override\n        protected Collection get(final Map map) {\n            return map.values();\n        }\n\n        @Override\n        protected Object iteratorNext(final Map.Entry entry) {\n            return entry.getValue();\n        }\n    }\n\n    /**\n     * Set implementation over the entries of the FastHashMap\n     */\n    private class EntrySet extends CollectionView implements Set {\n        @Override\n        protected Collection get(final Map map) {\n            return map.entrySet();\n        }\n\n        @Override\n        protected Object iteratorNext(final Map.Entry entry) {\n            return entry;\n        }\n    }\n}",
            "file_name": "WeakFastHashMap.java",
            "human_label": "Check whether a map contains a mapping for the specified key.",
            "level": "class_runnable",
            "lineno": "177",
            "name": "containsKey",
            "oracle_context": "{ \"apis\" : \"[]\", \"classes\" : \"[]\", \"vars\" : \"[fast, map]\" }",
            "package": "net.hasor.utils.convert",
            "project": "hasor-master"
        },
        {
            "_id": "636767561a6d9265ec017f7c",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.*;\\nimport org.jgrapht.alg.interfaces.*;\\nimport org.jgrapht.graph.*;\\nimport org.jgrapht.traverse.*;\\nimport java.util.*;\\nclosedVertexListToTour(List tour,Graph graph);\\nedgeSetToTour(Set tour,Graph graph);\\ngetSingletonTour(Graph graph);\\ncheckGraph(Graph graph);\\nrequireNotEmpty(Graph graph);\\nvertexListToTour(List tour,Graph graph);\\n\", \"repo_level\" : \"\" }",
            "class_name": "HamiltonianCycleAlgorithmBase",
            "code": "protected GraphPath<V,E> edgeSetToTour(Set<E> tour,Graph<V,E> graph){\n  List<V> vertices=new ArrayList<>(tour.size() + 1);\n  MaskSubgraph<V,E> tourGraph=new MaskSubgraph<>(graph,v -> false,e -> !tour.contains(e));\n  new DepthFirstIterator<>(tourGraph).forEachRemaining(vertices::add);\n  return vertexListToTour(vertices,graph);\n}\n",
            "docstring": "/** \n * Transform from a Set representation to a graph path.\n * @param tour a set containing the edges of the tour\n * @param graph the graph\n * @return a graph path\n */\n",
            "end_lineno": "98",
            "file_content": "/*\n * (C) Copyright 2019-2021, by Peter Harman and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.alg.tour;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.interfaces.*;\nimport org.jgrapht.graph.*;\nimport org.jgrapht.traverse.*;\n\nimport java.util.*;\n\n/**\n * Base class for TSP solver algorithms.\n *\n * <p>\n * This class provides implementations of utilities for TSP solver classes.\n * </p>\n *\n * @param <V> the graph vertex type\n * @param <E> the graph edge type\n *\n * @author Peter Harman\n * @author Hannes Wellmann\n */\npublic abstract class HamiltonianCycleAlgorithmBase<V, E>\n    implements\n    HamiltonianCycleAlgorithm<V, E>\n{\n\n    /**\n     * Transform from a List representation to a graph path.\n     *\n     * @param tour a list containing the vertices of the tour (is modified)\n     * @param graph the graph\n     * @return a graph path\n     */\n    protected GraphPath<V, E> vertexListToTour(List<V> tour, Graph<V, E> graph)\n    {\n        tour.add(tour.get(0));\n        return closedVertexListToTour(tour, graph);\n    }\n\n    /**\n     * Transform from a closed List representation (first and last vertex element are the same) to a\n     * graph path.\n     *\n     * @param tour a closed list containing the vertices of the tour\n     * @param graph the graph\n     * @return a graph path\n     */\n    protected GraphPath<V, E> closedVertexListToTour(List<V> tour, Graph<V, E> graph)\n    {\n        assert tour.get(0) == tour.get(tour.size() - 1);\n\n        List<E> edges = new ArrayList<>(tour.size() - 1);\n        double tourWeight = 0d;\n        V u = tour.get(0);\n        for (V v : tour.subList(1, tour.size())) {\n            E e = graph.getEdge(u, v);\n            edges.add(e);\n            tourWeight += graph.getEdgeWeight(e);\n            u = v;\n        }\n        return new GraphWalk<>(graph, tour.get(0), tour.get(0), tour, edges, tourWeight);\n    }\n\n    /**\n     * Transform from a Set representation to a graph path.\n     *\n     * @param tour a set containing the edges of the tour\n     * @param graph the graph\n     * @return a graph path\n     */\n    protected GraphPath<V, E> edgeSetToTour(Set<E> tour, Graph<V, E> graph)\n    {\n        List<V> vertices = new ArrayList<>(tour.size() + 1);\n\n        MaskSubgraph<V, E> tourGraph =\n            new MaskSubgraph<>(graph, v -> false, e -> !tour.contains(e));\n        new DepthFirstIterator<>(tourGraph).forEachRemaining(vertices::add);\n\n        return vertexListToTour(vertices, graph);\n    }\n\n    /**\n     * Creates a tour for a graph with 1 vertex\n     *\n     * @param graph The graph\n     * @return A tour with a single vertex\n     */\n    protected GraphPath<V, E> getSingletonTour(Graph<V, E> graph)\n    {\n        assert graph.vertexSet().size() == 1;\n        V start = graph.vertexSet().iterator().next();\n        return new GraphWalk<>(\n            graph, start, start, Collections.singletonList(start), Collections.emptyList(), 0d);\n    }\n\n    /**\n     * Checks that graph is undirected, complete, and non-empty\n     *\n     * @param graph the graph\n     * @throws IllegalArgumentException if graph is not undirected\n     * @throws IllegalArgumentException if graph is not complete\n     * @throws IllegalArgumentException if graph contains no vertices\n     */\n    protected void checkGraph(Graph<V, E> graph)\n    {\n        GraphTests.requireUndirected(graph);\n\n        requireNotEmpty(graph);\n\n        if (!GraphTests.isComplete(graph)) {\n            throw new IllegalArgumentException(\"Graph is not complete\");\n        }\n    }\n\n    /**\n     * Checks that graph is not empty\n     *\n     * @param graph the graph\n     * @throws IllegalArgumentException if graph contains no vertices\n     */\n    protected void requireNotEmpty(Graph<V, E> graph)\n    {\n        if (graph.vertexSet().isEmpty()) {\n            throw new IllegalArgumentException(\"Graph contains no vertices\");\n        }\n    }\n}\n",
            "file_name": "HamiltonianCycleAlgorithmBase.java",
            "human_label": "Convert a set representation to a graph path.",
            "level": "class_runnable",
            "lineno": "82",
            "name": "edgeSetToTour",
            "oracle_context": "{ \"apis\" : \"[size, contains, forEachRemaining, vertexListToTour]\", \"classes\" : \"[List<V>, MaskSubgraph<V,E>]\", \"vars\" : \"[]\" }",
            "package": "org.jgrapht.alg.tour",
            "project": "jgrapht-master"
        },
        {
            "_id": "636766fe1a6d9265ec017823",
            "all_context": "{ \"class_level\" : \"ClassWriter classWriter;\\nClassReader sourceClassReader;\\nint majorVersion;\\nString className;\\nint entryCount;\\nEntry[] entries;\\nint constantPoolCount;\\nByteVector constantPool;\\nint bootstrapMethodCount;\\nByteVector bootstrapMethods;\\nint typeCount;\\nEntry[] typeTable;\\nint hashCode;\\nEntry next;\\nSymbolTable(ClassWriter classWriter);\\nSymbolTable(ClassWriter classWriter,ClassReader classReader);\\ngetSource();\\ngetMajorVersion();\\ngetClassName();\\nsetMajorVersionAndClassName(int majorVersion,String className);\\ngetConstantPoolCount();\\ngetConstantPoolLength();\\nputConstantPool(ByteVector output);\\ncomputeBootstrapMethodsSize();\\nputBootstrapMethods(ByteVector output);\\nget(int hashCode);\\nput(Entry entry);\\nadd(Entry entry);\\naddConstant(Object value);\\naddConstantClass(String value);\\naddConstantFieldref(String owner,String name,String descriptor);\\naddConstantMethodref(String owner,String name,String descriptor,boolean isInterface);\\naddConstantMemberReference(int tag,String owner,String name,String descriptor);\\naddConstantMemberReference(int index,int tag,String owner,String name,String descriptor);\\naddConstantString(String value);\\naddConstantInteger(int value);\\naddConstantFloat(float value);\\naddConstantIntegerOrFloat(int tag,int value);\\naddConstantIntegerOrFloat(int index,int tag,int value);\\naddConstantLong(long value);\\naddConstantDouble(double value);\\naddConstantLongOrDouble(int tag,long value);\\naddConstantLongOrDouble(int index,int tag,long value);\\naddConstantNameAndType(String name,String descriptor);\\naddConstantNameAndType(int index,String name,String descriptor);\\naddConstantUtf8(String value);\\naddConstantUtf8(int index,String value);\\naddConstantMethodHandle(int referenceKind,String owner,String name,String descriptor,boolean isInterface);\\naddConstantMethodHandle(int index,int referenceKind,String owner,String name,String descriptor);\\naddConstantMethodType(String methodDescriptor);\\naddConstantDynamic(String name,String descriptor,Handle bootstrapMethodHandle,Object bootstrapMethodArguments);\\naddConstantInvokeDynamic(String name,String descriptor,Handle bootstrapMethodHandle,Object bootstrapMethodArguments);\\naddConstantDynamicOrInvokeDynamicReference(int tag,String name,String descriptor,int bootstrapMethodIndex);\\naddConstantDynamicOrInvokeDynamicReference(int tag,int index,String name,String descriptor,int bootstrapMethodIndex);\\naddConstantModule(String moduleName);\\naddConstantPackage(String packageName);\\naddConstantUtf8Reference(int tag,String value);\\naddConstantUtf8Reference(int index,int tag,String value);\\naddBootstrapMethod(Handle bootstrapMethodHandle,Object bootstrapMethodArguments);\\naddBootstrapMethod(int offset,int length,int hashCode);\\ngetType(int typeIndex);\\naddType(String value);\\naddUninitializedType(String value,int bytecodeOffset);\\naddMergedType(int typeTableIndex1,int typeTableIndex2);\\naddTypeInternal(Entry entry);\\nhash(int tag,int value);\\nhash(int tag,long value);\\nhash(int tag,String value);\\nhash(int tag,String value1,int value2);\\nhash(int tag,String value1,String value2);\\nhash(int tag,String value1,String value2,int value3);\\nhash(int tag,String value1,String value2,String value3);\\nhash(int tag,String value1,String value2,String value3,int value4);\\nEntry(int index,int tag,String owner,String name,String value,long data,int hashCode);\\nEntry(int index,int tag,String value,int hashCode);\\nEntry(int index,int tag,String value,long data,int hashCode);\\nEntry(int index,int tag,String name,String value,int hashCode);\\nEntry(int index,int tag,long data,int hashCode);\\ncopyBootstrapMethods(ClassReader classReader,char[] charBuffer);\\n\", \"repo_level\" : \"\" }",
            "class_name": "SymbolTable",
            "code": "int addConstantNameAndType(final String name,final String descriptor){\n  final int tag=Symbol.CONSTANT_NAME_AND_TYPE_TAG;\n  int hashCode=hash(tag,name,descriptor);\n  Entry entry=get(hashCode);\n  while (entry != null) {\n    if (entry.tag == tag && entry.hashCode == hashCode && entry.name.equals(name) && entry.value.equals(descriptor)) {\n      return entry.index;\n    }\n    entry=entry.next;\n  }\n  constantPool.put122(tag,addConstantUtf8(name),addConstantUtf8(descriptor));\n  return put(new Entry(constantPoolCount++,tag,name,descriptor,hashCode)).index;\n}\n",
            "docstring": "/** \n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar item.\n * @param name a field or method name.\n * @param descriptor a field or method descriptor.\n * @return a new or already existing Symbol with the given value.\n */\n",
            "end_lineno": "669",
            "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage net.hasor.utils.asm;\n/**\n * The constant pool entries, the BootstrapMethods attribute entries and the (ASM specific) type\n * table entries of a class.\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4\">JVMS 4.4</a>\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23\">JVMS 4.7.23</a>\n * @author Eric Bruneton\n */\nfinal class SymbolTable {\n    /**\n     * The ClassWriter to which this SymbolTable belongs. This is only used to get access to {@link\n     * ClassWriter#getCommonSuperClass} and to serialize custom attributes with {@link\n     * Attribute#write}.\n     */\n    final         ClassWriter classWriter;\n    /**\n     * The ClassReader from which this SymbolTable was constructed, or {@literal null} if it was\n     * constructed from scratch.\n     */\n    private final ClassReader sourceClassReader;\n    /** The major version number of the class to which this symbol table belongs. */\n    private       int         majorVersion;\n    /** The internal name of the class to which this symbol table belongs. */\n    private       String      className;\n    /**\n     * The total number of {@link Entry} instances in {@link #entries}. This includes entries that are\n     * accessible (recursively) via {@link Entry#next}.\n     */\n    private       int         entryCount;\n    /**\n     * A hash set of all the entries in this SymbolTable (this includes the constant pool entries, the\n     * bootstrap method entries and the type table entries). Each {@link Entry} instance is stored at\n     * the array index given by its hash code modulo the array size. If several entries must be stored\n     * at the same array index, they are linked together via their {@link Entry#next} field. The\n     * factory methods of this class make sure that this table does not contain duplicated entries.\n     */\n    private       Entry[]     entries;\n    /**\n     * The number of constant pool items in {@link #constantPool}, plus 1. The first constant pool\n     * item has index 1, and long and double items count for two items.\n     */\n    private       int         constantPoolCount;\n    /**\n     * The content of the ClassFile's constant_pool JVMS structure corresponding to this SymbolTable.\n     * The ClassFile's constant_pool_count field is <i>not</i> included.\n     */\n    private       ByteVector  constantPool;\n    /**\n     * The number of bootstrap methods in {@link #bootstrapMethods}. Corresponds to the\n     * BootstrapMethods_attribute's num_bootstrap_methods field value.\n     */\n    private       int         bootstrapMethodCount;\n    /**\n     * The content of the BootstrapMethods attribute 'bootstrap_methods' array corresponding to this\n     * SymbolTable. Note that the first 6 bytes of the BootstrapMethods_attribute, and its\n     * num_bootstrap_methods field, are <i>not</i> included.\n     */\n    private       ByteVector  bootstrapMethods;\n    /**\n     * The actual number of elements in {@link #typeTable}. These elements are stored from index 0 to\n     * typeCount (excluded). The other array entries are empty.\n     */\n    private       int         typeCount;\n    /**\n     * An ASM specific type table used to temporarily store internal names that will not necessarily\n     * be stored in the constant pool. This type table is used by the control flow and data flow\n     * analysis algorithm used to compute stack map frames from scratch. This array stores {@link\n     * Symbol#TYPE_TAG} and {@link Symbol#UNINITIALIZED_TYPE_TAG}) Symbol. The type symbol at index\n     * {@code i} has its {@link Symbol#index} equal to {@code i} (and vice versa).\n     */\n    private       Entry[]     typeTable;\n\n    /**\n     * Constructs a new, empty SymbolTable for the given ClassWriter.\n     *\n     * @param classWriter a ClassWriter.\n     */\n    SymbolTable(final ClassWriter classWriter) {\n        this.classWriter = classWriter;\n        this.sourceClassReader = null;\n        this.entries = new Entry[256];\n        this.constantPoolCount = 1;\n        this.constantPool = new ByteVector();\n    }\n\n    /**\n     * Constructs a new SymbolTable for the given ClassWriter, initialized with the constant pool and\n     * bootstrap methods of the given ClassReader.\n     *\n     * @param classWriter a ClassWriter.\n     * @param classReader the ClassReader whose constant pool and bootstrap methods must be copied to\n     *     initialize the SymbolTable.\n     */\n    SymbolTable(final ClassWriter classWriter, final ClassReader classReader) {\n        this.classWriter = classWriter;\n        this.sourceClassReader = classReader;\n        // Copy the constant pool binary content.\n        byte[] inputBytes = classReader.classFileBuffer;\n        int constantPoolOffset = classReader.getItem(1) - 1;\n        int constantPoolLength = classReader.header - constantPoolOffset;\n        constantPoolCount = classReader.getItemCount();\n        constantPool = new ByteVector(constantPoolLength);\n        constantPool.putByteArray(inputBytes, constantPoolOffset, constantPoolLength);\n        // Add the constant pool items in the symbol table entries. Reserve enough space in 'entries' to\n        // avoid too many hash set collisions (entries is not dynamically resized by the addConstant*\n        // method calls below), and to account for bootstrap method entries.\n        entries = new Entry[constantPoolCount * 2];\n        char[] charBuffer = new char[classReader.getMaxStringLength()];\n        boolean hasBootstrapMethods = false;\n        int itemIndex = 1;\n        while (itemIndex < constantPoolCount) {\n            int itemOffset = classReader.getItem(itemIndex);\n            int itemTag = inputBytes[itemOffset - 1];\n            int nameAndTypeItemOffset;\n            switch (itemTag) {\n            case Symbol.CONSTANT_FIELDREF_TAG:\n            case Symbol.CONSTANT_METHODREF_TAG:\n            case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n                nameAndTypeItemOffset = classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));\n                addConstantMemberReference(itemIndex, itemTag, classReader.readClass(itemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer));\n                break;\n            case Symbol.CONSTANT_INTEGER_TAG:\n            case Symbol.CONSTANT_FLOAT_TAG:\n                addConstantIntegerOrFloat(itemIndex, itemTag, classReader.readInt(itemOffset));\n                break;\n            case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n                addConstantNameAndType(itemIndex, classReader.readUTF8(itemOffset, charBuffer), classReader.readUTF8(itemOffset + 2, charBuffer));\n                break;\n            case Symbol.CONSTANT_LONG_TAG:\n            case Symbol.CONSTANT_DOUBLE_TAG:\n                addConstantLongOrDouble(itemIndex, itemTag, classReader.readLong(itemOffset));\n                break;\n            case Symbol.CONSTANT_UTF8_TAG:\n                addConstantUtf8(itemIndex, classReader.readUtf(itemIndex, charBuffer));\n                break;\n            case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n                int memberRefItemOffset = classReader.getItem(classReader.readUnsignedShort(itemOffset + 1));\n                nameAndTypeItemOffset = classReader.getItem(classReader.readUnsignedShort(memberRefItemOffset + 2));\n                addConstantMethodHandle(itemIndex, classReader.readByte(itemOffset), classReader.readClass(memberRefItemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer));\n                break;\n            case Symbol.CONSTANT_DYNAMIC_TAG:\n            case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n                hasBootstrapMethods = true;\n                nameAndTypeItemOffset = classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));\n                addConstantDynamicOrInvokeDynamicReference(itemTag, itemIndex, classReader.readUTF8(nameAndTypeItemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer), classReader.readUnsignedShort(itemOffset));\n                break;\n            case Symbol.CONSTANT_STRING_TAG:\n            case Symbol.CONSTANT_CLASS_TAG:\n            case Symbol.CONSTANT_METHOD_TYPE_TAG:\n            case Symbol.CONSTANT_MODULE_TAG:\n            case Symbol.CONSTANT_PACKAGE_TAG:\n                addConstantUtf8Reference(itemIndex, itemTag, classReader.readUTF8(itemOffset, charBuffer));\n                break;\n            default:\n                throw new IllegalArgumentException();\n            }\n            itemIndex += (itemTag == Symbol.CONSTANT_LONG_TAG || itemTag == Symbol.CONSTANT_DOUBLE_TAG) ? 2 : 1;\n        }\n        // Copy the BootstrapMethods, if any.\n        if (hasBootstrapMethods) {\n            copyBootstrapMethods(classReader, charBuffer);\n        }\n    }\n\n    /**\n     * Read the BootstrapMethods 'bootstrap_methods' array binary content and add them as entries of\n     * the SymbolTable.\n     *\n     * @param classReader the ClassReader whose bootstrap methods must be copied to initialize the\n     *     SymbolTable.\n     * @param charBuffer a buffer used to read strings in the constant pool.\n     */\n    private void copyBootstrapMethods(final ClassReader classReader, final char[] charBuffer) {\n        // Find attributOffset of the 'bootstrap_methods' array.\n        byte[] inputBytes = classReader.classFileBuffer;\n        int currentAttributeOffset = classReader.getFirstAttributeOffset();\n        for (int i = classReader.readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n            String attributeName = classReader.readUTF8(currentAttributeOffset, charBuffer);\n            if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n                bootstrapMethodCount = classReader.readUnsignedShort(currentAttributeOffset + 6);\n                break;\n            }\n            currentAttributeOffset += 6 + classReader.readInt(currentAttributeOffset + 2);\n        }\n        if (bootstrapMethodCount > 0) {\n            // Compute the offset and the length of the BootstrapMethods 'bootstrap_methods' array.\n            int bootstrapMethodsOffset = currentAttributeOffset + 8;\n            int bootstrapMethodsLength = classReader.readInt(currentAttributeOffset + 2) - 2;\n            bootstrapMethods = new ByteVector(bootstrapMethodsLength);\n            bootstrapMethods.putByteArray(inputBytes, bootstrapMethodsOffset, bootstrapMethodsLength);\n            // Add each bootstrap method in the symbol table entries.\n            int currentOffset = bootstrapMethodsOffset;\n            for (int i = 0; i < bootstrapMethodCount; i++) {\n                int offset = currentOffset - bootstrapMethodsOffset;\n                int bootstrapMethodRef = classReader.readUnsignedShort(currentOffset);\n                currentOffset += 2;\n                int numBootstrapArguments = classReader.readUnsignedShort(currentOffset);\n                currentOffset += 2;\n                int hashCode = classReader.readConst(bootstrapMethodRef, charBuffer).hashCode();\n                while (numBootstrapArguments-- > 0) {\n                    int bootstrapArgument = classReader.readUnsignedShort(currentOffset);\n                    currentOffset += 2;\n                    hashCode ^= classReader.readConst(bootstrapArgument, charBuffer).hashCode();\n                }\n                add(new Entry(i, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode & 0x7FFFFFFF));\n            }\n        }\n    }\n\n    /**\n     * Returns the ClassReader from which this SymbolTable was constructed.\n     *\n     * @return the ClassReader from which this SymbolTable was constructed, or {@literal null} if it\n     *     was constructed from scratch.\n     */\n    ClassReader getSource() {\n        return sourceClassReader;\n    }\n\n    /**\n     * Returns the major version of the class to which this symbol table belongs.\n     *\n     * @return the major version of the class to which this symbol table belongs.\n     */\n    int getMajorVersion() {\n        return majorVersion;\n    }\n\n    /**\n     * Returns the internal name of the class to which this symbol table belongs.\n     *\n     * @return the internal name of the class to which this symbol table belongs.\n     */\n    String getClassName() {\n        return className;\n    }\n\n    /**\n     * Sets the major version and the name of the class to which this symbol table belongs. Also adds\n     * the class name to the constant pool.\n     *\n     * @param majorVersion a major ClassFile version number.\n     * @param className an internal class name.\n     * @return the constant pool index of a new or already existing Symbol with the given class name.\n     */\n    int setMajorVersionAndClassName(final int majorVersion, final String className) {\n        this.majorVersion = majorVersion;\n        this.className = className;\n        return addConstantClass(className).index;\n    }\n\n    /**\n     * Returns the number of items in this symbol table's constant_pool array (plus 1).\n     *\n     * @return the number of items in this symbol table's constant_pool array (plus 1).\n     */\n    int getConstantPoolCount() {\n        return constantPoolCount;\n    }\n\n    /**\n     * Returns the length in bytes of this symbol table's constant_pool array.\n     *\n     * @return the length in bytes of this symbol table's constant_pool array.\n     */\n    int getConstantPoolLength() {\n        return constantPool.length;\n    }\n\n    /**\n     * Puts this symbol table's constant_pool array in the given ByteVector, preceded by the\n     * constant_pool_count value.\n     *\n     * @param output where the JVMS ClassFile's constant_pool array must be put.\n     */\n    void putConstantPool(final ByteVector output) {\n        output.putShort(constantPoolCount).putByteArray(constantPool.data, 0, constantPool.length);\n    }\n\n    /**\n     * Returns the size in bytes of this symbol table's BootstrapMethods attribute. Also adds the\n     * attribute name in the constant pool.\n     *\n     * @return the size in bytes of this symbol table's BootstrapMethods attribute.\n     */\n    int computeBootstrapMethodsSize() {\n        if (bootstrapMethods != null) {\n            addConstantUtf8(Constants.BOOTSTRAP_METHODS);\n            return 8 + bootstrapMethods.length;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * Puts this symbol table's BootstrapMethods attribute in the given ByteVector. This includes the\n     * 6 attribute header bytes and the num_bootstrap_methods value.\n     *\n     * @param output where the JVMS BootstrapMethods attribute must be put.\n     */\n    void putBootstrapMethods(final ByteVector output) {\n        if (bootstrapMethods != null) {\n            output.putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS)).putInt(bootstrapMethods.length + 2).putShort(bootstrapMethodCount).putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length);\n        }\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Generic symbol table entries management.\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the list of entries which can potentially have the given hash code.\n     *\n     * @param hashCode a {@link Entry#hashCode} value.\n     * @return the list of entries which can potentially have the given hash code. The list is stored\n     *     via the {@link Entry#next} field.\n     */\n    private Entry get(final int hashCode) {\n        return entries[hashCode % entries.length];\n    }\n\n    /**\n     * Puts the given entry in the {@link #entries} hash set. This method does <i>not</i> check\n     * whether {@link #entries} already contains a similar entry or not. {@link #entries} is resized\n     * if necessary to avoid hash collisions (multiple entries needing to be stored at the same {@link\n     * #entries} array index) as much as possible, with reasonable memory usage.\n     *\n     * @param entry an Entry (which must not already be contained in {@link #entries}).\n     * @return the given entry\n     */\n    private Entry put(final Entry entry) {\n        if (entryCount > (entries.length * 3) / 4) {\n            int currentCapacity = entries.length;\n            int newCapacity = currentCapacity * 2 + 1;\n            Entry[] newEntries = new Entry[newCapacity];\n            for (int i = currentCapacity - 1; i >= 0; --i) {\n                Entry currentEntry = entries[i];\n                while (currentEntry != null) {\n                    int newCurrentEntryIndex = currentEntry.hashCode % newCapacity;\n                    Entry nextEntry = currentEntry.next;\n                    currentEntry.next = newEntries[newCurrentEntryIndex];\n                    newEntries[newCurrentEntryIndex] = currentEntry;\n                    currentEntry = nextEntry;\n                }\n            }\n            entries = newEntries;\n        }\n        entryCount++;\n        int index = entry.hashCode % entries.length;\n        entry.next = entries[index];\n        return entries[index] = entry;\n    }\n\n    /**\n     * Adds the given entry in the {@link #entries} hash set. This method does <i>not</i> check\n     * whether {@link #entries} already contains a similar entry or not, and does <i>not</i> resize\n     * {@link #entries} if necessary.\n     *\n     * @param entry an Entry (which must not already be contained in {@link #entries}).\n     */\n    private void add(final Entry entry) {\n        entryCount++;\n        int index = entry.hashCode % entries.length;\n        entry.next = entries[index];\n        entries[index] = entry;\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Constant pool entries management.\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Adds a number or string constant to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value the value of the constant to be added to the constant pool. This parameter must be\n     *     an {@link Integer}, {@link Byte}, {@link Character}, {@link Short}, {@link Boolean}, {@link\n     *     Float}, {@link Long}, {@link Double}, {@link String}, {@link Type} or {@link Handle}.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstant(final Object value) {\n        if (value instanceof Integer) {\n            return addConstantInteger(((Integer) value).intValue());\n        } else if (value instanceof Byte) {\n            return addConstantInteger(((Byte) value).intValue());\n        } else if (value instanceof Character) {\n            return addConstantInteger(((Character) value).charValue());\n        } else if (value instanceof Short) {\n            return addConstantInteger(((Short) value).intValue());\n        } else if (value instanceof Boolean) {\n            return addConstantInteger(((Boolean) value).booleanValue() ? 1 : 0);\n        } else if (value instanceof Float) {\n            return addConstantFloat(((Float) value).floatValue());\n        } else if (value instanceof Long) {\n            return addConstantLong(((Long) value).longValue());\n        } else if (value instanceof Double) {\n            return addConstantDouble(((Double) value).doubleValue());\n        } else if (value instanceof String) {\n            return addConstantString((String) value);\n        } else if (value instanceof Type) {\n            Type type = (Type) value;\n            int typeSort = type.getSort();\n            if (typeSort == Type.OBJECT) {\n                return addConstantClass(type.getInternalName());\n            } else if (typeSort == Type.METHOD) {\n                return addConstantMethodType(type.getDescriptor());\n            } else { // type is a primitive or array type.\n                return addConstantClass(type.getDescriptor());\n            }\n        } else if (value instanceof Handle) {\n            Handle handle = (Handle) value;\n            return addConstantMethodHandle(handle.getTag(), handle.getOwner(), handle.getName(), handle.getDesc(), handle.isInterface());\n        } else if (value instanceof ConstantDynamic) {\n            ConstantDynamic constantDynamic = (ConstantDynamic) value;\n            return addConstantDynamic(constantDynamic.getName(), constantDynamic.getDescriptor(), constantDynamic.getBootstrapMethod(), constantDynamic.getBootstrapMethodArgumentsUnsafe());\n        } else {\n            throw new IllegalArgumentException(\"value \" + value);\n        }\n    }\n\n    /**\n     * Adds a CONSTANT_Class_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value the internal name of a class.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantClass(final String value) {\n        return addConstantUtf8Reference(Symbol.CONSTANT_CLASS_TAG, value);\n    }\n\n    /**\n     * Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param owner the internal name of a class.\n     * @param name a field name.\n     * @param descriptor a field descriptor.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantFieldref(final String owner, final String name, final String descriptor) {\n        return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor);\n    }\n\n    /**\n     * Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this\n     * symbol table. Does nothing if the constant pool already contains a similar item.\n     *\n     * @param owner the internal name of a class.\n     * @param name a method name.\n     * @param descriptor a method descriptor.\n     * @param isInterface whether owner is an interface or not.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantMethodref(final String owner, final String name, final String descriptor, final boolean isInterface) {\n        int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG;\n        return addConstantMemberReference(tag, owner, name, descriptor);\n    }\n\n    /**\n     * Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to\n     * the constant pool of this symbol table. Does nothing if the constant pool already contains a\n     * similar item.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\n     *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n     * @param owner the internal name of a class.\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     * @return a new or already existing Symbol with the given value.\n     */\n    private Entry addConstantMemberReference(final int tag, final String owner, final String name, final String descriptor) {\n        int hashCode = hash(tag, owner, name, descriptor);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        constantPool.put122(tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor));\n        return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, 0, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info\n     * to the constant pool of this symbol table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\n     *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n     * @param owner the internal name of a class.\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     */\n    private void addConstantMemberReference(final int index, final int tag, final String owner, final String name, final String descriptor) {\n        add(new Entry(index, tag, owner, name, descriptor, 0, hash(tag, owner, name, descriptor)));\n    }\n\n    /**\n     * Adds a CONSTANT_String_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value a string.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantString(final String value) {\n        return addConstantUtf8Reference(Symbol.CONSTANT_STRING_TAG, value);\n    }\n\n    /**\n     * Adds a CONSTANT_Integer_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value an int.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantInteger(final int value) {\n        return addConstantIntegerOrFloat(Symbol.CONSTANT_INTEGER_TAG, value);\n    }\n\n    /**\n     * Adds a CONSTANT_Float_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value a float.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantFloat(final float value) {\n        return addConstantIntegerOrFloat(Symbol.CONSTANT_FLOAT_TAG, Float.floatToRawIntBits(value));\n    }\n\n    /**\n     * Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n     * @param value an int or float.\n     * @return a constant pool constant with the given tag and primitive values.\n     */\n    private Symbol addConstantIntegerOrFloat(final int tag, final int value) {\n        int hashCode = hash(tag, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        constantPool.putByte(tag).putInt(value);\n        return put(new Entry(constantPoolCount++, tag, value, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\n     * table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n     * @param value an int or float.\n     */\n    private void addConstantIntegerOrFloat(final int index, final int tag, final int value) {\n        add(new Entry(index, tag, value, hash(tag, value)));\n    }\n\n    /**\n     * Adds a CONSTANT_Long_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value a long.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantLong(final long value) {\n        return addConstantLongOrDouble(Symbol.CONSTANT_LONG_TAG, value);\n    }\n\n    /**\n     * Adds a CONSTANT_Double_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value a double.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantDouble(final double value) {\n        return addConstantLongOrDouble(Symbol.CONSTANT_DOUBLE_TAG, Double.doubleToRawLongBits(value));\n    }\n\n    /**\n     * Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.\n     * Does nothing if the constant pool already contains a similar item.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n     * @param value a long or double.\n     * @return a constant pool constant with the given tag and primitive values.\n     */\n    private Symbol addConstantLongOrDouble(final int tag, final long value) {\n        int hashCode = hash(tag, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        int index = constantPoolCount;\n        constantPool.putByte(tag).putLong(value);\n        constantPoolCount += 2;\n        return put(new Entry(index, tag, value, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol\n     * table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n     * @param value a long or double.\n     */\n    private void addConstantLongOrDouble(final int index, final int tag, final long value) {\n        add(new Entry(index, tag, value, hash(tag, value)));\n    }\n\n    /**\n     * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     * @return a new or already existing Symbol with the given value.\n     */\n    int addConstantNameAndType(final String name, final String descriptor) {\n        final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;\n        int hashCode = hash(tag, name, descriptor);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.name.equals(name) && entry.value.equals(descriptor)) {\n                return entry.index;\n            }\n            entry = entry.next;\n        }\n        constantPool.put122(tag, addConstantUtf8(name), addConstantUtf8(descriptor));\n        return put(new Entry(constantPoolCount++, tag, name, descriptor, hashCode)).index;\n    }\n\n    /**\n     * Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     */\n    private void addConstantNameAndType(final int index, final String name, final String descriptor) {\n        final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;\n        add(new Entry(index, tag, name, descriptor, hash(tag, name, descriptor)));\n    }\n\n    /**\n     * Adds a CONSTANT_Utf8_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param value a string.\n     * @return a new or already existing Symbol with the given value.\n     */\n    int addConstantUtf8(final String value) {\n        int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == Symbol.CONSTANT_UTF8_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {\n                return entry.index;\n            }\n            entry = entry.next;\n        }\n        constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value);\n        return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index;\n    }\n\n    /**\n     * Adds a new CONSTANT_String_info to the constant pool of this symbol table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param value a string.\n     */\n    private void addConstantUtf8(final int index, final String value) {\n        add(new Entry(index, Symbol.CONSTANT_UTF8_TAG, value, hash(Symbol.CONSTANT_UTF8_TAG, value)));\n    }\n\n    /**\n     * Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table. Does nothing if\n     * the constant pool already contains a similar item.\n     *\n     * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\n     *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\n     *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\n     *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n     * @param owner the internal name of a class of interface.\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     * @param isInterface whether owner is an interface or not.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantMethodHandle(final int referenceKind, final String owner, final String name, final String descriptor, final boolean isInterface) {\n        final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;\n        // Note that we don't need to include isInterface in the hash computation, because it is\n        // redundant with owner (we can't have the same owner with different isInterface values).\n        int hashCode = hash(tag, owner, name, descriptor, referenceKind);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.data == referenceKind && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        if (referenceKind <= Opcodes.H_PUTSTATIC) {\n            constantPool.put112(tag, referenceKind, addConstantFieldref(owner, name, descriptor).index);\n        } else {\n            constantPool.put112(tag, referenceKind, addConstantMethodref(owner, name, descriptor, isInterface).index);\n        }\n        return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, referenceKind, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\n     *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\n     *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\n     *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n     * @param owner the internal name of a class of interface.\n     * @param name a field or method name.\n     * @param descriptor a field or method descriptor.\n     */\n    private void addConstantMethodHandle(final int index, final int referenceKind, final String owner, final String name, final String descriptor) {\n        final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;\n        int hashCode = hash(tag, owner, name, descriptor, referenceKind);\n        add(new Entry(index, tag, owner, name, descriptor, referenceKind, hashCode));\n    }\n\n    /**\n     * Adds a CONSTANT_MethodType_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param methodDescriptor a method descriptor.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantMethodType(final String methodDescriptor) {\n        return addConstantUtf8Reference(Symbol.CONSTANT_METHOD_TYPE_TAG, methodDescriptor);\n    }\n\n    /**\n     * Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table. Also adds the related\n     * bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the constant\n     * pool already contains a similar item.\n     *\n     * @param name a method name.\n     * @param descriptor a field descriptor.\n     * @param bootstrapMethodHandle a bootstrap method handle.\n     * @param bootstrapMethodArguments the bootstrap method arguments.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantDynamic(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\n        Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);\n        return addConstantDynamicOrInvokeDynamicReference(Symbol.CONSTANT_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);\n    }\n\n    /**\n     * Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table. Also adds the\n     * related bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param name a method name.\n     * @param descriptor a method descriptor.\n     * @param bootstrapMethodHandle a bootstrap method handle.\n     * @param bootstrapMethodArguments the bootstrap method arguments.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantInvokeDynamic(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\n        Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);\n        return addConstantDynamicOrInvokeDynamicReference(Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);\n    }\n\n    /**\n     * Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol\n     * table. Does nothing if the constant pool already contains a similar item.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\n     *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n     * @param name a method name.\n     * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG) or a method descriptor for\n     *     CONSTANT_INVOKE_DYNAMIC_TAG.\n     * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\n     * @return a new or already existing Symbol with the given value.\n     */\n    private Symbol addConstantDynamicOrInvokeDynamicReference(final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) {\n        int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.data == bootstrapMethodIndex && entry.name.equals(name) && entry.value.equals(descriptor)) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        constantPool.put122(tag, bootstrapMethodIndex, addConstantNameAndType(name, descriptor));\n        return put(new Entry(constantPoolCount++, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this\n     * symbol table.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\n     *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n     * @param index the constant pool index of the new Symbol.\n     * @param name a method name.\n     * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG or a method descriptor for\n     *     CONSTANT_INVOKE_DYNAMIC_TAG.\n     * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\n     */\n    private void addConstantDynamicOrInvokeDynamicReference(final int tag, final int index, final String name, final String descriptor, final int bootstrapMethodIndex) {\n        int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);\n        add(new Entry(index, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));\n    }\n\n    /**\n     * Adds a CONSTANT_Module_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param moduleName a fully qualified name (using dots) of a module.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantModule(final String moduleName) {\n        return addConstantUtf8Reference(Symbol.CONSTANT_MODULE_TAG, moduleName);\n    }\n\n    /**\n     * Adds a CONSTANT_Package_info to the constant pool of this symbol table. Does nothing if the\n     * constant pool already contains a similar item.\n     *\n     * @param packageName the internal name of a package.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addConstantPackage(final String packageName) {\n        return addConstantUtf8Reference(Symbol.CONSTANT_PACKAGE_TAG, packageName);\n    }\n\n    /**\n     * Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\n     * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table. Does\n     * nothing if the constant pool already contains a similar item.\n     *\n     * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\n     *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\n     *     Symbol#CONSTANT_PACKAGE_TAG}.\n     * @param value an internal class name, an arbitrary string, a method descriptor, a module or a\n     *     package name, depending on tag.\n     * @return a new or already existing Symbol with the given value.\n     */\n    private Symbol addConstantUtf8Reference(final int tag, final String value) {\n        int hashCode = hash(tag, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.value.equals(value)) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        constantPool.put12(tag, addConstantUtf8(value));\n        return put(new Entry(constantPoolCount++, tag, value, hashCode));\n    }\n\n    /**\n     * Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\n     * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.\n     *\n     * @param index the constant pool index of the new Symbol.\n     * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\n     *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\n     *     Symbol#CONSTANT_PACKAGE_TAG}.\n     * @param value an internal class name, an arbitrary string, a method descriptor, a module or a\n     *     package name, depending on tag.\n     */\n    private void addConstantUtf8Reference(final int index, final int tag, final String value) {\n        add(new Entry(index, tag, value, hash(tag, value)));\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Bootstrap method entries management.\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\n     * the BootstrapMethods already contains a similar bootstrap method.\n     *\n     * @param bootstrapMethodHandle a bootstrap method handle.\n     * @param bootstrapMethodArguments the bootstrap method arguments.\n     * @return a new or already existing Symbol with the given value.\n     */\n    Symbol addBootstrapMethod(final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\n        ByteVector bootstrapMethodsAttribute = bootstrapMethods;\n        if (bootstrapMethodsAttribute == null) {\n            bootstrapMethodsAttribute = bootstrapMethods = new ByteVector();\n        }\n        // The bootstrap method arguments can be Constant_Dynamic values, which reference other\n        // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool\n        // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified\n        // while adding the given bootstrap method to it, in the rest of this method.\n        for (Object bootstrapMethodArgument : bootstrapMethodArguments) {\n            addConstant(bootstrapMethodArgument);\n        }\n        // Write the bootstrap method in the BootstrapMethods table. This is necessary to be able to\n        // compare it with existing ones, and will be reverted below if there is already a similar\n        // bootstrap method.\n        int bootstrapMethodOffset = bootstrapMethodsAttribute.length;\n        bootstrapMethodsAttribute.putShort(addConstantMethodHandle(bootstrapMethodHandle.getTag(), bootstrapMethodHandle.getOwner(), bootstrapMethodHandle.getName(), bootstrapMethodHandle.getDesc(), bootstrapMethodHandle.isInterface()).index);\n        int numBootstrapArguments = bootstrapMethodArguments.length;\n        bootstrapMethodsAttribute.putShort(numBootstrapArguments);\n        for (Object bootstrapMethodArgument : bootstrapMethodArguments) {\n            bootstrapMethodsAttribute.putShort(addConstant(bootstrapMethodArgument).index);\n        }\n        // Compute the length and the hash code of the bootstrap method.\n        int bootstrapMethodlength = bootstrapMethodsAttribute.length - bootstrapMethodOffset;\n        int hashCode = bootstrapMethodHandle.hashCode();\n        for (Object bootstrapMethodArgument : bootstrapMethodArguments) {\n            hashCode ^= bootstrapMethodArgument.hashCode();\n        }\n        hashCode &= 0x7FFFFFFF;\n        // Add the bootstrap method to the symbol table or revert the above changes.\n        return addBootstrapMethod(bootstrapMethodOffset, bootstrapMethodlength, hashCode);\n    }\n\n    /**\n     * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\n     * the BootstrapMethods already contains a similar bootstrap method (more precisely, reverts the\n     * content of {@link #bootstrapMethods} to remove the last, duplicate bootstrap method).\n     *\n     * @param offset the offset of the last bootstrap method in {@link #bootstrapMethods}, in bytes.\n     * @param length the length of this bootstrap method in {@link #bootstrapMethods}, in bytes.\n     * @param hashCode the hash code of this bootstrap method.\n     * @return a new or already existing Symbol with the given value.\n     */\n    private Symbol addBootstrapMethod(final int offset, final int length, final int hashCode) {\n        final byte[] bootstrapMethodsData = bootstrapMethods.data;\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == Symbol.BOOTSTRAP_METHOD_TAG && entry.hashCode == hashCode) {\n                int otherOffset = (int) entry.data;\n                boolean isSameBootstrapMethod = true;\n                for (int i = 0; i < length; ++i) {\n                    if (bootstrapMethodsData[offset + i] != bootstrapMethodsData[otherOffset + i]) {\n                        isSameBootstrapMethod = false;\n                        break;\n                    }\n                }\n                if (isSameBootstrapMethod) {\n                    bootstrapMethods.length = offset; // Revert to old position.\n                    return entry;\n                }\n            }\n            entry = entry.next;\n        }\n        return put(new Entry(bootstrapMethodCount++, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode));\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Type table entries management.\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * Returns the type table element whose index is given.\n     *\n     * @param typeIndex a type table index.\n     * @return the type table element whose index is given.\n     */\n    Symbol getType(final int typeIndex) {\n        return typeTable[typeIndex];\n    }\n\n    /**\n     * Adds a type in the type table of this symbol table. Does nothing if the type table already\n     * contains a similar type.\n     *\n     * @param value an internal class name.\n     * @return the index of a new or already existing type Symbol with the given value.\n     */\n    int addType(final String value) {\n        int hashCode = hash(Symbol.TYPE_TAG, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {\n                return entry.index;\n            }\n            entry = entry.next;\n        }\n        return addTypeInternal(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode));\n    }\n\n    /**\n     * Adds an {@link Frame#ITEM_UNINITIALIZED} type in the type table of this symbol table. Does\n     * nothing if the type table already contains a similar type.\n     *\n     * @param value an internal class name.\n     * @param bytecodeOffset the bytecode offset of the NEW instruction that created this {@link\n     *     Frame#ITEM_UNINITIALIZED} type value.\n     * @return the index of a new or already existing type Symbol with the given value.\n     */\n    int addUninitializedType(final String value, final int bytecodeOffset) {\n        int hashCode = hash(Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == Symbol.UNINITIALIZED_TYPE_TAG && entry.hashCode == hashCode && entry.data == bytecodeOffset && entry.value.equals(value)) {\n                return entry.index;\n            }\n            entry = entry.next;\n        }\n        return addTypeInternal(new Entry(typeCount, Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset, hashCode));\n    }\n\n    /**\n     * Adds a merged type in the type table of this symbol table. Does nothing if the type table\n     * already contains a similar type.\n     *\n     * @param typeTableIndex1 a {@link Symbol#TYPE_TAG} type, specified by its index in the type\n     *     table.\n     * @param typeTableIndex2 another {@link Symbol#TYPE_TAG} type, specified by its index in the type\n     *     table.\n     * @return the index of a new or already existing {@link Symbol#TYPE_TAG} type Symbol,\n     *     corresponding to the common super class of the given types.\n     */\n    int addMergedType(final int typeTableIndex1, final int typeTableIndex2) {\n        long data = typeTableIndex1 < typeTableIndex2 ? typeTableIndex1 | (((long) typeTableIndex2) << 32) : typeTableIndex2 | (((long) typeTableIndex1) << 32);\n        int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == Symbol.MERGED_TYPE_TAG && entry.hashCode == hashCode && entry.data == data) {\n                return entry.info;\n            }\n            entry = entry.next;\n        }\n        String type1 = typeTable[typeTableIndex1].value;\n        String type2 = typeTable[typeTableIndex2].value;\n        int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2));\n        put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG, data, hashCode)).info = commonSuperTypeIndex;\n        return commonSuperTypeIndex;\n    }\n\n    /**\n     * Adds the given type Symbol to {@link #typeTable}.\n     *\n     * @param entry a {@link Symbol#TYPE_TAG} or {@link Symbol#UNINITIALIZED_TYPE_TAG} type symbol.\n     *     The index of this Symbol must be equal to the current value of {@link #typeCount}.\n     * @return the index in {@link #typeTable} where the given type was added, which is also equal to\n     *     entry's index by hypothesis.\n     */\n    private int addTypeInternal(final Entry entry) {\n        if (typeTable == null) {\n            typeTable = new Entry[16];\n        }\n        if (typeCount == typeTable.length) {\n            Entry[] newTypeTable = new Entry[2 * typeTable.length];\n            System.arraycopy(typeTable, 0, newTypeTable, 0, typeTable.length);\n            typeTable = newTypeTable;\n        }\n        typeTable[typeCount++] = entry;\n        return put(entry).index;\n    }\n    // -----------------------------------------------------------------------------------------------\n    // Static helper methods to compute hash codes.\n    // -----------------------------------------------------------------------------------------------\n\n    private static int hash(final int tag, final int value) {\n        return 0x7FFFFFFF & (tag + value);\n    }\n\n    private static int hash(final int tag, final long value) {\n        return 0x7FFFFFFF & (tag + (int) value + (int) (value >>> 32));\n    }\n\n    private static int hash(final int tag, final String value) {\n        return 0x7FFFFFFF & (tag + value.hashCode());\n    }\n\n    private static int hash(final int tag, final String value1, final int value2) {\n        return 0x7FFFFFFF & (tag + value1.hashCode() + value2);\n    }\n\n    private static int hash(final int tag, final String value1, final String value2) {\n        return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode());\n    }\n\n    private static int hash(final int tag, final String value1, final String value2, final int value3) {\n        return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * (value3 + 1));\n    }\n\n    private static int hash(final int tag, final String value1, final String value2, final String value3) {\n        return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode());\n    }\n\n    private static int hash(final int tag, final String value1, final String value2, final String value3, final int value4) {\n        return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode() * value4);\n    }\n\n    /**\n     * An entry of a SymbolTable. This concrete and private subclass of {@link Symbol} adds two fields\n     * which are only used inside SymbolTable, to implement hash sets of symbols (in order to avoid\n     * duplicate symbols). See {@link #entries}.\n     *\n     * @author Eric Bruneton\n     */\n    private static class Entry extends Symbol {\n        /** The hash code of this entry. */\n        final int hashCode;\n        /**\n         * Another entry (and so on recursively) having the same hash code (modulo the size of {@link\n         * #entries}) as this one.\n         */\n        Entry next;\n\n        Entry(final int index, final int tag, final String owner, final String name, final String value, final long data, final int hashCode) {\n            super(index, tag, owner, name, value, data);\n            this.hashCode = hashCode;\n        }\n\n        Entry(final int index, final int tag, final String value, final int hashCode) {\n            super(index, tag, /* owner = */ null, /* name = */ null, value, /* data = */ 0);\n            this.hashCode = hashCode;\n        }\n\n        Entry(final int index, final int tag, final String value, final long data, final int hashCode) {\n            super(index, tag, /* owner = */ null, /* name = */ null, value, data);\n            this.hashCode = hashCode;\n        }\n\n        Entry(final int index, final int tag, final String name, final String value, final int hashCode) {\n            super(index, tag, /* owner = */ null, name, value, /* data = */ 0);\n            this.hashCode = hashCode;\n        }\n\n        Entry(final int index, final int tag, final long data, final int hashCode) {\n            super(index, tag, /* owner = */ null, /* name = */ null, /* value = */ null, data);\n            this.hashCode = hashCode;\n        }\n    }\n}\n",
            "file_name": "SymbolTable.java",
            "human_label": "Add constant information generated by its name and type to the constant pool and return the index of the constant.",
            "level": "project_runnable",
            "lineno": "649",
            "name": "addConstantNameAndType",
            "oracle_context": "{ \"apis\" : \"[hash, get, equals, put122, addConstantUtf8, put, Entry]\", \"classes\" : \"[Entry, Symbol]\", \"vars\" : \"[CONSTANT_NAME_AND_TYPE_TAG, value, index, next, constantPool, constantPoolCount]\" }",
            "package": "net.hasor.utils.asm",
            "project": "hasor-master"
        },
        {
            "_id": "6367676c1a6d9265ec018204",
            "all_context": "{ \"class_level\" : \"import java.nio.charset.Charset;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nimport java.util.Enumeration;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Locale;\\nimport java.util.Properties;\\nimport java.util.Set;\\nimport java.util.StringTokenizer;\\nimport java.util.TreeSet;\\nString FOLDER_SEPARATOR;\\nString WINDOWS_FOLDER_SEPARATOR;\\nString TOP_PATH;\\nString CURRENT_PATH;\\nchar EXTENSION_SEPARATOR;\\nCharset UTF_8;\\nStrings();\\nhasLength(String str);\\nhasText(CharSequence str);\\nhasText(String str);\\ncontainsWhitespace(CharSequence str);\\ncontainsWhitespace(String str);\\ntrimWhitespace(String str);\\ntrimWhitespace(CharSequence str);\\nclean(String str);\\nclean(CharSequence str);\\ntrimAllWhitespace(String str);\\ntrimLeadingWhitespace(String str);\\ntrimTrailingWhitespace(String str);\\ntrimLeadingCharacter(String str,char leadingCharacter);\\ntrimTrailingCharacter(String str,char trailingCharacter);\\nstartsWithIgnoreCase(String str,String prefix);\\nendsWithIgnoreCase(String str,String suffix);\\nsubstringMatch(CharSequence str,int index,CharSequence substring);\\ncountOccurrencesOf(String str,String sub);\\nreplace(String inString,String oldPattern,String newPattern);\\ndelete(String inString,String pattern);\\ndeleteAny(String inString,String charsToDelete);\\nquote(String str);\\nquoteIfString(Object obj);\\nunqualify(String qualifiedName);\\nunqualify(String qualifiedName,char separator);\\ncapitalize(String str);\\nuncapitalize(String str);\\nchangeFirstCharacterCase(String str,boolean capitalize);\\ngetFilename(String path);\\ngetFilenameExtension(String path);\\nstripFilenameExtension(String path);\\napplyRelativePath(String path,String relativePath);\\ncleanPath(String path);\\npathEquals(String path1,String path2);\\nparseLocaleString(String localeString);\\nvalidateLocalePart(String localePart);\\ntoLanguageTag(Locale locale);\\naddStringToArray(String[] array,String str);\\nconcatenateStringArrays(String[] array1,String[] array2);\\nmergeStringArrays(String[] array1,String[] array2);\\nsortStringArray(String[] array);\\ntoStringArray(Collection collection);\\ntoStringArray(Enumeration enumeration);\\ntrimArrayElements(String[] array);\\nremoveDuplicateStrings(String[] array);\\nsplit(String toSplit,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter,String charsToDelete);\\ntokenizeToStringArray(String str,String delimiters);\\ntokenizeToStringArray(String str,String delimiters,boolean trimTokens,boolean ignoreEmptyTokens);\\ndelimitedListToStringArray(String str,String delimiter);\\ndelimitedListToStringArray(String str,String delimiter,String charsToDelete);\\ncommaDelimitedListToStringArray(String str);\\ncommaDelimitedListToSet(String str);\\ncollectionToDelimitedString(Collection coll,String delim,String prefix,String suffix);\\ncollectionToDelimitedString(Collection coll,String delim);\\ncollectionToCommaDelimitedString(Collection coll);\\narrayToDelimitedString(Object[] arr,String delim);\\narrayToCommaDelimitedString(Object[] arr);\\nhasLength(CharSequence str);\\n\", \"repo_level\" : \"\" }",
            "class_name": "Strings",
            "code": "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n  if (Objects.isEmpty(array1)) {\n    return array2;\n  }\n  if (Objects.isEmpty(array2)) {\n    return array1;\n  }\n  String[] newArr=new String[array1.length + array2.length];\n  System.arraycopy(array1,0,newArr,0,array1.length);\n  System.arraycopy(array2,0,newArr,array1.length,array2.length);\n  return newArr;\n}\n",
            "docstring": "/** \n * Concatenate the given String arrays into one, with overlapping array elements included twice. <p>The order of elements in the original arrays is preserved.\n * @param array1 the first array (can be <code>null</code>)\n * @param array2 the second array (can be <code>null</code>)\n * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n */\n",
            "end_lineno": "755",
            "file_content": "/*\n * Copyright (C) 2014 jsonwebtoken.io\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.jsonwebtoken.lang;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic final class Strings {\n\n    private static final String FOLDER_SEPARATOR = \"/\";\n\n    private static final String WINDOWS_FOLDER_SEPARATOR = \"\\\\\";\n\n    private static final String TOP_PATH = \"..\";\n\n    private static final String CURRENT_PATH = \".\";\n\n    private static final char EXTENSION_SEPARATOR = '.';\n\n    public static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    private Strings(){} //prevent instantiation\n\n    //---------------------------------------------------------------------\n    // General convenience methods for working with Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Check that the given CharSequence is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a CharSequence that purely consists of whitespace.\n     * <pre>\n     * Strings.hasLength(null) = false\n     * Strings.hasLength(\"\") = false\n     * Strings.hasLength(\" \") = true\n     * Strings.hasLength(\"Hello\") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(CharSequence str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasLength(CharSequence)\n     */\n    public static boolean hasLength(String str) {\n        return hasLength((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <pre>\n     * Strings.hasText(null) = false\n     * Strings.hasText(\"\") = false\n     * Strings.hasText(\" \") = false\n     * Strings.hasText(\"12345\") = true\n     * Strings.hasText(\" 12345 \") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not <code>null</code>,\n     * its length is greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     * greater than 0, and it does not contain whitespace only\n     * @see #hasText(CharSequence)\n     */\n    public static boolean hasText(String str) {\n        return hasText((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence contains any whitespace characters.\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not empty and\n     * contains at least 1 whitespace character\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean containsWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String contains any whitespace characters.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not empty and\n     * contains at least 1 whitespace character\n     * @see #containsWhitespace(CharSequence)\n     */\n    public static boolean containsWhitespace(String str) {\n        return containsWhitespace((CharSequence) str);\n    }\n\n    /**\n     * Trim leading and trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimWhitespace(String str) {\n        return (String) trimWhitespace((CharSequence)str);\n    }\n    \n    \n    private static CharSequence trimWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        final int length = str.length();\n\n        int start = 0;\n\t\twhile (start < length && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        \n\t\tint end = length;\n        while (start < length && Character.isWhitespace(str.charAt(end - 1))) {\n            end--;\n        }\n        \n        return ((start > 0) || (end < length)) ? str.subSequence(start, end) : str;\n    }\n\n    public static String clean(String str) {\n    \tCharSequence result = clean((CharSequence) str);\n        \n        return result!=null?result.toString():null;\n    }\n    \n    public static CharSequence clean(CharSequence str) {\n        str = trimWhitespace(str);\n        if (!hasLength(str)) {\n            return null;\n        }\n        return str;\n    }\n\n    /**\n     * Trim <i>all</i> whitespace from the given String:\n     * leading, trailing, and intermediate characters.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimAllWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        int index = 0;\n        while (sb.length() > index) {\n            if (Character.isWhitespace(sb.charAt(index))) {\n                sb.deleteCharAt(index);\n            }\n            else {\n                index++;\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim leading whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimLeadingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimTrailingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied leading character from the given String.\n     * @param str the String to check\n     * @param leadingCharacter the leading character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimLeadingCharacter(String str, char leadingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied trailing character from the given String.\n     * @param str the String to check\n     * @param trailingCharacter the trailing character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimTrailingCharacter(String str, char trailingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n\n    /**\n     * Returns {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @param str the String to check\n     * @param prefix the prefix to look for\n     * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @param str the String to check\n     * @param suffix the suffix to look for\n     * @return {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @see java.lang.String#endsWith\n     */\n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        if (str == null || suffix == null) {\n            return false;\n        }\n        if (str.endsWith(suffix)) {\n            return true;\n        }\n        if (str.length() < suffix.length()) {\n            return false;\n        }\n\n        String lcStr = str.substring(str.length() - suffix.length()).toLowerCase();\n        String lcSuffix = suffix.toLowerCase();\n        return lcStr.equals(lcSuffix);\n    }\n\n    /**\n     * Returns {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     * @param str the original string (or StringBuilder)\n     * @param index the index in the original string to start matching against\n     * @param substring the substring to match at the given index\n     * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     */\n    public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n        for (int j = 0; j < substring.length(); j++) {\n            int i = index + j;\n            if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the number of occurrences the substring {@code sub} appears in string {@code str}.\n     * @param str string to search in. Return 0 if this is null.\n     * @param sub string to search for. Return 0 if this is null.\n     * @return the number of occurrences the substring {@code sub} appears in string {@code str}.\n     */\n    public static int countOccurrencesOf(String str, String sub) {\n        if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n            return 0;\n        }\n        int count = 0;\n        int pos = 0;\n        int idx;\n        while ((idx = str.indexOf(sub, pos)) != -1) {\n            ++count;\n            pos = idx + sub.length();\n        }\n        return count;\n    }\n\n    /**\n     * Replace all occurrences of a substring within a string with\n     * another string.\n     * @param inString String to examine\n     * @param oldPattern String to replace\n     * @param newPattern String to insert\n     * @return a String with the replacements\n     */\n    public static String replace(String inString, String oldPattern, String newPattern) {\n        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        int pos = 0; // our position in the old string\n        int index = inString.indexOf(oldPattern);\n        // the index of an occurrence we've found, or -1\n        int patLen = oldPattern.length();\n        while (index >= 0) {\n            sb.append(inString.substring(pos, index));\n            sb.append(newPattern);\n            pos = index + patLen;\n            index = inString.indexOf(oldPattern, pos);\n        }\n        sb.append(inString.substring(pos));\n        // remember to append any characters to the right of a match\n        return sb.toString();\n    }\n\n    /**\n     * Delete all occurrences of the given substring.\n     * @param inString the original String\n     * @param pattern the pattern to delete all occurrences of\n     * @return the resulting String\n     */\n    public static String delete(String inString, String pattern) {\n        return replace(inString, pattern, \"\");\n    }\n\n    /**\n     * Delete any character in a given String.\n     * @param inString the original String\n     * @param charsToDelete a set of characters to delete.\n     * E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n     * @return the resulting String\n     */\n    public static String deleteAny(String inString, String charsToDelete) {\n        if (!hasLength(inString) || !hasLength(charsToDelete)) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < inString.length(); i++) {\n            char c = inString.charAt(i);\n            if (charsToDelete.indexOf(c) == -1) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with formatted Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Quote the given String with single quotes.\n     * @param str the input String (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or <code>null</code> if the input was <code>null</code>\n     */\n    public static String quote(String str) {\n        return (str != null ? \"'\" + str + \"'\" : null);\n    }\n\n    /**\n     * Turn the given Object into a String with single quotes\n     * if it is a String; keeping the Object as-is else.\n     * @param obj the input Object (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or the input object as-is if not a String\n     */\n    public static Object quoteIfString(Object obj) {\n        return (obj instanceof String ? quote((String) obj) : obj);\n    }\n\n    /**\n     * Unqualify a string qualified by a '.' dot character. For example,\n     * \"this.name.is.qualified\", returns \"qualified\".\n     * @param qualifiedName the qualified name\n     * @return an unqualified string by stripping all previous text before (and including) the last period character.\n     */\n    public static String unqualify(String qualifiedName) {\n        return unqualify(qualifiedName, '.');\n    }\n\n    /**\n     * Unqualify a string qualified by a separator character. For example,\n     * \"this:name:is:qualified\" returns \"qualified\" if using a ':' separator.\n     * @param qualifiedName the qualified name\n     * @param separator the separator\n     * @return an unqualified string by stripping all previous text before and including the last {@code separator} character.\n     */\n    public static String unqualify(String qualifiedName, char separator) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);\n    }\n\n    /**\n     * Capitalize a <code>String</code>, changing the first letter to\n     * upper case as per {@link Character#toUpperCase(char)}.\n     * No other letters are changed.\n     * @param str the String to capitalize, may be <code>null</code>\n     * @return the capitalized String, <code>null</code> if null\n     */\n    public static String capitalize(String str) {\n        return changeFirstCharacterCase(str, true);\n    }\n\n    /**\n     * Uncapitalize a <code>String</code>, changing the first letter to\n     * lower case as per {@link Character#toLowerCase(char)}.\n     * No other letters are changed.\n     * @param str the String to uncapitalize, may be <code>null</code>\n     * @return the uncapitalized String, <code>null</code> if null\n     */\n    public static String uncapitalize(String str) {\n        return changeFirstCharacterCase(str, false);\n    }\n\n    private static String changeFirstCharacterCase(String str, boolean capitalize) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str.length());\n        if (capitalize) {\n            sb.append(Character.toUpperCase(str.charAt(0)));\n        }\n        else {\n            sb.append(Character.toLowerCase(str.charAt(0)));\n        }\n        sb.append(str.substring(1));\n        return sb.toString();\n    }\n\n    /**\n     * Extract the filename from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"myfile.txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename, or <code>null</code> if none\n     */\n    public static String getFilename(String path) {\n        if (path == null) {\n            return null;\n        }\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);\n    }\n\n    /**\n     * Extract the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename extension, or <code>null</code> if none\n     */\n    public static String getFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return null;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return null;\n        }\n        return path.substring(extIndex + 1);\n    }\n\n    /**\n     * Strip the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"mypath/myfile\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the path with stripped filename extension,\n     * or <code>null</code> if none\n     */\n    public static String stripFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return path;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return path;\n        }\n        return path.substring(0, extIndex);\n    }\n\n    /**\n     * Apply the given relative path to the given path,\n     * assuming standard Java folder separation (i.e. \"/\" separators).\n     * @param path the path to start from (usually a full file path)\n     * @param relativePath the relative path to apply\n     * (relative to the full file path above)\n     * @return the full file path that results from applying the relative path\n     */\n    public static String applyRelativePath(String path, String relativePath) {\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (separatorIndex != -1) {\n            String newPath = path.substring(0, separatorIndex);\n            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n                newPath += FOLDER_SEPARATOR;\n            }\n            return newPath + relativePath;\n        }\n        else {\n            return relativePath;\n        }\n    }\n\n    /**\n     * Normalize the path by suppressing sequences like \"path/..\" and\n     * inner simple dots.\n     * <p>The result is convenient for path comparison. For other uses,\n     * notice that Windows separators (\"\\\") are replaced by simple slashes.\n     * @param path the original path\n     * @return the normalized path\n     */\n    public static String cleanPath(String path) {\n        if (path == null) {\n            return null;\n        }\n        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);\n\n        // Strip prefix from path to analyze, to not treat it as part of the\n        // first path element. This is necessary to correctly parse paths like\n        // \"file:core/../core/io/Resource.class\", where the \"..\" should just\n        // strip the first \"core\" directory while keeping the \"file:\" prefix.\n        int prefixIndex = pathToUse.indexOf(\":\");\n        String prefix = \"\";\n        if (prefixIndex != -1) {\n            prefix = pathToUse.substring(0, prefixIndex + 1);\n            pathToUse = pathToUse.substring(prefixIndex + 1);\n        }\n        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {\n            prefix = prefix + FOLDER_SEPARATOR;\n            pathToUse = pathToUse.substring(1);\n        }\n\n        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);\n        List<String> pathElements = new LinkedList<String>();\n        int tops = 0;\n\n        for (int i = pathArray.length - 1; i >= 0; i--) {\n            String element = pathArray[i];\n            if (CURRENT_PATH.equals(element)) {\n                // Points to current directory - drop it.\n            }\n            else if (TOP_PATH.equals(element)) {\n                // Registering top path found.\n                tops++;\n            }\n            else {\n                if (tops > 0) {\n                    // Merging path element with element corresponding to top path.\n                    tops--;\n                }\n                else {\n                    // Normal path element found.\n                    pathElements.add(0, element);\n                }\n            }\n        }\n\n        // Remaining top paths need to be retained.\n        for (int i = 0; i < tops; i++) {\n            pathElements.add(0, TOP_PATH);\n        }\n\n        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);\n    }\n\n    /**\n     * Compare two paths after normalization of them.\n     * @param path1 first path for comparison\n     * @param path2 second path for comparison\n     * @return whether the two paths are equivalent after normalization\n     */\n    public static boolean pathEquals(String path1, String path2) {\n        return cleanPath(path1).equals(cleanPath(path2));\n    }\n\n    /**\n     * Parse the given <code>localeString</code> value into a {@link java.util.Locale}.\n     * <p>This is the inverse operation of {@link java.util.Locale#toString Locale's toString}.\n     * @param localeString the locale string, following <code>Locale's</code>\n     * <code>toString()</code> format (\"en\", \"en_UK\", etc);\n     * also accepts spaces as separators, as an alternative to underscores\n     * @return a corresponding <code>Locale</code> instance\n     */\n    public static Locale parseLocaleString(String localeString) {\n        String[] parts = tokenizeToStringArray(localeString, \"_ \", false, false);\n        String language = (parts.length > 0 ? parts[0] : \"\");\n        String country = (parts.length > 1 ? parts[1] : \"\");\n        validateLocalePart(language);\n        validateLocalePart(country);\n        String variant = \"\";\n        if (parts.length >= 2) {\n            // There is definitely a variant, and it is everything after the country\n            // code sans the separator between the country code and the variant.\n            int endIndexOfCountryCode = localeString.indexOf(country) + country.length();\n            // Strip off any leading '_' and whitespace, what's left is the variant.\n            variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));\n            if (variant.startsWith(\"_\")) {\n                variant = trimLeadingCharacter(variant, '_');\n            }\n        }\n        return (language.length() > 0 ? new Locale(language, country, variant) : null);\n    }\n\n    private static void validateLocalePart(String localePart) {\n        for (int i = 0; i < localePart.length(); i++) {\n            char ch = localePart.charAt(i);\n            if (ch != '_' && ch != ' ' && !Character.isLetterOrDigit(ch)) {\n                throw new IllegalArgumentException(\n                    \"Locale part \\\"\" + localePart + \"\\\" contains invalid characters\");\n            }\n        }\n    }\n\n    /**\n     * Determine the RFC 3066 compliant language tag,\n     * as used for the HTTP \"Accept-Language\" header.\n     * @param locale the Locale to transform to a language tag\n     * @return the RFC 3066 compliant language tag as String\n     */\n    public static String toLanguageTag(Locale locale) {\n        return locale.getLanguage() + (hasText(locale.getCountry()) ? \"-\" + locale.getCountry() : \"\");\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with String arrays\n    //---------------------------------------------------------------------\n\n    /**\n     * Append the given String to the given String array, returning a new array\n     * consisting of the input array contents plus the given String.\n     * @param array the array to append to (can be <code>null</code>)\n     * @param str the String to append\n     * @return the new array (never <code>null</code>)\n     */\n    public static String[] addStringToArray(String[] array, String str) {\n        if (Objects.isEmpty(array)) {\n            return new String[] {str};\n        }\n        String[] newArr = new String[array.length + 1];\n        System.arraycopy(array, 0, newArr, 0, array.length);\n        newArr[array.length] = str;\n        return newArr;\n    }\n\n    /**\n     * Concatenate the given String arrays into one,\n     * with overlapping array elements included twice.\n     * <p>The order of elements in the original arrays is preserved.\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        String[] newArr = new String[array1.length + array2.length];\n        System.arraycopy(array1, 0, newArr, 0, array1.length);\n        System.arraycopy(array2, 0, newArr, array1.length, array2.length);\n        return newArr;\n    }\n\n    /**\n     * Merge the given String arrays into one, with overlapping\n     * array elements only included once.\n     * <p>The order of elements in the original arrays is preserved\n     * (with the exception of overlapping elements, which are only\n     * included on their first occurrence).\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] mergeStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        List<String> result = new ArrayList<String>();\n        result.addAll(Arrays.asList(array1));\n        for (String str : array2) {\n            if (!result.contains(str)) {\n                result.add(str);\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Turn given source String array into sorted array.\n     * @param array the source array\n     * @return the sorted array (never <code>null</code>)\n     */\n    public static String[] sortStringArray(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        Arrays.sort(array);\n        return array;\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Collection was <code>null</code>)\n     */\n    public static String[] toStringArray(Collection<String> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new String[collection.size()]);\n    }\n\n    /**\n     * Copy the given Enumeration into a String array.\n     * The Enumeration must contain String elements only.\n     * @param enumeration the Enumeration to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Enumeration was <code>null</code>)\n     */\n    public static String[] toStringArray(Enumeration<String> enumeration) {\n        if (enumeration == null) {\n            return null;\n        }\n        List<String> list = java.util.Collections.list(enumeration);\n        return list.toArray(new String[list.size()]);\n    }\n\n    /**\n     * Trim the elements of the given String array,\n     * calling <code>String.trim()</code> on each of them.\n     * @param array the original String array\n     * @return the resulting array (of the same size) with trimmed elements\n     */\n    public static String[] trimArrayElements(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        String[] result = new String[array.length];\n        for (int i = 0; i < array.length; i++) {\n            String element = array[i];\n            result[i] = (element != null ? element.trim() : null);\n        }\n        return result;\n    }\n\n    /**\n     * Remove duplicate Strings from the given array.\n     * Also sorts the array, as it uses a TreeSet.\n     * @param array the String array\n     * @return an array without duplicates, in natural sort order\n     */\n    public static String[] removeDuplicateStrings(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return array;\n        }\n        Set<String> set = new TreeSet<String>();\n        for (String element : array) {\n            set.add(element);\n        }\n        return toStringArray(set);\n    }\n\n    /**\n     * Split a String at the first occurrence of the delimiter.\n     * Does not include the delimiter in the result.\n     * @param toSplit the string to split\n     * @param delimiter to split the string up with\n     * @return a two element array with index 0 being before the delimiter, and\n     * index 1 being after the delimiter (neither element includes the delimiter);\n     * or <code>null</code> if the delimiter wasn't found in the given input String\n     */\n    public static String[] split(String toSplit, String delimiter) {\n        if (!hasLength(toSplit) || !hasLength(delimiter)) {\n            return null;\n        }\n        int offset = toSplit.indexOf(delimiter);\n        if (offset < 0) {\n            return null;\n        }\n        String beforeDelimiter = toSplit.substring(0, offset);\n        String afterDelimiter = toSplit.substring(offset + delimiter.length());\n        return new String[] {beforeDelimiter, afterDelimiter};\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was null or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {\n        return splitArrayElementsIntoProperties(array, delimiter, null);\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @param charsToDelete one or more characters to remove from each element\n     * prior to attempting the split operation (typically the quotation mark\n     * symbol), or <code>null</code> if no removal should occur\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was <code>null</code> or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(\n        String[] array, String delimiter, String charsToDelete) {\n\n        if (Objects.isEmpty(array)) {\n            return null;\n        }\n        Properties result = new Properties();\n        for (String element : array) {\n            if (charsToDelete != null) {\n                element = deleteAny(element, charsToDelete);\n            }\n            String[] splittedElement = split(element, delimiter);\n            if (splittedElement == null) {\n                continue;\n            }\n            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n        }\n        return result;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter)\n     * @param trimTokens trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     * (only applies to tokens that are empty after trimming; StringTokenizer\n     * will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     * was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(\n        String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List<String> tokens = new ArrayList<String>();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter) {\n        return delimitedListToStringArray(str, delimiter, null);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @param charsToDelete a set of characters to delete. Useful for deleting unwanted\n     * line breaks: e.g. \"\\r\\n\\f\" will delete all new lines and line feeds in a String.\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {\n        if (str == null) {\n            return new String[0];\n        }\n        if (delimiter == null) {\n            return new String[] {str};\n        }\n        List<String> result = new ArrayList<String>();\n        if (\"\".equals(delimiter)) {\n            for (int i = 0; i < str.length(); i++) {\n                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));\n            }\n        }\n        else {\n            int pos = 0;\n            int delPos;\n            while ((delPos = str.indexOf(delimiter, pos)) != -1) {\n                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));\n                pos = delPos + delimiter.length();\n            }\n            if (str.length() > 0 && pos <= str.length()) {\n                // Add rest of String, but not in case of empty input.\n                result.add(deleteAny(str.substring(pos), charsToDelete));\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Convert a CSV list into an array of Strings.\n     * @param str the input String\n     * @return an array of Strings, or the empty array in case of empty input\n     */\n    public static String[] commaDelimitedListToStringArray(String str) {\n        return delimitedListToStringArray(str, \",\");\n    }\n\n    /**\n     * Convenience method to convert a CSV string list to a set.\n     * Note that this will suppress duplicates.\n     * @param str the input String\n     * @return a Set of String entries in the list\n     */\n    public static Set<String> commaDelimitedListToSet(String str) {\n        Set<String> set = new TreeSet<String>();\n        String[] tokens = commaDelimitedListToStringArray(str);\n        for (String token : tokens) {\n            set.add(token);\n        }\n        return set;\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @param prefix the String to start each element with\n     * @param suffix the String to end each element with\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {\n        if (Collections.isEmpty(coll)) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        Iterator<?> it = coll.iterator();\n        while (it.hasNext()) {\n            sb.append(prefix).append(it.next()).append(suffix);\n            if (it.hasNext()) {\n                sb.append(delim);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim) {\n        return collectionToDelimitedString(coll, delim, \"\", \"\");\n    }\n\n    /**\n     * Convenience method to return a Collection as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @return the delimited String\n     */\n    public static String collectionToCommaDelimitedString(Collection<?> coll) {\n        return collectionToDelimitedString(coll, \",\");\n    }\n\n    /**\n     * Convenience method to return a String array as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String arrayToDelimitedString(Object[] arr, String delim) {\n        if (Objects.isEmpty(arr)) {\n            return \"\";\n        }\n        if (arr.length == 1) {\n            return Objects.nullSafeToString(arr[0]);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < arr.length; i++) {\n            if (i > 0) {\n                sb.append(delim);\n            }\n            sb.append(arr[i]);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a String array as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @return the delimited String\n     */\n    public static String arrayToCommaDelimitedString(Object[] arr) {\n        return arrayToDelimitedString(arr, \",\");\n    }\n\n}\n\n",
            "file_name": "Strings.java",
            "human_label": "Concatenate two string arrays into one.",
            "level": "slib_runnable",
            "lineno": "736",
            "name": "concatenateStringArrays",
            "oracle_context": "{ \"apis\" : \"[isEmpty, arraycopy]\", \"classes\" : \"[String[]]\", \"vars\" : \"[length]\" }",
            "package": "io.jsonwebtoken.lang",
            "project": "jjwt-master"
        },
        {
            "_id": "636767641a6d9265ec018190",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.*;\\nimport org.jgrapht.alg.util.*;\\nimport org.jgrapht.generate.*;\\nimport org.jgrapht.graph.*;\\nimport org.jgrapht.util.*;\\nimport java.util.*;\\nint n;\\nint m;\\nGraph<V,E> graph;\\nMap<V,Integer> vertices;\\nList<V> indices;\\nBoolean weaklyChordal;\\nGraphPath<V,E> certificate;\\nWeakChordalityInspector(Graph graph);\\nisWeaklyChordal();\\ngetCertificate();\\nlazyComputeWeakChordality();\\ncomputeGlobalSeparatorList();\\nreformatSeparatorList(List separators,E edge);\\ngetLabeling(E edge);\\nsortSeparatorsList(List separators);\\nunequalSeparators(List sep1,List sep2);\\ncomputeCoConnectedComponents(Graph graph,List separator);\\nputToNextBucket(Integer vertex,Integer vertexLabel,List bucketsByLabel,List labels);\\nreload(List bucketsByLabel,List labels,int minLabel);\\ncheckLabels(List coConnectedComponents,List separator);\\nfindHole(V sourceInSeparator,V source,V target,V targetInSeparator);\\nfindAntiHole(V source,V targetInSeparator);\\nfindHole(Graph graph,V sourceInSeparator,V source,V target,V targetInSeparator);\\nfindCycle(Set visited,Graph graph,V tarInSep,V tar,V sour,V sourInSep);\\nminimizeCycle(Graph graph,List cycle,V tar,V tarInSep,V sour,V sourInSep);\\nfindSeparators(Graph graph,E edge);\\ngetSeparator(Graph graph,V startVertex,Map dfsMap);\\nneighborhoodSetOf(Graph g,E edge);\\ninitMappings();\\n\", \"repo_level\" : \"\" }",
            "class_name": "WeakChordalityInspector",
            "code": "private void reload(List<Set<Integer>> bucketsByLabel,List<Integer> labels,int minLabel){\n  if (minLabel != 0 && minLabel < bucketsByLabel.size()) {\n    Set<Integer> bucket=bucketsByLabel.get(minLabel);\n    for (    Integer vertex : bucket) {\n      labels.set(vertex,0);\n      bucketsByLabel.get(0).add(vertex);\n    }\n    bucket.clear();\n  }\n}\n",
            "docstring": "/** \n * Moves all vertices from the bucket with label  {@code minLabel} to the bucket with label 0.Clears the bucket with label  {@code minLabel}. Updates the labeling accordingly.\n * @param bucketsByLabel the buckets vertices are stored in\n * @param labels the labels of the vertices\n * @param minLabel the minimum value of the non-empty bucket\n */\n",
            "end_lineno": "471",
            "file_content": "/*\n * (C) Copyright 2018-2021, by Timofey Chudakov and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.alg.cycle;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.util.*;\nimport org.jgrapht.generate.*;\nimport org.jgrapht.graph.*;\nimport org.jgrapht.util.*;\n\nimport java.util.*;\n\n/**\n * Tests whether a graph is <a href=\"http://www.graphclasses.org/classes/gc_14.html\">weakly\n * chordal</a>. Weakly chordal graphs are also known as weakly triangulated graphs. Triangulated in\n * the context of chordality has a different meaning than triangulated in the context of planarity,\n * where it refers to a maximal planar graph, see:\n * <a href=\"http://mathworld.wolfram.com/TriangulatedGraph.html\">\n * http://mathworld.wolfram.com/TriangulatedGraph.html</a>\n * <p>\n * The following definitions of are equivalent:\n * <ol>\n * <li>A graph is weakly chordal (weakly triangulated) if neither it nor its complement contains a\n * <a href=\"http://mathworld.wolfram.com/ChordlessCycle.html\">chordless cycles</a> with five or more\n * vertices.</li>\n * <li>A 2-pair in a graph is a pair of non-adjacent vertices $x$, $y$ such that every chordless\n * path has exactly two edges. A graph is weakly chordal if every connected\n * <a href=\"https://en.wikipedia.org/wiki/Induced_subgraph\">induced subgraph</a> $H$ that is not a\n * complete graph, contains a 2-pair.</li>\n * </ol>\n * Chordal and weakly chordal graphs are\n * <a href=\"http://mathworld.wolfram.com/PerfectGraph.html\">perfect</a>.<br>\n * For more details, refer to: Hayward, R.B. Weakly triangulated graphs, Journal of Combinatorial\n * Theory, Series B, vol 39, Issue 3, pp 200-208, 1985.\n * <p>\n * The implementation in this class is based on: Lars Severin Skeide (2002)\n * <a href=\"http://www.ii.uib.no/~skeide/rec_wcg.pdf\"><i>Recognizing weakly chordal graphs</i></a>.\n * Candidate Scientist Thesis in Informatics. Department of Informatics, University of Bergen,\n * Norway. The terminology used in this implementation is consistent with the one used in this\n * thesis.\n * <p>\n * Both the runtime complexity and space complexity of the algorithm implemented in this class is\n * $\\mathcal{O}(|E|^2)$.<br>\n * The inspected {@code graph} is specified at the construction time and cannot be modified. When\n * the graph is modified externally, the behavior of the {@code WeakChordalityInspector} is\n * undefined.\n * <p>\n * In the case the inspected graph in not weakly chordal, this inspector provides a certificate in\n * the form of some <a href = \"http://graphclasses.org/smallgraphs.html#holes\">hole</a> or\n * <a href=\"http://graphclasses.org/smallgraphs.html#antiholes\">anti-hole</a>. The running time of\n * finding a hole is $\\mathcal{O}(|V| + |E|)$ and of finding an anti-hole - $\\mathcal{O}(|E|^2)$ in\n * the worst case.\n *\n * @param <V> the graph vertex type\n * @param <E> the graph edge type\n * @author Timofey Chudakov\n */\npublic class WeakChordalityInspector<V, E>\n{\n    /**\n     * Vertex number\n     */\n    private final int n;\n    /**\n     * Edge number\n     */\n    private final int m;\n    /**\n     * The inspected graph\n     */\n    private Graph<V, E> graph;\n    /**\n     * Bijective mapping of vertices onto $\\left[0,n-1\\right]$\n     */\n    private Map<V, Integer> vertices;\n    /**\n     * Inverse of the bijective mapping of vertices onto $\\left[0,n-1\\right]$\n     */\n    private List<V> indices;\n    /**\n     * Contains true if the graph is weakly chordal, otherwise false. Is null before the first call\n     * to the {@link WeakChordalityInspector#isWeaklyChordal()}.\n     */\n    private Boolean weaklyChordal = null;\n    /**\n     * Contains a hole or an anti-hole of the graph, if it isn't weakly chordal\n     */\n    private GraphPath<V, E> certificate;\n\n    /**\n     * Creates a weak chordality inspector for the {@code graph}\n     *\n     * @param graph the inspected {@code graph}\n     */\n    public WeakChordalityInspector(Graph<V, E> graph)\n    {\n        this.graph = Objects.requireNonNull(graph);\n        if (graph.getType().isDirected()) {\n            this.graph = new AsUndirectedGraph<>(graph);\n        }\n        n = graph.vertexSet().size();\n        m = graph.edgeSet().size();\n        initMappings();\n    }\n\n    /**\n     * Initializes the mappings of the vertices\n     */\n    private void initMappings()\n    {\n        VertexToIntegerMapping<V> mapping = new VertexToIntegerMapping<>(graph.vertexSet());\n        vertices = mapping.getVertexMap();\n        indices = mapping.getIndexList();\n    }\n\n    /**\n     * Check whether the inspected {@code graph} is weakly chordal. Note: this value is computed\n     * lazily.\n     *\n     * @return true, if the inspected {@code graph} is weakly chordal, otherwise false.\n     */\n    public boolean isWeaklyChordal()\n    {\n        return lazyComputeWeakChordality();\n    }\n\n    /**\n     * Computes and returns the certificate in the form of a hole or anti-hole in the inspected\n     * {@code graph}. Returns null if the inspected graph is weakly chordal. Note: certificate is\n     * computed lazily.\n     *\n     * @return a <a href=\"http://graphclasses.org/smallgraphs.html#holes\">hole</a> or\n     *         <a href=\"http://graphclasses.org/smallgraphs.html#antiholes\">anti-hole</a> in the\n     *         inspected {@code graph}, null if the {@code graph} is weakly chordal\n     */\n    public GraphPath<V, E> getCertificate()\n    {\n        lazyComputeWeakChordality();\n        return certificate;\n    }\n\n    /**\n     * Lazily tests the weak chordality of the {@code graph} and returns the computed value.\n     *\n     * @return true, if the inspected {@code graph} is weakly chordal, otherwise false.\n     */\n    private boolean lazyComputeWeakChordality()\n    {\n        if (weaklyChordal == null) {\n            List<Pair<List<Pair<Integer, Integer>>, E>> globalSeparatorList =\n                computeGlobalSeparatorList();\n\n            if (globalSeparatorList.size() > 0) {\n                Pair<Integer, Integer> pair;\n                sortSeparatorsList(globalSeparatorList);\n\n                // Iterating over separators. Computing coconnected components only for distinct\n                // separators\n                int separatorsNum = 1;\n                List<Pair<Integer, Integer>> original = globalSeparatorList.get(0).getFirst();\n                List<List<Integer>> coConnectedComponents =\n                    computeCoConnectedComponents(graph, original);\n\n                for (Pair<List<Pair<Integer, Integer>>, E> separator : globalSeparatorList) {\n                    if (unequalSeparators(original, separator.getFirst())) {\n                        original = separator.getFirst();\n                        ++separatorsNum;\n                        if (n + m < separatorsNum) {\n                            return weaklyChordal = false;\n                        } else {\n                            coConnectedComponents = computeCoConnectedComponents(graph, original);\n                        }\n                    }\n                    if ((pair = checkLabels(coConnectedComponents, separator.getFirst())) != null) {\n                        // Found a pair of vertices which has labels 1 and 2. This means the graph\n                        // isn't weakly chordal. Start detecting a hole\n                        E holeFormer = separator.getSecond();\n                        V source = graph.getEdgeSource(holeFormer);\n                        V target = graph.getEdgeTarget(holeFormer);\n\n                        V sourceInSeparator = indices.get(pair.getFirst());\n                        V targetInSeparator = indices.get(pair.getSecond());\n\n                        if (!graph.containsEdge(source, sourceInSeparator)) {\n                            V t = sourceInSeparator;\n                            sourceInSeparator = targetInSeparator;\n                            targetInSeparator = t;\n                        }\n                        if (graph.containsEdge(sourceInSeparator, targetInSeparator)) {\n                            findAntiHole(source, targetInSeparator);\n                        } else {\n                            findHole(sourceInSeparator, source, target, targetInSeparator);\n                        }\n                        return weaklyChordal = false;\n                    }\n                }\n\n                return weaklyChordal = true;\n            } else {\n\n                return weaklyChordal = true;\n            }\n        }\n        return weaklyChordal;\n    }\n\n    /**\n     * Computes the global separator list of the {@code graph}. More precisely, for every edge $e$\n     * in the $G = (V, E)$ computes list of minimal separators $S_e$ in the neighborhood of $e$ and\n     * then concatenates these lists. Note: the result may contain duplicates\n     *\n     * @return the list of minimal separators of every edge $e$ in the inspected graph\n     */\n    private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList()\n    {\n        List<Pair<List<Pair<Integer, Integer>>, E>> globalSeparatorList = new ArrayList<>();\n        for (E edge : graph.edgeSet()) {\n            V source = graph.getEdgeSource(edge);\n            V target = graph.getEdgeTarget(edge);\n            if (source != target) {\n                List<Set<V>> edgeSeparators = findSeparators(graph, edge);\n                globalSeparatorList.addAll(reformatSeparatorList(edgeSeparators, edge));\n            }\n        }\n        return globalSeparatorList;\n    }\n\n    /**\n     * Reformats the list o {@code separators} so that is can be conveniently used by this\n     * inspector. More precisely, in every separator from the list of minimal separators in the\n     * neighborhood of the {@code edge} substitutes all vertices for their indices in the numeration\n     * defined by {@code vertices}. Pairs every separator with the {@code edge}.\n     *\n     * @param separators the list of minimal separators in the neighborhood of the {@code edge}\n     * @param edge the edge, which neighborhood contains minimal separators from {@code separators}\n     * @return the reformatted list of minimal separators\n     */\n    private List<Pair<List<Pair<Integer, Integer>>, E>> reformatSeparatorList(\n        List<Set<V>> separators, E edge)\n    {\n        List<Integer> labeling = getLabeling(edge);\n        List<Pair<List<Pair<Integer, Integer>>, E>> reformattedSeparators = new ArrayList<>();\n        List<List<List<Pair<Integer, Integer>>>> vInSeparator = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            vInSeparator.add(new ArrayList<>());\n        }\n\n        for (Set<V> computedSeparator : separators) {\n            List<Pair<Integer, Integer>> reformattedSeparator =\n                new ArrayList<>(computedSeparator.size());\n            reformattedSeparators.add(new Pair<>(reformattedSeparator, edge));\n            for (V vertex : computedSeparator) {\n                int vertexIndex = vertices.get(vertex);\n                vInSeparator.get(vertexIndex).add(reformattedSeparator);\n            }\n        }\n\n        for (int vertex = 0; vertex < n; vertex++) {\n            List<List<Pair<Integer, Integer>>> listOfSeparators = vInSeparator.get(vertex);\n            for (List<Pair<Integer, Integer>> separator : listOfSeparators) {\n                separator.add(new Pair<>(vertex, labeling.get(vertex)));\n            }\n        }\n\n        return reformattedSeparators;\n\n    }\n\n    /**\n     * Computes the labeling of the neighborhood of {@code edge} on the vertices {@code source} and\n     * {@code target}. Vertex from the neighborhood is labeled with \"1\" if it sees only\n     * {@code source}, \"2\" is it sees only {@code target}, and \"3\" if it sees both vertices.\n     *\n     * @param edge the edge, whose neighborhood is to be labeled\n     * @return the computed labeling with the respect to the rule described above\n     */\n    private List<Integer> getLabeling(E edge)\n    {\n        V source = graph.getEdgeSource(edge);\n        V target = graph.getEdgeTarget(edge);\n        List<Integer> labeling = new ArrayList<>(Collections.nCopies(n, null));\n        for (E sourceEdge : graph.edgesOf(source)) {\n            labeling.set(vertices.get(Graphs.getOppositeVertex(graph, sourceEdge, source)), 1);\n        }\n        for (E targetEdge : graph.edgesOf(target)) {\n            Integer oppositeIndex =\n                vertices.get(Graphs.getOppositeVertex(graph, targetEdge, target));\n            if (labeling.get(oppositeIndex) != null) {\n                labeling.set(oppositeIndex, 3);\n            } else {\n                labeling.set(oppositeIndex, 2);\n            }\n        }\n        return labeling;\n    }\n\n    /**\n     * Sorts the {@code separators} using bucket sort\n     *\n     * @param separators the list of separators to be sorted\n     */\n    private void sortSeparatorsList(List<Pair<List<Pair<Integer, Integer>>, E>> separators)\n    {\n        Queue<Pair<List<Pair<Integer, Integer>>, E>> mainQueue = new ArrayDeque<>();\n        int maxSeparatorLength = 0;\n        for (Pair<List<Pair<Integer, Integer>>, E> separator : separators) {\n            if (separator.getFirst().size() > maxSeparatorLength) {\n                maxSeparatorLength = separator.getFirst().size();\n            }\n            mainQueue.add(separator);\n        }\n        separators.clear();\n        List<Queue<Pair<List<Pair<Integer, Integer>>, E>>> queues = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            queues.add(new LinkedList<>());\n        }\n        for (int i = 0; i < maxSeparatorLength; i++) {\n            while (!mainQueue.isEmpty()) {\n                Pair<List<Pair<Integer, Integer>>, E> separator = mainQueue.remove();\n                if (i >= separator.getFirst().size()) {\n                    separators.add(separator);\n                } else {\n                    queues\n                        .get(\n                            separator\n                                .getFirst().get(separator.getFirst().size() - i - 1).getFirst())\n                        .add(separator);\n                }\n            }\n            for (Queue<Pair<List<Pair<Integer, Integer>>, E>> queue : queues) {\n                mainQueue.addAll(queue);\n                queue.clear();\n            }\n        }\n        separators.addAll(mainQueue);\n    }\n\n    /**\n     * Compares two separators for inequality. Labeling of the vertices in the separators isn't\n     * considered\n     *\n     * @param sep1 first separator\n     * @param sep2 second separator\n     * @return true, if the separators are unequal, false otherwise\n     */\n    private boolean unequalSeparators(\n        List<Pair<Integer, Integer>> sep1, List<Pair<Integer, Integer>> sep2)\n    {\n        if (sep1.size() == sep2.size()) {\n            for (int i = 0; i < sep1.size(); i++) {\n                if (!sep2.get(i).getFirst().equals(sep1.get(i).getFirst())) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Computes the connected components of the complement of the graph induces by the vertices of\n     * the {@code separator}. They are also called \"coconnected components\". The running time is\n     * $\\mathcal{O}(|V| + |E|)$.\n     *\n     * @param separator the separators, whose coconnected components are computed\n     * @return the coconected of the {@code separator}\n     */\n    private List<List<Integer>> computeCoConnectedComponents(\n        Graph<V, E> graph, List<Pair<Integer, Integer>> separator)\n    {\n        List<List<Integer>> coConnectedComponents = new ArrayList<>();\n\n        // Initializing buckets, labels and set of unvisited vertices. Every vertex in separator is\n        // put\n        // to bucket with label 0\n        List<Set<Integer>> bucketsByLabel = new ArrayList<>(separator.size());\n        for (int i = 0; i < separator.size(); i++) {\n            bucketsByLabel.add(new HashSet<>());\n        }\n        List<Integer> labels = new ArrayList<>(Collections.nCopies(n, -1));\n        Set<Integer> unvisited = CollectionUtil.newHashSetWithExpectedSize(separator.size());\n        separator.forEach(pair -> {\n            unvisited.add(pair.getFirst());\n            labels.set(pair.getFirst(), 0);\n        });\n        bucketsByLabel.set(0, unvisited);\n        int minLabel = 0;\n\n        while (unvisited.size() > 0) {\n            List<Integer> coConnectedComponent = new ArrayList<>();\n            do {\n                // When minLabel = coConnectedComponent.size(), we've visited all vertices in some\n                // coconnected component in the separator. If there exist unvisited vertices, we\n                // start again\n                while (!bucketsByLabel.get(minLabel).isEmpty()) {\n                    Integer vertex = bucketsByLabel.get(minLabel).iterator().next();\n                    bucketsByLabel.get(minLabel).remove(vertex);\n                    coConnectedComponent.add(vertex);\n                    labels.set(vertex, -1);\n\n                    for (E edge : graph.edgesOf(indices.get(vertex))) {\n                        Integer opposite = vertices\n                            .get(Graphs.getOppositeVertex(graph, edge, indices.get(vertex)));\n                        Integer oppositeLabel = labels.get(opposite);\n                        if (oppositeLabel != -1) {\n                            putToNextBucket(opposite, oppositeLabel, bucketsByLabel, labels);\n                        }\n                    }\n                }\n                ++minLabel;\n            } while (minLabel != coConnectedComponent.size());\n            reload(bucketsByLabel, labels, minLabel);\n\n            coConnectedComponents.add(coConnectedComponent);\n            minLabel = 0;\n        }\n        return coConnectedComponents;\n    }\n\n    /**\n     * Moves the {@code vertex} to the next bucket.\n     *\n     * @param vertex the vertex to be moved\n     * @param vertexLabel the label of the {@code vertex}\n     * @param bucketsByLabel the buckets, in which vertices are stored\n     * @param labels the labels of the vertices\n     */\n    private void putToNextBucket(\n        Integer vertex, Integer vertexLabel, List<Set<Integer>> bucketsByLabel,\n        List<Integer> labels)\n    {\n        bucketsByLabel.get(vertexLabel).remove(vertex);\n        bucketsByLabel.get(vertexLabel + 1).add(vertex);\n        labels.set(vertex, vertexLabel + 1);\n    }\n\n    /**\n     * Moves all vertices from the bucket with label {@code minLabel} to the bucket with label 0.\n     * Clears the bucket with label {@code minLabel}. Updates the labeling accordingly.\n     *\n     * @param bucketsByLabel the buckets vertices are stored in\n     * @param labels the labels of the vertices\n     * @param minLabel the minimum value of the non-empty bucket\n     */\n    private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel)\n    {\n        if (minLabel != 0 && minLabel < bucketsByLabel.size()) {\n            Set<Integer> bucket = bucketsByLabel.get(minLabel);\n            for (Integer vertex : bucket) {\n                labels.set(vertex, 0);\n                bucketsByLabel.get(0).add(vertex);\n            }\n            bucket.clear();\n        }\n    }\n\n    /**\n     * For a given coconnected component of the {@code separator} checks whether every vertex in it\n     * is seen by al least one vertex of the edge that is separated by the {@code separator}\n     *\n     * @param coConnectedComponents the set of the coconected components of the {@code separator}\n     * @param separator minimal separator of some edge in the {@code graph}\n     * @return true if the condition described above holds, false otherwise\n     */\n    private Pair<Integer, Integer> checkLabels(\n        List<List<Integer>> coConnectedComponents, List<Pair<Integer, Integer>> separator)\n    {\n        List<Integer> vertexLabels = new ArrayList<>(Collections.nCopies(n, null));\n        for (Pair<Integer, Integer> vertexAndLabel : separator) {\n            vertexLabels.set(vertexAndLabel.getFirst(), vertexAndLabel.getSecond());\n        }\n        for (List<Integer> coConnectedComponent : coConnectedComponents) {\n            int label = 0;\n            Integer labelVertex = null;\n            for (Integer vertex : coConnectedComponent) {\n                if (vertexLabels.get(vertex) != 3) {\n                    if (label != 0) {\n                        if (label != vertexLabels.get(vertex)) {\n                            return new Pair<>(labelVertex, vertex);\n                        }\n                    } else {\n                        label = vertexLabels.get(vertex);\n                        labelVertex = vertex;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Finds a hole in the inspected {@code graph}. Vertices {@code sourceInSeparator},\n     * {@code source}, {@code target} and {@code targetInSeparator} belong to the computes hole.\n     * They are used to correctly find a hole in the inspected graph.\n     *\n     * @param sourceInSeparator vertex on the hole\n     * @param source vertex on the hole\n     * @param target vertex on the hole\n     * @param targetInSeparator vertex on the hole\n     */\n    private void findHole(V sourceInSeparator, V source, V target, V targetInSeparator)\n    {\n        this.certificate = findHole(graph, sourceInSeparator, source, target, targetInSeparator);\n    }\n\n    /**\n     * Finds an anti-hole in the inspected {@code graph}. Vertices {@code source} and\n     * {@code targetInSeparator} specify an edge, which belongs to the anti-hole in the complement\n     * of the {@code graph}. Then the hole in the complement of the graph is computed in the graph's\n     * complement in the same way a hole is computed in the {@code graph}.\n     *\n     * @param source endpoint of the edge that belongs to the anti-hole\n     * @param targetInSeparator endpoint of the edge that belongs to the anti-hole\n     */\n    private void findAntiHole(V source, V targetInSeparator)\n    {\n        // Generating the complement of the inspected graph\n        ComplementGraphGenerator<V, E> generator = new ComplementGraphGenerator<>(graph, false);\n        Graph<V, E> complement = Pseudograph.<V, E> createBuilder(graph.getEdgeSupplier()).build();\n        generator.generateGraph(complement);\n\n        E cycleFormer = complement.getEdge(source, targetInSeparator);\n        V cycleSource = graph.getEdgeSource(cycleFormer);\n        V cycleTarget = graph.getEdgeTarget(cycleFormer);\n\n        // For edge cycleFormer we need to find the separator, which contains vertices with labels 1\n        // and 2\n        // After that the procedure of detecting a hole in the complement of the graph is identical\n        // to finding a hole in the graph itself\n        List<Set<V>> separators = findSeparators(complement, cycleFormer);\n        List<Pair<List<Pair<Integer, Integer>>, E>> reformatted =\n            reformatSeparatorList(separators, cycleFormer);\n\n        sortSeparatorsList(reformatted);\n\n        List<Pair<Integer, Integer>> original = reformatted.get(0).getFirst();\n        List<List<Integer>> coConnectedComponents =\n            computeCoConnectedComponents(complement, original);\n\n        Pair<Integer, Integer> pair;\n        for (Pair<List<Pair<Integer, Integer>>, E> separator : reformatted) {\n            if (unequalSeparators(separator.getFirst(), original)) {\n                original = separator.getFirst();\n                coConnectedComponents =\n                    computeCoConnectedComponents(complement, separator.getFirst());\n            }\n            if ((pair = checkLabels(coConnectedComponents, separator.getFirst())) != null) {\n                // Found a pair of vertices with labels 1 and 2\n                V cycleSourceInSeparator = indices.get(pair.getFirst());\n                V cycleTargetInSeparator = indices.get(pair.getSecond());\n                if (!complement.containsEdge(cycleSourceInSeparator, cycleSource)) {\n                    V t = cycleSourceInSeparator;\n                    cycleSourceInSeparator = cycleTargetInSeparator;\n                    cycleTargetInSeparator = t;\n                }\n                this.certificate = findHole(\n                    complement, cycleSourceInSeparator, cycleSource, cycleTarget,\n                    cycleTargetInSeparator);\n                return;\n            }\n        }\n    }\n\n    /**\n     * Finds a hole in the specified {@code graph}. Vertices {@code sourceInSeparator},\n     * {@code source}, {@code target} and {@code targetInSeparator} belong to the computes hole.\n     * They are used to correctly find a hole in the specified {@code graph}.\n     *\n     * @param sourceInSeparator vertex on the hole\n     * @param source vertex on the hole\n     * @param target vertex on the hole\n     * @param targetInSeparator vertex on the hole\n     * @return the computed hole on the {@code graph}\n     */\n    private GraphPath<V, E> findHole(\n        Graph<V, E> graph, V sourceInSeparator, V source, V target, V targetInSeparator)\n    {\n        Set<V> visited = CollectionUtil.newHashSetWithExpectedSize(graph.vertexSet().size());\n        visited.add(target);\n        visited.add(source);\n\n        // Obtaining some cycle, which can be minimized to a hole\n        List<V> cycle =\n            findCycle(visited, graph, targetInSeparator, target, source, sourceInSeparator);\n        cycle = minimizeCycle(graph, cycle, target, targetInSeparator, source, sourceInSeparator);\n\n        return new GraphWalk<>(graph, cycle, 0);\n    }\n\n    /**\n     * Starts the iterative depth-first traversal from {@code sourInSep} vertex. Tries to build a\n     * cycle with the vertices, which aren't adjacent to the {@code tar} and {@code sour}. This\n     * condition is used in order to ensure that the cycle contains a hole, to which it is later\n     * minimized.\n     *\n     * @param visited defines which vertices have been visited already\n     * @param graph the graph the search is performed on\n     * @param tarInSep the end point of the cycle\n     * @param tar the vertex, which can't be adjacent to the vertices in the cycle\n     * @param sour the vertex, which can't be adjacent to the vertices in the cycle\n     * @param sourInSep the vertex the search is started from\n     * @return the computed cycle, which contains a hole\n     */\n    private List<V> findCycle(\n        Set<V> visited, Graph<V, E> graph, V tarInSep, V tar, V sour, V sourInSep)\n    {\n        List<V> cycle = new ArrayList<>(Arrays.asList(tarInSep, tar, sour));\n        Deque<V> stack = new ArrayDeque<>();\n        stack.add(sourInSep);\n\n        while (!stack.isEmpty()) {\n            V currentVertex = stack.removeLast();\n            if (visited.add(currentVertex)) {\n\n                // trying to advance cycle from current vertex\n                // removing all vertices from the head of the cycle, which aren't adjacent to the\n                // current vertex\n                while (!graph.containsEdge(cycle.get(cycle.size() - 1), currentVertex)) {\n                    cycle.remove(cycle.size() - 1);\n                }\n                cycle.add(currentVertex);\n                if (tarInSep.equals(currentVertex)) {\n                    // the cycle is complete\n                    break;\n                } else {\n                    for (V neighbor : Graphs.neighborListOf(graph, currentVertex)) {\n                        // add a vertex to the stack if it hasn't been visited yet and it isn't\n                        // adjacent to the\n                        // source vertex and (it isn't adjacent to the target vertex or it is\n                        // targetInSeparator (the end of the cycle))\n                        if (!visited.contains(neighbor) && !graph.containsEdge(sour, neighbor)\n                            && (!graph.containsEdge(tar, neighbor) || neighbor.equals(tarInSep)))\n                        {\n                            stack.add(neighbor);\n                        }\n                    }\n                }\n            }\n        }\n        return cycle;\n    }\n\n    /**\n     * Minimizes the {@code cycle} so that it contains a hole in the {@code graph}. Vertices\n     * {@code tar}, {@code tarInSep}, {@code sour} and {@code sourInSep} belong to the final result.\n     *\n     * @param graph the graph, which contains vertices from {@code cycle}\n     * @param cycle the cycle to minimize\n     * @param tar vertex, which should belong to the final result\n     * @param tarInSep vertex, which should belong to the final result\n     * @param sour vertex, which should belong to the final result\n     * @param sourInSep vertex, which should belong to the final result\n     * @return a list of vertices, which defines a hole in the {@code graph}\n     */\n    private List<V> minimizeCycle(\n        Graph<V, E> graph, List<V> cycle, V tar, V tarInSep, V sour, V sourInSep)\n    {\n        List<V> minimizedCycle = new ArrayList<>(Arrays.asList(tarInSep, tar, sour));\n        Set<V> forwardVertices = new HashSet<>(cycle);\n        forwardVertices.remove(tar);\n        forwardVertices.remove(sour);\n        forwardVertices.remove(sourInSep);\n\n        for (int i = 3; i < cycle.size() - 1;) {\n            V current = cycle.get(i);\n            minimizedCycle.add(current);\n            forwardVertices.remove(current);\n\n            // Computing a set of vertices, which are adjacent to current and have greater index\n            // in the cycle than current\n            Set<V> currentForward = new HashSet<>();\n            for (V neighbor : Graphs.neighborListOf(graph, current)) {\n                if (forwardVertices.contains(neighbor)) {\n                    currentForward.add(neighbor);\n                }\n            }\n\n            // Jump to the forward vertex with the greatest index. Therefore we ensure, that\n            // the resulting cycle doesn't contain chords\n            for (V forwardVertex : currentForward) {\n                if (forwardVertices.contains(forwardVertex)) {\n                    do {\n                        forwardVertices.remove(cycle.get(i));\n                        i++;\n                    } while (i < cycle.size() && !cycle.get(i).equals(forwardVertex));\n                }\n            }\n        }\n        minimizedCycle.add(tarInSep);\n        return minimizedCycle;\n    }\n\n    /**\n     * Computes and returns all minimal separators in the neighborhood of the {@code edge} in the\n     * {@code graph}. The result may contain duplicate separators.\n     *\n     * @param graph the graph to search minimal separators in\n     * @param edge the edge, whose neighborhood is being explored\n     * @return the list of all minimal separators in the neighborhood of the {@code edge}. The\n     *         resulted list may contain duplicates.\n     */\n    private List<Set<V>> findSeparators(Graph<V, E> graph, E edge)\n    {\n        List<Set<V>> separators = new ArrayList<>();\n        V source = graph.getEdgeSource(edge);\n        V target = graph.getEdgeTarget(edge);\n        Set<V> neighborhood = neighborhoodSetOf(graph, edge);\n        Map<V, Byte> dfsMap = CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());\n\n        // 0 - unvisited (white), 1 - neighbor of the edge (red), 2 - visited (black)\n        for (V vertex : graph.vertexSet()) {\n            if (neighborhood.contains(vertex)) {\n                dfsMap.put(vertex, (byte) 1);\n            } else {\n                dfsMap.put(vertex, (byte) 0);\n            }\n        }\n        dfsMap.put(source, (byte) 2);\n        dfsMap.put(target, (byte) 2);\n\n        for (V vertex : graph.vertexSet()) {\n            if (dfsMap.get(vertex) == 0) {\n                // possible to find one more separator\n                Set<V> separator = getSeparator(graph, vertex, dfsMap);\n                if (!separator.isEmpty()) {\n                    separators.add(separator);\n                }\n            }\n        }\n\n        return separators;\n    }\n\n    /**\n     * Performs iterative depth-first search starting from the {@code startVertex} in the\n     * {@code graph}. Adds every encountered red vertex to the resulting separator. Doesn't process\n     * red vertices. Marks all white vertices with black color.\n     *\n     * @param graph the graph dfs is performed on\n     * @param startVertex the vertex to start depth-first traversal from\n     * @param dfsMap the depth-first vertex labeling\n     * @return the computed separator, which consists of all encountered red vertices\n     */\n    private Set<V> getSeparator(Graph<V, E> graph, V startVertex, Map<V, Byte> dfsMap)\n    {\n        Deque<V> stack = new ArrayDeque<>();\n        Set<V> separator = new HashSet<>();\n        stack.add(startVertex);\n\n        while (!stack.isEmpty()) {\n            V currentVertex = stack.removeLast();\n            if (dfsMap.get(currentVertex) == 0) {\n                dfsMap.put(currentVertex, (byte) 2);\n                for (E edge : graph.edgesOf(currentVertex)) {\n                    V opposite = Graphs.getOppositeVertex(graph, edge, currentVertex);\n                    if (dfsMap.get(opposite) == 0) {\n                        stack.add(opposite);\n                    } else if (dfsMap.get(opposite) == 1) {\n                        separator.add(opposite); // found red vertex, which belongs to the separator\n                    }\n                }\n            }\n        }\n\n        return separator;\n    }\n\n    /**\n     * Returns a set of vertices that are neighbors of the source of the specified edge or of the\n     * target of specified edge. The endpoints of the specified edge aren't included in the result.\n     *\n     * @param g the graph to look for neighbors in\n     * @param edge the edge to get the neighbors of\n     * @return a set of vertices that are neighbors of at least one endpoint of the specified edge.\n     *         The endpoints of the specified edge aren't included in the result\n     */\n    private Set<V> neighborhoodSetOf(Graph<V, E> g, E edge)\n    {\n        Set<V> neighborhood = new HashSet<>();\n\n        V source = g.getEdgeSource(edge);\n        V target = g.getEdgeTarget(edge);\n\n        for (E e : g.edgesOf(source)) {\n            neighborhood.add(Graphs.getOppositeVertex(g, e, source));\n        }\n        for (E e : g.edgesOf(target)) {\n            neighborhood.add(Graphs.getOppositeVertex(g, e, target));\n        }\n        neighborhood.remove(source);\n        neighborhood.remove(target);\n\n        return neighborhood;\n    }\n}\n",
            "file_name": "WeakChordalityInspector.java",
            "human_label": "Move all vertices from the minimum label bucket to the bucket with label 0 and clear the minimum label bucket.",
            "level": "self_contained",
            "lineno": "453",
            "name": "reload",
            "oracle_context": "{ \"apis\" : \"[size, get, set, add, clear]\", \"classes\" : \"[Set<Integer>]\", \"vars\" : \"[]\" }",
            "package": "org.jgrapht.alg.cycle",
            "project": "jgrapht-master"
        },
        {
            "_id": "6367676a1a6d9265ec0181d4",
            "all_context": "{ \"class_level\" : \"import java.nio.charset.Charset;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nimport java.util.Enumeration;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Locale;\\nimport java.util.Properties;\\nimport java.util.Set;\\nimport java.util.StringTokenizer;\\nimport java.util.TreeSet;\\nString FOLDER_SEPARATOR;\\nString WINDOWS_FOLDER_SEPARATOR;\\nString TOP_PATH;\\nString CURRENT_PATH;\\nchar EXTENSION_SEPARATOR;\\nCharset UTF_8;\\nStrings();\\nhasLength(String str);\\nhasText(CharSequence str);\\nhasText(String str);\\ncontainsWhitespace(CharSequence str);\\ncontainsWhitespace(String str);\\ntrimWhitespace(String str);\\ntrimWhitespace(CharSequence str);\\nclean(String str);\\nclean(CharSequence str);\\ntrimAllWhitespace(String str);\\ntrimLeadingWhitespace(String str);\\ntrimTrailingWhitespace(String str);\\ntrimLeadingCharacter(String str,char leadingCharacter);\\ntrimTrailingCharacter(String str,char trailingCharacter);\\nstartsWithIgnoreCase(String str,String prefix);\\nendsWithIgnoreCase(String str,String suffix);\\nsubstringMatch(CharSequence str,int index,CharSequence substring);\\ncountOccurrencesOf(String str,String sub);\\nreplace(String inString,String oldPattern,String newPattern);\\ndelete(String inString,String pattern);\\ndeleteAny(String inString,String charsToDelete);\\nquote(String str);\\nquoteIfString(Object obj);\\nunqualify(String qualifiedName);\\nunqualify(String qualifiedName,char separator);\\ncapitalize(String str);\\nuncapitalize(String str);\\nchangeFirstCharacterCase(String str,boolean capitalize);\\ngetFilename(String path);\\ngetFilenameExtension(String path);\\nstripFilenameExtension(String path);\\napplyRelativePath(String path,String relativePath);\\ncleanPath(String path);\\npathEquals(String path1,String path2);\\nparseLocaleString(String localeString);\\nvalidateLocalePart(String localePart);\\ntoLanguageTag(Locale locale);\\naddStringToArray(String[] array,String str);\\nconcatenateStringArrays(String[] array1,String[] array2);\\nmergeStringArrays(String[] array1,String[] array2);\\nsortStringArray(String[] array);\\ntoStringArray(Collection collection);\\ntoStringArray(Enumeration enumeration);\\ntrimArrayElements(String[] array);\\nremoveDuplicateStrings(String[] array);\\nsplit(String toSplit,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter,String charsToDelete);\\ntokenizeToStringArray(String str,String delimiters);\\ntokenizeToStringArray(String str,String delimiters,boolean trimTokens,boolean ignoreEmptyTokens);\\ndelimitedListToStringArray(String str,String delimiter);\\ndelimitedListToStringArray(String str,String delimiter,String charsToDelete);\\ncommaDelimitedListToStringArray(String str);\\ncommaDelimitedListToSet(String str);\\ncollectionToDelimitedString(Collection coll,String delim,String prefix,String suffix);\\ncollectionToDelimitedString(Collection coll,String delim);\\ncollectionToCommaDelimitedString(Collection coll);\\narrayToDelimitedString(Object[] arr,String delim);\\narrayToCommaDelimitedString(Object[] arr);\\nhasLength(CharSequence str);\\n\", \"repo_level\" : \"\" }",
            "class_name": "Strings",
            "code": "public static String[] addStringToArray(String[] array,String str){\n  if (Objects.isEmpty(array)) {\n    return new String[]{str};\n  }\n  String[] newArr=new String[array.length + 1];\n  System.arraycopy(array,0,newArr,0,array.length);\n  newArr[array.length]=str;\n  return newArr;\n}\n",
            "docstring": "/** \n * Append the given String to the given String array, returning a new array consisting of the input array contents plus the given String.\n * @param array the array to append to (can be <code>null</code>)\n * @param str the String to append\n * @return the new array (never <code>null</code>)\n */\n",
            "end_lineno": "734",
            "file_content": "/*\n * Copyright (C) 2014 jsonwebtoken.io\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.jsonwebtoken.lang;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic final class Strings {\n\n    private static final String FOLDER_SEPARATOR = \"/\";\n\n    private static final String WINDOWS_FOLDER_SEPARATOR = \"\\\\\";\n\n    private static final String TOP_PATH = \"..\";\n\n    private static final String CURRENT_PATH = \".\";\n\n    private static final char EXTENSION_SEPARATOR = '.';\n\n    public static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    private Strings(){} //prevent instantiation\n\n    //---------------------------------------------------------------------\n    // General convenience methods for working with Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Check that the given CharSequence is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a CharSequence that purely consists of whitespace.\n     * <pre>\n     * Strings.hasLength(null) = false\n     * Strings.hasLength(\"\") = false\n     * Strings.hasLength(\" \") = true\n     * Strings.hasLength(\"Hello\") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(CharSequence str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasLength(CharSequence)\n     */\n    public static boolean hasLength(String str) {\n        return hasLength((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <pre>\n     * Strings.hasText(null) = false\n     * Strings.hasText(\"\") = false\n     * Strings.hasText(\" \") = false\n     * Strings.hasText(\"12345\") = true\n     * Strings.hasText(\" 12345 \") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not <code>null</code>,\n     * its length is greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     * greater than 0, and it does not contain whitespace only\n     * @see #hasText(CharSequence)\n     */\n    public static boolean hasText(String str) {\n        return hasText((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence contains any whitespace characters.\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not empty and\n     * contains at least 1 whitespace character\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean containsWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String contains any whitespace characters.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not empty and\n     * contains at least 1 whitespace character\n     * @see #containsWhitespace(CharSequence)\n     */\n    public static boolean containsWhitespace(String str) {\n        return containsWhitespace((CharSequence) str);\n    }\n\n    /**\n     * Trim leading and trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimWhitespace(String str) {\n        return (String) trimWhitespace((CharSequence)str);\n    }\n    \n    \n    private static CharSequence trimWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        final int length = str.length();\n\n        int start = 0;\n\t\twhile (start < length && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        \n\t\tint end = length;\n        while (start < length && Character.isWhitespace(str.charAt(end - 1))) {\n            end--;\n        }\n        \n        return ((start > 0) || (end < length)) ? str.subSequence(start, end) : str;\n    }\n\n    public static String clean(String str) {\n    \tCharSequence result = clean((CharSequence) str);\n        \n        return result!=null?result.toString():null;\n    }\n    \n    public static CharSequence clean(CharSequence str) {\n        str = trimWhitespace(str);\n        if (!hasLength(str)) {\n            return null;\n        }\n        return str;\n    }\n\n    /**\n     * Trim <i>all</i> whitespace from the given String:\n     * leading, trailing, and intermediate characters.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimAllWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        int index = 0;\n        while (sb.length() > index) {\n            if (Character.isWhitespace(sb.charAt(index))) {\n                sb.deleteCharAt(index);\n            }\n            else {\n                index++;\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim leading whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimLeadingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimTrailingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied leading character from the given String.\n     * @param str the String to check\n     * @param leadingCharacter the leading character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimLeadingCharacter(String str, char leadingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied trailing character from the given String.\n     * @param str the String to check\n     * @param trailingCharacter the trailing character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimTrailingCharacter(String str, char trailingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n\n    /**\n     * Returns {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @param str the String to check\n     * @param prefix the prefix to look for\n     * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @param str the String to check\n     * @param suffix the suffix to look for\n     * @return {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @see java.lang.String#endsWith\n     */\n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        if (str == null || suffix == null) {\n            return false;\n        }\n        if (str.endsWith(suffix)) {\n            return true;\n        }\n        if (str.length() < suffix.length()) {\n            return false;\n        }\n\n        String lcStr = str.substring(str.length() - suffix.length()).toLowerCase();\n        String lcSuffix = suffix.toLowerCase();\n        return lcStr.equals(lcSuffix);\n    }\n\n    /**\n     * Returns {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     * @param str the original string (or StringBuilder)\n     * @param index the index in the original string to start matching against\n     * @param substring the substring to match at the given index\n     * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     */\n    public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n        for (int j = 0; j < substring.length(); j++) {\n            int i = index + j;\n            if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the number of occurrences the substring {@code sub} appears in string {@code str}.\n     * @param str string to search in. Return 0 if this is null.\n     * @param sub string to search for. Return 0 if this is null.\n     * @return the number of occurrences the substring {@code sub} appears in string {@code str}.\n     */\n    public static int countOccurrencesOf(String str, String sub) {\n        if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n            return 0;\n        }\n        int count = 0;\n        int pos = 0;\n        int idx;\n        while ((idx = str.indexOf(sub, pos)) != -1) {\n            ++count;\n            pos = idx + sub.length();\n        }\n        return count;\n    }\n\n    /**\n     * Replace all occurrences of a substring within a string with\n     * another string.\n     * @param inString String to examine\n     * @param oldPattern String to replace\n     * @param newPattern String to insert\n     * @return a String with the replacements\n     */\n    public static String replace(String inString, String oldPattern, String newPattern) {\n        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        int pos = 0; // our position in the old string\n        int index = inString.indexOf(oldPattern);\n        // the index of an occurrence we've found, or -1\n        int patLen = oldPattern.length();\n        while (index >= 0) {\n            sb.append(inString.substring(pos, index));\n            sb.append(newPattern);\n            pos = index + patLen;\n            index = inString.indexOf(oldPattern, pos);\n        }\n        sb.append(inString.substring(pos));\n        // remember to append any characters to the right of a match\n        return sb.toString();\n    }\n\n    /**\n     * Delete all occurrences of the given substring.\n     * @param inString the original String\n     * @param pattern the pattern to delete all occurrences of\n     * @return the resulting String\n     */\n    public static String delete(String inString, String pattern) {\n        return replace(inString, pattern, \"\");\n    }\n\n    /**\n     * Delete any character in a given String.\n     * @param inString the original String\n     * @param charsToDelete a set of characters to delete.\n     * E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n     * @return the resulting String\n     */\n    public static String deleteAny(String inString, String charsToDelete) {\n        if (!hasLength(inString) || !hasLength(charsToDelete)) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < inString.length(); i++) {\n            char c = inString.charAt(i);\n            if (charsToDelete.indexOf(c) == -1) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with formatted Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Quote the given String with single quotes.\n     * @param str the input String (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or <code>null</code> if the input was <code>null</code>\n     */\n    public static String quote(String str) {\n        return (str != null ? \"'\" + str + \"'\" : null);\n    }\n\n    /**\n     * Turn the given Object into a String with single quotes\n     * if it is a String; keeping the Object as-is else.\n     * @param obj the input Object (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or the input object as-is if not a String\n     */\n    public static Object quoteIfString(Object obj) {\n        return (obj instanceof String ? quote((String) obj) : obj);\n    }\n\n    /**\n     * Unqualify a string qualified by a '.' dot character. For example,\n     * \"this.name.is.qualified\", returns \"qualified\".\n     * @param qualifiedName the qualified name\n     * @return an unqualified string by stripping all previous text before (and including) the last period character.\n     */\n    public static String unqualify(String qualifiedName) {\n        return unqualify(qualifiedName, '.');\n    }\n\n    /**\n     * Unqualify a string qualified by a separator character. For example,\n     * \"this:name:is:qualified\" returns \"qualified\" if using a ':' separator.\n     * @param qualifiedName the qualified name\n     * @param separator the separator\n     * @return an unqualified string by stripping all previous text before and including the last {@code separator} character.\n     */\n    public static String unqualify(String qualifiedName, char separator) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);\n    }\n\n    /**\n     * Capitalize a <code>String</code>, changing the first letter to\n     * upper case as per {@link Character#toUpperCase(char)}.\n     * No other letters are changed.\n     * @param str the String to capitalize, may be <code>null</code>\n     * @return the capitalized String, <code>null</code> if null\n     */\n    public static String capitalize(String str) {\n        return changeFirstCharacterCase(str, true);\n    }\n\n    /**\n     * Uncapitalize a <code>String</code>, changing the first letter to\n     * lower case as per {@link Character#toLowerCase(char)}.\n     * No other letters are changed.\n     * @param str the String to uncapitalize, may be <code>null</code>\n     * @return the uncapitalized String, <code>null</code> if null\n     */\n    public static String uncapitalize(String str) {\n        return changeFirstCharacterCase(str, false);\n    }\n\n    private static String changeFirstCharacterCase(String str, boolean capitalize) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str.length());\n        if (capitalize) {\n            sb.append(Character.toUpperCase(str.charAt(0)));\n        }\n        else {\n            sb.append(Character.toLowerCase(str.charAt(0)));\n        }\n        sb.append(str.substring(1));\n        return sb.toString();\n    }\n\n    /**\n     * Extract the filename from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"myfile.txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename, or <code>null</code> if none\n     */\n    public static String getFilename(String path) {\n        if (path == null) {\n            return null;\n        }\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);\n    }\n\n    /**\n     * Extract the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename extension, or <code>null</code> if none\n     */\n    public static String getFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return null;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return null;\n        }\n        return path.substring(extIndex + 1);\n    }\n\n    /**\n     * Strip the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"mypath/myfile\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the path with stripped filename extension,\n     * or <code>null</code> if none\n     */\n    public static String stripFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return path;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return path;\n        }\n        return path.substring(0, extIndex);\n    }\n\n    /**\n     * Apply the given relative path to the given path,\n     * assuming standard Java folder separation (i.e. \"/\" separators).\n     * @param path the path to start from (usually a full file path)\n     * @param relativePath the relative path to apply\n     * (relative to the full file path above)\n     * @return the full file path that results from applying the relative path\n     */\n    public static String applyRelativePath(String path, String relativePath) {\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (separatorIndex != -1) {\n            String newPath = path.substring(0, separatorIndex);\n            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n                newPath += FOLDER_SEPARATOR;\n            }\n            return newPath + relativePath;\n        }\n        else {\n            return relativePath;\n        }\n    }\n\n    /**\n     * Normalize the path by suppressing sequences like \"path/..\" and\n     * inner simple dots.\n     * <p>The result is convenient for path comparison. For other uses,\n     * notice that Windows separators (\"\\\") are replaced by simple slashes.\n     * @param path the original path\n     * @return the normalized path\n     */\n    public static String cleanPath(String path) {\n        if (path == null) {\n            return null;\n        }\n        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);\n\n        // Strip prefix from path to analyze, to not treat it as part of the\n        // first path element. This is necessary to correctly parse paths like\n        // \"file:core/../core/io/Resource.class\", where the \"..\" should just\n        // strip the first \"core\" directory while keeping the \"file:\" prefix.\n        int prefixIndex = pathToUse.indexOf(\":\");\n        String prefix = \"\";\n        if (prefixIndex != -1) {\n            prefix = pathToUse.substring(0, prefixIndex + 1);\n            pathToUse = pathToUse.substring(prefixIndex + 1);\n        }\n        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {\n            prefix = prefix + FOLDER_SEPARATOR;\n            pathToUse = pathToUse.substring(1);\n        }\n\n        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);\n        List<String> pathElements = new LinkedList<String>();\n        int tops = 0;\n\n        for (int i = pathArray.length - 1; i >= 0; i--) {\n            String element = pathArray[i];\n            if (CURRENT_PATH.equals(element)) {\n                // Points to current directory - drop it.\n            }\n            else if (TOP_PATH.equals(element)) {\n                // Registering top path found.\n                tops++;\n            }\n            else {\n                if (tops > 0) {\n                    // Merging path element with element corresponding to top path.\n                    tops--;\n                }\n                else {\n                    // Normal path element found.\n                    pathElements.add(0, element);\n                }\n            }\n        }\n\n        // Remaining top paths need to be retained.\n        for (int i = 0; i < tops; i++) {\n            pathElements.add(0, TOP_PATH);\n        }\n\n        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);\n    }\n\n    /**\n     * Compare two paths after normalization of them.\n     * @param path1 first path for comparison\n     * @param path2 second path for comparison\n     * @return whether the two paths are equivalent after normalization\n     */\n    public static boolean pathEquals(String path1, String path2) {\n        return cleanPath(path1).equals(cleanPath(path2));\n    }\n\n    /**\n     * Parse the given <code>localeString</code> value into a {@link java.util.Locale}.\n     * <p>This is the inverse operation of {@link java.util.Locale#toString Locale's toString}.\n     * @param localeString the locale string, following <code>Locale's</code>\n     * <code>toString()</code> format (\"en\", \"en_UK\", etc);\n     * also accepts spaces as separators, as an alternative to underscores\n     * @return a corresponding <code>Locale</code> instance\n     */\n    public static Locale parseLocaleString(String localeString) {\n        String[] parts = tokenizeToStringArray(localeString, \"_ \", false, false);\n        String language = (parts.length > 0 ? parts[0] : \"\");\n        String country = (parts.length > 1 ? parts[1] : \"\");\n        validateLocalePart(language);\n        validateLocalePart(country);\n        String variant = \"\";\n        if (parts.length >= 2) {\n            // There is definitely a variant, and it is everything after the country\n            // code sans the separator between the country code and the variant.\n            int endIndexOfCountryCode = localeString.indexOf(country) + country.length();\n            // Strip off any leading '_' and whitespace, what's left is the variant.\n            variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));\n            if (variant.startsWith(\"_\")) {\n                variant = trimLeadingCharacter(variant, '_');\n            }\n        }\n        return (language.length() > 0 ? new Locale(language, country, variant) : null);\n    }\n\n    private static void validateLocalePart(String localePart) {\n        for (int i = 0; i < localePart.length(); i++) {\n            char ch = localePart.charAt(i);\n            if (ch != '_' && ch != ' ' && !Character.isLetterOrDigit(ch)) {\n                throw new IllegalArgumentException(\n                    \"Locale part \\\"\" + localePart + \"\\\" contains invalid characters\");\n            }\n        }\n    }\n\n    /**\n     * Determine the RFC 3066 compliant language tag,\n     * as used for the HTTP \"Accept-Language\" header.\n     * @param locale the Locale to transform to a language tag\n     * @return the RFC 3066 compliant language tag as String\n     */\n    public static String toLanguageTag(Locale locale) {\n        return locale.getLanguage() + (hasText(locale.getCountry()) ? \"-\" + locale.getCountry() : \"\");\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with String arrays\n    //---------------------------------------------------------------------\n\n    /**\n     * Append the given String to the given String array, returning a new array\n     * consisting of the input array contents plus the given String.\n     * @param array the array to append to (can be <code>null</code>)\n     * @param str the String to append\n     * @return the new array (never <code>null</code>)\n     */\n    public static String[] addStringToArray(String[] array, String str) {\n        if (Objects.isEmpty(array)) {\n            return new String[] {str};\n        }\n        String[] newArr = new String[array.length + 1];\n        System.arraycopy(array, 0, newArr, 0, array.length);\n        newArr[array.length] = str;\n        return newArr;\n    }\n\n    /**\n     * Concatenate the given String arrays into one,\n     * with overlapping array elements included twice.\n     * <p>The order of elements in the original arrays is preserved.\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        String[] newArr = new String[array1.length + array2.length];\n        System.arraycopy(array1, 0, newArr, 0, array1.length);\n        System.arraycopy(array2, 0, newArr, array1.length, array2.length);\n        return newArr;\n    }\n\n    /**\n     * Merge the given String arrays into one, with overlapping\n     * array elements only included once.\n     * <p>The order of elements in the original arrays is preserved\n     * (with the exception of overlapping elements, which are only\n     * included on their first occurrence).\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] mergeStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        List<String> result = new ArrayList<String>();\n        result.addAll(Arrays.asList(array1));\n        for (String str : array2) {\n            if (!result.contains(str)) {\n                result.add(str);\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Turn given source String array into sorted array.\n     * @param array the source array\n     * @return the sorted array (never <code>null</code>)\n     */\n    public static String[] sortStringArray(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        Arrays.sort(array);\n        return array;\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Collection was <code>null</code>)\n     */\n    public static String[] toStringArray(Collection<String> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new String[collection.size()]);\n    }\n\n    /**\n     * Copy the given Enumeration into a String array.\n     * The Enumeration must contain String elements only.\n     * @param enumeration the Enumeration to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Enumeration was <code>null</code>)\n     */\n    public static String[] toStringArray(Enumeration<String> enumeration) {\n        if (enumeration == null) {\n            return null;\n        }\n        List<String> list = java.util.Collections.list(enumeration);\n        return list.toArray(new String[list.size()]);\n    }\n\n    /**\n     * Trim the elements of the given String array,\n     * calling <code>String.trim()</code> on each of them.\n     * @param array the original String array\n     * @return the resulting array (of the same size) with trimmed elements\n     */\n    public static String[] trimArrayElements(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        String[] result = new String[array.length];\n        for (int i = 0; i < array.length; i++) {\n            String element = array[i];\n            result[i] = (element != null ? element.trim() : null);\n        }\n        return result;\n    }\n\n    /**\n     * Remove duplicate Strings from the given array.\n     * Also sorts the array, as it uses a TreeSet.\n     * @param array the String array\n     * @return an array without duplicates, in natural sort order\n     */\n    public static String[] removeDuplicateStrings(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return array;\n        }\n        Set<String> set = new TreeSet<String>();\n        for (String element : array) {\n            set.add(element);\n        }\n        return toStringArray(set);\n    }\n\n    /**\n     * Split a String at the first occurrence of the delimiter.\n     * Does not include the delimiter in the result.\n     * @param toSplit the string to split\n     * @param delimiter to split the string up with\n     * @return a two element array with index 0 being before the delimiter, and\n     * index 1 being after the delimiter (neither element includes the delimiter);\n     * or <code>null</code> if the delimiter wasn't found in the given input String\n     */\n    public static String[] split(String toSplit, String delimiter) {\n        if (!hasLength(toSplit) || !hasLength(delimiter)) {\n            return null;\n        }\n        int offset = toSplit.indexOf(delimiter);\n        if (offset < 0) {\n            return null;\n        }\n        String beforeDelimiter = toSplit.substring(0, offset);\n        String afterDelimiter = toSplit.substring(offset + delimiter.length());\n        return new String[] {beforeDelimiter, afterDelimiter};\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was null or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {\n        return splitArrayElementsIntoProperties(array, delimiter, null);\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @param charsToDelete one or more characters to remove from each element\n     * prior to attempting the split operation (typically the quotation mark\n     * symbol), or <code>null</code> if no removal should occur\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was <code>null</code> or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(\n        String[] array, String delimiter, String charsToDelete) {\n\n        if (Objects.isEmpty(array)) {\n            return null;\n        }\n        Properties result = new Properties();\n        for (String element : array) {\n            if (charsToDelete != null) {\n                element = deleteAny(element, charsToDelete);\n            }\n            String[] splittedElement = split(element, delimiter);\n            if (splittedElement == null) {\n                continue;\n            }\n            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n        }\n        return result;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter)\n     * @param trimTokens trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     * (only applies to tokens that are empty after trimming; StringTokenizer\n     * will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     * was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(\n        String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List<String> tokens = new ArrayList<String>();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter) {\n        return delimitedListToStringArray(str, delimiter, null);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @param charsToDelete a set of characters to delete. Useful for deleting unwanted\n     * line breaks: e.g. \"\\r\\n\\f\" will delete all new lines and line feeds in a String.\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {\n        if (str == null) {\n            return new String[0];\n        }\n        if (delimiter == null) {\n            return new String[] {str};\n        }\n        List<String> result = new ArrayList<String>();\n        if (\"\".equals(delimiter)) {\n            for (int i = 0; i < str.length(); i++) {\n                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));\n            }\n        }\n        else {\n            int pos = 0;\n            int delPos;\n            while ((delPos = str.indexOf(delimiter, pos)) != -1) {\n                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));\n                pos = delPos + delimiter.length();\n            }\n            if (str.length() > 0 && pos <= str.length()) {\n                // Add rest of String, but not in case of empty input.\n                result.add(deleteAny(str.substring(pos), charsToDelete));\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Convert a CSV list into an array of Strings.\n     * @param str the input String\n     * @return an array of Strings, or the empty array in case of empty input\n     */\n    public static String[] commaDelimitedListToStringArray(String str) {\n        return delimitedListToStringArray(str, \",\");\n    }\n\n    /**\n     * Convenience method to convert a CSV string list to a set.\n     * Note that this will suppress duplicates.\n     * @param str the input String\n     * @return a Set of String entries in the list\n     */\n    public static Set<String> commaDelimitedListToSet(String str) {\n        Set<String> set = new TreeSet<String>();\n        String[] tokens = commaDelimitedListToStringArray(str);\n        for (String token : tokens) {\n            set.add(token);\n        }\n        return set;\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @param prefix the String to start each element with\n     * @param suffix the String to end each element with\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {\n        if (Collections.isEmpty(coll)) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        Iterator<?> it = coll.iterator();\n        while (it.hasNext()) {\n            sb.append(prefix).append(it.next()).append(suffix);\n            if (it.hasNext()) {\n                sb.append(delim);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim) {\n        return collectionToDelimitedString(coll, delim, \"\", \"\");\n    }\n\n    /**\n     * Convenience method to return a Collection as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @return the delimited String\n     */\n    public static String collectionToCommaDelimitedString(Collection<?> coll) {\n        return collectionToDelimitedString(coll, \",\");\n    }\n\n    /**\n     * Convenience method to return a String array as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String arrayToDelimitedString(Object[] arr, String delim) {\n        if (Objects.isEmpty(arr)) {\n            return \"\";\n        }\n        if (arr.length == 1) {\n            return Objects.nullSafeToString(arr[0]);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < arr.length; i++) {\n            if (i > 0) {\n                sb.append(delim);\n            }\n            sb.append(arr[i]);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a String array as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @return the delimited String\n     */\n    public static String arrayToCommaDelimitedString(Object[] arr) {\n        return arrayToDelimitedString(arr, \",\");\n    }\n\n}\n\n",
            "file_name": "Strings.java",
            "human_label": "Append a string to a string array.",
            "level": "slib_runnable",
            "lineno": "719",
            "name": "addStringToArray",
            "oracle_context": "{ \"apis\" : \"[isEmpty, arraycopy]\", \"classes\" : \"[String[]]\", \"vars\" : \"[length]\" }",
            "package": "io.jsonwebtoken.lang",
            "project": "jjwt-master"
        },
        {
            "_id": "636766811a6d9265ec017499",
            "all_context": "{ \"class_level\" : \"import org.atmosphere.annotation.Processor;\\nimport org.atmosphere.cache.BroadcasterCacheInspector;\\nimport org.atmosphere.cache.DefaultBroadcasterCache;\\nimport org.atmosphere.cache.UUIDBroadcasterCache;\\nimport org.atmosphere.config.ApplicationConfiguration;\\nimport org.atmosphere.config.AtmosphereHandlerConfig;\\nimport org.atmosphere.config.AtmosphereHandlerProperty;\\nimport org.atmosphere.config.FrameworkConfiguration;\\nimport org.atmosphere.container.BlockingIOCometSupport;\\nimport org.atmosphere.container.Tomcat7BIOSupportWithWebSocket;\\nimport org.atmosphere.container.WebLogicServlet30WithWebSocket;\\nimport org.atmosphere.handler.AbstractReflectorAtmosphereHandler;\\nimport org.atmosphere.handler.ReflectorServletProcessor;\\nimport org.atmosphere.inject.InjectableObjectFactory;\\nimport org.atmosphere.interceptor.AndroidAtmosphereInterceptor;\\nimport org.atmosphere.interceptor.CacheHeadersInterceptor;\\nimport org.atmosphere.interceptor.CorsInterceptor;\\nimport org.atmosphere.interceptor.HeartbeatInterceptor;\\nimport org.atmosphere.interceptor.IdleResourceInterceptor;\\nimport org.atmosphere.interceptor.InvokationOrder;\\nimport org.atmosphere.interceptor.JSONPAtmosphereInterceptor;\\nimport org.atmosphere.interceptor.JavaScriptProtocol;\\nimport org.atmosphere.interceptor.OnDisconnectInterceptor;\\nimport org.atmosphere.interceptor.PaddingAtmosphereInterceptor;\\nimport org.atmosphere.interceptor.SSEAtmosphereInterceptor;\\nimport org.atmosphere.interceptor.WebSocketMessageSuspendInterceptor;\\nimport org.atmosphere.util.AtmosphereConfigReader;\\nimport org.atmosphere.util.DefaultEndpointMapper;\\nimport org.atmosphere.util.DefaultUUIDProvider;\\nimport org.atmosphere.util.EndpointMapper;\\nimport org.atmosphere.util.ExecutorsFactory;\\nimport org.atmosphere.util.IOUtils;\\nimport org.atmosphere.util.IntrospectionUtils;\\nimport org.atmosphere.util.ServletContextFactory;\\nimport org.atmosphere.util.UUIDProvider;\\nimport org.atmosphere.util.Utils;\\nimport org.atmosphere.util.Version;\\nimport org.atmosphere.util.VoidServletConfig;\\nimport org.atmosphere.util.analytics.FocusPoint;\\nimport org.atmosphere.util.analytics.JGoogleAnalyticsTracker;\\nimport org.atmosphere.util.analytics.ModuleDetection;\\nimport org.atmosphere.websocket.DefaultWebSocketFactory;\\nimport org.atmosphere.websocket.DefaultWebSocketProcessor;\\nimport org.atmosphere.websocket.WebSocket;\\nimport org.atmosphere.websocket.WebSocketFactory;\\nimport org.atmosphere.websocket.WebSocketHandler;\\nimport org.atmosphere.websocket.WebSocketProcessor;\\nimport org.atmosphere.websocket.WebSocketProtocol;\\nimport org.atmosphere.websocket.protocol.SimpleHttpProtocol;\\nimport org.slf4j.Logger;\\nimport org.slf4j.LoggerFactory;\\nimport javax.servlet.Servlet;\\nimport javax.servlet.ServletConfig;\\nimport javax.servlet.ServletContext;\\nimport javax.servlet.ServletException;\\nimport java.io.BufferedReader;\\nimport java.io.File;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.io.InputStreamReader;\\nimport java.io.UnsupportedEncodingException;\\nimport java.net.HttpURLConnection;\\nimport java.net.MalformedURLException;\\nimport java.net.URI;\\nimport java.net.URL;\\nimport java.net.URLClassLoader;\\nimport java.net.URLDecoder;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collections;\\nimport java.util.Comparator;\\nimport java.util.Enumeration;\\nimport java.util.HashMap;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Map.Entry;\\nimport java.util.Objects;\\nimport java.util.concurrent.ConcurrentHashMap;\\nimport java.util.concurrent.ConcurrentLinkedQueue;\\nimport java.util.concurrent.ExecutorService;\\nimport java.util.concurrent.ThreadPoolExecutor;\\nimport java.util.concurrent.atomic.AtomicBoolean;\\nimport static org.atmosphere.cpr.ApplicationConfig.ALLOW_QUERYSTRING_AS_REQUEST;\\nimport static org.atmosphere.cpr.ApplicationConfig.ATMOSPHERE_HANDLER;\\nimport static org.atmosphere.cpr.ApplicationConfig.ATMOSPHERE_HANDLER_MAPPING;\\nimport static org.atmosphere.cpr.ApplicationConfig.ATMOSPHERE_HANDLER_PATH;\\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_CACHE;\\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_CLASS;\\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_FACTORY;\\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_LIFECYCLE_POLICY;\\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_SHAREABLE_LISTENERS;\\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_WAIT_TIME;\\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCAST_FILTER_CLASSES;\\nimport static org.atmosphere.cpr.ApplicationConfig.CONTENT_TYPE_FIRST_RESPONSE;\\nimport static org.atmosphere.cpr.ApplicationConfig.DISABLE_ONSTATE_EVENT;\\nimport static org.atmosphere.cpr.ApplicationConfig.META_SERVICE_PATH;\\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_ALLOW_SESSION_TIMEOUT_REMOVAL;\\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_ATMOSPHERE_XML;\\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_BLOCKING_COMETSUPPORT;\\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_COMET_SUPPORT;\\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_NATIVE_COMETSUPPORT;\\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_SERVLET_MAPPING;\\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_SESSION_SUPPORT;\\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_THROW_EXCEPTION_ON_CLONED_REQUEST;\\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_USE_STREAM;\\nimport static org.atmosphere.cpr.ApplicationConfig.SUSPENDED_ATMOSPHERE_RESOURCE_UUID;\\nimport static org.atmosphere.cpr.ApplicationConfig.USE_SERVLET_CONTEXT_PARAMETERS;\\nimport static org.atmosphere.cpr.ApplicationConfig.WEBSOCKET_PROCESSOR;\\nimport static org.atmosphere.cpr.ApplicationConfig.WEBSOCKET_PROTOCOL;\\nimport static org.atmosphere.cpr.ApplicationConfig.WEBSOCKET_SUPPORT;\\nimport static org.atmosphere.cpr.Broadcaster.ROOT_MASTER;\\nimport static org.atmosphere.cpr.FrameworkConfig.ATMOSPHERE_CONFIG;\\nimport static org.atmosphere.cpr.FrameworkConfig.CDI_INJECTOR;\\nimport static org.atmosphere.cpr.FrameworkConfig.GUICE_INJECTOR;\\nimport static org.atmosphere.cpr.FrameworkConfig.HAZELCAST_BROADCASTER;\\nimport static org.atmosphere.cpr.FrameworkConfig.INJECT_LIBARY;\\nimport static org.atmosphere.cpr.FrameworkConfig.JERSEY_BROADCASTER;\\nimport static org.atmosphere.cpr.FrameworkConfig.JERSEY_CONTAINER;\\nimport static org.atmosphere.cpr.FrameworkConfig.JGROUPS_BROADCASTER;\\nimport static org.atmosphere.cpr.FrameworkConfig.JMS_BROADCASTER;\\nimport static org.atmosphere.cpr.FrameworkConfig.KAFKA_BROADCASTER;\\nimport static org.atmosphere.cpr.FrameworkConfig.RABBITMQ_BROADCASTER;\\nimport static org.atmosphere.cpr.FrameworkConfig.REDIS_BROADCASTER;\\nimport static org.atmosphere.cpr.FrameworkConfig.RMI_BROADCASTER;\\nimport static org.atmosphere.cpr.FrameworkConfig.SPRING_INJECTOR;\\nimport static org.atmosphere.cpr.FrameworkConfig.THROW_EXCEPTION_ON_CLONED_REQUEST;\\nimport static org.atmosphere.cpr.FrameworkConfig.XMPP_BROADCASTER;\\nimport static org.atmosphere.cpr.HeaderConfig.ATMOSPHERE_POST_BODY;\\nimport static org.atmosphere.cpr.HeaderConfig.X_ATMOSPHERE_TRACKING_ID;\\nimport static org.atmosphere.util.IOUtils.realPath;\\nimport static org.atmosphere.websocket.WebSocket.WEBSOCKET_SUSPEND;\\nString DEFAULT_ATMOSPHERE_CONFIG_PATH;\\nString DEFAULT_LIB_PATH;\\nString DEFAULT_HANDLER_PATH;\\nString META_SERVICE;\\nString MAPPING_REGEX;\\nString ASYNC_IO;\\nLogger logger;\\nList<String> broadcasterFilters;\\nList<AsyncSupportListener> asyncSupportListeners;\\nList<AtmosphereResourceListener> atmosphereResourceListeners;\\nArrayList<String> possibleComponentsCandidate;\\nHashMap<String,String> initParams;\\nAtmosphereConfig config;\\nAtomicBoolean isCometSupportConfigured;\\nboolean isFilter;\\nMap<String,AtmosphereHandlerWrapper> atmosphereHandlers;\\nConcurrentLinkedQueue<String> broadcasterTypes;\\nConcurrentLinkedQueue<String> objectFactoryType;\\nConcurrentLinkedQueue<BroadcasterCacheInspector> inspectors;\\nString mappingRegex;\\nboolean useNativeImplementation;\\nboolean useBlockingImplementation;\\nboolean useStreamForFlushingComments;\\nboolean useServlet30;\\nAsyncSupport asyncSupport;\\nString broadcasterClassName;\\nboolean isCometSupportSpecified;\\nboolean isBroadcasterSpecified;\\nboolean isSessionSupportSpecified;\\nboolean isThrowExceptionOnClonedRequestSpecified;\\nBroadcasterFactory broadcasterFactory;\\nString broadcasterFactoryClassName;\\nString broadcasterCacheClassName;\\nboolean webSocketEnabled;\\nString broadcasterLifeCyclePolicy;\\nString webSocketProtocolClassName;\\nWebSocketProtocol webSocketProtocol;\\nString handlersPath;\\nServletConfig servletConfig;\\nboolean autoDetectHandlers;\\nboolean hasNewWebSocketProtocol;\\nString atmosphereDotXmlPath;\\nString metaServicePath;\\nLinkedList<AtmosphereInterceptor> interceptors;\\nboolean scanDone;\\nString annotationProcessorClassName;\\nList<BroadcasterListener> broadcasterListeners;\\nString webSocketProcessorClassName;\\nboolean webSocketProtocolInitialized;\\nEndpointMapper<AtmosphereHandlerWrapper> endpointMapper;\\nString libPath;\\nboolean isInit;\\nboolean sharedThreadPools;\\nList<String> packages;\\nLinkedList<String> annotationPackages;\\nboolean allowAllClassesScan;\\nboolean annotationFound;\\nboolean executeFirstSet;\\nAtmosphereObjectFactory<?> objectFactory;\\nAtomicBoolean isDestroyed;\\nboolean externalizeDestroy;\\nAnnotationProcessor annotationProcessor;\\nList<String> excludedInterceptors;\\nLinkedList<BroadcasterCacheListener> broadcasterCacheListeners;\\nList<BroadcasterConfig.FilterManipulator> filterManipulators;\\nAtmosphereResourceFactory arFactory;\\nMetaBroadcaster metaBroadcaster;\\nAtmosphereResourceSessionFactory sessionFactory;\\nString defaultSerializerClassName;\\nClass<Serializer> defaultSerializerClass;\\nList<AtmosphereFrameworkListener> frameworkListeners;\\nUUIDProvider uuidProvider;\\nThread shutdownHook;\\nList<Class<? extends AtmosphereInterceptor>> DEFAULT_ATMOSPHERE_INTERCEPTORS;\\nWebSocketFactory webSocketFactory;\\nIllegalStateException initializationError;\\nAtmosphereHandler REFLECTOR_ATMOSPHEREHANDLER;\\nAtmosphereHandler atmosphereHandler;\\nBroadcaster broadcaster;\\nString mapping;\\nboolean create;\\nboolean needRequestScopedInjection;\\nboolean wilcardMapping;\\nMetaServiceProcedure procedure;\\nAtomicBoolean done;\\nonRequest(AtmosphereResource resource);\\ndestroy();\\nsetAndConfigureAtmosphereResourceFactory(AtmosphereResourceFactory arFactory);\\nAtmosphereHandlerWrapper(BroadcasterFactory broadcasterFactory,AtmosphereHandler atmosphereHandler,String mapping,AtmosphereConfig config);\\nhookInjection(AtmosphereConfig config);\\nAtmosphereHandlerWrapper(AtmosphereHandler atmosphereHandler,Broadcaster broadcaster,AtmosphereConfig config);\\ntoString();\\nneedRequestScopedInjection();\\nwildcardMapping();\\napply(AtmosphereFramework fwk,Class clazz);\\napply(AtmosphereFramework fwk,Class c);\\nconfigure(AtmosphereConfig config);\\nnewClassInstance(Class classType,Class defaultType);\\nallowInjectionOf(Object o);\\nAtmosphereFramework();\\nAtmosphereFramework(ServletConfig sc);\\nAtmosphereFramework(boolean isFilter,boolean autoDetectHandlers);\\nnewAtmosphereConfig();\\npopulateBroadcasterType();\\npopulateObjectFactoryType();\\naddAtmosphereHandler(String mapping,AtmosphereHandler h,List l);\\naddAtmosphereHandler(String mapping,AtmosphereHandler h,Broadcaster broadcaster,List l);\\naddAtmosphereHandler(String mapping,AtmosphereHandler h,String broadcasterId,List l);\\ncreateWrapperAndConfigureHandler(AtmosphereHandler h,String mapping,List l);\\naddAtmosphereHandler(String mapping,AtmosphereHandler h);\\naddMapping(String path,AtmosphereHandlerWrapper w);\\nnormalizePath(String path);\\naddAtmosphereHandler(String mapping,AtmosphereHandler h,String broadcasterId);\\ninitServletProcessor(AtmosphereHandler h);\\naddAtmosphereHandler(String mapping,AtmosphereHandler h,Broadcaster broadcaster);\\nremoveAtmosphereHandler(String mapping);\\nremoveAllAtmosphereHandler();\\nremoveAllInitParams();\\naddInitParameter(String name,String value);\\nreadSystemProperties();\\npatchContainer();\\ninit();\\ninit(ServletConfig sc);\\npreventOOM();\\ninit(ServletConfig sc,boolean wrap);\\nservletConfig(ServletConfig sc,boolean wrap);\\ngetServletName();\\ngetServletContext();\\ngetInitParameter(String name);\\ngetInitParameterNames();\\nreconfigureInitParams(boolean reconfigureInitParams);\\ninfo();\\nuniverse();\\nconfigureAnnotationPackages();\\nanalytics();\\nconfigureAtmosphereInterceptor(ServletConfig sc);\\nnewAInterceptor(Class a);\\ncompare(AtmosphereInterceptor i1,AtmosphereInterceptor i2);\\nconfigureWebDotXmlAtmosphereHandler(ServletConfig sc);\\nconfigureScanningPackage(ServletConfig sc,String value);\\ndefaultPackagesToScan();\\nconfigureBroadcasterFactory();\\nconfigureBroadcaster();\\ninstallAnnotationProcessor(ServletConfig sc);\\ndoInitParamsForWebSocket(ServletConfig sc);\\ndoInitParams(ServletConfig sc);\\ndoInitParams(ServletConfig sc,boolean reconfigure);\\nloadConfiguration(ServletConfig sc);\\ndetectSupportedFramework(ServletConfig sc);\\nconfigureDetectedFramework(ReflectorServletProcessor rsp,boolean isJersey);\\nlookupDefaultBroadcasterType(String defaultB);\\nautodetectBroadcaster();\\nlookupDefaultObjectFactoryType();\\nsessionSupport(boolean sessionSupport);\\ninitAtmosphereHandler(ServletConfig sc);\\ninitAtmosphereHandler();\\ncheckWebSocketSupportState();\\nonRequest(AtmosphereResource r);\\ninitWebSocket();\\ninitEndpointMapper();\\ncloseAtmosphereResource();\\ndestroyInterceptors();\\nresetStates();\\nloadMetaService();\\nloadAtmosphereDotXml(InputStream stream,ClassLoader c);\\nsetAsyncSupport(AsyncSupport asyncSupport);\\nsetCometSupport(AsyncSupport asyncSupport);\\ngetAsyncSupport();\\ngetCometSupport();\\ncreateAsyncSupportResolver();\\nautoDetectContainer();\\nautoDetectAtmosphereHandlers(ServletContext servletContext,ClassLoader classloader);\\nloadAtmosphereHandlersFromPath(ClassLoader classloader,String realPath);\\nautoDetectWebSocketHandler(ServletContext servletContext,ClassLoader classloader);\\nloadWebSocketFromPath(ClassLoader classloader,String realPath);\\ngetFiles(File f);\\nconfigureRequestResponse(AtmosphereRequest req,AtmosphereResponse res);\\ndoCometSupport(AtmosphereRequest req,AtmosphereResponse res);\\ngetDefaultBroadcasterClassName();\\nsetDefaultBroadcasterClassName(String bccn);\\nisUseStreamForFlushingComments();\\nisUseServlet30();\\nsetUseStreamForFlushingComments(boolean useStreamForFlushingComments);\\ngetBroadcasterFactory();\\nsetBroadcasterFactory(BroadcasterFactory broadcasterFactory);\\ngetBroadcasterCacheClassName();\\nsetBroadcasterCacheClassName(String broadcasterCacheClassName);\\naddBroadcasterType(String broadcasterTypeString);\\nbroadcasterTypes();\\ngetWebSocketProtocolClassName();\\nsetWebSocketProtocolClassName(String webSocketProtocolClassName);\\ngetAtmosphereHandlers();\\nconfigureQueryStringAsRequest(AtmosphereRequest request);\\ngetWebSocketProtocol();\\nisUseNativeImplementation();\\nsetUseNativeImplementation(boolean useNativeImplementation);\\nisUseBlockingImplementation();\\nsetUseBlockingImplementation(boolean useBlockingImplementation);\\ngetAtmosphereDotXmlPath();\\nsetAtmosphereDotXmlPath(String atmosphereDotXmlPath);\\ngetHandlersPath();\\nsetHandlersPath(String handlersPath);\\ngetLibPath();\\nsetLibPath(String libPath);\\ngetWebSocketProcessorClassName();\\nsetWebsocketProcessorClassName(String webSocketProcessorClassName);\\ninterceptor(AtmosphereInterceptor c);\\naddDefaultOrAppInterceptors();\\naddInterceptorToAllWrappers(AtmosphereInterceptor c);\\naddInterceptorToWrapper(AtmosphereHandlerWrapper wrapper,AtmosphereInterceptor c);\\naddInterceptorToWrapper(AtmosphereHandlerWrapper wrapper,List interceptors);\\ncheckDuplicate(AtmosphereInterceptor c);\\ncheckDuplicate(List interceptorList,Class c);\\ninterceptors();\\nannotationProcessorClassName(String annotationProcessorClassName);\\nasyncSupportListener(AsyncSupportListener asyncSupportListener);\\nasyncSupportListeners();\\naddBroadcasterListener(BroadcasterListener b);\\naddBroadcasterCacheListener(BroadcasterCacheListener b);\\nbroadcasterCacheListeners();\\naddBroadcasterCacheInjector(BroadcasterCacheInspector b);\\ninspectors();\\ngetAtmosphereConfig();\\ngetServletConfig();\\nbroadcasterFilters();\\nbroadcasterFilters(BroadcastFilter f);\\nisShareExecutorServices();\\nshareExecutorServices(boolean sharedThreadPools);\\nautoConfigureService(ServletContext sc);\\nendPointMapper();\\nendPointMapper(EndpointMapper endpointMapper);\\naddAnnotationPackage(Class clazz);\\nnotify(TYPE type,AtmosphereRequest request,AtmosphereResponse response);\\nnotifyDestroyed(String uuid);\\nnotifySuspended(String uuid);\\naddWebSocketHandler(WebSocketHandler handler);\\naddWebSocketHandler(String path,WebSocketHandler handler);\\naddWebSocketHandler(String path,WebSocketHandler handler,AtmosphereHandler h);\\naddWebSocketHandler(String path,WebSocketHandler handler,AtmosphereHandler h,List l);\\nannotationScanned(boolean b);\\ninitialized();\\npackages();\\ncustomAnnotationPackages();\\naddCustomAnnotationPackage(Class p);\\nobjectFactory(AtmosphereObjectFactory objectFactory);\\nexternalizeDestroy(boolean externalizeDestroy);\\nannotationProcessor();\\nisBroadcasterSpecified();\\nconfigureObjectFactory();\\nexcludeInterceptor(String interceptor);\\nfilterManipulator(FilterManipulator m);\\nfilterManipulators();\\nisAServletFilter();\\nobjectFactoryType();\\nmappingRegex();\\nmappingRegex(String mappingRegex);\\nsetUseServlet30(boolean useServlet30);\\nwebSocketEnabled();\\nwebSocketEnabled(boolean webSocketEnabled);\\nbroadcasterLifeCyclePolicy();\\nbroadcasterLifeCyclePolicy(String broadcasterLifeCyclePolicy);\\nbroadcasterListeners();\\nsharedThreadPools();\\nsharedThreadPools(boolean sharedThreadPools);\\nallowAllClassesScan();\\nallowAllClassesScan(boolean allowAllClassesScan);\\nobjectFactory();\\nexternalizeDestroy();\\nexcludedInterceptors();\\ndefaultInterceptors();\\natmosphereFactory();\\nconfigureAtmosphereResourceFactory();\\nconfigureWebSocketFactory();\\nmetaBroadcaster();\\nconfigureMetaBroadcaster();\\ngetDefaultSerializerClassName();\\ngetDefaultSerializerClass();\\nsetDefaultSerializerClassName(String defaultSerializerClassName);\\ninitDefaultSerializer();\\nsessionFactory();\\nisDestroyed();\\nframeworkListener(AtmosphereFrameworkListener l);\\nframeworkListeners();\\nonPreInit();\\nonPostInit();\\nonPreDestroy();\\nonPostDestroy();\\natmosphereResourceListeners();\\natmosphereResourceListener(AtmosphereResourceListener atmosphereResourceListener);\\nuuidProvider(UUIDProvider uuidProvider);\\nuuidProvider();\\nwebSocketFactory();\\nwebSocketFactory(WebSocketFactory webSocketFactory);\\ninitializationError(IllegalStateException initializationError);\\nMetaServiceAction(MetaServiceProcedure p);\\n\", \"repo_level\" : \"public interface Processor { void handle(AtmosphereFramework framework,Class annotatedClass);\\n }\\npublic interface BroadcasterCacheInspector { boolean inspect(BroadcastMessage message);\\n }\\npublic interface DefaultBroadcasterCache {public void start();\\npublic void stop();\\npublic void cleanup();\\npublic CacheMessage addToCache(String broadcasterId,String uuid,BroadcastMessage message);\\npublic List<Object> retrieveFromCache(String id,String uuid);\\npublic BroadcasterCache clearCache(String broadcasterId,String uuid,CacheMessage cache);\\npublic BroadcasterCache excludeFromCache(String broadcasterId,AtmosphereResource r);\\npublic BroadcasterCache cacheCandidate(String broadcasterId,String uuid);\\npublic BroadcasterCache inspector(BroadcasterCacheInspector interceptor);\\npublic BroadcasterCache addBroadcasterCacheListener(BroadcasterCacheListener l);\\npublic BroadcasterCache removeBroadcasterCacheListener(BroadcasterCacheListener l);\\npublic void configure(AtmosphereConfig config);\\n }\\npublic interface UUIDBroadcasterCache {public void configure(AtmosphereConfig config);\\npublic void start();\\npublic void stop();\\npublic void cleanup();\\npublic CacheMessage addToCache(String broadcasterId,String uuid,BroadcastMessage message);\\npublic List<Object> retrieveFromCache(String broadcasterId,String uuid);\\npublic BroadcasterCache clearCache(String broadcasterId,String uuid,CacheMessage message);\\npublic BroadcasterCache inspector(BroadcasterCacheInspector b);\\npublic BroadcasterCache addBroadcasterCacheListener(BroadcasterCacheListener l);\\npublic BroadcasterCache removeBroadcasterCacheListener(BroadcasterCacheListener l);\\nprotected String uuid(AtmosphereResource r);\\npublic Map<String,ConcurrentLinkedQueue<CacheMessage>> messages();\\npublic Map<String,Long> activeClients();\\nprotected boolean inspect(BroadcastMessage m);\\npublic void setInvalidateCacheInterval(long invalidateCacheInterval);\\npublic void setClientIdleTime(long clientIdleTime);\\nprotected void invalidateExpiredEntries();\\npublic BroadcasterCache excludeFromCache(String broadcasterId,AtmosphereResource r);\\npublic BroadcasterCache cacheCandidate(String broadcasterId,String uuid);\\npublic String toString();\\npublic List<BroadcasterCacheListener> listeners();\\npublic List<BroadcasterCacheInspector> inspectors();\\n }\\npublic interface ApplicationConfiguration {public String getParamName();\\npublic void setParamName(String paramName);\\npublic String getParamValue();\\npublic void setParamValue(String paramValue);\\n }\\npublic interface AtmosphereHandlerConfig {public String getSupportSession();\\npublic void setSupportSession(String supportSession);\\npublic String getContextRoot();\\npublic void setContextRoot(String contextRoot);\\npublic String getClassName();\\npublic void setClassName(String className);\\npublic String getBroadcaster();\\npublic void setBroadcaster(String broadcaster);\\npublic List<AtmosphereHandlerProperty> getProperties();\\npublic void setProperties(List properties);\\npublic List<ApplicationConfiguration> getApplicationConfig();\\npublic void setApplicationConfig(List applicationConfig);\\npublic List<FrameworkConfiguration> getFrameworkConfig();\\npublic void setFrameworkConfig(List frameworkConfig);\\npublic String getBroadcasterCache();\\npublic void setBroadcasterCache(String broadcasterCache);\\npublic List<String> getBroadcastFilterClasses();\\npublic void setAtmosphereInterceptorClasses(List interceptors);\\npublic List<String> getAtmosphereInterceptorClasses();\\npublic void setBroadcastFilterClasses(List broadcastFilterClasses);\\npublic String getCometSupport();\\npublic void setCometSupport(String cometSupport);\\n }\\npublic interface AtmosphereHandlerProperty {public String getName();\\npublic void setName(String name);\\npublic String getValue();\\npublic void setValue(String value);\\n }\\npublic interface FrameworkConfiguration {public String getParamName();\\npublic void setParamName(String paramName);\\npublic String getParamValue();\\npublic void setParamValue(String paramValue);\\n }\\npublic interface BlockingIOCometSupport {public Action service(AtmosphereRequest req,AtmosphereResponse res);\\nprotected void suspend(Action action,AtmosphereRequest req,AtmosphereResponse res);\\npublic void onResume(AtmosphereResourceEvent event);\\npublic Action cancelled(AtmosphereRequest req,AtmosphereResponse res);\\npublic void action(AtmosphereResourceImpl r);\\npublic AsyncSupport<AtmosphereResourceImpl> complete(AtmosphereResourceImpl r);\\n }\\npublic interface Tomcat7BIOSupportWithWebSocket {public Action service(AtmosphereRequest req,AtmosphereResponse res);\\npublic Action doService(AtmosphereRequest req,AtmosphereResponse res);\\npublic boolean supportWebSocket();\\n }\\npublic interface WebLogicServlet30WithWebSocket {public boolean supportWebSocket();\\npublic String getContainerName();\\n }\\npublic interface AbstractReflectorAtmosphereHandler {public void onStateChange(AtmosphereResourceEvent event);\\nprotected void write(AtmosphereResourceEvent event,ServletOutputStream o,byte[] data);\\nprotected boolean useTwoStepWrite(AtmosphereResourceEvent event);\\nfinal void postStateChange(AtmosphereResourceEvent event);\\npublic void destroy();\\npublic void init(AtmosphereConfig config);\\npublic void onRequest(AtmosphereResource resource);\\n }\\npublic interface ReflectorServletProcessor { void loadWebApplication(ServletConfig sc);\\npublic void onRequest(AtmosphereResource r);\\npublic void init(AtmosphereConfig config);\\npublic void addFilter(Filter filter);\\npublic void destroy();\\npublic String getServletClass();\\npublic void setServletClass(String servletClass);\\npublic String getServletClassName();\\npublic void setServletClassName(String servletClass);\\npublic void setFilterClassName(String filterClass);\\npublic void addFilterClassName(String filterClass,String filterName);\\npublic Servlet getServlet();\\npublic void setServlet(Servlet servlet);\\npublic void destroy();\\npublic String getInitParameter(String name);\\npublic Enumeration<String> getInitParameterNames();\\npublic ServletConfig getServletConfig();\\npublic ServletContext getServletContext();\\npublic String getServletInfo();\\npublic void init(ServletConfig sc);\\npublic void init();\\npublic void log(String msg);\\npublic void log(String message,Throwable t);\\npublic void service(ServletRequest req,ServletResponse res);\\npublic String getServletName();\\npublic String toString();\\n }\\npublic interface InjectableObjectFactory {public void configure(AtmosphereConfig config);\\npublic void started(AtmosphereFramework framework);\\nprotected void retryInjection(AtmosphereFramework framework);\\npublic U newClassInstance(Class classType,Class defaultType);\\npublic T inject(T instance);\\npublic void applyMethods(U instance,Class defaultType);\\npublic void injectInjectable(U instance,Class defaultType,AtmosphereFramework framework);\\npublic void injectFields(Set fields,U instance,AtmosphereFramework framework,LinkedList injectable);\\npublic AtmosphereObjectFactory allowInjectionOf(Injectable injectable);\\npublic AtmosphereObjectFactory allowInjectionOf(Injectable injectable,boolean first);\\npublic String toString();\\npublic U getInjectable(Class u);\\npublic void requestScoped(Object instance,Class defaultType,AtmosphereResource r);\\npublic void requestScoped(Object instance,Class defaultType);\\npublic boolean needRequestScoped(Class defaultType);\\npublic InjectableObjectFactory listener(InjectionListener i);\\nprotected void injectionFailed();\\nprotected void nullFieldInjectionFor(Field field,U instance,Class clazz);\\nprotected void fieldInjectionException(Field field,U instance,Class clazz,Exception ex);\\nprotected void methodInjectionException(Method m,U instance,Class clazz,Exception ex);\\nprotected void preFieldInjection(Field field,U instance,Class clazz);\\nprotected void postFieldInjection(Field field,U instance,Class clazz);\\nprotected void preMethodInjection(Method method,U instance,Class clazz);\\nprotected void postMethodInjection(Method method,U instance,Class clazz);\\n }\\npublic interface AndroidAtmosphereInterceptor {public Action inspect(AtmosphereResource r);\\npublic void prePayload(AtmosphereResponse response,byte[] data,int offset,int length);\\npublic void postPayload(AtmosphereResponse response,byte[] data,int offset,int length);\\npublic String toString();\\n }\\npublic interface CacheHeadersInterceptor {public void configure(AtmosphereConfig config);\\npublic Action inspect(AtmosphereResource r);\\npublic boolean injectCacheHeaders();\\npublic boolean writeHeaders();\\npublic CacheHeadersInterceptor injectCacheHeaders(boolean injectCacheHeaders);\\npublic CacheHeadersInterceptor writeHeaders(boolean writeHeaders);\\npublic String toString();\\n }\\npublic interface CorsInterceptor {public void configure(AtmosphereConfig config);\\npublic Action inspect(AtmosphereResource r);\\npublic boolean enableAccessControl();\\npublic CorsInterceptor enableAccessControl(boolean enableAccessControl);\\npublic PRIORITY priority();\\npublic String toString();\\n }\\npublic interface HeartbeatInterceptor {public HeartbeatInterceptor paddingText(byte[] paddingBytes);\\npublic byte[] getPaddingBytes();\\npublic HeartbeatInterceptor heartbeatFrequencyInSeconds(int heartbeatFrequencyInSeconds);\\npublic int heartbeatFrequencyInSeconds();\\npublic int clientHeartbeatFrequencyInSeconds();\\npublic HeartbeatInterceptor clientHeartbeatFrequencyInSeconds(int clientHeartbeatFrequencyInSeconds);\\npublic boolean resumeOnHeartbeat();\\npublic HeartbeatInterceptor resumeOnHeartbeat(boolean resumeOnHeartbeat);\\npublic void configure(AtmosphereConfig config);\\npublic Action inspect(AtmosphereResource r);\\npublic void onHeartbeat(AtmosphereResourceEvent event);\\npublic void onSuspend(AtmosphereResourceEvent event);\\npublic void onResume(AtmosphereResourceEvent event);\\npublic void onDisconnect(AtmosphereResourceEvent event);\\npublic void onClose(AtmosphereResourceEvent event);\\npublic byte[] transformPayload(AtmosphereResponse response,byte[] responseDraft,byte[] data);\\npublic void postPayload(AtmosphereResponse response,byte[] data,int offset,int length);\\nprotected int extractHeartbeatInterval(AtmosphereResourceImpl resource);\\n void cancelF(AtmosphereRequest request);\\npublic HeartbeatInterceptor clock(int interval,AtmosphereResource r,AtmosphereRequest request,AtmosphereResponse response);\\npublic String toString();\\npublic void destroy();\\n }\\npublic interface IdleResourceInterceptor {public void configure(AtmosphereConfig config);\\nprotected void idleResources();\\npublic long maxInactiveTime();\\npublic IdleResourceInterceptor maxInactiveTime(long maxInactiveTime);\\npublic Action inspect(AtmosphereResource r);\\npublic PRIORITY priority();\\npublic void destroy();\\n }\\npublic interface InvokationOrder { PRIORITY priority();\\n }\\npublic interface JSONPAtmosphereInterceptor {public void configure(AtmosphereConfig config);\\npublic Action inspect(AtmosphereResource r);\\n String callbackName();\\npublic void prePayload(AtmosphereResponse response,byte[] data,int offset,int length);\\npublic byte[] transformPayload(AtmosphereResponse response,byte[] responseDraft,byte[] data);\\npublic void postPayload(AtmosphereResponse response,byte[] data,int offset,int length);\\npublic String toString();\\n }\\npublic interface JavaScriptProtocol {public void configure(AtmosphereConfig config);\\npublic Action inspect(AtmosphereResource ar);\\npublic void onSuspend(AtmosphereResourceEvent event);\\npublic String wsDelimiter();\\npublic JavaScriptProtocol wsDelimiter(String wsDelimiter);\\npublic boolean enforceAtmosphereVersion();\\npublic JavaScriptProtocol enforceAtmosphereVersion(boolean enforceAtmosphereVersion);\\npublic String toString();\\n }\\npublic interface OnDisconnectInterceptor {public void configure(AtmosphereConfig config);\\npublic Action inspect(AtmosphereResource r);\\npublic String toString();\\n }\\npublic interface PaddingAtmosphereInterceptor {static String confPadding(int size);\\npublic Action inspect(AtmosphereResource r);\\npublic void prePayload(AtmosphereResponse response,byte[] data,int offset,int length);\\npublic void postPayload(AtmosphereResponse response,byte[] data,int offset,int length);\\npublic String toString();\\npublic void onPreSuspend(AtmosphereResourceEvent event);\\n }\\npublic interface SSEAtmosphereInterceptor {public void configure(AtmosphereConfig config);\\npublic void onPreSuspend(AtmosphereResourceEvent event);\\npublic Action inspect(AtmosphereResource r);\\npublic void prePayload(AtmosphereResponse response,byte[] data,int offset,int length);\\npublic byte[] transformPayload(AtmosphereResponse response,byte[] responseDraft,byte[] data);\\npublic void postPayload(AtmosphereResponse response,byte[] data,int offset,int length);\\npublic String toString();\\n }\\npublic interface WebSocketMessageSuspendInterceptor {public Action inspect(AtmosphereResource r);\\n }\\npublic interface AtmosphereConfigReader {public AtmosphereConfig parse(AtmosphereConfig config,String filename);\\npublic AtmosphereConfig parse(AtmosphereConfig config,InputStream stream);\\nstatic AtmosphereConfigReader getInstance();\\n }\\npublic interface DefaultEndpointMapper {protected U match(String path,Map handlers);\\npublic String computePath(AtmosphereRequest req);\\npublic void configure(AtmosphereConfig config);\\npublic U map(AtmosphereRequest req,Map handlers);\\npublic U map(String path,Map handlers);\\n }\\npublic interface DefaultUUIDProvider {public String generateUuid();\\n }\\npublic interface EndpointMapper { U map(AtmosphereRequest req,Map handlers);\\n U map(String path,Map handlers);\\n }\\npublic interface ExecutorsFactory {public Thread newThread(Runnable runnable);\\nstatic ExecutorService getMessageDispatcher(AtmosphereConfig config,String name);\\nstatic ExecutorService getAsyncOperationExecutor(AtmosphereConfig config,String name);\\nstatic ScheduledExecutorService getScheduler(AtmosphereConfig config);\\npublic Thread newThread(Runnable runnable);\\nstatic void reset(AtmosphereConfig config);\\n }\\npublic interface IOUtils {static void deliver(Object o,DeliverTo deliverConfig,DELIVER_TO defaultDeliver,AtmosphereResource r);\\nstatic Object readEntirely(AtmosphereResource r);\\nstatic boolean isBodyBinary(AtmosphereRequest request);\\nstatic boolean isBodyEmpty(Object o);\\nstatic StringBuilder readEntirelyAsString(AtmosphereResource r);\\nstatic byte[] readEntirelyAsByte(AtmosphereResource r);\\nstatic byte[] forceReadEntirelyAsByte(AtmosphereResource r);\\nstatic String guestServletPath(AtmosphereConfig config);\\nstatic String guestRawServletPath(AtmosphereConfig config);\\nstatic String getCleanedServletPath(String fullServletPath);\\nstatic Class<?> loadClass(Class thisClass,String className);\\nstatic boolean isAtmosphere(String className);\\nstatic Map<String,AtmosphereFramework.MetaServiceAction> readServiceFile(String path);\\nstatic void close(Closeable closeableArray);\\nstatic String realPath(ServletContext servletContext,String targetPath);\\n }\\npublic interface IntrospectionUtils {static void execute(Object proxy,String method);\\nstatic void setAttribute(Object proxy,String name,Object value);\\nstatic Object getAttribute(Object proxy,String name);\\nstatic boolean setProperty(Object o,String name,String value);\\nstatic boolean addProperty(Object o,String name,String value);\\npublic boolean invokeProperty(Object object,String setter,String name,String value);\\nstatic Object getProperty(Object object,String name);\\nstatic void setProperty(Object object,String name);\\nstatic String replaceProperties(String value,Hashtable staticProp,PropertySource dynamicProp);\\nstatic String capitalize(String name);\\nstatic String unCapitalize(String name);\\nstatic void addToClassPath(Vector cpV,String dir);\\nstatic void addToolsJar(Vector v);\\nstatic String[] getFilesByExt(String ld,String ext);\\npublic boolean accept(File d,String name);\\nstatic URL getURL(String base,String file);\\nstatic void addJarsFromClassPath(Vector jars,String cp);\\nstatic URL[] getClassPath(Vector v);\\nstatic URL[] getClassPath(String dir,String cpath,String cpathProp,boolean addTools);\\nstatic boolean processArgs(Object proxy,String args);\\nstatic boolean processArgs(Object proxy,String args,String args0,String args1,Hashtable aliases);\\nstatic void clear();\\nstatic String[] findVoidSetters(Class c);\\nstatic String[] findBooleanSetters(Class c);\\nstatic Method[] findMethods(Class c);\\nstatic Method findMethod(Class c,String name,Class params);\\nstatic boolean hasHook(Object obj,String methodN);\\nstatic void callMain(Class c,String args);\\nstatic Object callMethod1(Object target,String methodN,Object param1,String typeParam1,ClassLoader cl);\\nstatic Object callMethod0(Object target,String methodN);\\nstatic Object callMethodN(Object target,String methodN,Object params,Class typeParams);\\nstatic Object convert(String object,Class paramType);\\npublic String getProperty(String key);\\npublic void setAttribute(String key,Object o);\\nstatic void debug(String s);\\n }\\npublic interface ServletContextFactory {public void init(ServletContext servletContext);\\npublic ServletContext getServletContext();\\nstatic ServletContextFactory getDefault();\\n }\\npublic interface UUIDProvider { String generateUuid();\\n }\\npublic interface Utils {static boolean webSocketEnabled(HttpServletRequest request);\\nstatic boolean rawWebSocket(HttpServletRequest request);\\nstatic boolean firefoxWebSocketEnabled(HttpServletRequest request);\\nstatic boolean twoConnectionsTransport(TRANSPORT t);\\nstatic boolean webSocketQueryStringPresentOrNull(HttpServletRequest request);\\nstatic boolean resumableTransport(TRANSPORT t);\\nstatic boolean pollableTransport(TRANSPORT t);\\nstatic boolean pushMessage(TRANSPORT t);\\nstatic boolean atmosphereProtocol(AtmosphereRequest r);\\nstatic boolean webSocketMessage(AtmosphereResource r);\\nstatic boolean properProtocol(HttpServletRequest request);\\nstatic AtmosphereResource websocketResource(AtmosphereResource r);\\nstatic boolean closeMessage(HttpServletRequest request);\\nstatic Object invoke(Object proxiedInstance,Method m,Object o);\\nstatic void inject(AtmosphereResource r);\\nstatic void inject(Object object,Class clazz,AtmosphereResource r);\\nstatic void inject(Object object,Class clazz,AtmosphereConfig config);\\nstatic Set<Field> getInheritedPrivateFields(Class type);\\nstatic Set<Method> getInheritedPrivateMethod(Class type);\\nstatic boolean requestScopedInjection(AtmosphereConfig config,AtmosphereHandler h);\\nstatic boolean requestScopedInjection(AtmosphereConfig config,Object o);\\nstatic void destroyMeteor(AtmosphereRequest req);\\nstatic String pathInfo(AtmosphereRequest request);\\nstatic boolean isRunningTest();\\nstatic boolean isUnderJDK11AndUp();\\n }\\npublic interface Version {static void main(String[] args);\\nstatic String getRawVersion();\\nstatic String getDotedVersion();\\nstatic int getMajorVersion();\\nstatic int getMinorVersion();\\nstatic int getMicroVersion();\\nstatic boolean equalVersion(int major,int minor);\\n }\\npublic interface VoidServletConfig {public String getServletName();\\npublic ServletContext getServletContext();\\npublic String getInitParameter(String name);\\npublic Enumeration<String> getInitParameterNames();\\n }\\npublic interface FocusPoint {public String getName();\\npublic void setParentTrackPoint(FocusPoint parentFocusPoint);\\npublic FocusPoint getParentFocusPoint();\\npublic String getContentURI();\\npublic String getContentTitle();\\n }\\npublic interface JGoogleAnalyticsTracker {public void setUrlBuildingStrategy(URLBuildingStrategy urlBuildingStrategy);\\npublic void trackSynchronously(FocusPoint focusPoint);\\n }\\npublic interface ModuleDetection {static String detect();\\nstatic boolean check(String clazz);\\n }\\npublic interface DefaultWebSocketFactory {public WebSocket find(String uuid);\\n }\\npublic interface DefaultWebSocketProcessor {public WebSocketProcessor configure(AtmosphereConfig config);\\npublic Action service(AtmosphereRequest req,AtmosphereResponse res);\\npublic boolean handshake(HttpServletRequest request);\\npublic WebSocketProcessor registerWebSocketHandler(String path,WebSocketHandlerProxy webSockethandler);\\nfinal void open(WebSocket webSocket,AtmosphereRequest request,AtmosphereResponse response);\\nprotected WebSocketHandler postProcessMapping(WebSocket webSocket,AtmosphereRequest request,WebSocketHandlerProxy w);\\npublic void invokeWebSocketProtocol(WebSocket webSocket,String webSocketMessage);\\npublic void invokeWebSocketProtocol(WebSocket webSocket,byte[] data,int offset,int length);\\npublic void invokeWebSocketProtocol(WebSocket webSocket,InputStream stream);\\npublic void invokeWebSocketProtocol(WebSocket webSocket,Reader reader);\\nfinal void dispatch(WebSocket webSocket,AtmosphereRequest request,AtmosphereResponse r);\\npublic void close(WebSocket webSocket,int closeCode);\\npublic void executeClose(WebSocket webSocket,int closeCode);\\npublic void destroy();\\npublic void notifyListener(WebSocket webSocket,WebSocketEventListener.WebSocketEvent event);\\nstatic Map<String,String> configureHeader(AtmosphereRequest request);\\nprotected void dispatchStream(WebSocket webSocket,InputStream is);\\nprotected void dispatchReader(WebSocket webSocket,Reader r);\\nprotected void optimizeMapping();\\npublic boolean wildcardMapping();\\npublic DefaultWebSocketProcessor wildcardMapping(boolean wildcardMapping);\\npublic Map<String,WebSocketHandlerProxy> handlers();\\npublic boolean executeAsync();\\npublic boolean destroyable();\\npublic int byteBufferMaxSize();\\npublic DefaultWebSocketProcessor byteBufferMaxSize(int byteBufferMaxSize);\\npublic int charBufferMaxSize();\\npublic DefaultWebSocketProcessor charBufferMaxSize(int charBufferMaxSize);\\npublic long closingTime();\\npublic EndpointMapper<WebSocketHandlerProxy> mapper();\\npublic boolean invokeInterceptors();\\npublic void onPong(WebSocket webSocket,byte[] payload,int offset,int length);\\npublic void onPing(WebSocket webSocket,byte[] payload,int offset,int length);\\n }\\npublic interface WebSocket {public AtmosphereConfig config();\\nprotected WebSocket webSocketHandler(WebSocketHandler webSocketHandler);\\npublic WebSocket binaryWrite(boolean binaryWrite);\\npublic WebSocketHandler webSocketHandler();\\npublic WebSocket resource(AtmosphereResource r);\\nsynchronized void shiftAttributes();\\npublic Map<String,Object> attributes();\\npublic AtmosphereResource resource();\\npublic long lastWriteTimeStampInMilliseconds();\\nprotected byte[] transform(byte[] b,int offset,int length);\\nprotected byte[] transform(AtmosphereResponse response,byte[] b,int offset,int length);\\npublic WebSocket write(AtmosphereResponse r,String data);\\npublic WebSocket write(AtmosphereResponse r,byte[] data);\\npublic WebSocket write(AtmosphereResponse r,byte[] b,int offset,int length);\\npublic WebSocket broadcast(Object o);\\npublic WebSocket writeError(AtmosphereResponse r,int errorCode,String message);\\npublic WebSocket redirect(AtmosphereResponse r,String location);\\npublic void close(AtmosphereResponse r);\\npublic WebSocket flush(AtmosphereResponse r);\\npublic boolean isOpen();\\npublic WebSocket write(String s);\\npublic WebSocket write(byte[] b,int offset,int length);\\npublic WebSocket write(byte[] b);\\npublic void close();\\npublic void close(int statusCode,String reasonText);\\npublic String uuid();\\nstatic void notSupported(AtmosphereRequest request,AtmosphereResponse response);\\npublic WebSocket sendPing(byte[] payload);\\npublic WebSocket sendPong(byte[] payload);\\npublic WebSocket attachment(Object attachment);\\npublic Object attachment();\\n }\\npublic interface WebSocketFactory { WebSocket find(String uuid);\\n }\\npublic interface WebSocketHandler { void onByteMessage(WebSocket webSocket,byte[] data,int offset,int length);\\n void onTextMessage(WebSocket webSocket,String data);\\n void onOpen(WebSocket webSocket);\\n void onClose(WebSocket webSocket);\\n void onError(WebSocket webSocket,WebSocketException t);\\n }\\npublic interface WebSocketProcessor { WebSocketProcessor configure(AtmosphereConfig config);\\n boolean handshake(HttpServletRequest request);\\n WebSocketProcessor registerWebSocketHandler(String path,WebSocketHandlerProxy webSockethandler);\\n void open(WebSocket webSocket,AtmosphereRequest request,AtmosphereResponse response);\\n void invokeWebSocketProtocol(WebSocket webSocket,String webSocketMessage);\\n void invokeWebSocketProtocol(WebSocket webSocket,byte[] data,int offset,int length);\\n void invokeWebSocketProtocol(WebSocket webSocket,InputStream stream);\\n void invokeWebSocketProtocol(WebSocket webSocket,Reader reader);\\n void close(WebSocket webSocket,int closeCode);\\n void notifyListener(WebSocket webSocket,WebSocketEvent webSocketEvent);\\n void destroy();\\npublic AtmosphereResponse response();\\npublic String path();\\npublic WebSocketHandlerProxy path(String path);\\npublic WebSocketHandler proxied();\\npublic void onByteMessage(WebSocket webSocket,byte[] data,int offset,int length);\\npublic void onTextMessage(WebSocket webSocket,String data);\\npublic void onOpen(WebSocket webSocket);\\npublic void onClose(WebSocket webSocket);\\npublic void onError(WebSocket webSocket,WebSocketException t);\\n }\\npublic interface WebSocketProtocol { List<AtmosphereRequest> onMessage(WebSocket webSocket,String data);\\n List<AtmosphereRequest> onMessage(WebSocket webSocket,byte[] data,int offset,int length);\\n void onOpen(WebSocket webSocket);\\n void onClose(WebSocket webSocket);\\n void onError(WebSocket webSocket,WebSocketException t);\\n }\\npublic interface SimpleHttpProtocol {public void configure(AtmosphereConfig config);\\npublic List<AtmosphereRequest> onMessage(WebSocket webSocket,String message);\\npublic List<AtmosphereRequest> onMessage(WebSocket webSocket,byte[] d,int offset,int length);\\npublic void onOpen(WebSocket webSocket);\\npublic void onClose(WebSocket webSocket);\\npublic void onError(WebSocket webSocket,WebSocketException t);\\n }\\n\" }",
            "class_name": "AtmosphereFramework",
            "code": "private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList,Class<? extends AtmosphereInterceptor> c){\n  for (  final AtmosphereInterceptor i : interceptorList) {\n    if (i.getClass().equals(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n",
            "docstring": "/** \n * <p> Checks in the specified list if there is at least one instance of the given {@link AtmosphereInterceptor interceptor} implementation class.</p>\n * @param interceptorList the interceptors\n * @param c               the interceptor class\n * @return {@code false} if an instance of the class already exists in the list, {@code true} otherwise\n */\n",
            "end_lineno": "2683",
            "file_content": "/*\n * Copyright 2008-2022 Async-IO.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.atmosphere.cpr;\n\nimport org.atmosphere.annotation.Processor;\nimport org.atmosphere.cache.BroadcasterCacheInspector;\nimport org.atmosphere.cache.DefaultBroadcasterCache;\nimport org.atmosphere.cache.UUIDBroadcasterCache;\nimport org.atmosphere.config.ApplicationConfiguration;\nimport org.atmosphere.config.AtmosphereHandlerConfig;\nimport org.atmosphere.config.AtmosphereHandlerProperty;\nimport org.atmosphere.config.FrameworkConfiguration;\nimport org.atmosphere.container.BlockingIOCometSupport;\nimport org.atmosphere.container.Tomcat7BIOSupportWithWebSocket;\nimport org.atmosphere.container.WebLogicServlet30WithWebSocket;\nimport org.atmosphere.handler.AbstractReflectorAtmosphereHandler;\nimport org.atmosphere.handler.ReflectorServletProcessor;\nimport org.atmosphere.inject.InjectableObjectFactory;\nimport org.atmosphere.interceptor.AndroidAtmosphereInterceptor;\nimport org.atmosphere.interceptor.CacheHeadersInterceptor;\nimport org.atmosphere.interceptor.CorsInterceptor;\nimport org.atmosphere.interceptor.HeartbeatInterceptor;\nimport org.atmosphere.interceptor.IdleResourceInterceptor;\nimport org.atmosphere.interceptor.InvokationOrder;\nimport org.atmosphere.interceptor.JSONPAtmosphereInterceptor;\nimport org.atmosphere.interceptor.JavaScriptProtocol;\nimport org.atmosphere.interceptor.OnDisconnectInterceptor;\nimport org.atmosphere.interceptor.PaddingAtmosphereInterceptor;\nimport org.atmosphere.interceptor.SSEAtmosphereInterceptor;\nimport org.atmosphere.interceptor.WebSocketMessageSuspendInterceptor;\nimport org.atmosphere.util.AtmosphereConfigReader;\nimport org.atmosphere.util.DefaultEndpointMapper;\nimport org.atmosphere.util.DefaultUUIDProvider;\nimport org.atmosphere.util.EndpointMapper;\nimport org.atmosphere.util.ExecutorsFactory;\nimport org.atmosphere.util.IOUtils;\nimport org.atmosphere.util.IntrospectionUtils;\nimport org.atmosphere.util.ServletContextFactory;\nimport org.atmosphere.util.UUIDProvider;\nimport org.atmosphere.util.Utils;\nimport org.atmosphere.util.Version;\nimport org.atmosphere.util.VoidServletConfig;\nimport org.atmosphere.util.analytics.FocusPoint;\nimport org.atmosphere.util.analytics.JGoogleAnalyticsTracker;\nimport org.atmosphere.util.analytics.ModuleDetection;\nimport org.atmosphere.websocket.DefaultWebSocketFactory;\nimport org.atmosphere.websocket.DefaultWebSocketProcessor;\nimport org.atmosphere.websocket.WebSocket;\nimport org.atmosphere.websocket.WebSocketFactory;\nimport org.atmosphere.websocket.WebSocketHandler;\nimport org.atmosphere.websocket.WebSocketProcessor;\nimport org.atmosphere.websocket.WebSocketProtocol;\nimport org.atmosphere.websocket.protocol.SimpleHttpProtocol;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.Servlet;\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.net.URLDecoder;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.atmosphere.cpr.ApplicationConfig.ALLOW_QUERYSTRING_AS_REQUEST;\nimport static org.atmosphere.cpr.ApplicationConfig.ATMOSPHERE_HANDLER;\nimport static org.atmosphere.cpr.ApplicationConfig.ATMOSPHERE_HANDLER_MAPPING;\nimport static org.atmosphere.cpr.ApplicationConfig.ATMOSPHERE_HANDLER_PATH;\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_CACHE;\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_CLASS;\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_FACTORY;\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_LIFECYCLE_POLICY;\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_SHAREABLE_LISTENERS;\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCASTER_WAIT_TIME;\nimport static org.atmosphere.cpr.ApplicationConfig.BROADCAST_FILTER_CLASSES;\nimport static org.atmosphere.cpr.ApplicationConfig.CONTENT_TYPE_FIRST_RESPONSE;\nimport static org.atmosphere.cpr.ApplicationConfig.DISABLE_ONSTATE_EVENT;\nimport static org.atmosphere.cpr.ApplicationConfig.META_SERVICE_PATH;\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_ALLOW_SESSION_TIMEOUT_REMOVAL;\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_ATMOSPHERE_XML;\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_BLOCKING_COMETSUPPORT;\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_COMET_SUPPORT;\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_NATIVE_COMETSUPPORT;\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_SERVLET_MAPPING;\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_SESSION_SUPPORT;\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_THROW_EXCEPTION_ON_CLONED_REQUEST;\nimport static org.atmosphere.cpr.ApplicationConfig.PROPERTY_USE_STREAM;\nimport static org.atmosphere.cpr.ApplicationConfig.SUSPENDED_ATMOSPHERE_RESOURCE_UUID;\nimport static org.atmosphere.cpr.ApplicationConfig.USE_SERVLET_CONTEXT_PARAMETERS;\nimport static org.atmosphere.cpr.ApplicationConfig.WEBSOCKET_PROCESSOR;\nimport static org.atmosphere.cpr.ApplicationConfig.WEBSOCKET_PROTOCOL;\nimport static org.atmosphere.cpr.ApplicationConfig.WEBSOCKET_SUPPORT;\nimport static org.atmosphere.cpr.Broadcaster.ROOT_MASTER;\nimport static org.atmosphere.cpr.FrameworkConfig.ATMOSPHERE_CONFIG;\nimport static org.atmosphere.cpr.FrameworkConfig.CDI_INJECTOR;\nimport static org.atmosphere.cpr.FrameworkConfig.GUICE_INJECTOR;\nimport static org.atmosphere.cpr.FrameworkConfig.HAZELCAST_BROADCASTER;\nimport static org.atmosphere.cpr.FrameworkConfig.INJECT_LIBARY;\nimport static org.atmosphere.cpr.FrameworkConfig.JERSEY_BROADCASTER;\nimport static org.atmosphere.cpr.FrameworkConfig.JERSEY_CONTAINER;\nimport static org.atmosphere.cpr.FrameworkConfig.JGROUPS_BROADCASTER;\nimport static org.atmosphere.cpr.FrameworkConfig.JMS_BROADCASTER;\nimport static org.atmosphere.cpr.FrameworkConfig.KAFKA_BROADCASTER;\nimport static org.atmosphere.cpr.FrameworkConfig.RABBITMQ_BROADCASTER;\nimport static org.atmosphere.cpr.FrameworkConfig.REDIS_BROADCASTER;\nimport static org.atmosphere.cpr.FrameworkConfig.RMI_BROADCASTER;\nimport static org.atmosphere.cpr.FrameworkConfig.SPRING_INJECTOR;\nimport static org.atmosphere.cpr.FrameworkConfig.THROW_EXCEPTION_ON_CLONED_REQUEST;\nimport static org.atmosphere.cpr.FrameworkConfig.XMPP_BROADCASTER;\nimport static org.atmosphere.cpr.HeaderConfig.ATMOSPHERE_POST_BODY;\nimport static org.atmosphere.cpr.HeaderConfig.X_ATMOSPHERE_TRACKING_ID;\nimport static org.atmosphere.util.IOUtils.realPath;\nimport static org.atmosphere.websocket.WebSocket.WEBSOCKET_SUSPEND;\n\n/**\n * The {@link AtmosphereFramework} is the entry point for the framework. This class can be used to from Servlet/filter\n * to dispatch {@link AtmosphereRequest} and {@link AtmosphereResponse}. The framework can also be configured using\n * the setXXX method. The life cycle of this class is\n * <blockquote><pre>\n * AtmosphereFramework f = new AtmosphereFramework();\n * f.init();\n * f.doCometSupport(AtmosphereRequest, AtmosphereResource);\n * f.destroy();\n * </pre></blockquote>\n *\n * @author Jeanfrancois Arcand\n */\npublic class AtmosphereFramework {\n\n    public static final String DEFAULT_ATMOSPHERE_CONFIG_PATH = \"/META-INF/atmosphere.xml\";\n    public static final String DEFAULT_LIB_PATH = \"/WEB-INF/lib/\";\n    public static final String DEFAULT_HANDLER_PATH = \"/WEB-INF/classes/\";\n    public static final String META_SERVICE = \"META-INF/services/\";\n    public static final String MAPPING_REGEX = \"[a-zA-Z0-9-&.*_~=@;\\\\?]+\";\n    public static final String ASYNC_IO = \"io.async\";\n\n    protected static final Logger logger = LoggerFactory.getLogger(AtmosphereFramework.class);\n\n    protected final List<String> broadcasterFilters = new ArrayList<>();\n    protected final List<AsyncSupportListener> asyncSupportListeners = new ArrayList<>();\n    protected final List<AtmosphereResourceListener> atmosphereResourceListeners = new ArrayList<>();\n    protected final ArrayList<String> possibleComponentsCandidate = new ArrayList<>();\n    protected final HashMap<String, String> initParams = new HashMap<>();\n    protected final AtmosphereConfig config;\n    protected final AtomicBoolean isCometSupportConfigured = new AtomicBoolean(false);\n    protected final boolean isFilter;\n    protected final Map<String, AtmosphereHandlerWrapper> atmosphereHandlers = new ConcurrentHashMap<>();\n    protected final ConcurrentLinkedQueue<String> broadcasterTypes = new ConcurrentLinkedQueue<>();\n    protected final ConcurrentLinkedQueue<String> objectFactoryType = new ConcurrentLinkedQueue<>();\n    protected final ConcurrentLinkedQueue<BroadcasterCacheInspector> inspectors = new ConcurrentLinkedQueue<>();\n\n    protected String mappingRegex = MAPPING_REGEX;\n    protected boolean useNativeImplementation;\n    protected boolean useBlockingImplementation;\n    protected boolean useStreamForFlushingComments = true;\n    protected boolean useServlet30 = true;\n    protected AsyncSupport asyncSupport;\n    protected String broadcasterClassName = DefaultBroadcaster.class.getName();\n    protected boolean isCometSupportSpecified;\n    protected boolean isBroadcasterSpecified;\n    protected boolean isSessionSupportSpecified;\n    protected boolean isThrowExceptionOnClonedRequestSpecified;\n    protected BroadcasterFactory broadcasterFactory;\n    protected String broadcasterFactoryClassName;\n    protected String broadcasterCacheClassName;\n    protected boolean webSocketEnabled = true;\n    protected String broadcasterLifeCyclePolicy = \"NEVER\";\n    protected String webSocketProtocolClassName = SimpleHttpProtocol.class.getName();\n    protected WebSocketProtocol webSocketProtocol;\n    protected String handlersPath = DEFAULT_HANDLER_PATH;\n    protected ServletConfig servletConfig;\n    protected boolean autoDetectHandlers = true;\n    private boolean hasNewWebSocketProtocol;\n    protected String atmosphereDotXmlPath = DEFAULT_ATMOSPHERE_CONFIG_PATH;\n    protected String metaServicePath = META_SERVICE;\n    protected final LinkedList<AtmosphereInterceptor> interceptors = new LinkedList<>();\n    protected boolean scanDone;\n    protected String annotationProcessorClassName = \"org.atmosphere.cpr.DefaultAnnotationProcessor\";\n    protected final List<BroadcasterListener> broadcasterListeners = Collections.synchronizedList(new ArrayList<>());\n    protected String webSocketProcessorClassName = DefaultWebSocketProcessor.class.getName();\n    protected boolean webSocketProtocolInitialized;\n    protected EndpointMapper<AtmosphereHandlerWrapper> endpointMapper = new DefaultEndpointMapper<>();\n    protected String libPath = DEFAULT_LIB_PATH;\n    protected boolean isInit;\n    protected boolean sharedThreadPools = true;\n    protected final List<String> packages = new ArrayList<>();\n    protected final LinkedList<String> annotationPackages = new LinkedList<>();\n    protected boolean allowAllClassesScan = true;\n    protected boolean annotationFound;\n    protected boolean executeFirstSet;\n    protected AtmosphereObjectFactory<?> objectFactory = new DefaultAtmosphereObjectFactory();\n    protected final AtomicBoolean isDestroyed = new AtomicBoolean();\n    protected boolean externalizeDestroy;\n    protected AnnotationProcessor annotationProcessor;\n    protected final List<String> excludedInterceptors = new ArrayList<>();\n    protected final LinkedList<BroadcasterCacheListener> broadcasterCacheListeners = new LinkedList<>();\n    protected final List<BroadcasterConfig.FilterManipulator> filterManipulators = new ArrayList<>();\n    protected AtmosphereResourceFactory arFactory;\n    protected MetaBroadcaster metaBroadcaster;\n    protected AtmosphereResourceSessionFactory sessionFactory;\n    protected String defaultSerializerClassName;\n    protected Class<Serializer> defaultSerializerClass;\n    protected final List<AtmosphereFrameworkListener> frameworkListeners = new LinkedList<>();\n    private UUIDProvider uuidProvider = new DefaultUUIDProvider();\n    protected Thread shutdownHook;\n    public static final List<Class<? extends AtmosphereInterceptor>> DEFAULT_ATMOSPHERE_INTERCEPTORS = new LinkedList<Class<? extends AtmosphereInterceptor>>() {\n        {\n            // Add CORS support\n            add(CorsInterceptor.class);\n            // Default Interceptor\n            add(CacheHeadersInterceptor.class);\n            // WebKit & IE Padding\n            add(PaddingAtmosphereInterceptor.class);\n            // Android 2.3.x streaming support\n            add(AndroidAtmosphereInterceptor.class);\n            // Heartbeat\n            add(HeartbeatInterceptor.class);\n            // Add SSE support\n            add(SSEAtmosphereInterceptor.class);\n            // ADD JSONP support\n            add(JSONPAtmosphereInterceptor.class);\n            // ADD Tracking ID Handshake\n            add(JavaScriptProtocol.class);\n            // WebSocket and suspend\n            add(WebSocketMessageSuspendInterceptor.class);\n            // OnDisconnect\n            add(OnDisconnectInterceptor.class);\n            // Idle connection\n            add(IdleResourceInterceptor.class);\n        }\n    };\n    private WebSocketFactory webSocketFactory;\n    private IllegalStateException initializationError;\n\n    /**\n     * An implementation of {@link AbstractReflectorAtmosphereHandler}.\n     */\n    public final static AtmosphereHandler REFLECTOR_ATMOSPHEREHANDLER = new AbstractReflectorAtmosphereHandler() {\n        @Override\n        public void onRequest(AtmosphereResource resource) {\n            logger.trace(\"VoidHandler {}\", resource.uuid());\n        }\n\n        @Override\n        public void destroy() {\n            logger.trace(\"VoidHandler\");\n        }\n    };\n\n    public void setAndConfigureAtmosphereResourceFactory(AtmosphereResourceFactory arFactory) {\n        this.arFactory = arFactory;\n        this.arFactory.configure(config);\n    }\n\n    public static final class AtmosphereHandlerWrapper {\n\n        public final AtmosphereHandler atmosphereHandler;\n        public Broadcaster broadcaster;\n        public String mapping;\n        public final LinkedList<AtmosphereInterceptor> interceptors = new LinkedList<>();\n        public boolean create;\n        private boolean needRequestScopedInjection;\n        private final boolean wilcardMapping;\n\n        public AtmosphereHandlerWrapper(BroadcasterFactory broadcasterFactory, final AtmosphereHandler atmosphereHandler, String mapping,\n                                        final AtmosphereConfig config) {\n            this.atmosphereHandler = atmosphereHandler;\n\n            try {\n                if (broadcasterFactory != null) {\n                    this.broadcaster = broadcasterFactory.lookup(mapping, true);\n                } else {\n                    this.mapping = mapping;\n                }\n            } catch (Exception t) {\n                throw new RuntimeException(t);\n            }\n            wilcardMapping = mapping.contains(\"{\") && mapping.contains(\"}\");\n            hookInjection(config);\n        }\n\n        void hookInjection(final AtmosphereConfig config) {\n            config.startupHook(framework -> needRequestScopedInjection = Utils.requestScopedInjection(config, atmosphereHandler));\n        }\n\n        public AtmosphereHandlerWrapper(final AtmosphereHandler atmosphereHandler, Broadcaster broadcaster,\n                                        final AtmosphereConfig config) {\n            this.atmosphereHandler = atmosphereHandler;\n            this.broadcaster = broadcaster;\n            hookInjection(config);\n            wilcardMapping = false;\n        }\n\n        @Override\n        public String toString() {\n\n            StringBuilder b = new StringBuilder();\n            for (int i = 0; i < interceptors.size(); i++) {\n                b.append(\"\\n\\t\").append(i).append(\": \").append(interceptors.get(i).getClass().getName());\n            }\n\n            return \"\\n atmosphereHandler\"\n                    + \"\\n\\t\" + atmosphereHandler\n                    + \"\\n interceptors\" +\n                    b.toString()\n                    + \"\\n broadcaster\"\n                    + \"\\t\" + broadcaster;\n        }\n\n        public boolean needRequestScopedInjection() {\n            return needRequestScopedInjection;\n        }\n\n        public boolean wildcardMapping() {\n            return wilcardMapping;\n        }\n    }\n\n    /**\n     * <p>\n     * This enumeration represents all possible actions to specify in a meta service file.\n     * </p>\n     *\n     * @author Guillaume DROUET\n     * @version 1.0\n     * @since 2.2.0\n     */\n    public enum MetaServiceAction {\n\n        /**\n         * Install service.\n         */\n        INSTALL(new InstallMetaServiceProcedure()),\n\n        /**\n         * Exclude service.\n         */\n        EXCLUDE(new ExcludeMetaServiceProcedure());\n\n        /**\n         * The procedure to apply.\n         */\n        private MetaServiceProcedure procedure;\n\n        /**\n         * <p>\n         * Builds a new instance.\n         * </p>\n         *\n         * @param p the enum procedure\n         */\n        MetaServiceAction(final MetaServiceProcedure p) {\n            procedure = p;\n        }\n\n        /**\n         * <p>\n         * Applies this action to given class.\n         * </p>\n         *\n         * @param fwk   the framework\n         * @param clazz the class\n         * @throws Exception if procedure fails\n         */\n        public void apply(final AtmosphereFramework fwk, final Class<?> clazz) throws Exception {\n            procedure.apply(fwk, clazz);\n\n        }\n\n        /**\n         * <p>\n         * This interface defined a method with a signature like a procedure to process an action.\n         * </p>\n         *\n         * @author Guillaume DROUET\n         * @version 1.0\n         * @since 2.2.0\n         */\n        private interface MetaServiceProcedure {\n\n            /**\n             * <p>\n             * Processes an action.\n             * </p>\n             *\n             * @param fwk   the framework\n             * @param clazz the class to use during processing\n             * @throws Exception if procedure fails\n             */\n            void apply(final AtmosphereFramework fwk, final Class<?> clazz) throws Exception;\n        }\n\n        /**\n         * <p>\n         * Install the classes.\n         * </p>\n         *\n         * @author Guillaume DROUET\n         * @version 1.0\n         * @since 2.2.0\n         */\n        private static class InstallMetaServiceProcedure implements MetaServiceProcedure {\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public void apply(final AtmosphereFramework fwk, final Class c) throws Exception {\n                if (AtmosphereInterceptor.class.isAssignableFrom(c)) {\n                    fwk.interceptor(fwk.newClassInstance(AtmosphereInterceptor.class, c));\n                } else if (Broadcaster.class.isAssignableFrom(c)) {\n                    fwk.setDefaultBroadcasterClassName(c.getName());\n                } else if (BroadcasterListener.class.isAssignableFrom(c)) {\n                    fwk.addBroadcasterListener(fwk.newClassInstance(BroadcasterListener.class, c));\n                } else if (BroadcasterCache.class.isAssignableFrom(c)) {\n                    fwk.setBroadcasterCacheClassName(c.getName());\n                } else if (BroadcastFilter.class.isAssignableFrom(c)) {\n                    fwk.broadcasterFilters.add(c.getName());\n                } else if (BroadcasterCacheInspector.class.isAssignableFrom(c)) {\n                    fwk.inspectors.add(fwk.newClassInstance(BroadcasterCacheInspector.class, c));\n                } else if (AsyncSupportListener.class.isAssignableFrom(c)) {\n                    fwk.asyncSupportListeners.add(fwk.newClassInstance(AsyncSupportListener.class, c));\n                } else if (AsyncSupport.class.isAssignableFrom(c)) {\n                    fwk.setAsyncSupport(fwk.newClassInstance(AsyncSupport.class, c));\n                } else if (BroadcasterCacheListener.class.isAssignableFrom(c)) {\n                    fwk.broadcasterCacheListeners.add(fwk.newClassInstance(BroadcasterCacheListener.class, c));\n                } else if (BroadcasterConfig.FilterManipulator.class.isAssignableFrom(c)) {\n                    fwk.filterManipulators.add(fwk.newClassInstance(BroadcasterConfig.FilterManipulator.class, c));\n                } else if (WebSocketProtocol.class.isAssignableFrom(c)) {\n                    fwk.webSocketProtocolClassName = c.getName();\n                } else if (WebSocketProcessor.class.isAssignableFrom(c)) {\n                    fwk.webSocketProcessorClassName = c.getName();\n                } else if (AtmosphereResourceFactory.class.isAssignableFrom(c)) {\n                    fwk.setAndConfigureAtmosphereResourceFactory(fwk.newClassInstance(AtmosphereResourceFactory.class, c));\n                } else if (AtmosphereFrameworkListener.class.isAssignableFrom(c)) {\n                    fwk.frameworkListener(fwk.newClassInstance(AtmosphereFrameworkListener.class, c));\n                } else if (WebSocketFactory.class.isAssignableFrom(c)) {\n                    fwk.webSocketFactory(fwk.newClassInstance(WebSocketFactory.class, c));\n                } else if (AtmosphereFramework.class.isAssignableFrom(c)) {\n                    // No OPS\n                } else if (EndpointMapper.class.isAssignableFrom(c)) {\n                    fwk.endPointMapper(fwk.newClassInstance(EndpointMapper.class, c));\n                } else {\n                    logger.warn(\"{} is not a framework service that could be installed\", c.getName());\n                }\n            }\n        }\n\n        /**\n         * <p>\n         * Exclude the services.\n         * </p>\n         *\n         * @author Guillaume DROUET\n         * @version 1.0\n         * @since 2.2.0\n         */\n        private static class ExcludeMetaServiceProcedure implements MetaServiceProcedure {\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public void apply(final AtmosphereFramework fwk, final Class<?> c) {\n                if (AtmosphereInterceptor.class.isAssignableFrom(c)) {\n                    fwk.excludeInterceptor(c.getName());\n                } else {\n                    logger.warn(\"{} is not a framework service that could be excluded, pull request is welcome ;-)\", c.getName());\n                }\n            }\n        }\n    }\n\n    public static class DefaultAtmosphereObjectFactory implements AtmosphereObjectFactory<Object> {\n        public String toString() {\n            return \"DefaultAtmosphereObjectFactory\";\n        }\n\n        @Override\n        public void configure(AtmosphereConfig config) {\n        }\n\n        @Override\n        public <T, U extends T> U newClassInstance(Class<T> classType,\n                                                   Class<U> defaultType) throws InstantiationException, IllegalAccessException {\n            return defaultType.newInstance();\n        }\n\n        @Override\n        public AtmosphereObjectFactory<Object> allowInjectionOf(java.lang.Object o) {\n            return this;\n        }\n    }\n\n    /**\n     * Create an AtmosphereFramework.\n     */\n    public AtmosphereFramework() {\n        this(false, true);\n    }\n\n    /**\n     * Create an AtmosphereFramework and initialize it via {@link AtmosphereFramework#init(javax.servlet.ServletConfig)}.\n     */\n    public AtmosphereFramework(ServletConfig sc) throws ServletException {\n        this(false, true);\n        // TODO: What?\n        init(sc);\n    }\n\n    /**\n     * Create an AtmosphereFramework.\n     *\n     * @param isFilter true if this instance is used as an {@link AtmosphereFilter}\n     */\n    public AtmosphereFramework(boolean isFilter, boolean autoDetectHandlers) {\n        this.isFilter = isFilter;\n        this.autoDetectHandlers = autoDetectHandlers;\n        config = newAtmosphereConfig();\n    }\n\n    /**\n     * Create an instance of {@link org.atmosphere.cpr.AtmosphereConfig}\n     */\n    protected AtmosphereConfig newAtmosphereConfig() {\n        return new AtmosphereConfig(this);\n    }\n\n    /**\n     * The order of addition is quite important here.\n     */\n    private void populateBroadcasterType() {\n        broadcasterTypes.add(KAFKA_BROADCASTER);\n        broadcasterTypes.add(HAZELCAST_BROADCASTER);\n        broadcasterTypes.add(XMPP_BROADCASTER);\n        broadcasterTypes.add(REDIS_BROADCASTER);\n        broadcasterTypes.add(JGROUPS_BROADCASTER);\n        broadcasterTypes.add(JMS_BROADCASTER);\n        broadcasterTypes.add(RMI_BROADCASTER);\n        broadcasterTypes.add(RABBITMQ_BROADCASTER);\n    }\n\n    /**\n     * The order of addition is quite important here.\n     */\n    private void populateObjectFactoryType() {\n        objectFactoryType.add(CDI_INJECTOR);\n        objectFactoryType.add(SPRING_INJECTOR);\n        objectFactoryType.add(GUICE_INJECTOR);\n    }\n\n    /**\n     * Add an {@link AtmosphereHandler} serviced by the {@link Servlet}\n     * This API is exposed to allow embedding an Atmosphere application.\n     *\n     * @param mapping The servlet mapping (servlet path)\n     * @param h       implementation of an {@link AtmosphereHandler}\n     * @param l       An array of {@link AtmosphereInterceptor}.\n     */\n    public AtmosphereFramework addAtmosphereHandler(String mapping, AtmosphereHandler h, List<AtmosphereInterceptor> l) {\n        if (!mapping.startsWith(\"/\")) {\n            mapping = \"/\" + mapping;\n        }\n        createWrapperAndConfigureHandler(h, mapping, l);\n\n        if (!isInit) {\n            logger.info(\"Installed AtmosphereHandler {} mapped to context-path: {}\", h.getClass().getName(), mapping);\n            logger.info(\"Installed the following AtmosphereInterceptor mapped to AtmosphereHandler {}\", h.getClass().getName());\n            if (!l.isEmpty()) {\n                for (AtmosphereInterceptor s : l) {\n                    logger.info(\"\\t{} : {}\", s.getClass().getName(), s);\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Add an {@link AtmosphereHandler} serviced by the {@link Servlet}.\n     * This API is exposed to allow embedding an Atmosphere application.\n     *\n     * @param mapping     The servlet mapping (servlet path)\n     * @param h           implementation of an {@link AtmosphereHandler}\n     * @param broadcaster The {@link Broadcaster} associated with AtmosphereHandler\n     * @param l           A list of {@link AtmosphereInterceptor}s\n     */\n    public AtmosphereFramework addAtmosphereHandler(String mapping, AtmosphereHandler h, Broadcaster broadcaster, List<AtmosphereInterceptor> l) {\n        if (!mapping.startsWith(\"/\")) {\n            mapping = \"/\" + mapping;\n        }\n\n        createWrapperAndConfigureHandler(h, mapping, l).broadcaster = broadcaster;\n\n        if (!isInit) {\n            logger.info(\"Installed AtmosphereHandler {} mapped to context-path {} and Broadcaster Class {}\", h.getClass().getName(), mapping, broadcaster.getClass().getName());\n        } else {\n            logger.debug(\"Installed AtmosphereHandler {} mapped to context-path {} and Broadcaster Class {}\",\n                    h.getClass().getName(), mapping, broadcaster.getClass().getName());\n        }\n\n        if (!l.isEmpty()) {\n            logger.info(\"Installed AtmosphereInterceptor {} mapped to AtmosphereHandler {}\", l, h.getClass().getName());\n        }\n        return this;\n    }\n\n\n    /**\n     * Add an {@link AtmosphereHandler} serviced by the {@link Servlet}.\n     * This API is exposed to allow embedding an Atmosphere application.\n     *\n     * @param mapping       The servlet mapping (servlet path)\n     * @param h             implementation of an {@link AtmosphereHandler}\n     * @param broadcasterId The {@link Broadcaster#getID} value.\n     * @param l             A list of {@link AtmosphereInterceptor}\n     */\n    public AtmosphereFramework addAtmosphereHandler(String mapping, AtmosphereHandler h, String broadcasterId, List<AtmosphereInterceptor> l) {\n        if (!mapping.startsWith(\"/\")) {\n            mapping = \"/\" + mapping;\n        }\n\n        createWrapperAndConfigureHandler(h, mapping, l).broadcaster.setID(broadcasterId);\n\n        logger.info(\"Installed AtmosphereHandler {} mapped to context-path: {}\", h.getClass().getName(), mapping);\n        if (!l.isEmpty()) {\n            logger.info(\"Installed AtmosphereInterceptor {} mapped to AtmosphereHandler {}\", l, h.getClass().getName());\n        }\n        return this;\n    }\n\n    protected AtmosphereHandlerWrapper createWrapperAndConfigureHandler(AtmosphereHandler h, String mapping, List<AtmosphereInterceptor> l) {\n        AtmosphereHandlerWrapper w = new AtmosphereHandlerWrapper(broadcasterFactory, h, mapping, config);\n        addMapping(mapping, w);\n        addInterceptorToWrapper(w, l);\n        initServletProcessor(h);\n        return w;\n    }\n\n    /**\n     * Add an {@link AtmosphereHandler} serviced by the {@link Servlet}\n     * This API is exposed to allow embedding an Atmosphere application.\n     *\n     * @param mapping The servlet mapping (servlet path)\n     * @param h       implementation of an {@link AtmosphereHandler}\n     */\n    public AtmosphereFramework addAtmosphereHandler(String mapping, AtmosphereHandler h) {\n        addAtmosphereHandler(mapping, h, Collections.emptyList());\n        return this;\n    }\n\n    private AtmosphereFramework addMapping(String path, AtmosphereHandlerWrapper w) {\n        atmosphereHandlers.put(normalizePath(path), w);\n        return this;\n    }\n\n    public String normalizePath(String path) {\n        // We are using JAXRS mapping algorithm.\n        if (path.contains(\"*\")) {\n            path = path.replace(\"*\", mappingRegex);\n        }\n\n        if (path.endsWith(\"/\")) {\n            path = path + mappingRegex;\n        }\n        return path;\n    }\n\n\n    /**\n     * Add an {@link AtmosphereHandler} serviced by the {@link Servlet}.\n     * This API is exposed to allow embedding an Atmosphere application.\n     *\n     * @param mapping       The servlet mapping (servlet path)\n     * @param h             implementation of an {@link AtmosphereHandler}\n     * @param broadcasterId The {@link Broadcaster#getID} value\n     */\n    public AtmosphereFramework addAtmosphereHandler(String mapping, AtmosphereHandler h, String broadcasterId) {\n        addAtmosphereHandler(mapping, h, broadcasterId, Collections.emptyList());\n        return this;\n    }\n\n    private void initServletProcessor(AtmosphereHandler h) {\n        if (!isInit) return;\n\n        try {\n            if (h instanceof AtmosphereServletProcessor) {\n                ((AtmosphereServletProcessor) h).init(config);\n            }\n        } catch (ServletException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Add an {@link AtmosphereHandler} serviced by the {@link Servlet}.\n     * This API is exposed to allow embedding an Atmosphere application.\n     *\n     * @param mapping     The servlet mapping (servlet path)\n     * @param h           implementation of an {@link AtmosphereHandler}\n     * @param broadcaster The {@link Broadcaster} associated with AtmosphereHandler.\n     */\n    public AtmosphereFramework addAtmosphereHandler(String mapping, AtmosphereHandler h, Broadcaster broadcaster) {\n        addAtmosphereHandler(mapping, h, broadcaster, Collections.emptyList());\n        return this;\n    }\n\n    /**\n     * Remove an {@link AtmosphereHandler}.\n     *\n     * @param mapping the mapping used when invoking {@link #addAtmosphereHandler(String, AtmosphereHandler)};\n     * @return true if removed\n     */\n    public AtmosphereFramework removeAtmosphereHandler(String mapping) {\n\n        if (mapping.endsWith(\"/\")) {\n            mapping += mappingRegex;\n        }\n\n        atmosphereHandlers.remove(mapping);\n        return this;\n    }\n\n    /**\n     * Remove all {@link AtmosphereHandler}s.\n     */\n    public AtmosphereFramework removeAllAtmosphereHandler() {\n        atmosphereHandlers.clear();\n        return this;\n    }\n\n    /**\n     * Remove all init parameters.\n     */\n    public AtmosphereFramework removeAllInitParams() {\n        initParams.clear();\n        return this;\n    }\n\n    /**\n     * Add init-param like if they were defined in web.xml\n     *\n     * @param name  The name\n     * @param value The value\n     */\n    public AtmosphereFramework addInitParameter(String name, String value) {\n        initParams.put(name, value);\n        return this;\n    }\n\n    protected void readSystemProperties() {\n        if (System.getProperty(PROPERTY_NATIVE_COMETSUPPORT) != null) {\n            useNativeImplementation = Boolean\n                    .parseBoolean(System.getProperty(PROPERTY_NATIVE_COMETSUPPORT));\n            isCometSupportSpecified = true;\n        }\n\n        if (System.getProperty(PROPERTY_BLOCKING_COMETSUPPORT) != null) {\n            useBlockingImplementation = Boolean\n                    .parseBoolean(System.getProperty(PROPERTY_BLOCKING_COMETSUPPORT));\n            isCometSupportSpecified = true;\n        }\n        atmosphereDotXmlPath = System.getProperty(PROPERTY_ATMOSPHERE_XML, atmosphereDotXmlPath);\n\n        if (System.getProperty(DISABLE_ONSTATE_EVENT) != null) {\n            initParams.put(DISABLE_ONSTATE_EVENT, System.getProperty(DISABLE_ONSTATE_EVENT));\n        }\n    }\n\n    /**\n     * Path specific container using their own property.\n     */\n    public void patchContainer() {\n        System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"false\");\n    }\n\n    /**\n     * Initialize the AtmosphereFramework. Invoke this method after having properly configured this class using the setters.\n     */\n    public AtmosphereFramework init() {\n        try {\n            init(servletConfig == null ? new VoidServletConfig(initParams) : servletConfig, false);\n        } catch (ServletException e) {\n            logger.error(\"\", e);\n        }\n        return this;\n    }\n\n    /**\n     * Initialize the AtmosphereFramework using the {@link ServletContext}.\n     *\n     * @param sc the {@link ServletContext}\n     */\n    public AtmosphereFramework init(final ServletConfig sc) throws ServletException {\n        return init(sc, true);\n    }\n\n    /**\n     * Prevent Atmosphere from scanning the entire class path.\n     */\n    protected void preventOOM() {\n\n        String s = config.getInitParameter(ApplicationConfig.SCAN_CLASSPATH);\n        if (s != null) {\n            allowAllClassesScan = Boolean.parseBoolean(s);\n        }\n\n        try {\n            Class.forName(\"org.testng.Assert\");\n            allowAllClassesScan = false;\n        } catch (ClassNotFoundException e) {\n        }\n    }\n\n    /**\n     * Initialize the AtmosphereFramework using the {@link ServletContext}.\n     *\n     * @param sc the {@link ServletContext}\n     */\n    public AtmosphereFramework init(final ServletConfig sc, boolean wrap) throws ServletException {\n        if (isInit) return this;\n\n        servletConfig(sc, wrap);\n        readSystemProperties();\n        populateBroadcasterType();\n        populateObjectFactoryType();\n        loadMetaService();\n        onPreInit();\n\n        try {\n\n            ServletContextFactory.getDefault().init(sc.getServletContext());\n\n            preventOOM();\n            doInitParams(servletConfig);\n            doInitParamsForWebSocket(servletConfig);\n            lookupDefaultObjectFactoryType();\n\n            if (logger.isTraceEnabled()) {\n                asyncSupportListener(newClassInstance(AsyncSupportListener.class, AsyncSupportListenerAdapter.class));\n            }\n\n            configureObjectFactory();\n            configureAnnotationPackages();\n\n            configureBroadcasterFactory();\n            configureMetaBroadcaster();\n            configureAtmosphereResourceFactory();\n            if (isSessionSupportSpecified) {\n                sessionFactory();\n            }\n            configureScanningPackage(servletConfig, ApplicationConfig.ANNOTATION_PACKAGE);\n            configureScanningPackage(servletConfig, FrameworkConfig.JERSEY2_SCANNING_PACKAGE);\n            configureScanningPackage(servletConfig, FrameworkConfig.JERSEY_SCANNING_PACKAGE);\n            // Force scanning of the packages defined.\n            defaultPackagesToScan();\n\n            installAnnotationProcessor(servletConfig);\n\n            autoConfigureService(servletConfig.getServletContext());\n\n            // Reconfigure in case an annotation changed the default.\n            configureBroadcasterFactory();\n            patchContainer();\n            configureBroadcaster();\n            loadConfiguration(servletConfig);\n            initWebSocket();\n            initEndpointMapper();\n            initDefaultSerializer();\n\n            autoDetectContainer();\n            configureWebDotXmlAtmosphereHandler(servletConfig);\n            asyncSupport.init(servletConfig);\n            initAtmosphereHandler(servletConfig);\n            configureAtmosphereInterceptor(servletConfig);\n            analytics();\n\n            // http://java.net/jira/browse/ATMOSPHERE-157\n            if (sc.getServletContext() != null) {\n                sc.getServletContext().setAttribute(BroadcasterFactory.class.getName(), broadcasterFactory);\n            }\n\n            String s = config.getInitParameter(ApplicationConfig.BROADCASTER_SHARABLE_THREAD_POOLS);\n            if (s != null) {\n                sharedThreadPools = Boolean.parseBoolean(s);\n            }\n\n            this.shutdownHook = new Thread(AtmosphereFramework.this::destroy);\n\n            Runtime.getRuntime().addShutdownHook(this.shutdownHook);\n\n            if (logger.isInfoEnabled()) {\n                info();\n            }\n\n            if (initializationError != null) {\n                logger.trace(\"ContainerInitalizer exception. May not be an issue if Atmosphere started properly \", initializationError);\n            }\n\n            universe();\n        } catch (Throwable t) {\n            logger.error(\"Failed to initialize Atmosphere Framework\", t);\n\n            if (t instanceof ServletException) {\n                throw (ServletException) t;\n            }\n\n            throw new ServletException(t);\n        }\n        isInit = true;\n        config.initComplete();\n\n        // wlc 12.x\n        if (WebLogicServlet30WithWebSocket.class.isAssignableFrom(asyncSupport.getClass())) {\n            servletConfig.getServletContext().setAttribute(AtmosphereConfig.class.getName(), config);\n        }\n\n        onPostInit();\n\n        return this;\n    }\n\n    protected void servletConfig(final ServletConfig sc, boolean wrap) {\n        if (wrap) {\n\n            String value = sc.getServletContext().getInitParameter(USE_SERVLET_CONTEXT_PARAMETERS);\n            final boolean useServletContextParameters = Boolean.parseBoolean(value);\n\n            servletConfig = new ServletConfig() {\n\n                final AtomicBoolean done = new AtomicBoolean();\n\n                public String getServletName() {\n                    return sc.getServletName();\n                }\n\n                public ServletContext getServletContext() {\n                    return sc.getServletContext();\n                }\n\n                public String getInitParameter(String name) {\n                    String param = initParams.get(name);\n                    if (param == null) {\n                        param = sc.getInitParameter(name);\n\n                        if (param == null && useServletContextParameters) {\n                            param = sc.getServletContext().getInitParameter(name);\n                        }\n                    }\n                    return param;\n                }\n\n                public Enumeration<String> getInitParameterNames() {\n                    if (!done.getAndSet(true)) {\n                        Enumeration<String> en = sc.getInitParameterNames();\n                        if (en != null) {\n                            while (en.hasMoreElements()) {\n                                String name = en.nextElement();\n                                if (!initParams.containsKey(name)) {\n                                    initParams.put(name, sc.getInitParameter(name));\n                                }\n                            }\n                        }\n                    }\n                    return Collections.enumeration(initParams.keySet());\n                }\n            };\n        } else {\n            servletConfig = sc;\n        }\n    }\n\n    public void reconfigureInitParams(boolean reconfigureInitParams) {\n        if (reconfigureInitParams) {\n            doInitParams(servletConfig, reconfigureInitParams);\n            doInitParamsForWebSocket(servletConfig);\n        }\n    }\n\n    private void info() {\n\n        if (logger.isTraceEnabled()) {\n            Enumeration<String> e = servletConfig.getInitParameterNames();\n            logger.trace(\"Configured init-params\");\n            String n;\n            while (e.hasMoreElements()) {\n                n = e.nextElement();\n                logger.trace(\"\\t{} = {}\", n, servletConfig.getInitParameter(n));\n            }\n        }\n\n        logger.info(\"Using EndpointMapper {}\", endpointMapper.getClass());\n        for (String i : broadcasterFilters) {\n            logger.info(\"Using BroadcastFilter: {}\", i);\n        }\n\n        if (broadcasterCacheClassName == null || DefaultBroadcasterCache.class.getName().equals(broadcasterCacheClassName)) {\n            logger.warn(\"No BroadcasterCache configured. Broadcasted message between client reconnection will be LOST. \" +\n                    \"It is recommended to configure the {}\", UUIDBroadcasterCache.class.getName());\n        } else {\n            logger.info(\"Using BroadcasterCache: {}\", broadcasterCacheClassName);\n        }\n\n        String s = config.getInitParameter(BROADCASTER_WAIT_TIME);\n\n        logger.info(\"Default Broadcaster Class: {}\", broadcasterClassName);\n        logger.info(\"Broadcaster Shared List Resources: {}\", config.getInitParameter(BROADCASTER_SHAREABLE_LISTENERS, false));\n        logger.info(\"Broadcaster Polling Wait Time {}\", s == null ? DefaultBroadcaster.POLLING_DEFAULT : s);\n        logger.info(\"Shared ExecutorService supported: {}\", sharedThreadPools);\n\n        ExecutorService executorService = ExecutorsFactory.getMessageDispatcher(config, Broadcaster.ROOT_MASTER);\n        if (executorService != null) {\n            if (ThreadPoolExecutor.class.isAssignableFrom(executorService.getClass())) {\n                long max = ((ThreadPoolExecutor) executorService).getMaximumPoolSize();\n                logger.info(\"Messaging Thread Pool Size: {}\",\n                        ((ThreadPoolExecutor) executorService).getMaximumPoolSize() == 2147483647 ? \"Unlimited\" : max);\n            } else {\n                logger.info(\"Messaging ExecutorService Pool Size unavailable - Not instance of ThreadPoolExecutor\");\n            }\n        }\n\n        executorService = ExecutorsFactory.getAsyncOperationExecutor(config, Broadcaster.ROOT_MASTER);\n        if (executorService != null) {\n            if (ThreadPoolExecutor.class.isAssignableFrom(executorService.getClass())) {\n                logger.info(\"Async I/O Thread Pool Size: {}\",\n                        ((ThreadPoolExecutor) executorService).getMaximumPoolSize());\n            } else {\n                logger.info(\"Async I/O ExecutorService Pool Size unavailable - Not instance of ThreadPoolExecutor\");\n            }\n        }\n        logger.info(\"Using BroadcasterFactory: {}\", broadcasterFactory.getClass().getName());\n        logger.info(\"Using AtmosphereResurceFactory: {}\", arFactory.getClass().getName());\n        logger.info(\"Using WebSocketProcessor: {}\", webSocketProcessorClassName);\n        if (defaultSerializerClassName != null && !defaultSerializerClassName.isEmpty()) {\n            logger.info(\"Using Serializer: {}\", defaultSerializerClassName);\n        }\n\n        WebSocketProcessor wp = WebSocketProcessorFactory.getDefault().getWebSocketProcessor(this);\n        boolean b = false;\n        if (DefaultWebSocketProcessor.class.isAssignableFrom(wp.getClass())) {\n            b = ((DefaultWebSocketProcessor) wp).invokeInterceptors();\n        }\n        logger.info(\"Invoke AtmosphereInterceptor on WebSocket message {}\", b);\n        logger.info(\"HttpSession supported: {}\", config.isSupportSession());\n\n        logger.info(\"Atmosphere is using {} for dependency injection and object creation\", objectFactory);\n        logger.info(\"Atmosphere is using async support: {} running under container: {}\",\n                getAsyncSupport().getClass().getName(), asyncSupport.getContainerName());\n        logger.info(\"Atmosphere Framework {} started.\", Version.getRawVersion());\n\n        logger.info(\"\\n\\n\\tFor Atmosphere Framework Commercial Support, visit \\n\\t{} \" +\n                \"or send an email to {}\\n\", \"http://www.async-io.org/\", \"support@async-io.org\");\n\n        if (logger.isTraceEnabled()) {\n            for (Entry<String, AtmosphereHandlerWrapper> e : atmosphereHandlers.entrySet()) {\n                logger.trace(\"\\nConfigured AtmosphereHandler {}\\n\", e.getKey());\n                logger.trace(\"{}\", e.getValue());\n            }\n        }\n    }\n\n    protected void universe() {\n        Universe.broadcasterFactory(broadcasterFactory);\n        Universe.resourceFactory(arFactory);\n        Universe.sessionResourceFactory(sessionFactory);\n        Universe.framework(this);\n    }\n\n    private void configureAnnotationPackages() {\n        // We must scan the default annotation set.\n        annotationPackages.add(Processor.class.getPackage().getName());\n\n        String s = config.getInitParameter(ApplicationConfig.CUSTOM_ANNOTATION_PACKAGE);\n        if (s != null) {\n            String[] l = s.split(\",\");\n            for (String p : l) {\n                annotationPackages.addLast(p);\n            }\n        }\n    }\n\n    protected void analytics() {\n        if (!config.getInitParameter(ApplicationConfig.ANALYTICS, true)) return;\n\n        final String container = getServletContext().getServerInfo();\n        Thread t = new Thread(() -> {\n            try {\n                logger.debug(\"Retrieving Atmosphere's latest version from http://async-io.org/version.html\");\n                HttpURLConnection urlConnection = (HttpURLConnection)\n                        URI.create(\"http://async-io.org/version.html\").toURL().openConnection();\n                urlConnection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n                urlConnection.setRequestProperty(\"Connection\", \"keep-alive\");\n                urlConnection.setRequestProperty(\"Cache-Control\", \"max-age=0\");\n                urlConnection.setRequestProperty(\"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\");\n                urlConnection.setRequestProperty(\"Accept-Language\", \"en-US,en;q=0.8\");\n                urlConnection.setRequestProperty(\"Accept-Charset\", \"ISO-8859-1,utf-8;q=0.7,*;q=0.3\");\n                urlConnection.setRequestProperty(\"If-Modified-Since\", \"ISO-8859-1,utf-8;q=0.7,*;q=0.3\");\n                urlConnection.setInstanceFollowRedirects(true);\n\n                BufferedReader in = new BufferedReader(new InputStreamReader(\n                        urlConnection.getInputStream()));\n\n                String inputLine;\n                String newVersion = Version.getRawVersion();\n                String clientVersion = null;\n                String nextMajorRelease = null;\n                boolean nextAvailable = false;\n                if (!newVersion.contains(\"SNAPSHOT\")) {\n                    try {\n                        while ((inputLine = in.readLine().trim()) != null) {\n                            if (inputLine.startsWith(\"ATMO23_VERSION=\")) {\n                                newVersion = inputLine.substring(\"ATMO23_VERSION=\".length());\n                            } else if (inputLine.startsWith(\"CLIENT3_VERSION=\")) {\n                                clientVersion = inputLine.substring(\"CLIENT3_VERSION=\".length());\n                                break;\n                            } else if (inputLine.startsWith(\"ATMO_RELEASE_VERSION=\")) {\n                                nextMajorRelease = inputLine.substring(\"ATMO_RELEASE_VERSION=\".length());\n                                if (nextMajorRelease.compareTo(Version.getRawVersion()) > 0\n                                        && !nextMajorRelease.toLowerCase().contains(\"rc\")\n                                        && !nextMajorRelease.toLowerCase().contains(\"beta\")) {\n                                    nextAvailable = true;\n                                }\n                            }\n                        }\n                    } finally {\n                        if (clientVersion != null) {\n                            logger.info(\"Latest version of Atmosphere's JavaScript Client {}\", clientVersion);\n                        }\n                        if (newVersion.compareTo(Version.getRawVersion()) > 0) {\n                            if (nextAvailable) {\n                                logger.info(\"\\n\\n\\tAtmosphere Framework Updates\\n\\tMinor available (bugs fixes): {}\\n\\tMajor available (new features): {}\", newVersion, nextMajorRelease);\n                            } else {\n                                logger.info(\"\\n\\n\\tAtmosphere Framework Updates:\\n\\tMinor Update available (bugs fixes): {}\", newVersion);\n                            }\n                        } else if (nextAvailable) {\n                            logger.info(\"\\n\\n\\tAtmosphere Framework Updates:\\n\\tMajor Update available (new features): {}\", nextMajorRelease);\n                        }\n                        try {\n                            in.close();\n                        } catch (IOException ex) {\n                        }\n                        urlConnection.disconnect();\n                    }\n                }\n\n                JGoogleAnalyticsTracker tracker = new JGoogleAnalyticsTracker(ModuleDetection.detect(), Version.getRawVersion(), \"UA-31990725-1\");\n                tracker.trackSynchronously(new FocusPoint(container, new FocusPoint(\"Atmosphere\")));\n\n            } catch (Throwable e) {\n            }\n        });\n        t.setDaemon(true);\n        t.start();\n    }\n\n    /**\n     * Configure the list of {@link AtmosphereInterceptor}.\n     *\n     * @param sc a ServletConfig\n     */\n    protected void configureAtmosphereInterceptor(ServletConfig sc) {\n        String s = sc.getInitParameter(ApplicationConfig.ATMOSPHERE_INTERCEPTORS);\n        if (s != null) {\n            String[] list = s.split(\",\");\n            for (String a : list) {\n                try {\n                    AtmosphereInterceptor ai = newClassInstance(AtmosphereInterceptor.class,\n                            (Class<AtmosphereInterceptor>) IOUtils.loadClass(getClass(), a.trim()));\n                    interceptor(ai);\n                } catch (Exception e) {\n                    logger.warn(\"\", e);\n                }\n            }\n        }\n\n        s = sc.getInitParameter(ApplicationConfig.DISABLE_ATMOSPHEREINTERCEPTOR);\n        if (!Boolean.parseBoolean(s)) {\n            logger.info(\"Installing Default AtmosphereInterceptors\");\n\n            for (Class<? extends AtmosphereInterceptor> a : DEFAULT_ATMOSPHERE_INTERCEPTORS) {\n                if (!excludedInterceptors.contains(a.getName())) {\n                    interceptors.add(newAInterceptor(a));\n                } else {\n                    logger.info(\"Dropping Interceptor {}\", a.getName());\n                }\n            }\n            logger.info(\"Set {} to disable them.\", ApplicationConfig.DISABLE_ATMOSPHEREINTERCEPTOR);\n        }\n        addDefaultOrAppInterceptors();\n    }\n\n    protected AtmosphereInterceptor newAInterceptor(Class<? extends AtmosphereInterceptor> a) {\n        AtmosphereInterceptor ai = null;\n        try {\n            ai = newClassInstance(AtmosphereInterceptor.class,\n                    (Class<AtmosphereInterceptor>) IOUtils.loadClass(getClass(), a.getName()));\n            logger.info(\"\\t{} : {}\", a.getName(), ai);\n        } catch (Exception ex) {\n            logger.warn(\"\", ex);\n        }\n        return ai;\n    }\n\n    private static class InterceptorComparator implements Comparator<AtmosphereInterceptor> {\n        @Override\n        public int compare(AtmosphereInterceptor i1, AtmosphereInterceptor i2) {\n            InvokationOrder.PRIORITY p1, p2;\n\n            if (i1 instanceof InvokationOrder) {\n                p1 = ((InvokationOrder) i1).priority();\n            } else {\n                p1 = InvokationOrder.PRIORITY.AFTER_DEFAULT;\n            }\n\n            if (i2 instanceof InvokationOrder) {\n                p2 = ((InvokationOrder) i2).priority();\n            } else {\n                p2 = InvokationOrder.PRIORITY.AFTER_DEFAULT;\n            }\n\n            int orderResult = 0;\n\n            switch (p1) {\n                case AFTER_DEFAULT:\n                    switch (p2) {\n                        case BEFORE_DEFAULT:\n                        case FIRST_BEFORE_DEFAULT:\n                            orderResult = 1;\n                            break;\n                    }\n                    break;\n\n                case BEFORE_DEFAULT:\n                    switch (p2) {\n                        case AFTER_DEFAULT:\n                            orderResult = -1;\n                            break;\n                        case FIRST_BEFORE_DEFAULT:\n                            orderResult = 1;\n                            break;\n                    }\n                    break;\n\n                case FIRST_BEFORE_DEFAULT:\n                    switch (p2) {\n                        case AFTER_DEFAULT:\n                        case BEFORE_DEFAULT:\n                            orderResult = -1;\n                            break;\n                    }\n                    break;\n            }\n\n            return orderResult;\n        }\n    }\n\n    protected void configureWebDotXmlAtmosphereHandler(ServletConfig sc) {\n        String s = sc.getInitParameter(ATMOSPHERE_HANDLER);\n        if (s != null) {\n            try {\n\n                String mapping = sc.getInitParameter(ATMOSPHERE_HANDLER_MAPPING);\n                if (mapping == null) {\n                    mapping = Broadcaster.ROOT_MASTER;\n                }\n                addAtmosphereHandler(mapping, newClassInstance(AtmosphereHandler.class,\n                        (Class<AtmosphereHandler>) IOUtils.loadClass(getClass(), s)));\n            } catch (Exception ex) {\n                logger.warn(\"Unable to load WebSocketHandle instance\", ex);\n            }\n        }\n    }\n\n    protected void configureScanningPackage(ServletConfig sc, String value) {\n        String packageName = sc.getInitParameter(value);\n        if (packageName != null) {\n            String[] list = packageName.split(\",\");\n            Collections.addAll(packages, list);\n        }\n    }\n\n    protected void defaultPackagesToScan() {\n        // Atmosphere HA/Pro\n        packages.add(\"io.async.control\");\n        packages.add(\"io.async.satellite\");\n        packages.add(\"io.async.postman\");\n    }\n\n    public void configureBroadcasterFactory() {\n        try {\n            // Check auto supported one\n            if (!isBroadcasterSpecified) {\n                broadcasterClassName = lookupDefaultBroadcasterType(broadcasterClassName);\n            }\n\n            if (broadcasterFactoryClassName != null && broadcasterFactory == null) {\n                broadcasterFactory = newClassInstance(BroadcasterFactory.class,\n                        (Class<BroadcasterFactory>) IOUtils.loadClass(getClass(), broadcasterFactoryClassName));\n                Class<? extends Broadcaster> bc =\n                        (Class<? extends Broadcaster>) IOUtils.loadClass(getClass(), broadcasterClassName);\n                broadcasterFactory.configure(bc, broadcasterLifeCyclePolicy, config);\n            }\n\n            if (broadcasterFactory == null) {\n                Class<? extends Broadcaster> bc =\n                        (Class<? extends Broadcaster>) IOUtils.loadClass(getClass(), broadcasterClassName);\n                broadcasterFactory = newClassInstance(BroadcasterFactory.class, DefaultBroadcasterFactory.class);\n                broadcasterFactory.configure(bc, broadcasterLifeCyclePolicy, config);\n            }\n\n            for (BroadcasterListener b : broadcasterListeners) {\n                broadcasterFactory.addBroadcasterListener(b);\n            }\n        } catch (Exception ex) {\n            logger.error(\"Unable to configure Broadcaster/Factory/Cache\", ex);\n        }\n    }\n\n    protected void configureBroadcaster() {\n\n        try {\n            Iterator<Entry<String, AtmosphereHandlerWrapper>> i = atmosphereHandlers.entrySet().iterator();\n            AtmosphereHandlerWrapper w;\n            Entry<String, AtmosphereHandlerWrapper> e;\n            while (i.hasNext()) {\n                e = i.next();\n                w = e.getValue();\n\n                if (w.broadcaster == null) {\n                    w.broadcaster = broadcasterFactory.get(w.mapping);\n                } else {\n                    if (broadcasterCacheClassName != null\n                            && w.broadcaster.getBroadcasterConfig().getBroadcasterCache().getClass().getName().equals(\n                            DefaultBroadcasterCache.class.getName())) {\n                        BroadcasterCache cache = newClassInstance(BroadcasterCache.class,\n                                (Class<BroadcasterCache>) IOUtils.loadClass(getClass(), broadcasterCacheClassName));\n                        cache.configure(config);\n                        w.broadcaster.getBroadcasterConfig().setBroadcasterCache(cache);\n                    }\n                }\n            }\n        } catch (Exception ex) {\n            logger.error(\"Unable to configure Broadcaster/Factory/Cache\", ex);\n        }\n    }\n\n    protected void installAnnotationProcessor(ServletConfig sc) {\n        String s = sc.getInitParameter(ApplicationConfig.ANNOTATION_PROCESSOR);\n        if (s != null) {\n            annotationProcessorClassName = s;\n        }\n    }\n\n    protected void doInitParamsForWebSocket(ServletConfig sc) {\n        String s = sc.getInitParameter(WEBSOCKET_SUPPORT);\n        if (s != null) {\n            webSocketEnabled = Boolean.parseBoolean(s);\n            sessionSupport(false);\n        }\n        s = sc.getInitParameter(WEBSOCKET_PROTOCOL);\n        if (s != null) {\n            webSocketProtocolClassName = s;\n        }\n\n        s = sc.getInitParameter(WEBSOCKET_PROCESSOR);\n        if (s != null) {\n            webSocketProcessorClassName = s;\n        }\n\n        s = config.getInitParameter(ApplicationConfig.WEBSOCKET_SUPPORT_SERVLET3);\n        if (s != null) {\n            useServlet30 = Boolean.parseBoolean(s);\n        }\n    }\n\n    /**\n     * Read init params from web.xml and apply them.\n     *\n     * @param sc {@link ServletConfig}\n     */\n    protected void doInitParams(ServletConfig sc) {\n        doInitParams(sc, false);\n    }\n\n    /**\n     * Read init params from web.xml and apply them.\n     *\n     * @param sc {@link ServletConfig}\n     */\n    protected void doInitParams(ServletConfig sc, boolean reconfigure) {\n        String s = sc.getInitParameter(PROPERTY_NATIVE_COMETSUPPORT);\n        if (s != null) {\n            useNativeImplementation = Boolean.parseBoolean(s);\n            if (useNativeImplementation) isCometSupportSpecified = true;\n        }\n        s = sc.getInitParameter(PROPERTY_BLOCKING_COMETSUPPORT);\n        if (s != null) {\n            useBlockingImplementation = Boolean.parseBoolean(s);\n            if (useBlockingImplementation) isCometSupportSpecified = true;\n        }\n        s = sc.getInitParameter(PROPERTY_USE_STREAM);\n        if (s != null) {\n            useStreamForFlushingComments = Boolean.parseBoolean(s);\n        }\n        s = sc.getInitParameter(PROPERTY_COMET_SUPPORT);\n        if (asyncSupport == null && s != null && !reconfigure) {\n            asyncSupport = new DefaultAsyncSupportResolver(config).newCometSupport(s);\n            isCometSupportSpecified = true;\n        }\n        s = sc.getInitParameter(BROADCASTER_CLASS);\n        if (s != null) {\n            broadcasterClassName = s;\n            isBroadcasterSpecified = true;\n        }\n        s = sc.getInitParameter(BROADCASTER_CACHE);\n        if (s != null) {\n            broadcasterCacheClassName = s;\n        }\n\n        s = sc.getInitParameter(PROPERTY_SESSION_SUPPORT);\n        if (s == null) {\n            s = sc.getServletContext().getInitParameter(PROPERTY_SESSION_SUPPORT);\n        }\n\n        if (s != null || SessionSupport.initializationHint) {\n            boolean sessionSupport = Boolean.parseBoolean(s) || SessionSupport.initializationHint;\n            config.setSupportSession(sessionSupport);\n            if (sessionSupport && (sc.getServletContext().getMajorVersion() < 3 || !SessionSupport.initializationHint)) {\n                logger.warn(\"SessionSupport error. Make sure you also define {} as a listener in web.xml, see https://github.com/Atmosphere/atmosphere/wiki/Enabling-HttpSession-Support\", SessionSupport.class.getName());\n            }\n            isSessionSupportSpecified = true;\n        }\n        s = sc.getInitParameter(PROPERTY_ALLOW_SESSION_TIMEOUT_REMOVAL);\n        if (s != null) {\n            config.setSessionTimeoutRemovalAllowed(Boolean.parseBoolean(s));\n        }\n        s = sc.getInitParameter(PROPERTY_THROW_EXCEPTION_ON_CLONED_REQUEST);\n        if (s != null) {\n            config.setThrowExceptionOnCloned(Boolean.parseBoolean(s));\n            isThrowExceptionOnClonedRequestSpecified = true;\n        }\n        s = sc.getInitParameter(DISABLE_ONSTATE_EVENT);\n        if (s != null) {\n            initParams.put(DISABLE_ONSTATE_EVENT, s);\n        } else {\n            initParams.put(DISABLE_ONSTATE_EVENT, \"false\");\n        }\n        s = sc.getInitParameter(BROADCAST_FILTER_CLASSES);\n        if (s != null) {\n            broadcasterFilters.addAll(Arrays.asList(s.split(\",\")));\n            logger.info(\"Installing BroadcastFilter class(es) {}\", s);\n        }\n        s = sc.getInitParameter(BROADCASTER_LIFECYCLE_POLICY);\n        if (s != null) {\n            broadcasterLifeCyclePolicy = s;\n        }\n        s = sc.getInitParameter(BROADCASTER_FACTORY);\n        if (s != null) {\n            broadcasterFactoryClassName = s;\n        }\n        s = sc.getInitParameter(ATMOSPHERE_HANDLER_PATH);\n        if (s != null) {\n            handlersPath = s;\n        }\n        s = sc.getInitParameter(PROPERTY_ATMOSPHERE_XML);\n        if (s != null) {\n            atmosphereDotXmlPath = s;\n        }\n        s = sc.getInitParameter(META_SERVICE_PATH);\n        if (s != null) {\n            metaServicePath = s;\n        }\n        s = sc.getInitParameter(ApplicationConfig.HANDLER_MAPPING_REGEX);\n        if (s != null) {\n            mappingRegex = s;\n        }\n\n        s = sc.getInitParameter(FrameworkConfig.JERSEY_SCANNING_PACKAGE);\n        if (s != null) {\n            packages.add(s);\n        }\n\n        s = sc.getInitParameter(ApplicationConfig.DEFAULT_SERIALIZER);\n        if (s != null) {\n            defaultSerializerClassName = s;\n        }\n\n        s = sc.getInitParameter(ApplicationConfig.DISABLE_ATMOSPHEREINTERCEPTORS);\n        if (s != null) {\n            excludedInterceptors.addAll(Arrays.asList(s.trim().replace(\" \", \"\").split(\",\")));\n        }\n    }\n\n    public void loadConfiguration(ServletConfig sc) throws ServletException {\n\n        if (!autoDetectHandlers) return;\n\n        try {\n            URL url = sc.getServletContext().getResource(handlersPath);\n            ClassLoader urlC = url == null ? getClass().getClassLoader() : new URLClassLoader(new URL[]{url},\n                    Thread.currentThread().getContextClassLoader());\n            loadAtmosphereDotXml(sc.getServletContext().\n                    getResourceAsStream(atmosphereDotXmlPath), urlC);\n\n            if (atmosphereHandlers.isEmpty()) {\n                autoDetectAtmosphereHandlers(sc.getServletContext(), urlC);\n\n                if (atmosphereHandlers.isEmpty()) {\n                    detectSupportedFramework(sc);\n                }\n            }\n\n            autoDetectWebSocketHandler(sc.getServletContext(), urlC);\n        } catch (Throwable t) {\n            throw new ServletException(t);\n        }\n    }\n\n    /**\n     * Auto-detect Jersey when no atmosphere.xml file is specified.\n     *\n     * @param sc {@link ServletConfig}\n     * @return true if Jersey classes are detected\n     * @throws ClassNotFoundException\n     */\n    protected boolean detectSupportedFramework(ServletConfig sc) throws Exception {\n\n        String broadcasterClassNameTmp = null;\n\n        boolean isJersey;\n        try {\n            IOUtils.loadClass(getClass(), JERSEY_CONTAINER);\n            isJersey = true;\n\n            if (!isBroadcasterSpecified) {\n                broadcasterClassNameTmp = lookupDefaultBroadcasterType(JERSEY_BROADCASTER);\n\n                IOUtils.loadClass(getClass(), broadcasterClassNameTmp);\n            }\n            useStreamForFlushingComments = true;\n\n            StringBuilder packagesInit = new StringBuilder();\n            for (String s : packages) {\n                packagesInit.append(s).append(\",\");\n            }\n\n            initParams.put(FrameworkConfig.JERSEY_SCANNING_PACKAGE, packagesInit.toString());\n        } catch (Throwable t) {\n            logger.trace(\"\", t);\n            return false;\n        }\n\n        logger.debug(\"Missing META-INF/atmosphere.xml but found the Jersey runtime. Starting Jersey\");\n\n        // Atmosphere 1.1 : could add regressions\n        // Jersey will itself handle the headers.\n        //initParams.put(WRITE_HEADERS, \"false\");\n\n        ReflectorServletProcessor rsp = newClassInstance(ReflectorServletProcessor.class, ReflectorServletProcessor.class);\n        if (broadcasterClassNameTmp != null) broadcasterClassName = broadcasterClassNameTmp;\n        configureDetectedFramework(rsp, isJersey);\n        sessionSupport(false);\n        initParams.put(DISABLE_ONSTATE_EVENT, \"true\");\n\n        String mapping = sc.getInitParameter(PROPERTY_SERVLET_MAPPING);\n        if (mapping == null) {\n            mapping = sc.getInitParameter(ATMOSPHERE_HANDLER_MAPPING);\n            if (mapping == null) {\n                mapping = Broadcaster.ROOT_MASTER;\n            }\n        }\n        Class<? extends Broadcaster> bc = (Class<? extends Broadcaster>) IOUtils.loadClass(getClass(), broadcasterClassName);\n\n        broadcasterFactory.destroy();\n\n        broadcasterFactory = newClassInstance(BroadcasterFactory.class, DefaultBroadcasterFactory.class);\n        broadcasterFactory.configure(bc, broadcasterLifeCyclePolicy, config);\n        for (BroadcasterListener b : broadcasterListeners) {\n            broadcasterFactory.addBroadcasterListener(b);\n        }\n\n        Broadcaster b;\n\n        try {\n            b = broadcasterFactory.get(bc, mapping);\n        } catch (IllegalStateException ex) {\n            logger.warn(\"Two Broadcaster's named {}. Renaming the second one to {}\", mapping, sc.getServletName() + mapping);\n            b = broadcasterFactory.get(bc, sc.getServletName() + mapping);\n        }\n\n        addAtmosphereHandler(mapping, rsp, b);\n        return true;\n    }\n\n    protected void configureDetectedFramework(ReflectorServletProcessor rsp, boolean isJersey) {\n        rsp.setServletClassName(JERSEY_CONTAINER);\n    }\n\n    protected String lookupDefaultBroadcasterType(String defaultB) {\n        if (autodetectBroadcaster()) {\n            for (String b : broadcasterTypes) {\n                try {\n                    Class.forName(b);\n                    logger.info(\"Detected a Broadcaster {} on the classpath. \" +\n                            \"This broadcaster will be used by default and will override any annotated resources. \" +\n                            \"Set {} to false to change the behavior\", b, ApplicationConfig.AUTODETECT_BROADCASTER);\n                    isBroadcasterSpecified = true;\n                    return b;\n                } catch (ClassNotFoundException e) {\n                }\n            }\n        }\n\n        return defaultB;\n    }\n\n    boolean autodetectBroadcaster() {\n        if (servletConfig == null) {\n            return true;\n        }\n\n        String autodetect = servletConfig.getInitParameter(ApplicationConfig.AUTODETECT_BROADCASTER);\n        return autodetect == null || Boolean.parseBoolean(autodetect);\n    }\n\n    protected AtmosphereObjectFactory<?> lookupDefaultObjectFactoryType() {\n\n        if (objectFactory != null && !DefaultAtmosphereObjectFactory.class.getName().equals(objectFactory.getClass()\n                .getName())) return objectFactory;\n\n        for (String b : objectFactoryType) {\n            try {\n                Class<?> c = Class.forName(b);\n                objectFactory = (AtmosphereObjectFactory<?>) c.newInstance();\n                break;\n            } catch (ClassNotFoundException e) {\n                logger.trace(e.getMessage() + \" not found\");\n            } catch (Exception e) {\n                logger.trace(\"\", e);\n            }\n        }\n\n        if (objectFactory == null || DefaultAtmosphereObjectFactory.class.getName().equals(objectFactory.getClass()\n                .getName())) {\n            try {\n                IOUtils.loadClass(getClass(), INJECT_LIBARY);\n                objectFactory = new InjectableObjectFactory();\n            } catch (Exception e) {\n                logger.trace(\"javax.inject.Inject nor installed. Using DefaultAtmosphereObjectFactory\");\n                objectFactory = new DefaultAtmosphereObjectFactory();\n            }\n        }\n\n        objectFactory.configure(config);\n        return objectFactory;\n    }\n\n    public void sessionSupport(boolean sessionSupport) {\n        if (!isSessionSupportSpecified) {\n            config.setSupportSession(sessionSupport);\n        } else if (!config.isSupportSession()) {\n            // Don't turn off session support.  Once it's on, leave it on.\n            config.setSupportSession(sessionSupport);\n        }\n    }\n\n    /**\n     * Initialize {@link AtmosphereServletProcessor}.\n     *\n     * @param sc the {@link ServletConfig}\n     * @throws javax.servlet.ServletException\n     * @Deprecated\n     */\n    public void initAtmosphereHandler(ServletConfig sc) throws ServletException {\n        initAtmosphereHandler();\n    }\n\n    public void initAtmosphereHandler() throws ServletException {\n\n        AtmosphereHandler a;\n        AtmosphereHandlerWrapper w;\n        for (Entry<String, AtmosphereHandlerWrapper> h : atmosphereHandlers.entrySet()) {\n            w = h.getValue();\n            a = w.atmosphereHandler;\n            if (a instanceof AtmosphereServletProcessor) {\n                ((AtmosphereServletProcessor) a).init(config);\n            }\n        }\n        checkWebSocketSupportState();\n    }\n\n    public void checkWebSocketSupportState() {\n        if (atmosphereHandlers.isEmpty() && !SimpleHttpProtocol.class.isAssignableFrom(webSocketProtocol.getClass())) {\n            logger.debug(\"Adding a void AtmosphereHandler mapped to /* to allow WebSocket application only\");\n            addAtmosphereHandler(Broadcaster.ROOT_MASTER, new AbstractReflectorAtmosphereHandler() {\n                @Override\n                public void onRequest(AtmosphereResource r) throws IOException {\n                    logger.debug(\"No AtmosphereHandler defined.\");\n                    if (!r.transport().equals(AtmosphereResource.TRANSPORT.WEBSOCKET)) {\n                        WebSocket.notSupported(r.getRequest(), r.getResponse());\n                    }\n                }\n\n                @Override\n                public void destroy() {\n                }\n            });\n        }\n    }\n\n    public void initWebSocket() {\n        if (webSocketProtocolInitialized) return;\n\n        if (webSocketProtocol == null) {\n            try {\n                webSocketProtocol = newClassInstance(WebSocketProtocol.class,\n                        (Class<WebSocketProtocol>) IOUtils.loadClass(this.getClass(), webSocketProtocolClassName));\n                logger.info(\"Installed WebSocketProtocol {} \", webSocketProtocolClassName);\n            } catch (Exception ex) {\n                logger.error(\"Cannot load the WebSocketProtocol {}\", getWebSocketProtocolClassName(), ex);\n                try {\n                    webSocketProtocol = newClassInstance(WebSocketProtocol.class, SimpleHttpProtocol.class);\n                } catch (Exception e) {\n                }\n            }\n        }\n        webSocketProtocolInitialized = true;\n        webSocketProtocol.configure(config);\n    }\n\n    public void initEndpointMapper() {\n        String s = servletConfig.getInitParameter(ApplicationConfig.ENDPOINT_MAPPER);\n        if (s != null) {\n            try {\n                endpointMapper = newClassInstance(EndpointMapper.class, (Class<EndpointMapper>) IOUtils.loadClass(this.getClass(), s));\n                logger.info(\"Installed EndpointMapper {} \", s);\n            } catch (Exception ex) {\n                logger.error(\"Cannot load the EndpointMapper {}\", s, ex);\n            }\n        }\n        endpointMapper.configure(config);\n    }\n\n    protected void closeAtmosphereResource() {\n        for (AtmosphereResource r : config.resourcesFactory().findAll()) {\n            try {\n                r.resume().close();\n            } catch (Exception e) {\n                logger.trace(\"\", e);\n            }\n        }\n    }\n\n    public AtmosphereFramework destroy() {\n\n        if (isDestroyed.getAndSet(true)) return this;\n\n        onPreDestroy();\n\n        closeAtmosphereResource();\n        destroyInterceptors();\n\n        // Invoke ShutdownHook.\n        config.destroy();\n\n        BroadcasterFactory factory = broadcasterFactory;\n        if (factory != null) {\n            factory.destroy();\n        }\n\n        if (asyncSupport != null && AsynchronousProcessor.class.isAssignableFrom(asyncSupport.getClass())) {\n            ((AsynchronousProcessor) asyncSupport).shutdown();\n        }\n\n        // We just need one bc to shutdown the shared thread pool\n        for (Entry<String, AtmosphereHandlerWrapper> entry : atmosphereHandlers.entrySet()) {\n            AtmosphereHandlerWrapper handlerWrapper = entry.getValue();\n            try {\n                handlerWrapper.atmosphereHandler.destroy();\n            } catch (Throwable t) {\n                logger.warn(\"\", t);\n            }\n        }\n\n        if (metaBroadcaster != null) metaBroadcaster.destroy();\n        if (arFactory != null) arFactory.destroy();\n        if (sessionFactory != null) sessionFactory.destroy();\n\n        WebSocketProcessorFactory.getDefault().destroy();\n\n        ExecutorsFactory.reset(config);\n\n        resetStates();\n\n        onPostDestroy();\n\n        try {\n            if (this.shutdownHook != null) {\n                Runtime.getRuntime().removeShutdownHook(this.shutdownHook);\n                shutdownHook = null;\n            }\n        } catch (IllegalStateException ex) {\n            logger.trace(\"\", ex);\n        }\n\n        config.properties().clear();\n        return this;\n    }\n\n    protected void destroyInterceptors() {\n        for (AtmosphereHandlerWrapper w : atmosphereHandlers.values()) {\n            for (AtmosphereInterceptor i : w.interceptors) {\n                try {\n                    i.destroy();\n                } catch (Throwable ex) {\n                    logger.warn(\"\", ex);\n                }\n            }\n        }\n    }\n\n    public AtmosphereFramework resetStates() {\n        isInit = false;\n        executeFirstSet = false;\n\n        broadcasterFilters.clear();\n        asyncSupportListeners.clear();\n        possibleComponentsCandidate.clear();\n        initParams.clear();\n        atmosphereHandlers.clear();\n        broadcasterTypes.clear();\n        objectFactoryType.clear();\n        inspectors.clear();\n        broadcasterListeners.clear();\n        packages.clear();\n        annotationPackages.clear();\n        excludedInterceptors.clear();\n        broadcasterCacheListeners.clear();\n        filterManipulators.clear();\n        interceptors.clear();\n\n        broadcasterFactory = null;\n        arFactory = null;\n        metaBroadcaster = null;\n        sessionFactory = null;\n        annotationFound = false;\n        return this;\n    }\n\n    protected void loadMetaService() {\n        try {\n            Map<String, MetaServiceAction> config = (Map<String, MetaServiceAction>) servletConfig.getServletContext().getAttribute(AtmosphereFramework.MetaServiceAction.class.getName());\n            if (config == null) {\n                config = IOUtils.readServiceFile(metaServicePath + AtmosphereFramework.class.getName());\n            }\n\n            for (final Map.Entry<String, MetaServiceAction> action : config.entrySet()) {\n                try {\n                    final Class c = IOUtils.loadClass(AtmosphereFramework.class, action.getKey());\n                    action.getValue().apply(this, c);\n                } catch (ClassNotFoundException ex) {\n                    if (action.getKey().startsWith(ASYNC_IO)) {\n                        logger.trace(\"Unable to load class {}\", ex.getMessage());\n                    } else {\n                        logger.warn(\"\", ex);\n                    }\n                }\n            }\n        } catch (Exception ex) {\n            logger.warn(\"\", ex);\n        }\n    }\n\n    /**\n     * Load AtmosphereHandler defined under META-INF/atmosphere.xml.\n     *\n     * @param stream The input stream we read from.\n     * @param c      The classloader\n     */\n    protected void loadAtmosphereDotXml(InputStream stream, ClassLoader c)\n            throws IOException, ServletException {\n\n        if (stream == null) {\n            return;\n        }\n\n        logger.info(\"Found Atmosphere Configuration under {}\", atmosphereDotXmlPath);\n        AtmosphereConfigReader.getInstance().parse(config, stream);\n        AtmosphereHandler handler = null;\n        for (AtmosphereHandlerConfig atmoHandler : config.getAtmosphereHandlerConfig()) {\n            try {\n                if (!atmoHandler.getClassName().startsWith(\"@\")) {\n                    if (!ReflectorServletProcessor.class.getName().equals(atmoHandler.getClassName())) {\n                        handler = newClassInstance(AtmosphereHandler.class,\n                                (Class<AtmosphereHandler>) IOUtils.loadClass(this.getClass(), atmoHandler.getClassName()));\n                    } else {\n                        handler = newClassInstance(AtmosphereHandler.class, ReflectorServletProcessor.class);\n                    }\n                    logger.info(\"Installed AtmosphereHandler {} mapped to context-path: {}\", handler, atmoHandler.getContextRoot());\n                }\n\n                for (ApplicationConfiguration a : atmoHandler.getApplicationConfig()) {\n                    initParams.put(a.getParamName(), a.getParamValue());\n                }\n\n                for (FrameworkConfiguration a : atmoHandler.getFrameworkConfig()) {\n                    initParams.put(a.getParamName(), a.getParamValue());\n                }\n\n                for (AtmosphereHandlerProperty handlerProperty : atmoHandler.getProperties()) {\n\n                    if (handlerProperty.getValue() != null && handlerProperty.getValue().contains(\"jersey\")) {\n                        initParams.put(DISABLE_ONSTATE_EVENT, \"true\");\n                        useStreamForFlushingComments = true;\n                        broadcasterClassName = lookupDefaultBroadcasterType(JERSEY_BROADCASTER);\n                        broadcasterFactory.destroy();\n                        broadcasterFactory = null;\n                        configureBroadcasterFactory();\n                        configureBroadcaster();\n                    }\n\n                    if (handler != null) {\n                        IntrospectionUtils.setProperty(handler, handlerProperty.getName(), handlerProperty.getValue());\n                        IntrospectionUtils.addProperty(handler, handlerProperty.getName(), handlerProperty.getValue());\n                    }\n                }\n\n                sessionSupport(Boolean.parseBoolean(atmoHandler.getSupportSession()));\n\n                if (handler != null) {\n                    String broadcasterClass = atmoHandler.getBroadcaster();\n                    Broadcaster b;\n                    /*\n                     * If there is more than one AtmosphereHandler defined, their Broadcaster\n                     * may clash each other with the BroadcasterFactory. In that case we will use the\n                     * last one defined.\n                     */\n                    if (broadcasterClass != null) {\n                        broadcasterClassName = broadcasterClass;\n                        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n                        Class<? extends Broadcaster> bc = (Class<? extends Broadcaster>) cl.loadClass(broadcasterClassName);\n                        broadcasterFactory = newClassInstance(BroadcasterFactory.class, DefaultBroadcasterFactory.class);\n                        broadcasterFactory.configure(bc, broadcasterLifeCyclePolicy, config);\n                    }\n\n                    b = broadcasterFactory.lookup(atmoHandler.getContextRoot(), true);\n\n                    AtmosphereHandlerWrapper wrapper = new AtmosphereHandlerWrapper(handler, b, config);\n                    addMapping(atmoHandler.getContextRoot(), wrapper);\n\n                    String bc = atmoHandler.getBroadcasterCache();\n                    if (bc != null) {\n                        broadcasterCacheClassName = bc;\n                    }\n\n                    if (atmoHandler.getCometSupport() != null) {\n                        asyncSupport = (AsyncSupport) c.loadClass(atmoHandler.getCometSupport())\n                                .getDeclaredConstructor(new Class[]{AtmosphereConfig.class})\n                                .newInstance(new Object[]{config});\n                    }\n\n                    if (atmoHandler.getBroadcastFilterClasses() != null) {\n                        broadcasterFilters.addAll(atmoHandler.getBroadcastFilterClasses());\n                    }\n\n                    LinkedList<AtmosphereInterceptor> l = new LinkedList<AtmosphereInterceptor>();\n                    if (atmoHandler.getAtmosphereInterceptorClasses() != null) {\n                        for (String a : atmoHandler.getAtmosphereInterceptorClasses()) {\n                            try {\n                                AtmosphereInterceptor ai = newClassInstance(AtmosphereInterceptor.class,\n                                        (Class<AtmosphereInterceptor>) IOUtils.loadClass(getClass(), a));\n                                l.add(ai);\n                            } catch (Throwable e) {\n                                logger.warn(\"\", e);\n                            }\n                        }\n                    }\n                    addInterceptorToWrapper(wrapper, l);\n\n                    if (!l.isEmpty()) {\n                        logger.info(\"Installed AtmosphereInterceptor {} mapped to AtmosphereHandler {}\", l, atmoHandler.getClassName());\n                    }\n                }\n            } catch (Throwable t) {\n                logger.warn(\"Unable to load AtmosphereHandler class: \" + atmoHandler.getClassName(), t);\n                throw new ServletException(t);\n            }\n\n        }\n    }\n\n    /**\n     * Set the {@link AsyncSupport} implementation. Make sure you don't set an implementation that only works on\n     * some container. See {@link BlockingIOCometSupport} for an example.\n     *\n     * @param asyncSupport\n     */\n    public AtmosphereFramework setAsyncSupport(AsyncSupport asyncSupport) {\n        this.asyncSupport = asyncSupport;\n        return this;\n    }\n\n    /**\n     * @param asyncSupport\n     * @return\n     * @Deprecated - Use {@link #setAsyncSupport(AsyncSupport)}\n     */\n    public AtmosphereFramework setCometSupport(AsyncSupport asyncSupport) {\n        return setAsyncSupport(asyncSupport);\n    }\n\n    /**\n     * Return the current {@link AsyncSupport}.\n     *\n     * @return the current {@link AsyncSupport}\n     */\n    public AsyncSupport getAsyncSupport() {\n        return asyncSupport;\n    }\n\n    /**\n     * Return the current {@link AsyncSupport}.\n     *\n     * @return the current {@link AsyncSupport}\n     * @deprecated Use getAsyncSupport\n     */\n    public AsyncSupport getCometSupport() {\n        return asyncSupport;\n    }\n\n    /**\n     * Returns an instance of AsyncSupportResolver {@link AsyncSupportResolver}.\n     *\n     * @return CometSupportResolver\n     */\n    protected AsyncSupportResolver createAsyncSupportResolver() {\n        return new DefaultAsyncSupportResolver(config);\n    }\n\n\n    /**\n     * Auto detect the underlying Servlet Container we are running on.\n     */\n    protected void autoDetectContainer() {\n        // Was defined in atmosphere.xml\n        if (getAsyncSupport() == null) {\n            setAsyncSupport(createAsyncSupportResolver()\n                    .resolve(useNativeImplementation, useBlockingImplementation, useServlet30));\n        }\n    }\n\n    /**\n     * Auto detect instance of {@link AtmosphereHandler} in case META-INF/atmosphere.xml\n     * is missing.\n     *\n     * @param servletContext {@link ServletContext}\n     * @param classloader    {@link ClassLoader} to load the class.\n     * @throws java.net.MalformedURLException\n     */\n    public void autoDetectAtmosphereHandlers(ServletContext servletContext, ClassLoader classloader)\n            throws MalformedURLException {\n\n        // If Handler has been added\n        if (!atmosphereHandlers.isEmpty()) return;\n\n        logger.info(\"Auto detecting atmosphere handlers {}\", handlersPath);\n\n        String realPath = servletContext.getRealPath(handlersPath);\n\n        // Weblogic bug\n        if (realPath == null) {\n            URL u = servletContext.getResource(handlersPath);\n            if (u == null) return;\n            realPath = u.getPath();\n        }\n\n        loadAtmosphereHandlersFromPath(classloader, realPath);\n    }\n\n    public void loadAtmosphereHandlersFromPath(ClassLoader classloader, String realPath) {\n        File file = new File(realPath);\n\n        if (file.exists() && file.isDirectory()) {\n            getFiles(file);\n            scanDone = true;\n\n            for (String className : possibleComponentsCandidate) {\n                try {\n                    className = className.replace('\\\\', '/');\n                    className = className.replaceFirst(\"^.*/(WEB-INF|target)(?:/scala-[^/]+)?/(test-)?classes/(.*)\\\\.class\", \"$3\").replace(\"/\", \".\");\n                    Class<?> clazz = classloader.loadClass(className);\n\n                    if (AtmosphereHandler.class.isAssignableFrom(clazz)) {\n                        AtmosphereHandler handler = newClassInstance(AtmosphereHandler.class, (Class<AtmosphereHandler>) clazz);\n                        addMapping(\"/\" + handler.getClass().getSimpleName(),\n                                new AtmosphereHandlerWrapper(broadcasterFactory, handler, \"/\" + handler.getClass().getSimpleName(), config));\n                        logger.info(\"Installed AtmosphereHandler {} mapped to context-path: {}\", handler, handler.getClass().getName());\n                    }\n                } catch (Throwable t) {\n                    logger.trace(\"failed to load class as an AtmosphereHandler: \" + className, t);\n                }\n            }\n        }\n    }\n\n    /**\n     * Auto detect instance of {@link org.atmosphere.websocket.WebSocketHandler} in case META-INF/atmosphere.xml\n     * is missing.\n     *\n     * @param servletContext {@link ServletContext}\n     * @param classloader    {@link ClassLoader} to load the class.\n     * @throws java.net.MalformedURLException\n     */\n    protected void autoDetectWebSocketHandler(ServletContext servletContext, ClassLoader classloader)\n            throws MalformedURLException {\n\n        if (hasNewWebSocketProtocol) return;\n\n        logger.info(\"Auto detecting WebSocketHandler in {}\", handlersPath);\n        loadWebSocketFromPath(classloader, realPath(servletContext, handlersPath));\n    }\n\n    protected void loadWebSocketFromPath(ClassLoader classloader, String realPath) {\n        File file = new File(realPath);\n\n        if (file.exists() && file.isDirectory()) {\n            getFiles(file);\n            scanDone = true;\n\n            for (String className : possibleComponentsCandidate) {\n                try {\n                    className = className.replace('\\\\', '/');\n                    className = className.replaceFirst(\"^.*/(WEB-INF|target)(?:/scala-[^/]+)?/(test-)?classes/(.*)\\\\.class\", \"$3\").replace(\"/\", \".\");\n                    Class<?> clazz = classloader.loadClass(className);\n\n                    if (WebSocketProtocol.class.isAssignableFrom(clazz)) {\n                        webSocketProtocol = newClassInstance(WebSocketProtocol.class, (Class<WebSocketProtocol>) clazz);\n                        logger.info(\"Installed WebSocketProtocol {}\", webSocketProtocol);\n                    }\n                } catch (Throwable t) {\n                    logger.trace(\"failed to load class as an WebSocketProtocol: \" + className, t);\n                }\n            }\n        }\n    }\n\n    /**\n     * Get a list of possible candidates to load as {@link AtmosphereHandler}.\n     *\n     * @param f the real path {@link File}\n     */\n    private void getFiles(File f) {\n        if (scanDone) return;\n\n        File[] files = f.listFiles();\n        for (File test : Objects.requireNonNull(files)) {\n            if (test.isDirectory()) {\n                getFiles(test);\n            } else {\n                String clazz = test.getAbsolutePath();\n                if (clazz.endsWith(\".class\")) {\n                    possibleComponentsCandidate.add(clazz);\n                }\n            }\n        }\n    }\n\n    /**\n     * Configure some attributes on the {@link AtmosphereRequest}.\n     *\n     * @param req {@link AtmosphereRequest}\n     */\n    public AtmosphereFramework configureRequestResponse(AtmosphereRequest req, AtmosphereResponse res) throws UnsupportedEncodingException {\n        req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments);\n        req.setAttribute(BROADCASTER_CLASS, broadcasterClassName);\n        req.setAttribute(ATMOSPHERE_CONFIG, config);\n        req.setAttribute(THROW_EXCEPTION_ON_CLONED_REQUEST, \"\" + config.isThrowExceptionOnCloned());\n\n        boolean skip = true;\n        String s = config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST);\n        if (s != null) {\n            skip = Boolean.parseBoolean(s);\n        }\n\n        if (!skip || req.getAttribute(WEBSOCKET_SUSPEND) == null) {\n            Map<String, String> headers = configureQueryStringAsRequest(req);\n            String body = headers.remove(ATMOSPHERE_POST_BODY);\n            if (body != null && body.isEmpty()) {\n                body = null;\n            }\n\n            // Reconfigure the request. Clear the Atmosphere queryString\n            req.headers(headers)\n                    .method(body != null && req.getMethod().equalsIgnoreCase(\"GET\") ? \"POST\" : req.getMethod());\n\n            if (body != null) {\n                req.body(URLDecoder.decode(body, req.getCharacterEncoding() == null ? \"UTF-8\" : req.getCharacterEncoding()));\n            }\n        }\n\n        s = req.getHeader(X_ATMOSPHERE_TRACKING_ID);\n\n        // Lookup for websocket\n        if (s == null || s.equals(\"0\")) {\n            String unique = config.getInitParameter(ApplicationConfig.UNIQUE_UUID_WEBSOCKET);\n            if (Boolean.parseBoolean(unique)) {\n                s = (String) req.getAttribute(SUSPENDED_ATMOSPHERE_RESOURCE_UUID);\n            }\n        }\n\n        if (s == null || s.equals(\"0\")) {\n            s = config.uuidProvider().generateUuid();\n            res.setHeader(HeaderConfig.X_FIRST_REQUEST, \"true\");\n            res.setHeader(X_ATMOSPHERE_TRACKING_ID, s);\n            String contentType = config.getInitParameter(CONTENT_TYPE_FIRST_RESPONSE);\n            if (contentType != null) {\n                res.setHeader(\"Content-Type\", contentType);\n            }\n        } else {\n            // This may breaks 1.0.0 application because the WebSocket's associated AtmosphereResource will\n            // all have the same UUID, and retrieving the original one for WebSocket, so we don't set it at all.\n            // Null means it is not an HTTP request.\n            if (req.resource() == null) {\n                res.setHeader(X_ATMOSPHERE_TRACKING_ID, s);\n            } else if (req.getAttribute(WebSocket.WEBSOCKET_INITIATED) == null) {\n                // WebSocket reconnect, in case an application manually set the header\n                // (impossible to retrieve the headers normally with WebSocket or SSE)\n                res.setHeader(X_ATMOSPHERE_TRACKING_ID, s);\n            }\n        }\n\n        if (req.getAttribute(SUSPENDED_ATMOSPHERE_RESOURCE_UUID) == null) {\n            req.setAttribute(SUSPENDED_ATMOSPHERE_RESOURCE_UUID, s);\n        }\n        return this;\n    }\n\n    /**\n     * Invoke the proprietary {@link AsyncSupport}.\n     *\n     * @param req\n     * @param res\n     * @return an {@link Action}\n     * @throws IOException\n     * @throws ServletException\n     */\n    public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException {\n\n        if (isDestroyed.get()) return Action.CANCELLED;\n\n        Action a = null;\n        try {\n            configureRequestResponse(req, res);\n            a = asyncSupport.service(req, res);\n        } catch (IllegalStateException ex) {\n            boolean isJBoss = ex.getMessage() != null && ex.getMessage().startsWith(\"JBoss failed\");\n            if (ex.getMessage() != null && (ex.getMessage().startsWith(\"Tomcat failed\") || isJBoss)) {\n                if (!isFilter) {\n                    logger.warn(\"Failed using comet support: {}, error: {} Is the NIO or APR Connector enabled?\", asyncSupport.getClass().getName(),\n                            ex.getMessage());\n                }\n                logger.error(\"If you have more than one Connector enabled, make sure they both use the same protocol, \" +\n                        \"e.g NIO/APR or HTTP for all. If not, {} will be used and cannot be changed.\", BlockingIOCometSupport.class.getName(), ex);\n\n                AsyncSupport current = asyncSupport;\n                asyncSupport = asyncSupport.supportWebSocket() && !isJBoss ? new Tomcat7BIOSupportWithWebSocket(config) : new BlockingIOCometSupport(config);\n                if (current instanceof AsynchronousProcessor) {\n                    ((AsynchronousProcessor) current).shutdown();\n                }\n\n                asyncSupport.init(config.getServletConfig());\n                logger.warn(\"Using \" + asyncSupport.getClass().getName());\n\n                a = asyncSupport.service(req, res);\n            } else {\n                logger.error(\"AtmosphereFramework exception\", ex);\n                throw ex;\n            }\n        } finally {\n            if (a != null) {\n                notify(a.type(), req, res);\n            }\n\n            if (!externalizeDestroy) {\n                if (req != null && a != null && a.type() != Action.TYPE.SUSPEND) {\n                    req.destroy();\n                    res.destroy();\n                    notify(Action.TYPE.DESTROYED, req, res);\n                }\n            }\n        }\n        return a;\n    }\n\n    /**\n     * Return the default {@link Broadcaster} class name.\n     *\n     * @return the broadcasterClassName\n     */\n    public String getDefaultBroadcasterClassName() {\n        return broadcasterClassName;\n    }\n\n    /**\n     * Set the default {@link Broadcaster} class name.\n     *\n     * @param bccn the broadcasterClassName to set\n     */\n    public AtmosphereFramework setDefaultBroadcasterClassName(String bccn) {\n        if (isBroadcasterSpecified) {\n            logger.trace(\"Broadcaster {} already set in web.xml\", broadcasterClassName);\n            return this;\n        }\n        isBroadcasterSpecified = true;\n\n        broadcasterClassName = bccn;\n\n        // Must reconfigure.\n        broadcasterFactory = null;\n        configureBroadcasterFactory();\n\n        // We must recreate all previously created Broadcaster.\n        for (AtmosphereHandlerWrapper w : atmosphereHandlers.values()) {\n            // If case one listener is initializing the framework.\n            if (w.broadcaster != null) {\n                w.broadcaster = broadcasterFactory.lookup(w.broadcaster.getID(), true);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <tt>true</tt> if Atmosphere uses {@link AtmosphereResponseImpl#getOutputStream()}\n     * by default for write operation.\n     *\n     * @return the useStreamForFlushingComments\n     */\n    public boolean isUseStreamForFlushingComments() {\n        return useStreamForFlushingComments;\n    }\n\n    public boolean isUseServlet30() {\n        return useServlet30;\n    }\n\n    /**\n     * Set to <tt>true</tt> so Atmosphere uses {@link AtmosphereResponseImpl#getOutputStream()}\n     * by default for write operation. Default is false.\n     *\n     * @param useStreamForFlushingComments the useStreamForFlushingComments to set\n     */\n    public AtmosphereFramework setUseStreamForFlushingComments(boolean useStreamForFlushingComments) {\n        this.useStreamForFlushingComments = useStreamForFlushingComments;\n        return this;\n    }\n\n    /**\n     * Get the {@link BroadcasterFactory} which is used by Atmosphere to construct\n     * {@link Broadcaster}.\n     *\n     * @return {@link BroadcasterFactory}\n     */\n    public BroadcasterFactory getBroadcasterFactory() {\n        if (broadcasterFactory == null) {\n            configureBroadcasterFactory();\n        }\n        return broadcasterFactory;\n    }\n\n    /**\n     * Set the {@link BroadcasterFactory} which is used by Atmosphere to construct\n     * {@link Broadcaster}.\n     *\n     * @return {@link BroadcasterFactory}\n     */\n    public AtmosphereFramework setBroadcasterFactory(final BroadcasterFactory broadcasterFactory) {\n        this.broadcasterFactory = broadcasterFactory;\n        configureBroadcaster();\n        return this;\n    }\n\n    /**\n     * Return the {@link org.atmosphere.cpr.BroadcasterCache} class name.\n     *\n     * @return the {@link org.atmosphere.cpr.BroadcasterCache} class name\n     */\n    public String getBroadcasterCacheClassName() {\n        return broadcasterCacheClassName;\n    }\n\n    /**\n     * Set the {@link org.atmosphere.cpr.BroadcasterCache} class name.\n     *\n     * @param broadcasterCacheClassName\n     */\n    public AtmosphereFramework setBroadcasterCacheClassName(String broadcasterCacheClassName) {\n        this.broadcasterCacheClassName = broadcasterCacheClassName;\n        return this;\n    }\n\n    /**\n     * Add a new Broadcaster class name that AtmosphereServlet can use when initializing requests, and when the\n     * atmosphere.xml broadcaster element is unspecified.\n     *\n     * @param broadcasterTypeString\n     */\n    public AtmosphereFramework addBroadcasterType(String broadcasterTypeString) {\n        broadcasterTypes.add(broadcasterTypeString);\n        return this;\n    }\n\n    public ConcurrentLinkedQueue<String> broadcasterTypes() {\n        return broadcasterTypes;\n    }\n\n    public String getWebSocketProtocolClassName() {\n        return webSocketProtocolClassName;\n    }\n\n    public AtmosphereFramework setWebSocketProtocolClassName(String webSocketProtocolClassName) {\n        hasNewWebSocketProtocol = true;\n        this.webSocketProtocolClassName = webSocketProtocolClassName;\n        return this;\n    }\n\n    public Map<String, AtmosphereHandlerWrapper> getAtmosphereHandlers() {\n        return atmosphereHandlers;\n    }\n\n    protected Map<String, String> configureQueryStringAsRequest(AtmosphereRequest request) {\n        Map<String, String> headers = new HashMap<String, String>();\n\n        StringBuilder q = new StringBuilder();\n        try {\n            String qs = request.getQueryString();\n            if (qs != null && !qs.isEmpty()) {\n                String[] params = qs.split(\"&\");\n                String[] s;\n                for (String p : params) {\n                    s = p.split(\"=\", 2);\n                    final String header = s[0];\n                    final String value = s.length > 1 ? s[1] : \"\";\n\n                    if (header.equalsIgnoreCase(\"Content-Type\")) {\n                        // Use the one set by the user first.\n                        if (request.getContentType() == null ||\n                                !request.getContentType().equalsIgnoreCase(s.length > 1 ? value : \"\")) {\n                            request.contentType(s.length > 1 ? URLDecoder.decode(value, \"UTF-8\") : \"\");\n                        }\n                    }\n                    if (!header.isEmpty()\n                            && !header.toLowerCase().startsWith(\"x-atmo\")\n                            && !header.equalsIgnoreCase(HeaderConfig.X_HEARTBEAT_SERVER)\n                            && !header.equalsIgnoreCase(\"Content-Type\")\n                            && !header.equalsIgnoreCase(\"_\")) {\n                        q.append(header).append(\"=\").append(s.length > 1 ? value : \"\").append(\"&\");\n                    }\n                    headers.put(header, s.length > 1 ? value : \"\");\n                }\n            }\n        } catch (Exception ex) {\n            logger.error(\"Unable to parse query string\", ex);\n        }\n        String disallowModifyQueryString = config.getInitParameter(ApplicationConfig.DISALLOW_MODIFY_QUERYSTRING);\n        if (disallowModifyQueryString == null ||\n                disallowModifyQueryString.length() == 0 || \"false\".equalsIgnoreCase(disallowModifyQueryString)) {\n            if (q.length() > 0) {\n                q.deleteCharAt(q.length() - 1);\n            }\n            request.queryString(q.toString());\n        }\n\n        logger.trace(\"Query String translated to headers {}\", headers);\n        return headers;\n    }\n\n    public WebSocketProtocol getWebSocketProtocol() {\n        // TODO: Spagetthi code, needs to rework.\n        // Make sure we initialized the WebSocketProtocol\n        initWebSocket();\n        return webSocketProtocol;\n    }\n\n    public boolean isUseNativeImplementation() {\n        return useNativeImplementation;\n    }\n\n    public AtmosphereFramework setUseNativeImplementation(boolean useNativeImplementation) {\n        this.useNativeImplementation = useNativeImplementation;\n        return this;\n    }\n\n    public boolean isUseBlockingImplementation() {\n        return useBlockingImplementation;\n    }\n\n    public AtmosphereFramework setUseBlockingImplementation(boolean useBlockingImplementation) {\n        this.useBlockingImplementation = useBlockingImplementation;\n        return this;\n    }\n\n    public String getAtmosphereDotXmlPath() {\n        return atmosphereDotXmlPath;\n    }\n\n    public AtmosphereFramework setAtmosphereDotXmlPath(String atmosphereDotXmlPath) {\n        this.atmosphereDotXmlPath = atmosphereDotXmlPath;\n        return this;\n    }\n\n    public String getHandlersPath() {\n        return handlersPath;\n    }\n\n    public AtmosphereFramework setHandlersPath(String handlersPath) {\n        this.handlersPath = handlersPath;\n        return this;\n    }\n\n    /**\n     * Return the location of the JARs containing the application classes. Default is WEB-INF/lib.\n     *\n     * @return the location of the JARs containing the application classes. Default is WEB-INF/lib\n     */\n    public String getLibPath() {\n        return libPath;\n    }\n\n    /**\n     * Set the location of the JARs containing the application.\n     *\n     * @param libPath the location of the JARs containing the application.\n     * @return this\n     */\n    public AtmosphereFramework setLibPath(String libPath) {\n        this.libPath = libPath;\n        return this;\n    }\n\n    /**\n     * The current {@link org.atmosphere.websocket.WebSocketProcessor} used to handle websocket requests.\n     *\n     * @return {@link org.atmosphere.websocket.WebSocketProcessor}\n     */\n    public String getWebSocketProcessorClassName() {\n        return webSocketProcessorClassName;\n    }\n\n    /**\n     * Set the {@link org.atmosphere.websocket.WebSocketProcessor} class name used to process WebSocket requests. Default is\n     * {@link DefaultWebSocketProcessor}\n     *\n     * @param webSocketProcessorClassName {@link org.atmosphere.websocket.WebSocketProcessor}\n     * @return this\n     */\n    public AtmosphereFramework setWebsocketProcessorClassName(String webSocketProcessorClassName) {\n        this.webSocketProcessorClassName = webSocketProcessorClassName;\n        return this;\n    }\n\n    /**\n     * Add an {@link AtmosphereInterceptor} implementation. The adding order of {@link AtmosphereInterceptor} will be used, e.g\n     * the first added {@link AtmosphereInterceptor} will always be called first.\n     *\n     * @param c {@link AtmosphereInterceptor}\n     * @return this\n     */\n    public AtmosphereFramework interceptor(AtmosphereInterceptor c) {\n        if (!checkDuplicate(c)) {\n            interceptors.add(c);\n            if (isInit) {\n                addInterceptorToAllWrappers(c);\n            }\n        }\n        return this;\n    }\n\n    protected void addDefaultOrAppInterceptors() {\n        for (AtmosphereInterceptor c : interceptors) {\n            addInterceptorToAllWrappers(c);\n        }\n    }\n\n    protected void addInterceptorToAllWrappers(AtmosphereInterceptor c) {\n        c.configure(config);\n        InvokationOrder.PRIORITY p = InvokationOrder.class.isAssignableFrom(c.getClass()) ? ((InvokationOrder) c).priority() : InvokationOrder.AFTER_DEFAULT;\n\n        logger.info(\"Installed AtmosphereInterceptor {} with priority {} \", c, p.name());\n        //need insert this new interceptor into all the existing handlers\n        for (AtmosphereHandlerWrapper wrapper : atmosphereHandlers.values()) {\n            addInterceptorToWrapper(wrapper, c);\n        }\n    }\n\n    protected void addInterceptorToWrapper(AtmosphereHandlerWrapper wrapper, AtmosphereInterceptor c) {\n        if (!checkDuplicate(wrapper.interceptors, c.getClass())) {\n            wrapper.interceptors.add(c);\n            wrapper.interceptors.sort(new InterceptorComparator());\n        }\n    }\n\n    protected void addInterceptorToWrapper(AtmosphereHandlerWrapper wrapper, List<AtmosphereInterceptor> interceptors) {\n\n        for (AtmosphereInterceptor c : this.interceptors) {\n            addInterceptorToWrapper(wrapper, c);\n        }\n\n        for (AtmosphereInterceptor c : interceptors) {\n            addInterceptorToWrapper(wrapper, c);\n            c.configure(config);\n        }\n    }\n\n    /**\n     * <p>\n     * Checks if an instance of the specified {@link AtmosphereInterceptor} implementation exists in the\n     * {@link #interceptors}.\n     * </p>\n     *\n     * @param c the implementation\n     * @return {@code false} if an instance of the same interceptor's class already exists in  {@link #interceptors}, {@code true} otherwise\n     */\n    private boolean checkDuplicate(final AtmosphereInterceptor c) {\n        return checkDuplicate(interceptors, c.getClass());\n    }\n\n    /**\n     * <p>\n     * Checks in the specified list if there is at least one instance of the given\n     * {@link AtmosphereInterceptor interceptor} implementation class.\n     * </p>\n     *\n     * @param interceptorList the interceptors\n     * @param c               the interceptor class\n     * @return {@code false} if an instance of the class already exists in the list, {@code true} otherwise\n     */\n    private boolean checkDuplicate(final List<AtmosphereInterceptor> interceptorList, Class<? extends AtmosphereInterceptor> c) {\n        for (final AtmosphereInterceptor i : interceptorList) {\n            if (i.getClass().equals(c)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the list of {@link AtmosphereInterceptor}.\n     *\n     * @return the list of {@link AtmosphereInterceptor}\n     */\n    public LinkedList<AtmosphereInterceptor> interceptors() {\n        return interceptors;\n    }\n\n    /**\n     * Set the {@link AnnotationProcessor} class name.\n     *\n     * @param annotationProcessorClassName the {@link AnnotationProcessor} class name.\n     * @return this\n     */\n    public AtmosphereFramework annotationProcessorClassName(String annotationProcessorClassName) {\n        this.annotationProcessorClassName = annotationProcessorClassName;\n        return this;\n    }\n\n    /**\n     * Add an {@link AsyncSupportListener}.\n     *\n     * @param asyncSupportListener an {@link AsyncSupportListener}\n     * @return this;\n     */\n    public AtmosphereFramework asyncSupportListener(AsyncSupportListener asyncSupportListener) {\n        asyncSupportListeners.add(asyncSupportListener);\n        return this;\n    }\n\n    /**\n     * Return the list of {@link AsyncSupportListener}s.\n     *\n     * @return\n     */\n    public List<AsyncSupportListener> asyncSupportListeners() {\n        return asyncSupportListeners;\n    }\n\n    /**\n     * Add {@link BroadcasterListener} to all created {@link Broadcaster}s.\n     */\n    public AtmosphereFramework addBroadcasterListener(BroadcasterListener b) {\n        broadcasterFactory.addBroadcasterListener(b);\n        broadcasterListeners.add(b);\n        return this;\n    }\n\n    /**\n     * Add {@link BroadcasterCacheListener} to the {@link BroadcasterCache}.\n     */\n    public AtmosphereFramework addBroadcasterCacheListener(BroadcasterCacheListener b) {\n        broadcasterCacheListeners.add(b);\n        return this;\n    }\n\n    public List<BroadcasterCacheListener> broadcasterCacheListeners() {\n        return broadcasterCacheListeners;\n    }\n\n    /**\n     * Add a {@link BroadcasterCacheInspector} which will be associated with the defined {@link BroadcasterCache}.\n     *\n     * @param b {@link BroadcasterCacheInspector}\n     * @return this;\n     */\n    public AtmosphereFramework addBroadcasterCacheInjector(BroadcasterCacheInspector b) {\n        inspectors.add(b);\n        return this;\n    }\n\n    /**\n     * Return the list of {@link BroadcasterCacheInspector}s.\n     *\n     * @return the list of {@link BroadcasterCacheInspector}s\n     */\n    public ConcurrentLinkedQueue<BroadcasterCacheInspector> inspectors() {\n        return inspectors;\n    }\n\n    /**\n     * Return a configured instance of {@link AtmosphereConfig}.\n     *\n     * @return a configured instance of {@link AtmosphereConfig}\n     */\n    public AtmosphereConfig getAtmosphereConfig() {\n        return config;\n    }\n\n    /**\n     * Return the {@link ServletContext}\n     *\n     * @return the {@link ServletContext}\n     */\n    public ServletContext getServletContext() {\n        return servletConfig.getServletContext();\n    }\n\n    public ServletConfig getServletConfig() {\n        return servletConfig;\n    }\n\n    /**\n     * Return the list of {@link BroadcastFilter}s.\n     *\n     * @return the list of {@link BroadcastFilter}s\n     */\n    public List<String> broadcasterFilters() {\n        return broadcasterFilters;\n    }\n\n    /**\n     * Add a {@link BroadcastFilter}.\n     *\n     * @return\n     */\n    public AtmosphereFramework broadcasterFilters(BroadcastFilter f) {\n        broadcasterFilters.add(f.getClass().getName());\n\n        for (Broadcaster b : config.getBroadcasterFactory().lookupAll()) {\n            b.getBroadcasterConfig().addFilter(f);\n        }\n        return this;\n    }\n\n    /**\n     * Returns true if {@link java.util.concurrent.ExecutorService} is shared among all components.\n     *\n     * @return true if {@link java.util.concurrent.ExecutorService} is shared amongst all components\n     */\n    public boolean isShareExecutorServices() {\n        return sharedThreadPools;\n    }\n\n    /**\n     * Set to true to have a {@link java.util.concurrent.ExecutorService} shared among all components.\n     *\n     * @param sharedThreadPools\n     * @return this\n     */\n    public AtmosphereFramework shareExecutorServices(boolean sharedThreadPools) {\n        this.sharedThreadPools = sharedThreadPools;\n        return this;\n    }\n\n    protected void autoConfigureService(ServletContext sc) throws IOException {\n        String path = handlersPath != DEFAULT_HANDLER_PATH ? handlersPath : realPath(sc, handlersPath);\n        try {\n            annotationProcessor = newClassInstance(AnnotationProcessor.class,\n                    (Class<AnnotationProcessor>) IOUtils.loadClass(getClass(), annotationProcessorClassName));\n            logger.info(\"Atmosphere is using {} for processing annotation\", annotationProcessorClassName);\n\n            annotationProcessor.configure(config);\n\n            if (!packages.isEmpty()) {\n                for (String s : packages) {\n                    annotationProcessor.scan(s);\n                }\n            }\n\n            // Second try.\n            if (!annotationFound) {\n                if (path != null) {\n                    annotationProcessor.scan(new File(path));\n                }\n\n                // Always scan library\n                String pathLibs = !libPath.equals(DEFAULT_LIB_PATH) ? libPath : realPath(sc, DEFAULT_LIB_PATH);\n                if (pathLibs != null) {\n                    File libFolder = new File(pathLibs);\n                    File[] jars = libFolder.listFiles((arg0, arg1) -> arg1.endsWith(\".jar\"));\n\n                    if (jars != null) {\n                        for (File file : jars) {\n                            annotationProcessor.scan(file);\n                        }\n                    }\n                }\n            }\n\n            if (!annotationFound && allowAllClassesScan) {\n                logger.debug(\"Scanning all classes on the classpath\");\n                annotationProcessor.scanAll();\n            }\n        } catch (Throwable e) {\n            logger.error(\"\", e);\n        } finally {\n            if (annotationProcessor != null) {\n                annotationProcessor.destroy();\n            }\n        }\n    }\n\n    /**\n     * The current {@link EndpointMapper} used to map requests to {@link AtmosphereHandler}.\n     *\n     * @return {@link EndpointMapper}\n     */\n    public EndpointMapper<AtmosphereHandlerWrapper> endPointMapper() {\n        return endpointMapper;\n    }\n\n    /**\n     * Set the {@link EndpointMapper}.\n     *\n     * @param endpointMapper {@link EndpointMapper}\n     * @return this\n     */\n    public AtmosphereFramework endPointMapper(EndpointMapper endpointMapper) {\n        this.endpointMapper = endpointMapper;\n        return this;\n    }\n\n    /**\n     * Add support for package detection of Atmosphere's Component.\n     *\n     * @param clazz a Class\n     * @return this.\n     */\n    public AtmosphereFramework addAnnotationPackage(Class<?> clazz) {\n        if (clazz.getPackage() == null) {\n            logger.error(\"Class {} must have a package defined\", clazz);\n        } else {\n            packages.add(clazz.getPackage().getName());\n        }\n        return this;\n    }\n\n    public AtmosphereFramework notify(Action.TYPE type, AtmosphereRequest request, AtmosphereResponse response) {\n        for (AsyncSupportListener l : asyncSupportListeners()) {\n            try {\n                switch (type) {\n                    case TIMEOUT:\n                        l.onTimeout(request, response);\n                        break;\n                    case CANCELLED:\n                        l.onClose(request, response);\n                        break;\n                    case SUSPEND:\n                        l.onSuspend(request, response);\n                        break;\n                    case RESUME:\n                        l.onResume(request, response);\n                        break;\n                    case DESTROYED:\n                        l.onDestroyed(request, response);\n                        break;\n                }\n            } catch (Throwable t) {\n                logger.warn(\"\", t);\n            }\n        }\n        return this;\n    }\n\n    public AtmosphereFramework notifyDestroyed(String uuid) {\n        for (AtmosphereResourceListener l : atmosphereResourceListeners()) {\n            l.onDisconnect(uuid);\n        }\n        return this;\n    }\n\n    public AtmosphereFramework notifySuspended(String uuid) {\n        for (AtmosphereResourceListener l : atmosphereResourceListeners()) {\n            l.onSuspended(uuid);\n        }\n        return this;\n    }\n\n    /**\n     * Add an {@link WebSocketHandler} mapped to \"/*\".\n     * return this\n     */\n    public AtmosphereFramework addWebSocketHandler(WebSocketHandler handler) {\n        addWebSocketHandler(ROOT_MASTER, handler);\n        return this;\n    }\n\n    /**\n     * Add an {@link WebSocketHandler} mapped to the path.\n     * return this\n     */\n    public AtmosphereFramework addWebSocketHandler(String path, WebSocketHandler handler) {\n        addWebSocketHandler(path, handler, REFLECTOR_ATMOSPHEREHANDLER, Collections.emptyList());\n        return this;\n    }\n\n    /**\n     * Add an {@link WebSocketHandler} mapped to the path and the {@link AtmosphereHandler} in case {@link Broadcaster} are\n     * used.\n     *\n     * @param path    a path\n     * @param handler a {@link WebSocketHandler}\n     * @param h       an {@link AtmosphereHandler}\n     * @return this\n     */\n    public AtmosphereFramework addWebSocketHandler(String path, WebSocketHandler handler, AtmosphereHandler h) {\n        addWebSocketHandler(path, handler, REFLECTOR_ATMOSPHEREHANDLER, Collections.emptyList());\n        return this;\n    }\n\n    /**\n     * Add an {@link WebSocketHandler} mapped to the path and the {@link AtmosphereHandler} in case {@link Broadcaster} are\n     * used.\n     *\n     * @param path    a path\n     * @param handler a {@link WebSocketHandler}\n     * @param h       an {@link AtmosphereHandler}\n     * @param l       {@link AtmosphereInterceptor}\n     * @return this\n     */\n    public AtmosphereFramework addWebSocketHandler(String path, WebSocketHandler handler, AtmosphereHandler h, List<AtmosphereInterceptor> l) {\n        WebSocketProcessorFactory.getDefault().getWebSocketProcessor(this)\n                .registerWebSocketHandler(path,\n                        new WebSocketProcessor.WebSocketHandlerProxy(broadcasterFactory.lookup(path, true).getClass(), handler));\n        addAtmosphereHandler(path, h, l);\n        return this;\n    }\n\n    /**\n     * Invoked when a {@link AnnotationProcessor} found an annotation.\n     *\n     * @param b true when found\n     * @return this\n     */\n    public AtmosphereFramework annotationScanned(boolean b) {\n        annotationFound = b;\n        return this;\n    }\n\n    /**\n     * Return true if the {@link #init()} has been sucessfully executed.\n     *\n     * @return true if the {@link #init()} has been sucessfully executed.\n     */\n    public boolean initialized() {\n        return isInit;\n    }\n\n    public List<String> packages() {\n        return packages;\n    }\n\n    /**\n     * Return the list of packages the framework should look for {@link org.atmosphere.config.AtmosphereAnnotation}.\n     *\n     * @return the list of packages the framework should look for {@link org.atmosphere.config.AtmosphereAnnotation}\n     */\n    public List<String> customAnnotationPackages() {\n        return annotationPackages;\n    }\n\n    /**\n     * Add a package containing classes annotated with {@link org.atmosphere.config.AtmosphereAnnotation}.\n     *\n     * @param p a package\n     * @return this;\n     */\n    public AtmosphereFramework addCustomAnnotationPackage(Class p) {\n        annotationPackages.addLast(p.getPackage().getName());\n        return this;\n    }\n\n    /**\n     * Instantiate a class\n     *\n     * @param classType   The Required Class's Type\n     * @param defaultType The default implementation of the Class's Type.\n     * @return the an instance of defaultType\n     * @throws InstantiationException\n     * @throws IllegalAccessException\n     */\n    public <T, U extends T> T newClassInstance(Class<T> classType, Class<U> defaultType) throws InstantiationException, IllegalAccessException {\n        return objectFactory.newClassInstance(classType, defaultType);\n    }\n\n    /**\n     * Set an object used for class instantiation.\n     * Allows for integration with dependency injection frameworks.\n     *\n     * @param objectFactory\n     */\n    public void objectFactory(AtmosphereObjectFactory objectFactory) {\n        this.objectFactory = objectFactory;\n        this.objectFactory.configure(config);\n    }\n\n    /**\n     * If set to true, the task of finishing the request/response lifecycle will not be handled by this class.\n     *\n     * @param externalizeDestroy\n     * @return this\n     */\n    public AtmosphereFramework externalizeDestroy(boolean externalizeDestroy) {\n        this.externalizeDestroy = externalizeDestroy;\n        return this;\n    }\n\n    /**\n     * Return the {@link AnnotationProcessor}\n     *\n     * @return the {@link AnnotationProcessor}\n     */\n    public AnnotationProcessor annotationProcessor() {\n        return annotationProcessor;\n    }\n\n    /**\n     * Was a {@link Broadcaster} defined in web.xml or programmatically added.\n     *\n     * @return true is defined.\n     */\n    public boolean isBroadcasterSpecified() {\n        return isBroadcasterSpecified;\n    }\n\n    protected void configureObjectFactory() {\n        String s = config.getInitParameter(ApplicationConfig.OBJECT_FACTORY);\n        if (s != null) {\n            try {\n                AtmosphereObjectFactory aci = (AtmosphereObjectFactory) IOUtils.loadClass(getClass(), s).newInstance();\n                logger.debug(\"Found ObjectFactory {}\", aci.getClass().getName());\n                objectFactory(aci);\n            } catch (Exception ex) {\n                logger.warn(\"Unable to load AtmosphereClassInstantiator instance\", ex);\n            }\n        }\n\n        if (!DefaultAtmosphereObjectFactory.class.isAssignableFrom(objectFactory.getClass())) {\n            logger.trace(\"ObjectFactory already set to {}\", objectFactory);\n        }\n    }\n\n    /**\n     * Exclude an {@link AtmosphereInterceptor} from being added, at startup, by Atmosphere. The default's {@link #DEFAULT_ATMOSPHERE_INTERCEPTORS}\n     * are candidates for being excluded.\n     *\n     * @param interceptor an {@link AtmosphereInterceptor} class name\n     * @return this\n     */\n    public AtmosphereFramework excludeInterceptor(String interceptor) {\n        excludedInterceptors.add(interceptor);\n        return this;\n    }\n\n    public AtmosphereFramework filterManipulator(BroadcasterConfig.FilterManipulator m) {\n        filterManipulators.add(m);\n        return this;\n    }\n\n    public List<BroadcasterConfig.FilterManipulator> filterManipulators() {\n        return filterManipulators;\n    }\n\n    public boolean isAServletFilter() {\n        return isFilter;\n    }\n\n    public ConcurrentLinkedQueue<String> objectFactoryType() {\n        return objectFactoryType;\n    }\n\n    public String mappingRegex() {\n        return mappingRegex;\n    }\n\n    public AtmosphereFramework mappingRegex(String mappingRegex) {\n        this.mappingRegex = mappingRegex;\n        return this;\n    }\n\n    public void setUseServlet30(boolean useServlet30) {\n        this.useServlet30 = useServlet30;\n    }\n\n    public boolean webSocketEnabled() {\n        return webSocketEnabled;\n    }\n\n    public AtmosphereFramework webSocketEnabled(boolean webSocketEnabled) {\n        this.webSocketEnabled = webSocketEnabled;\n        return this;\n    }\n\n    public String broadcasterLifeCyclePolicy() {\n        return broadcasterLifeCyclePolicy;\n    }\n\n    public AtmosphereFramework broadcasterLifeCyclePolicy(String broadcasterLifeCyclePolicy) {\n        this.broadcasterLifeCyclePolicy = broadcasterLifeCyclePolicy;\n        return this;\n    }\n\n    public List<BroadcasterListener> broadcasterListeners() {\n        return broadcasterListeners;\n    }\n\n    public boolean sharedThreadPools() {\n        return sharedThreadPools;\n    }\n\n    public AtmosphereFramework sharedThreadPools(boolean sharedThreadPools) {\n        this.sharedThreadPools = sharedThreadPools;\n        return this;\n    }\n\n    public boolean allowAllClassesScan() {\n        return allowAllClassesScan;\n    }\n\n    public AtmosphereFramework allowAllClassesScan(boolean allowAllClassesScan) {\n        this.allowAllClassesScan = allowAllClassesScan;\n        return this;\n    }\n\n    public AtmosphereObjectFactory objectFactory() {\n        return objectFactory;\n    }\n\n    public boolean externalizeDestroy() {\n        return externalizeDestroy;\n    }\n\n    public List<String> excludedInterceptors() {\n        return excludedInterceptors;\n    }\n\n    public Class<? extends AtmosphereInterceptor>[] defaultInterceptors() {\n        return DEFAULT_ATMOSPHERE_INTERCEPTORS.toArray(new Class[DEFAULT_ATMOSPHERE_INTERCEPTORS.size()]);\n    }\n\n    public AtmosphereResourceFactory atmosphereFactory() {\n        if (arFactory == null) {\n            configureAtmosphereResourceFactory();\n        }\n        return arFactory;\n    }\n\n    private AtmosphereFramework configureAtmosphereResourceFactory() {\n        if (arFactory != null) return this;\n\n        synchronized (this) {\n            try {\n                arFactory = newClassInstance(AtmosphereResourceFactory.class, DefaultAtmosphereResourceFactory.class);\n            } catch (InstantiationException | IllegalAccessException e) {\n                logger.error(\"\", e);\n            }\n            arFactory.configure(config);\n        }\n        return this;\n    }\n\n    private AtmosphereFramework configureWebSocketFactory() {\n        if (webSocketFactory != null) return this;\n\n        synchronized (this) {\n            try {\n                webSocketFactory = newClassInstance(WebSocketFactory.class, DefaultWebSocketFactory.class);\n            } catch (InstantiationException | IllegalAccessException e) {\n                logger.error(\"\", e);\n            }\n        }\n        return this;\n    }\n\n    public MetaBroadcaster metaBroadcaster() {\n        return metaBroadcaster;\n    }\n\n    private AtmosphereFramework configureMetaBroadcaster() {\n        try {\n            metaBroadcaster = newClassInstance(MetaBroadcaster.class, DefaultMetaBroadcaster.class);\n            metaBroadcaster.configure(config);\n        } catch (InstantiationException | IllegalAccessException e) {\n            logger.error(\"\", e);\n        }\n        return this;\n    }\n\n    /**\n     * Get the default {@link org.atmosphere.cpr.Serializer} class name to use for {@link org.atmosphere.cpr.AtmosphereResource}s.\n     *\n     * @return the class name as a string, might be null if not configured\n     */\n    public String getDefaultSerializerClassName() {\n        return defaultSerializerClassName;\n    }\n\n    /**\n     * Get the default {@link org.atmosphere.cpr.Serializer} class to use for {@link org.atmosphere.cpr.AtmosphereResource}s.\n     *\n     * @return the class, might be null if not configured\n     */\n    public Class<Serializer> getDefaultSerializerClass() {\n        return defaultSerializerClass;\n    }\n\n    /**\n     * Set the default {@link org.atmosphere.cpr.Serializer} class name to use for {@link org.atmosphere.cpr.AtmosphereResource}s.\n     *\n     * @param defaultSerializerClassName the class name to use\n     * @return this\n     */\n    public AtmosphereFramework setDefaultSerializerClassName(String defaultSerializerClassName) {\n        this.defaultSerializerClassName = defaultSerializerClassName;\n        initDefaultSerializer();\n        return this;\n    }\n\n    private void initDefaultSerializer() {\n        if (defaultSerializerClassName != null && !defaultSerializerClassName.isEmpty()) {\n            try {\n                @SuppressWarnings(\"unchecked\")\n                Class<Serializer> clazz = (Class<Serializer>) IOUtils.loadClass(Serializer.class, defaultSerializerClassName);\n                if (Serializer.class.isAssignableFrom(clazz)) {\n                    defaultSerializerClass = clazz;\n                } else {\n                    logger.error(\"Default Serializer class name does not implement Serializer interface\");\n                    defaultSerializerClassName = null;\n                    defaultSerializerClass = null;\n                }\n            } catch (Exception e) {\n                logger.error(\"Unable to set default Serializer\", e);\n                defaultSerializerClassName = null;\n                defaultSerializerClass = null;\n            }\n        } else {\n            defaultSerializerClassName = null;\n            defaultSerializerClass = null;\n        }\n    }\n\n    /**\n     * Return the {@link AtmosphereResourceSessionFactory}\n     *\n     * @return the AtmosphereResourceSessionFactory\n     */\n    public synchronized AtmosphereResourceSessionFactory sessionFactory() {\n        if (sessionFactory == null) {\n            try {\n                sessionFactory = newClassInstance(AtmosphereResourceSessionFactory.class, DefaultAtmosphereResourceSessionFactory.class);\n            } catch (InstantiationException | IllegalAccessException e) {\n                logger.error(\"\", e);\n            }\n        }\n        return sessionFactory;\n    }\n\n    /**\n     * Return true is the {@link #destroy()} method has been invoked.\n     *\n     * @return true is the {@link #destroy()} method has been invoked.\n     */\n    public boolean isDestroyed() {\n        return isDestroyed.get();\n    }\n\n    /**\n     * Add a {@link org.atmosphere.cpr.AtmosphereFrameworkListener}\n     *\n     * @param l {@link org.atmosphere.cpr.AtmosphereFrameworkListener}\n     * @return this;\n     */\n    public AtmosphereFramework frameworkListener(AtmosphereFrameworkListener l) {\n        frameworkListeners.add(l);\n        return this;\n    }\n\n    /**\n     * Return the list of {@link org.atmosphere.cpr.AtmosphereFrameworkListener}\n     *\n     * @return {@link org.atmosphere.cpr.AtmosphereFrameworkListener}\n     */\n    public List<AtmosphereFrameworkListener> frameworkListeners() {\n        return frameworkListeners;\n    }\n\n    protected void onPreInit() {\n        for (AtmosphereFrameworkListener l : frameworkListeners) {\n            try {\n                l.onPreInit(this);\n            } catch (Exception e) {\n                logger.error(\"\", e);\n            }\n        }\n    }\n\n    protected void onPostInit() {\n        for (AtmosphereFrameworkListener l : frameworkListeners) {\n            try {\n                l.onPostInit(this);\n            } catch (Exception e) {\n                logger.error(\"\", e);\n            }\n        }\n    }\n\n    protected void onPreDestroy() {\n        for (AtmosphereFrameworkListener l : frameworkListeners) {\n            try {\n                l.onPreDestroy(this);\n            } catch (Exception e) {\n                logger.error(\"\", e);\n            }\n        }\n    }\n\n    protected void onPostDestroy() {\n        for (AtmosphereFrameworkListener l : frameworkListeners) {\n            try {\n                l.onPostDestroy(this);\n            } catch (Exception e) {\n                logger.error(\"\", e);\n            }\n        }\n    }\n\n    /**\n     * Return the list of {@link org.atmosphere.cpr.AtmosphereResourceListener}\n     *\n     * @return the list of {@link org.atmosphere.cpr.AtmosphereResourceListener}\n     */\n    public List<AtmosphereResourceListener> atmosphereResourceListeners() {\n        return atmosphereResourceListeners;\n    }\n\n    /**\n     * Add a {@link org.atmosphere.cpr.AtmosphereResourceListener}\n     *\n     * @param atmosphereResourceListener a {@link org.atmosphere.cpr.AtmosphereResourceListener}\n     * @return this\n     */\n    public AtmosphereFramework atmosphereResourceListener(AtmosphereResourceListener atmosphereResourceListener) {\n        atmosphereResourceListeners.add(atmosphereResourceListener);\n        return this;\n    }\n\n    /**\n     * Set a {@link java.util.UUID} like implementation for generating random UUID String\n     *\n     * @param uuidProvider\n     * @return this\n     */\n    public AtmosphereFramework uuidProvider(UUIDProvider uuidProvider) {\n        this.uuidProvider = uuidProvider;\n        return this;\n    }\n\n    /**\n     * Return the {@link org.atmosphere.util.UUIDProvider}\n     *\n     * @return {@link org.atmosphere.util.UUIDProvider}\n     */\n    public UUIDProvider uuidProvider() {\n        return uuidProvider;\n    }\n\n    /**\n     * Return the {@link WebSocketFactory}\n     *\n     * @return the {@link WebSocketFactory}\n     */\n    public WebSocketFactory webSocketFactory() {\n        if (webSocketFactory == null) {\n            configureWebSocketFactory();\n        }\n        return webSocketFactory;\n    }\n\n    /**\n     * Configure the {@link WebSocketFactory}\n     *\n     * @param webSocketFactory the {@link WebSocketFactory}\n     * @return this\n     */\n    public AtmosphereFramework webSocketFactory(WebSocketFactory webSocketFactory) {\n        this.webSocketFactory = webSocketFactory;\n        return this;\n    }\n\n    /**\n     * If a {@link ContainerInitializer} fail, log the excetion here.\n     *\n     * @param initializationError\n     */\n    public void initializationError(IllegalStateException initializationError) {\n        this.initializationError = initializationError;\n    }\n}\n",
            "file_name": "AtmosphereFramework.java",
            "human_label": "Check whether there is at least one instance of the implementation class in the lists. If so, true is returned. Otherwise, false is returned.",
            "level": "project_runnable",
            "lineno": "2666",
            "name": "checkDuplicate",
            "oracle_context": "{ \"apis\" : \"[equals, getClass]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
            "package": "org.atmosphere.cpr",
            "project": "atmosphere-atmosphere-2.7.x"
        },
        {
            "_id": "636767561a6d9265ec017f63",
            "all_context": "{ \"class_level\" : \"import java.util.Collection;\\nimport java.util.HashSet;\\nimport java.util.LinkedHashSet;\\nimport java.util.Map;\\nimport java.util.NoSuchElementException;\\nimport java.util.Set;\\nimport org.jgrapht.Graph;\\nimport org.jgrapht.GraphTests;\\nimport org.jgrapht.Graphs;\\nimport org.jgrapht.util.CollectionUtil;\\nBucketList bucketList;\\nV current;\\nBucket head;\\nMap<V,Bucket> bucketMap;\\nBucket next;\\nBucket prev;\\nSet<V> vertices;\\nLexBreadthFirstIterator(Graph graph);\\nnext();\\nisCrossComponentTraversal();\\nsetCrossComponentTraversal(boolean crossComponentTraversal);\\nadvance();\\ngetUnvisitedNeighbours(V vertex);\\nBucketList(Collection vertices);\\ncontainsBucketWith(V vertex);\\npoll();\\nupdateBuckets(Set vertices);\\nBucket(Collection vertices);\\nBucket(V vertex);\\nremoveVertex(V vertex);\\nremoveSelf();\\ninsertBefore(Bucket bucket);\\naddVertex(V vertex);\\nisEmpty();\\n\", \"repo_level\" : \"public interface Graph { Set<E> getAllEdges(V sourceVertex,V targetVertex);\\n E getEdge(V sourceVertex,V targetVertex);\\n Supplier<V> getVertexSupplier();\\n Supplier<E> getEdgeSupplier();\\n E addEdge(V sourceVertex,V targetVertex);\\n boolean addEdge(V sourceVertex,V targetVertex,E e);\\n V addVertex();\\n boolean addVertex(V v);\\n boolean containsEdge(V sourceVertex,V targetVertex);\\n boolean containsEdge(E e);\\n boolean containsVertex(V v);\\n Set<E> edgeSet();\\n int degreeOf(V vertex);\\n Set<E> edgesOf(V vertex);\\n int inDegreeOf(V vertex);\\n Set<E> incomingEdgesOf(V vertex);\\n int outDegreeOf(V vertex);\\n Set<E> outgoingEdgesOf(V vertex);\\n boolean removeAllEdges(Collection edges);\\n Set<E> removeAllEdges(V sourceVertex,V targetVertex);\\n boolean removeAllVertices(Collection vertices);\\n E removeEdge(V sourceVertex,V targetVertex);\\n boolean removeEdge(E e);\\n boolean removeVertex(V v);\\n Set<V> vertexSet();\\n V getEdgeSource(E e);\\n V getEdgeTarget(E e);\\n GraphType getType();\\n double getEdgeWeight(E e);\\n void setEdgeWeight(E e,double weight);\\ndefault void setEdgeWeight(V sourceVertex,V targetVertex,double weight);\\ndefault GraphIterables<V,E> iterables();\\n }\\npublic interface Graphs {static E addEdge(Graph g,V sourceVertex,V targetVertex,double weight);\\nstatic E addEdgeWithVertices(Graph g,V sourceVertex,V targetVertex);\\nstatic boolean addEdgeWithVertices(Graph targetGraph,Graph sourceGraph,E edge);\\nstatic E addEdgeWithVertices(Graph g,V sourceVertex,V targetVertex,double weight);\\nstatic boolean addGraph(Graph destination,Graph source);\\nstatic void addGraphReversed(Graph destination,Graph source);\\nstatic boolean addAllEdges(Graph destination,Graph source,Collection edges);\\nstatic boolean addAllVertices(Graph destination,Collection vertices);\\nstatic List<V> neighborListOf(Graph g,V vertex);\\nstatic Set<V> neighborSetOf(Graph g,V vertex);\\nstatic List<V> predecessorListOf(Graph g,V vertex);\\nstatic List<V> successorListOf(Graph g,V vertex);\\nstatic Graph<V,E> undirectedGraph(Graph g);\\nstatic boolean testIncidence(Graph g,E e,V v);\\nstatic V getOppositeVertex(Graph g,E e,V v);\\nstatic boolean removeVertexAndPreserveConnectivity(Graph graph,V vertex);\\nstatic boolean removeVerticesAndPreserveConnectivity(Graph graph,Predicate predicate);\\nstatic boolean removeVertexAndPreserveConnectivity(Graph graph,Iterable vertices);\\nstatic void addOutgoingEdges(Graph graph,V source,Iterable targets);\\nstatic void addIncomingEdges(Graph graph,V target,Iterable sources);\\nstatic boolean vertexHasSuccessors(Graph graph,V vertex);\\nstatic boolean vertexHasPredecessors(Graph graph,V vertex);\\nstatic VertexToIntegerMapping<V> getVertexToIntegerMapping(Graph graph);\\n }\\npublic interface CollectionUtil {static HashMap<K,V> newHashMapWithExpectedSize(int expectedSize);\\nstatic LinkedHashMap<K,V> newLinkedHashMapWithExpectedSize(int expectedSize);\\nstatic HashSet<E> newHashSetWithExpectedSize(int expectedSize);\\nstatic LinkedHashSet<E> newLinkedHashSetWithExpectedSize(int expectedSize);\\nstatic E getElement(Iterable iterable,int index);\\n }\\n\" }",
            "class_name": "LexBreadthFirstIterator",
            "code": "@Override public boolean hasNext(){\n  if (current != null) {\n    return true;\n  }\n  current=advance();\n  if (current != null && nListeners != 0) {\n    fireVertexTraversed(createVertexTraversalEvent(current));\n  }\n  return current != null;\n}\n",
            "docstring": "/** \n * Checks whether there exist unvisited vertices.\n * @return true if there exist unvisited vertices.\n */\n",
            "end_lineno": "103",
            "file_content": "/*\n * (C) Copyright 2018-2021, by Timofey Chudakov and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.traverse;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport org.jgrapht.Graph;\nimport org.jgrapht.GraphTests;\nimport org.jgrapht.Graphs;\nimport org.jgrapht.util.CollectionUtil;\n\n/**\n * A lexicographical breadth-first iterator for an undirected graph.\n * <p>\n * Every vertex has an implicit label (they aren't used explicitly in order to reduce time and\n * memory complexity). When some vertex is returned by this iterator, its index is the number of\n * vertices in this graph minus number of already returned vertices. For a given vertex v its label\n * is a concatenation of indices of already returned vertices, that were also its neighbours, with\n * some separator between them. For example, 7#4#3 is a valid vertex label.\n * <p>\n * Iterator chooses vertex with lexicographically largest label and returns it. It breaks ties\n * arbitrarily. For more information on lexicographical BFS see the following article: Corneil D.G.\n * (2004) <a href=\"https://pdfs.semanticscholar.org/d4b5/a492f781f23a30773841ec79c46d2ec2eb9c.pdf\">\n * <i>Lexicographic Breadth First Search  A Survey</i></a>. In: Hromkovi J., Nagl M., Westfechtel\n * B. (eds) Graph-Theoretic Concepts in Computer Science. WG 2004. Lecture Notes in Computer\n * Science, vol 3353. Springer, Berlin, Heidelberg; and the following\n * paper:<a href=\"http://www.cse.iitd.ac.in/~naveen/courses/CSL851/uwaterloo.pdf\"><i>CS 762:\n * Graph-theoretic algorithms. Lecture notes of a graduate course. University of Waterloo</i></a>.\n * <p>\n * For this iterator to work correctly the graph must not be modified during iteration. Currently\n * there are no means to ensure that, nor to fail-fast. The results of such modifications are\n * undefined.\n * <p>\n * Note: only vertex events are fired by this iterator.\n *\n * @param <V> the graph vertex type.\n * @param <E> the graph edge type.\n * @author Timofey Chudakov\n */\npublic class LexBreadthFirstIterator<V, E>\n    extends\n    AbstractGraphIterator<V, E>\n{\n\n    /**\n     * Reference to the {@code BucketList} that contains unvisited vertices.\n     */\n    private BucketList bucketList;\n\n    /**\n     * Contains current vertex of the {@code graph}.\n     */\n    private V current;\n\n    /**\n     * Creates new lexicographical breadth-first iterator for {@code graph}.\n     *\n     * @param graph the graph to be iterated.\n     */\n    public LexBreadthFirstIterator(Graph<V, E> graph)\n    {\n        super(graph);\n        GraphTests.requireUndirected(graph);\n        bucketList = new BucketList(graph.vertexSet());\n    }\n\n    /**\n     * Checks whether there exist unvisited vertices.\n     *\n     * @return true if there exist unvisited vertices.\n     */\n    @Override\n    public boolean hasNext()\n    {\n        if (current != null) {\n            return true;\n        }\n        current = advance();\n        if (current != null && nListeners != 0) {\n            fireVertexTraversed(createVertexTraversalEvent(current));\n        }\n        return current != null;\n    }\n\n    /**\n     * Returns the next vertex in the ordering.\n     *\n     * @return the next vertex in the ordering.\n     */\n    @Override\n    public V next()\n    {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        V result = current;\n        current = null;\n        if (nListeners != 0) {\n            fireVertexFinished(createVertexTraversalEvent(result));\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Always returns true since this iterator doesn't care about connected components.\n     */\n    @Override\n    public boolean isCrossComponentTraversal()\n    {\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Trying to disable the cross components nature of this iterator will result into throwing a\n     * {@link IllegalArgumentException}.\n     */\n    @Override\n    public void setCrossComponentTraversal(boolean crossComponentTraversal)\n    {\n        if (!crossComponentTraversal) {\n            throw new IllegalArgumentException(\"Iterator is always cross-component\");\n        }\n    }\n\n    /**\n     * Retrieves vertex from the {@code bucketList} and returns it.\n     *\n     * @return the vertex retrieved from the {@code bucketList}.\n     */\n    private V advance()\n    {\n        V vertex = bucketList.poll();\n        if (vertex != null) {\n            bucketList.updateBuckets(getUnvisitedNeighbours(vertex));\n        }\n        return vertex;\n    }\n\n    /**\n     * Computes and returns neighbours of {@code vertex} which haven't been visited by this\n     * iterator.\n     *\n     * @param vertex the vertex, whose neighbours are being explored.\n     * @return neighbours of {@code vertex} which have yet to be visited by this iterator.\n     */\n    private Set<V> getUnvisitedNeighbours(V vertex)\n    {\n        Set<V> unmapped = new LinkedHashSet<>();\n        Set<E> edges = graph.edgesOf(vertex);\n        for (E edge : edges) {\n            V oppositeVertex = Graphs.getOppositeVertex(graph, edge, vertex);\n            if (bucketList.containsBucketWith(oppositeVertex)) {\n                unmapped.add(oppositeVertex);\n            }\n        }\n        return unmapped;\n    }\n\n    /**\n     * Data structure for performing lexicographical breadth-first search. Allows to add and\n     * retrieve vertices from buckets, update their buckets after a new vertex has been added to the\n     * LexBFS order. Labels aren't used explicitly, which results in time and space optimization.\n     *\n     * @author Timofey Chudakov\n     */\n    class BucketList\n    {\n        /**\n         * Bucket with the vertices that have lexicographically largest label.\n         */\n        private Bucket head;\n        /**\n         * Map for mapping vertices to buckets they are currently in. Is used for finding the bucket\n         * of the vertex in constant time.\n         */\n        private Map<V, Bucket> bucketMap;\n\n        /**\n         * Creates a {@code BucketList} with a single bucket and all specified {@code vertices} in\n         * it.\n         *\n         * @param vertices the vertices of the graph, that should be stored in the {@code head}\n         *        bucket.\n         */\n        BucketList(Collection<V> vertices)\n        {\n            head = new Bucket(vertices);\n            bucketMap = CollectionUtil.newHashMapWithExpectedSize(vertices.size());\n            for (V vertex : vertices) {\n                bucketMap.put(vertex, head);\n            }\n        }\n\n        /**\n         * Checks whether there exists a bucket with the specified {@code vertex}.\n         *\n         * @param vertex the vertex whose presence in some {@code Bucket} in this {@code BucketList}\n         *        is checked.\n         * @return <tt>true</tt> if there exists a bucket with {@code vertex} in it, otherwise\n         *         <tt>false</tt>.\n         */\n        boolean containsBucketWith(V vertex)\n        {\n            return bucketMap.containsKey(vertex);\n        }\n\n        /**\n         * Retrieves element from the head bucket by invoking {@link Bucket#poll()} or null if this\n         * {@code BucketList} is empty.\n         * <p>\n         * Removes the head bucket if it becomes empty after the operation.\n         *\n         * @return vertex returned by {@link Bucket#poll()} invoked on head bucket or null if this\n         *         {@code BucketList} is empty.\n         */\n        V poll()\n        {\n            if (bucketMap.size() > 0) {\n                V res = head.poll();\n                bucketMap.remove(res);\n                if (head.isEmpty()) {\n                    head = head.next;\n                    if (head != null) {\n                        head.prev = null;\n                    }\n                }\n                return res;\n            } else {\n                return null;\n            }\n        }\n\n        /**\n         * For every bucket B in this {@code BucketList}, which contains vertices from the set\n         * {@code\n         * vertices}, creates a new {@code Bucket} B' and moves vertices from B to B' according to\n         * the following rule: $B' = B\\cap vertices$ and $B = B\\backslash B'$. For every such\n         * {@code Bucket} B only one {@code Bucket} B' is created. If some bucket B becomes empty\n         * after this operation, it is removed from the data structure.\n         *\n         * @param vertices the vertices, that should be moved to new buckets.\n         */\n        void updateBuckets(Set<V> vertices)\n        {\n            Set<Bucket> visitedBuckets = new HashSet<>();\n            for (V vertex : vertices) {\n                Bucket bucket = bucketMap.get(vertex);\n                if (visitedBuckets.contains(bucket)) {\n                    bucket.prev.addVertex(vertex);\n                    bucketMap.put(vertex, bucket.prev);\n                } else {\n                    visitedBuckets.add(bucket);\n                    Bucket newBucket = new Bucket(vertex);\n                    newBucket.insertBefore(bucket);\n                    bucketMap.put(vertex, newBucket);\n                    if (head == bucket) {\n                        head = newBucket;\n                    }\n                }\n                bucket.removeVertex(vertex);\n                if (bucket.isEmpty()) {\n                    visitedBuckets.remove(bucket);\n                    bucket.removeSelf();\n                }\n            }\n        }\n\n        /**\n         * Plays the role of the container of vertices. All vertices stored in a bucket have\n         * identical label. Labels aren't used explicitly.\n         * <p>\n         * Encapsulates operations of addition and removal of vertices from the bucket and removal\n         * of a bucket from the data structure.\n         */\n        private class Bucket\n        {\n            /**\n             * Reference of the bucket with lexicographically smaller label.\n             */\n            private Bucket next;\n            /**\n             * Reference of the bucket with lexicographically larger label.\n             */\n            private Bucket prev;\n            /**\n             * Set of vertices currently stored in this bucket.\n             */\n            private Set<V> vertices;\n\n            /**\n             * Creates a new bucket with all {@code vertices} stored in it.\n             *\n             * @param vertices vertices to store in this bucket.\n             */\n            Bucket(Collection<V> vertices)\n            {\n                this.vertices = new LinkedHashSet<>(vertices);\n            }\n\n            /**\n             * Creates a new Bucket with a single {@code vertex} in it.\n             *\n             * @param vertex the vertex to store in this bucket.\n             */\n            Bucket(V vertex)\n            {\n                this.vertices = new LinkedHashSet<>();\n                vertices.add(vertex);\n            }\n\n            /**\n             * Removes the {@code vertex} from this bucket.\n             *\n             * @param vertex the vertex to remove.\n             */\n            void removeVertex(V vertex)\n            {\n                vertices.remove(vertex);\n            }\n\n            /**\n             * Removes this bucket from the data structure.\n             */\n            void removeSelf()\n            {\n                if (next != null) {\n                    next.prev = prev;\n                }\n                if (prev != null) {\n                    prev.next = next;\n                }\n            }\n\n            /**\n             * Inserts this bucket in the data structure before the {@code bucket}.\n             *\n             * @param bucket the bucket, that will be the next to this bucket.\n             */\n            void insertBefore(Bucket bucket)\n            {\n                this.next = bucket;\n                if (bucket != null) {\n                    this.prev = bucket.prev;\n                    if (bucket.prev != null) {\n                        bucket.prev.next = this;\n                    }\n                    bucket.prev = this;\n                } else {\n                    this.prev = null;\n                }\n            }\n\n            /**\n             * Adds the {@code vertex} to this bucket.\n             *\n             * @param vertex the vertex to add.\n             */\n            void addVertex(V vertex)\n            {\n                vertices.add(vertex);\n            }\n\n            /**\n             * Retrieves one vertex from this bucket.\n             *\n             * @return vertex, that was removed from this bucket, null if the bucket was empty.\n             */\n            V poll()\n            {\n                if (vertices.isEmpty()) {\n                    return null;\n                } else {\n                    V vertex = vertices.iterator().next();\n                    vertices.remove(vertex);\n                    return vertex;\n                }\n            }\n\n            /**\n             * Checks whether this bucket is empty.\n             *\n             * @return <tt>true</tt> if this bucket doesn't contain any elements, otherwise false.\n             */\n            boolean isEmpty()\n            {\n                return vertices.size() == 0;\n            }\n        }\n    }\n}\n",
            "file_name": "LexBreadthFirstIterator.java",
            "human_label": "Check whether there are unvisited vertices. If so, return true. Otherwise, return false.",
            "level": "class_runnable",
            "lineno": "87",
            "name": "hasNext",
            "oracle_context": "{ \"apis\" : \"[advance, fireVertexTraversed, createVertexTraversalEvent]\", \"classes\" : \"[]\", \"vars\" : \"[current]\" }",
            "package": "org.jgrapht.traverse",
            "project": "jgrapht-master"
        },
        {
            "_id": "636767611a6d9265ec018112",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.*;\\nimport org.jgrapht.alg.connectivity.*;\\nimport org.jgrapht.alg.interfaces.*;\\nimport org.jgrapht.traverse.*;\\nimport java.util.*;\\nGraph<V,E> graph;\\nlong serialVersionUID;\\nList<V> path;\\nSet<V> cycleSet;\\nV root;\\nCycleDetector(Graph graph);\\ndetectCyclesContainingVertex(V v);\\nfindCycles();\\nfindCyclesContainingVertex(V v);\\nexecute(Set s,V v);\\nProbeIterator(Graph graph,Set cycleSet,V startVertex);\\nencounterVertexAgain(V vertex,E edge);\\nprovideNextVertex();\\ndetectCycles();\\n\", \"repo_level\" : \"\" }",
            "class_name": "CycleDetector$ProbeIterator",
            "code": "@Override protected V provideNextVertex(){\n  V v=super.provideNextVertex();\n  for (int i=path.size() - 1; i >= 0; --i) {\n    if (graph.containsEdge(path.get(i),v)) {\n      break;\n    }\n    path.remove(i);\n  }\n  path.add(v);\n  return v;\n}\n",
            "docstring": "/** \n * {@inheritDoc}\n */\n",
            "end_lineno": "239",
            "file_content": "/*\n * (C) Copyright 2004-2021, by John V Sichi and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.alg.cycle;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.connectivity.*;\nimport org.jgrapht.alg.interfaces.*;\nimport org.jgrapht.traverse.*;\n\nimport java.util.*;\n\n/**\n * Performs cycle detection on a graph. The <i>inspected graph</i> is specified at construction time\n * and cannot be modified. Currently, the detector supports only directed graphs.\n *\n * @param <V> the graph vertex type\n * @param <E> the graph edge type\n *\n * @author John V. Sichi\n */\npublic class CycleDetector<V, E>\n{\n    /**\n     * Graph on which cycle detection is being performed.\n     */\n    private Graph<V, E> graph;\n\n    /**\n     * Creates a cycle detector for the specified graph. Currently only directed graphs are\n     * supported.\n     *\n     * @param graph the directed graph in which to detect cycles\n     */\n    public CycleDetector(Graph<V, E> graph)\n    {\n        this.graph = GraphTests.requireDirected(graph);\n    }\n\n    /**\n     * Performs yes/no cycle detection on the entire graph.\n     *\n     * @return true iff the graph contains at least one cycle\n     */\n    public boolean detectCycles()\n    {\n        try {\n            execute(null, null);\n        } catch (CycleDetectedException ex) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Performs yes/no cycle detection on an individual vertex.\n     *\n     * @param v the vertex to test\n     *\n     * @return true if v is on at least one cycle\n     */\n    public boolean detectCyclesContainingVertex(V v)\n    {\n        try {\n            execute(null, v);\n        } catch (CycleDetectedException ex) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Finds the vertex set for the subgraph of all cycles.\n     *\n     * @return set of all vertices which participate in at least one cycle in this graph\n     */\n    public Set<V> findCycles()\n    {\n        // ProbeIterator can't be used to handle this case,\n        // so use StrongConnectivityAlgorithm instead.\n        StrongConnectivityAlgorithm<V, E> inspector =\n            new KosarajuStrongConnectivityInspector<>(graph);\n        List<Set<V>> components = inspector.stronglyConnectedSets();\n\n        // A vertex participates in a cycle if either of the following is\n        // true: (a) it is in a component whose size is greater than 1\n        // or (b) it is a self-loop\n\n        Set<V> set = new LinkedHashSet<>();\n        for (Set<V> component : components) {\n            if (component.size() > 1) {\n                // cycle\n                set.addAll(component);\n            } else {\n                V v = component.iterator().next();\n                if (graph.containsEdge(v, v)) {\n                    // self-loop\n                    set.add(v);\n                }\n            }\n        }\n\n        return set;\n    }\n\n    /**\n     * Finds the vertex set for the subgraph of all cycles which contain a particular vertex.\n     *\n     * <p>\n     * REVIEW jvs 25-Aug-2006: This implementation is not guaranteed to cover all cases. If you want\n     * to be absolutely certain that you report vertices from all cycles containing v, it's safer\n     * (but less efficient) to use StrongConnectivityAlgorithm instead and return the strongly\n     * connected component containing v.\n     *\n     * @param v the vertex to test\n     *\n     * @return set of all vertices reachable from v via at least one cycle\n     */\n    public Set<V> findCyclesContainingVertex(V v)\n    {\n        Set<V> set = new LinkedHashSet<>();\n        execute(set, v);\n\n        return set;\n    }\n\n    private void execute(Set<V> s, V v)\n    {\n        ProbeIterator<V, E> iter = new ProbeIterator<>(graph, s, v);\n\n        while (iter.hasNext()) {\n            iter.next();\n        }\n    }\n\n    /**\n     * Exception thrown internally when a cycle is detected during a yes/no cycle test. Must be\n     * caught by top-level detection method.\n     */\n    private static class CycleDetectedException\n        extends\n        RuntimeException\n    {\n        private static final long serialVersionUID = 3834305137802950712L;\n    }\n\n    /**\n     * Version of DFS which maintains a backtracking path used to probe for cycles.\n     */\n    private static class ProbeIterator<V, E>\n        extends\n        DepthFirstIterator<V, E>\n    {\n        private List<V> path;\n        private Set<V> cycleSet;\n        private V root;\n\n        ProbeIterator(Graph<V, E> graph, Set<V> cycleSet, V startVertex)\n        {\n            super(graph, startVertex);\n            this.path = new ArrayList<>();\n            this.cycleSet = cycleSet;\n            this.root = startVertex;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected void encounterVertexAgain(V vertex, E edge)\n        {\n            super.encounterVertexAgain(vertex, edge);\n\n            int i;\n\n            if (root != null) {\n                // For rooted detection, the path must either\n                // double back to the root, or to a node of a cycle\n                // which has already been detected.\n                if (vertex.equals(root)) {\n                    i = 0;\n                } else if ((cycleSet != null) && cycleSet.contains(vertex)) {\n                    i = 0;\n                } else {\n                    return;\n                }\n            } else {\n                i = path.indexOf(vertex);\n            }\n\n            if (i > -1) {\n                if (cycleSet == null) {\n                    // we're doing yes/no cycle detection\n                    throw new CycleDetectedException();\n                } else {\n                    for (; i < path.size(); ++i) {\n                        cycleSet.add(path.get(i));\n                    }\n                }\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected V provideNextVertex()\n        {\n            V v = super.provideNextVertex();\n\n            // backtrack\n            for (int i = path.size() - 1; i >= 0; --i) {\n                if (graph.containsEdge(path.get(i), v)) {\n                    break;\n                }\n\n                path.remove(i);\n            }\n\n            path.add(v);\n\n            return v;\n        }\n    }\n}\n",
            "file_name": "CycleDetector.java",
            "human_label": "Get next vertext from a graph.",
            "level": "class_runnable",
            "lineno": "219",
            "name": "provideNextVertex",
            "oracle_context": "{ \"apis\" : \"[size, containsEdge, get, remove, add]\", \"classes\" : \"[V]\", \"vars\" : \"[path, graph]\" }",
            "package": "org.jgrapht.alg.cycle",
            "project": "jgrapht-master"
        },
        {
            "_id": "636767631a6d9265ec018171",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.alg.util.*;\\nimport java.util.*;\\nimport java.util.function.*;\\nListNodeImpl<E> head;\\nint size;\\nint nextIndex;\\nListNodeImpl<E> next;\\nListNodeImpl<E> last;\\nint expectedModCount;\\nV value;\\nDoublyLinkedList<V> list;\\nListNodeImpl<V> next;\\nListNodeImpl<V> prev;\\ntail();\\nsize();\\nclear();\\naddListNode(ListNodeImpl node);\\nmoveAllListNodes(DoublyLinkedList list);\\nremoveListNode(ListNodeImpl node);\\nlink(ListNodeImpl predecessor,ListNodeImpl successor);\\nlinkBefore(ListNodeImpl node,ListNodeImpl successor);\\nlinkLast(ListNodeImpl node);\\nlinkListIntoThisBefore(int index,DoublyLinkedList list);\\nunlink(ListNodeImpl node);\\naddNode(int index,ListNode node);\\naddNodeFirst(ListNode node);\\naddNodeLast(ListNode node);\\naddNodeBefore(ListNode node,ListNode successor);\\ngetFirstNode();\\ngetLastNode();\\ngetNode(int index);\\ngetNodeAt(int index);\\nindexOfNode(ListNode node);\\ncontainsNode(ListNode node);\\nremoveNode(ListNode node);\\nnodeOf(Object element);\\nlastNodeOf(Object element);\\nsearchNode(Supplier first,UnaryOperator next,Object element);\\naddElementFirst(E element);\\naddElementLast(E element);\\naddElementBeforeNode(ListNode successor,E element);\\nadd(int index,E element);\\nget(int index);\\nremove(int index);\\naddFirst(E e);\\naddLast(E e);\\nofferFirst(E e);\\nofferLast(E e);\\nremoveFirst();\\nremoveLast();\\npollFirst();\\npollLast();\\ngetFirst();\\ngetLast();\\npeekFirst();\\npeekLast();\\nremoveFirstOccurrence(Object o);\\nremoveLastOccurrence(Object o);\\noffer(E e);\\nremove();\\npoll();\\nelement();\\npeek();\\npush(E e);\\npop();\\ninvert();\\nmoveFrom(int index,DoublyLinkedList movedList);\\nappend(DoublyLinkedList movedList);\\nprepend(DoublyLinkedList movedList);\\ncircularIterator(E firstElement);\\nreverseCircularIterator(E firstElement);\\ndescendingIterator();\\niterator();\\nlistIterator();\\nlistIterator(int index);\\nlistIterator(E element);\\nnext();\\nnextNode();\\nprevious();\\npreviousNode();\\nListNodeIteratorImpl(int startIndex);\\nListNodeIteratorImpl(int startIndex,ListNodeImpl startNode);\\nhasNext();\\nhasPrevious();\\nnextIndex();\\npreviousIndex();\\nadd(E e);\\nset(E e);\\ncheckForComodification();\\nreverseIterator(ListNodeIterator listIterator);\\ngetValue();\\ngetNext();\\ngetPrev();\\nListNodeImpl(V value);\\ntoString();\\nisEmpty();\\n\", \"repo_level\" : \"\" }",
            "class_name": "DoublyLinkedList",
            "code": "private boolean unlink(ListNodeImpl<E> node){\n  ListNodeImpl<E> prev=node.prev;\n  ListNodeImpl<E> next=node.next;\n  if (removeListNode(node)) {\n    if (size == 0) {\n      head=null;\n    }\n else {\n      link(prev,next);\n      if (head == node) {\n        head=next;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n",
            "docstring": "/** \n * Remove the non null  {@code node} from the list. \n */\n",
            "end_lineno": "259",
            "file_content": "/*\n * (C) Copyright 2018-2021, by Timofey Chudakov and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.util;\n\nimport org.jgrapht.alg.util.*;\n\nimport java.util.*;\nimport java.util.function.*;\n\n/**\n * {@code DoublyLinkedList} implements a doubly linked {@link List} data structure, that exposes its\n * {@link ListNode ListNodes} where the data is stored in.\n * <p>\n * An element holding {@code ListNode} can be removed or added to a {@code DoublyLinkedList} in\n * constant time O(1). Other methods that operate on {@code ListNodes} directly also have constant\n * runtime. This is also the case for methods that operate on the first(head) and last(tail) node or\n * element. Random access methods have a runtime O(n) that is linearly dependent on the size of the\n * {@code DoublyLinkedList}.\n * </p>\n * <p>\n * A {@code DoublyLinkedList} supports {@code null} elements but does not support\n * {@code null ListNodes}. This class is not thread safe and needs to be synchronized externally if\n * modified by concurrent threads.\n * </p>\n * <p>\n * The iterators over this list have a <i>fail-fast</i> behavior meaning that they throw a\n * {@link ConcurrentModificationException} after they detect a structural modification of the list,\n * that they're not responsible for.\n * </p>\n * <p>\n * This class is similar to {@link LinkedList}. The general difference is that the {@code ListNodes}\n * of this {@code List} are accessible and can be removed or added directly. To ensure the integrity\n * of the {@code List} nodes of this List have a reference to the List they belong to. This\n * increases the memory occupied by this list implementation compared to {@code LinkedList} for the\n * same elements. Instances of {@code LinkedList.Node} have three references each (the element, next\n * and previous), instances of {@code DoublyLinkedList.ListNode} have four (the element, next,\n * previous and the list).\n * </p>\n *\n * @param <E> the list element type\n * @author Timofey Chudakov\n * @author Hannes Wellmann\n */\npublic class DoublyLinkedList<E>\n    extends\n    AbstractSequentialList<E>\n    implements\n    Deque<E>\n{\n    /** The first element of the list, {@code null} if this list is empty. */\n    private ListNodeImpl<E> head = null;\n    private int size;\n\n    private ListNodeImpl<E> tail()\n    {\n        return head.prev;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isEmpty()\n    {\n        return head == null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int size()\n    {\n        return size;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void clear()\n    {\n        if (!isEmpty()) {\n            ListNodeImpl<E> node = head;\n            do {\n                ListNodeImpl<E> next = node.next;\n                boolean removed = removeListNode(node); // clears all links of removed node\n                assert removed;\n                node = next;\n            } while (node != head);\n\n            head = null;\n            assert size == 0;\n        }\n    }\n\n    // internal modification methods\n\n    /**\n     * Adds the given {@link ListNode} to this {@code List}.\n     * <p>\n     * Sets the {@code list} reference of {@code node} to this list, increases this lists\n     * {@code size} and {@code modcount} by one.\n     * </p>\n     * \n     * @param node the node to add to this list\n     * @throws IllegalArgumentException if {@code node} is already contained in this or another\n     *         {@code DoublyLinkedList}\n     */\n    private void addListNode(ListNodeImpl<E> node)\n    { // call this before any modification of this list is done\n        if (node.list != null) {\n            String list = (node.list == this) ? \"this\" : \"other\";\n            throw new IllegalArgumentException(\n                \"Node <\" + node + \"> already contained in \" + list + \" list\");\n        }\n        node.list = this;\n        size++;\n        modCount++;\n    }\n\n    /**\n     * Atomically moves all {@link ListNode ListNodes} from {@code list} to this list as if each\n     * node was removed with {@link #removeListNode(ListNodeImpl)} from {@code list} and\n     * subsequently added to this list by {@link #addListNode(ListNodeImpl)}.\n     */\n    private void moveAllListNodes(DoublyLinkedList<E> list)\n    { // call this before any modification of this list is done\n\n        for (ListNodeIteratorImpl it = list.new ListNodeIteratorImpl(0); it.hasNext();) {\n            ListNodeImpl<E> node = it.nextNode();\n            assert node.list == list;\n            node.list = this;\n        }\n        size += list.size;\n        list.size = 0;\n        modCount++;\n        list.modCount++;\n    }\n\n    /**\n     * Removes the given {@link ListNode} from this {@code List}, if it is contained in this\n     * {@code List}.\n     * <p>\n     * If {@code node} is contained in this list, sets the {@code list}, {@code next} and\n     * {@code prev} reference of {@code node} to {@code null} decreases this list's {@code size} and\n     * increases the {@code modcount} by one.\n     * </p>\n     * \n     * @param node the node to remove from this list\n     * @return true if {@code node} was removed from this list, else false\n     */\n    private boolean removeListNode(ListNodeImpl<E> node)\n    { // call this before any modification of this list is done\n        if (node.list == this) {\n\n            node.list = null;\n            node.next = null;\n            node.prev = null;\n\n            size--;\n            modCount++;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Establishes the links between the given {@link ListNodeImpl nodes} in such a way that the\n     * {@code predecessor} is linked before the {@code successor}.\n     * \n     * @param predecessor the first node linked before the other\n     * @param successor the second node linked after the other\n     */\n    private void link(ListNodeImpl<E> predecessor, ListNodeImpl<E> successor)\n    {\n        predecessor.next = successor;\n        successor.prev = predecessor;\n    }\n\n    /** Insert non null {@code node} before non null {@code successor} into the list. */\n    private void linkBefore(ListNodeImpl<E> node, ListNodeImpl<E> successor)\n    {\n        addListNode(node);\n        link(successor.prev, node);\n        link(node, successor);\n    }\n\n    /** Insert non null {@code node} as last node into the list. */\n    private void linkLast(ListNodeImpl<E> node)\n    {\n        if (isEmpty()) { // node will be the first and only one\n            addListNode(node);\n            link(node, node); // self link\n            head = node;\n        } else {\n            linkBefore(node, head);\n        }\n    }\n\n    /** Insert non null {@code list} before node at {@code index} into the list. */\n    private void linkListIntoThisBefore(int index, DoublyLinkedList<E> list)\n    {\n        int previousSize = size;\n        moveAllListNodes(list);\n\n        // link list's node into this list\n        if (previousSize == 0) {\n            head = list.head; // head and tail already linked together\n        } else {\n            ListNodeImpl<E> refNode = (index == previousSize) ? head : getNodeAt(index);\n\n            ListNodeImpl<E> listTail = list.tail();\n            link(refNode.prev, list.head); // changes list.tail()\n            link(listTail, refNode);\n\n            if (index == 0) {\n                head = list.head;\n            }\n        }\n        // clear list but do not call list.clear(), since their nodes are still used\n        list.head = null;\n    }\n\n    /** Remove the non null {@code node} from the list. */\n    private boolean unlink(ListNodeImpl<E> node)\n    {\n        ListNodeImpl<E> prev = node.prev;\n        ListNodeImpl<E> next = node.next;\n        if (removeListNode(node)) { // clears prev and next of node\n            if (size == 0) {\n                head = null;\n            } else {\n                // list is circular, don't have to worry about null values\n                link(prev, next);\n\n                if (head == node) {\n                    head = next;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // ----------------------------------------------------------------------------\n    // public modification and access methods\n\n    // ListNode methods:\n    // Base methods to access, add and remove nodes to/from this list.\n    // Used by all public methods if possible\n\n    /**\n     * Inserts the specified {@link ListNode node} at the specified position in this list.\n     * <p>\n     * This method has a linear runtime complexity O(n) that depends linearly on the distance of the\n     * index to the nearest end. Adding {@code node} as first or last takes only constant time O(1).\n     * </p>\n     * \n     * @param index index at which the specified {@code node} is to be inserted\n     * @param node the node to add\n     * @throws IndexOutOfBoundsException if the index is out of range\n     *         ({@code index < 0 || index > size()})\n     * @throws IllegalArgumentException if {@code node} is already part of this or another\n     *         {@code DoublyLinkedList}\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public void addNode(int index, ListNode<E> node)\n    {\n        ListNodeImpl<E> nodeImpl = (ListNodeImpl<E>) node;\n        if (index == size) { // also true if this is empty\n            linkLast(nodeImpl);\n        } else {\n            ListNodeImpl<E> successor = index == 0 ? head : getNodeAt(index);\n            linkBefore(nodeImpl, successor);\n            if (head == successor) {\n                head = nodeImpl;\n            }\n        }\n    }\n\n    /**\n     * Inserts the specified {@link ListNode node} at the front of this list.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @param node the node to add\n     * @throws IllegalArgumentException if {@code node} is already part of this or another\n     *         {@code DoublyLinkedList}\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public void addNodeFirst(ListNode<E> node)\n    {\n        addNode(0, node);\n    }\n\n    /**\n     * Inserts the specified {@link ListNode node} at the end of this list.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @param node the node to add\n     * @throws IllegalArgumentException if {@code node} is already part of this or another\n     *         {@code DoublyLinkedList}\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public void addNodeLast(ListNode<E> node)\n    {\n        addNode(size, node);\n    }\n\n    /**\n     * Inserts the specified {@link ListNode node} before the specified {@code successor} in this\n     * list.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @param node the node to add\n     * @param successor {@code ListNode} before which the {@code node} is inserted\n     * @throws IllegalArgumentException if {@code node} is already contained in this or another\n     *         {@code DoublyLinkedList} or {@code successor} is not contained in this list\n     * @throws NullPointerException if {@code successor} or {@code node} is {@code null}\n     */\n    public void addNodeBefore(ListNode<E> node, ListNode<E> successor)\n    {\n        ListNodeImpl<E> successorImpl = (ListNodeImpl<E>) successor;\n        ListNodeImpl<E> nodeImpl = (ListNodeImpl<E>) node;\n\n        if (successorImpl.list != this) {\n            throw new IllegalArgumentException(\"Node <\" + successorImpl + \"> not in this list\");\n        }\n        linkBefore(nodeImpl, successorImpl);\n        if (head == successorImpl) {\n            head = nodeImpl;\n        }\n    }\n\n    /**\n     * Returns the first {@link ListNode node} of this list.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @return the first {@code ListNode} of this list\n     * @throws NoSuchElementException if this list is empty\n     */\n    public ListNode<E> getFirstNode()\n    {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        return head;\n    }\n\n    /**\n     * Returns the last {@link ListNode node} of this list.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @return the last {@code ListNode} of this list\n     * @throws NoSuchElementException if this list is empty\n     */\n    public ListNode<E> getLastNode()\n    {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        return tail();\n    }\n\n    /**\n     * Returns the {@link ListNode node} at the specified position in this list.\n     * <p>\n     * This method has linear runtime complexity O(n).\n     * </p>\n     * \n     * @param index index of the {@code ListNode} to return\n     * @return the {@code ListNode} at the specified position in this list\n     * @throws IndexOutOfBoundsException if the index is out of range\n     *         ({@code index < 0 || index >= size()})\n     */\n    public ListNode<E> getNode(int index)\n    {\n        return getNodeAt(index);\n    }\n\n    /**\n     * Returns the {@link ListNodeImpl node} at the specified position in this list.\n     * \n     * @param index index of the {@code ListNodeImpl} to return\n     * @return the {@code ListNode} at the specified position in this list\n     * @throws IndexOutOfBoundsException if the index is out of range\n     *         ({@code index < 0 || index >= size()})\n     */\n    private ListNodeImpl<E> getNodeAt(int index)\n    {\n        if (index < 0 || size <= index) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index);\n        }\n        ListNodeImpl<E> node;\n        if (index < size / 2) {\n            node = head;\n            for (int i = 0; i < index; i++) {\n                node = node.next;\n            }\n        } else {\n            node = tail();\n            for (int i = size - 1; index < i; i--) {\n                node = node.prev;\n            }\n        }\n        return node;\n    }\n\n    /**\n     * Returns the index of the specified {@link ListNode node} in this list, or -1 if this list\n     * does not contain the {@code node}.\n     * <p>\n     * More formally, returns the index {@code i} such that {@code node == getNode(i)}, or -1 if\n     * there is no such index. Because a {@code ListNode} is contained in at most one list exactly\n     * once, the returned index (if not -1) is the only occurrence of that {@code node}.\n     * </p>\n     * <p>\n     * This method has linear runtime complexity O(n) to find {@code node} but returns in constant\n     * time O(1) if {@code node} is not {@link #containsNode(ListNode) contained} in this list.\n     * </p>\n     * \n     * @param node the node to search for\n     * @return the index of the specified {@code node} in this list, or -1 if this list does not\n     *         contain {@code node}\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public int indexOfNode(ListNode<E> node)\n    {\n        if (!containsNode(node)) {\n            return -1;\n        }\n        ListNodeImpl<E> current = head;\n        for (int i = 0; i < size; i++) {\n            if (current == node) {\n                return i;\n            }\n            current = current.next;\n        }\n        // should never happen:\n        throw new IllegalStateException(\"Node contained in list not found: \" + node);\n    }\n\n    /**\n     * Returns true if this {@code DoublyLinkedList} contains the specified {@link ListNode}.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @param node the node whose presence in this {@code DoublyLinkedList} is to be tested\n     * @return true if this {@code DoublyLinkedList} contains the {@link ListNode}\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public boolean containsNode(ListNode<E> node)\n    {\n        return ((ListNodeImpl<E>) node).list == this;\n    }\n\n    /**\n     * Removes the {@link ListNode node} from this list. Returns true if {@code node} was in this\n     * list and is now removed. If {@code node} is not contained in this list, the list is left\n     * unchanged.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     *\n     * @param node the node to remove from this list\n     * @return true if node was removed from this list\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public boolean removeNode(ListNode<E> node)\n    {\n        return unlink((ListNodeImpl<E>) node);\n    }\n\n    /**\n     * Returns the first {@link ListNode node} holding the specified {@code element} in this list.\n     * More formally, returns the first {@code ListNode} such that\n     * {@code Objects.equals(element, node.getValue())}, or {@code null} if there is no such node.\n     * <p>\n     * This method has linear runtime complexity O(n).\n     * </p>\n     * \n     * @param element the element whose {@code ListNode} is to return\n     * @return the first {@code ListNode} holding the {@code element} or null if no node was found\n     */\n    public ListNode<E> nodeOf(Object element)\n    {\n        return searchNode(() -> head, n -> n.next, element).getFirst();\n    }\n\n    /**\n     * Returns the last {@link ListNode node} holding the specified {@code element} in this list.\n     * More formally, returns the last {@code ListNode} such that\n     * {@code Objects.equals(element, node.getValue())}, or {@code null} if there is no such node.\n     * <p>\n     * This method has linear runtime complexity O(n).\n     * </p>\n     * \n     * @param element the element whose {@code ListNode} is to return\n     * @return the last {@code ListNode} holding the {@code element} or null if no node was found\n     */\n    public ListNode<E> lastNodeOf(Object element)\n    {\n        return searchNode(this::tail, n -> n.prev, element).getFirst();\n    }\n\n    /**\n     * Returns a {@link Pair} of the first encountered {@link ListNode} in this list, whose\n     * {@code value} is equal to the given {@code element}, and its index. Or if this list does not\n     * contain such node a Pair of {@code null} and {@code -1};\n     * <p>\n     * The search starts at the node supplied by {@code first} and advances in the direction induced\n     * by the specified {@code next} operator.\n     * </p>\n     * \n     * @param first supplier of the first node to check if this list is not empty\n     * @param next {@code Function} to get from the current node the next node to check\n     * @param element the element for that the first node with equal value is searched.\n     * @return a {@link Pair} of the first encountered {@code ListNode} holding a {@code value}\n     *         equal to {@code element} and its index, or if no such node was found a\n     *         {@code Pair.of(null, -1)}\n     */\n    private Pair<ListNodeImpl<E>, Integer> searchNode(\n        Supplier<ListNodeImpl<E>> first, UnaryOperator<ListNodeImpl<E>> next, Object element)\n    {\n        if (!isEmpty()) {\n            int index = 0;\n            ListNodeImpl<E> firstNode = first.get();\n            ListNodeImpl<E> node = firstNode;\n            do {\n                if (Objects.equals(node.value, element)) {\n                    return Pair.of(node, index);\n                }\n                index++;\n                node = next.apply(node);\n            } while (node != firstNode);\n        }\n        return Pair.of(null, -1);\n    }\n\n    /**\n     * Inserts the specified element at the front of this list. Returns the {@link ListNode}\n     * allocated to store the {@code value}. The returned {@code ListNode} is the new head of the\n     * list.\n     * <p>\n     * This method is equivalent to {@link #addFirst(Object)} but returns the allocated\n     * {@code ListNode}.\n     * </p>\n     * \n     * @param element the element to add\n     * @return the {@code ListNode} allocated to store the {@code value}\n     */\n    public ListNode<E> addElementFirst(E element)\n    {\n        ListNode<E> node = new ListNodeImpl<>(element);\n        addNode(0, node);\n        return node;\n    }\n\n    /**\n     * Inserts the specified element at the end of this list. Returns the {@link ListNode} allocated\n     * to store the {@code value}. The returned {@code ListNode} is the new tail of the list.\n     * <p>\n     * This method is equivalent to {@link #addLast(Object)} but returns the allocated\n     * {@code ListNode}.\n     * </p>\n     * \n     * @param element the element to add\n     * @return the {@code ListNode} allocated to store the {@code value}\n     */\n    public ListNode<E> addElementLast(E element)\n    {\n        ListNode<E> node = new ListNodeImpl<>(element);\n        addNode(size, node);\n        return node;\n    }\n\n    /**\n     * Inserts the specified element before the specified {@link ListNode successor} in this list.\n     * Returns the {@code ListNode} allocated to store the {@code value}.\n     *\n     * @param successor {@code ListNode} before which the node holding {@code value} is inserted\n     * @param element the element to add\n     * @return the {@code ListNode} allocated to store the {@code value}\n     * @throws IllegalArgumentException if {@code successor} is not contained in this list\n     * @throws NullPointerException if {@code successor} is {@code null}\n     */\n    public ListNode<E> addElementBeforeNode(ListNode<E> successor, E element)\n    {\n        ListNode<E> node = new ListNodeImpl<>(element);\n        addNodeBefore(node, successor);\n        return node;\n    }\n\n    // List methods (shortcut for most commonly used methods to avoid iterator creation)\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void add(int index, E element)\n    {\n        if (index == size) { // also true if this is empty\n            addElementLast(element);\n        } else {\n            addElementBeforeNode(getNode(index), element);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E get(int index)\n    {\n        return getNodeAt(index).value;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E remove(int index)\n    {\n        ListNode<E> node = getNode(index);\n        removeNode(node);\n        return node.getValue();\n    }\n\n    // Deque methods\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void addFirst(E e)\n    {\n        addElementFirst(e);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void addLast(E e)\n    {\n        addElementLast(e);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean offerFirst(E e)\n    {\n        addElementFirst(e);\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean offerLast(E e)\n    {\n        addElementLast(e);\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E removeFirst()\n    {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n\n        ListNode<E> node = head;\n        removeNode(node); // changes head\n        return node.getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E removeLast()\n    {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n\n        ListNode<E> node = tail();\n        removeNode(node); // changes tail\n        return node.getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E pollFirst()\n    {\n        if (isEmpty()) {\n            return null;\n        }\n        ListNode<E> node = head;\n        removeNode(node); // changes head\n        return node.getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E pollLast()\n    {\n        if (isEmpty()) {\n            return null;\n        }\n        ListNode<E> node = tail();\n        removeNode(node); // changes tail()\n        return node.getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E getFirst()\n    {\n        return getFirstNode().getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E getLast()\n    {\n        return getLastNode().getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E peekFirst()\n    {\n        return isEmpty() ? null : getFirst();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E peekLast()\n    {\n        return isEmpty() ? null : getLast();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean removeFirstOccurrence(Object o)\n    {\n        ListNode<E> node = nodeOf(o);\n        if (node != null) {\n            removeNode(node);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean removeLastOccurrence(Object o)\n    {\n        ListNode<E> node = lastNodeOf(o);\n        if (node != null) {\n            removeNode(node);\n            return true;\n        }\n        return false;\n    }\n\n    // Queue methods\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean offer(E e)\n    {\n        return offerLast(e);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E remove()\n    {\n        return removeFirst();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E poll()\n    {\n        return pollFirst();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E element()\n    {\n        return getFirst();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E peek()\n    {\n        return peekFirst();\n    }\n\n    // Stack methods\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void push(E e)\n    {\n        addFirst(e);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E pop()\n    {\n        return removeFirst();\n    }\n\n    // special bulk methods\n\n    /**\n     * Inverts the list. For instance, calling this method on the list $(a,b,c,\\dots,x,y,z)$ will\n     * result in the list $(z,y,x,\\dots,c,b,a)$. This method does only pointer manipulation, meaning\n     * that all the list nodes allocated for the previously added elements are valid after this\n     * method finishes.\n     */\n    public void invert()\n    {\n        if (size < 2) {\n            return;\n        }\n        ListNodeImpl<E> newHead = tail();\n        ListNodeImpl<E> current = head;\n        do {\n            ListNodeImpl<E> next = current.next;\n\n            current.next = current.prev;\n            current.prev = next;\n\n            current = next;\n        } while (current != head);\n        head = newHead;\n        ++modCount;\n    }\n\n    /**\n     * Moves all {@link ListNode ListNodes} of the given {@code sourceList} to this list and inserts\n     * them all before the node previously at the given position. All the {@code nodes} of\n     * {@code movedList} are moved to this list. When this method terminates this list contains all\n     * nodes of {@code movedList} and {@code movedList} is empty.\n     *\n     * @param index index of the first element of {@code list} in this {@code list} after it was\n     *        added\n     * @param movedList the {@code DoublyLinkedList} to move to this one\n     * @throws NullPointerException if {@code movedList} is {@code null}\n     */\n    public void moveFrom(int index, DoublyLinkedList<E> movedList)\n    {\n        linkListIntoThisBefore(index, movedList);\n    }\n\n    /**\n     * Appends the {@code movedList} to the end of this list. All the elements from\n     * {@code movedList} are transferred to this list, i.e. the {@code list} is empty after calling\n     * this method.\n     *\n     * @param movedList the {@code DoublyLinkedList} to append to this one\n     * @throws NullPointerException if {@code movedList} is {@code null}\n     */\n    public void append(DoublyLinkedList<E> movedList)\n    {\n        moveFrom(size, movedList);\n    }\n\n    /**\n     * Prepends the {@code movedList} to the beginning of this list. All the elements from\n     * {@code movedList} are transferred to this list, i.e. the {@code movedList} is empty after\n     * calling this method.\n     *\n     * @param movedList the {@code DoublyLinkedList} to prepend to this one\n     * @throws NullPointerException if {@code movedList} is {@code null}\n     */\n    public void prepend(DoublyLinkedList<E> movedList)\n    {\n        moveFrom(0, movedList);\n    }\n\n    // ----------------------------------------------------------------------------\n    // (List)Iterators\n\n    /**\n     * Returns a {@link NodeIterator} that starts at the first {@link ListNode} of this list that is\n     * equal to the specified {@code firstElement}, iterates in forward direction over the end of\n     * this list until the first node.\n     * <p>\n     * The first call to {@link NodeIterator#nextNode()} returns the first {@code node} that holds a\n     * value such that {@code Objects.equals(node.getValue, firstElement)} returns {@code true}. The\n     * returned {@code NodeIterator} iterates in forward direction returning the respective next\n     * element in subsequent calls to {@code next(Node)}. The returned iterator ignores the actual\n     * bounds of this {@code DoublyLinkedList} and iterates until the node before the first one is\n     * reached. Its {@link NodeIterator#hasNext() hasNext()} returns {@code false} if the next node\n     * would be the first one.\n     * </p>\n     * \n     * @param firstElement the element equal to the first {@code next()}\n     * @return a circular {@code NodeIterator} iterating forward from {@code firstElement}\n     */\n    public NodeIterator<E> circularIterator(E firstElement)\n    {\n        ListNodeImpl<E> startNode = (ListNodeImpl<E>) nodeOf(firstElement);\n        if (startNode == null) {\n            throw new NoSuchElementException();\n        }\n        return new ListNodeIteratorImpl(0, startNode);\n    }\n\n    /**\n     * Returns a {@link NodeIterator} that starts at the first {@link ListNode} of this list that is\n     * equal to the specified {@code firstElement}, iterates in reverse direction over the end of\n     * this list until the first node.\n     * <p>\n     * The first call to {@link NodeIterator#nextNode()} returns the first {@code node} that holds a\n     * value such that {@code Objects.equals(node.getValue, firstElement)} returns {@code true}. The\n     * returned {@code NodeIterator} iterates in reverse direction returning the respective previous\n     * element in subsequent calls to {@code next(Node)}. The returned iterator ignores the actual\n     * bounds of this {@code DoublyLinkedList} and iterates until the node before the first one is\n     * reached. Its {@link NodeIterator#hasNext() hasNext()} returns {@code false} if the next node\n     * would be the first one.\n     * </p>\n     * \n     * @param firstElement the element equal to the first {@code next()}\n     * @return a circular {@code NodeIterator} iterating backwards from {@code firstElement}\n     */\n    public NodeIterator<E> reverseCircularIterator(E firstElement)\n    {\n        ListNodeImpl<E> startNode = (ListNodeImpl<E>) nodeOf(firstElement);\n        if (startNode == null) {\n            throw new NoSuchElementException();\n        }\n        return reverseIterator(new ListNodeIteratorImpl(size, startNode.next));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public NodeIterator<E> descendingIterator()\n    {\n        return reverseIterator(listIterator(size));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public NodeIterator<E> iterator()\n    {\n        return listIterator();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public ListNodeIterator<E> listIterator()\n    {\n        return listIterator(0);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public ListNodeIterator<E> listIterator(int index)\n    {\n        return new ListNodeIteratorImpl(index);\n    }\n\n    /**\n     * Returns a {@link ListNodeIterator} over the elements in this list (in proper sequence)\n     * starting with the first {@link ListNode} whose value is equal to the specified\n     * {@code element}.\n     *\n     * @param element the first element to be returned from the list iterator (by a call to the\n     *        {@code next} method)\n     * @return a list iterator over the elements in this list (in proper sequence)\n     * @throws NoSuchElementException if {@code element} is not in the list\n     */\n    public ListNodeIterator<E> listIterator(E element)\n    {\n        Pair<ListNodeImpl<E>, Integer> startPair = searchNode(() -> head, n -> n.next, element);\n        ListNodeImpl<E> startNode = startPair.getFirst();\n        int startIndex = startPair.getSecond();\n        if (startNode == null) {\n            throw new NoSuchElementException();\n        }\n        return new ListNodeIteratorImpl(startIndex, startNode);\n    }\n\n    /**\n     * An extension of the {@link Iterator} interface for {@link DoublyLinkedList DoublyLinkedLists}\n     * exposing their {@link ListNode ListNodes}.\n     *\n     * @param <E> the list element type\n     */\n    public interface NodeIterator<E>\n        extends\n        Iterator<E>\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        default E next()\n        {\n            return nextNode().getValue();\n        }\n\n        /**\n         * Returns the next {@link ListNode} in the list and advances the cursor position.\n         *\n         * @return the next {@code ListNode}\n         * @see ListIterator#next()\n         */\n        ListNode<E> nextNode();\n\n    }\n\n    /**\n     * An extension of the {@link ListIterator} interface for {@link DoublyLinkedList\n     * DoublyLinkedLists} exposing their {@link ListNode ListNodes}.\n     *\n     * @param <E> the list element type\n     */\n    public interface ListNodeIterator<E>\n        extends\n        ListIterator<E>,\n        NodeIterator<E>\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        default E next()\n        {\n            return nextNode().getValue();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        default E previous()\n        {\n            return previousNode().getValue();\n        }\n\n        /**\n         * Returns the previous {@link ListNode} in the list and moves the cursor position\n         * backwards.\n         *\n         * @return the previous {@code ListNode}\n         * @see ListIterator#previous()\n         */\n        ListNode<E> previousNode();\n\n    }\n\n    /**\n     * An implementation of the {@link DoublyLinkedList.ListNodeIterator} interface.\n     */\n    private class ListNodeIteratorImpl\n        implements\n        ListNodeIterator<E>\n    {\n        /** Index in this list of the ListNode returned next. */\n        private int nextIndex;\n        /** ListNode this iterator will return next. Null if this list is empty. */\n        private ListNodeImpl<E> next;\n        /** ListNode this iterator returned last. */\n        private ListNodeImpl<E> last = null;\n\n        /**\n         * The number of modifications the list have had at the moment when this iterator was\n         * created\n         */\n        private int expectedModCount = modCount;\n\n        private ListNodeIteratorImpl(int startIndex)\n        {\n            this.nextIndex = startIndex;\n            if (startIndex == size) {\n                this.next = isEmpty() ? null : head;\n            } else {\n                this.next = getNodeAt(startIndex);\n            }\n        }\n\n        private ListNodeIteratorImpl(int startIndex, ListNodeImpl<E> startNode)\n        {\n            this.nextIndex = startIndex;\n            this.next = startNode;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean hasNext()\n        {\n            return nextIndex < size;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean hasPrevious()\n        {\n            return nextIndex > 0;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int nextIndex()\n        {\n            return nextIndex;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int previousIndex()\n        {\n            return nextIndex - 1;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public ListNodeImpl<E> nextNode()\n        {\n            checkForComodification();\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n\n            last = next;\n            next = next.next;\n            nextIndex++;\n            return last;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public ListNode<E> previousNode()\n        {\n            checkForComodification();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException();\n            }\n\n            last = next = next.prev;\n            nextIndex--;\n            return last;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void add(E e)\n        {\n            checkForComodification();\n\n            if (nextIndex == size) {\n                addElementLast(e); // sets head to new node of e if was empty\n                if (size == 1) { // was empty\n                    next = head; // jump over head threshold, so cursor is at the end\n                }\n            } else {\n                addElementBeforeNode(next, e);\n            }\n            last = null;\n            nextIndex++;\n            expectedModCount++;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void set(E e)\n        {\n            if (last == null) {\n                throw new IllegalStateException();\n            }\n            checkForComodification();\n            // replace node returned last with a new node holding e\n\n            ListNode<E> nextNode = last.next;\n            boolean wasLast = last == tail();\n            removeNode(last);\n            if (wasLast) { // or the sole node\n                last = (ListNodeImpl<E>) addElementLast(e);\n            } else {\n                last = (ListNodeImpl<E>) addElementBeforeNode(nextNode, e);\n            }\n            expectedModCount += 2; // because of unlink and add\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void remove()\n        {\n            if (last == null) {\n                throw new IllegalStateException();\n            }\n            checkForComodification();\n\n            ListNodeImpl<E> lastsNext = last.next;\n            removeNode(last);\n            if (next == last) { // previousNode() called before\n                // removed element after cursor (which would have been next)\n                next = lastsNext;\n            } else { // nextNode() called before\n                // removed element before cursor (next is unaffected but the index decreases)\n                nextIndex--;\n            }\n            last = null;\n            expectedModCount++;\n        }\n\n        /**\n         * Verifies that the list structure hasn't been changed since the iteration started\n         */\n        private void checkForComodification()\n        {\n            if (expectedModCount != modCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n    }\n\n    /**\n     * Returns a {@link NodeIterator} that iterates in reverse order, assuming the cursor of the\n     * specified {@link ListNodeIterator} is behind the tail of the list.\n     */\n    private static <E> NodeIterator<E> reverseIterator(ListNodeIterator<E> listIterator)\n    {\n        return new NodeIterator<E>()\n        {\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public boolean hasNext()\n            {\n                return listIterator.hasPrevious();\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public ListNode<E> nextNode()\n            {\n                return listIterator.previousNode();\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public void remove()\n            {\n                listIterator.remove();\n            }\n        };\n    }\n\n    /**\n     * Container for the elements stored in a {@link DoublyLinkedList}.\n     * <p>\n     * A {@link ListNode} is either contained exactly once in exactly one {@code DoublyLinkedList}\n     * or contained in no {@code DoublyLinkedList}.\n     * </p>\n     * \n     * @param <V> the type of the element stored in this node\n     */\n    public interface ListNode<V>\n    {\n        /**\n         * Returns the immutable value this {@code ListNode} contains.\n         *\n         * @return the value this list node contains\n         */\n        V getValue();\n\n        /**\n         * Returns the next node in the list structure with respect to this node\n         *\n         * @return the next node in the list structure with respect to this node\n         */\n        ListNode<V> getNext();\n\n        /**\n         * Returns the previous node in the list structure with respect to this node\n         *\n         * @return the previous node in the list structure with respect to this node\n         */\n        ListNode<V> getPrev();\n    }\n\n    /**\n     * The default {@link ListNode} implementation that enables checks and enforcement of a single\n     * container list policy.\n     */\n    private static class ListNodeImpl<V>\n        implements\n        ListNode<V>\n    {\n        private final V value;\n        private DoublyLinkedList<V> list = null;\n        private ListNodeImpl<V> next = null;\n        private ListNodeImpl<V> prev = null;\n\n        /**\n         * Creates new list node\n         *\n         * @param value the value this list node stores\n         */\n        ListNodeImpl(V value)\n        {\n            this.value = value;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            if (list == null) {\n                return \" - \" + value + \" - \"; // not in a list\n            } else {\n                return prev.value + \" -> \" + value + \" -> \" + next.value;\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public V getValue()\n        {\n            return value;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public ListNodeImpl<V> getNext()\n        {\n            return next;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public ListNodeImpl<V> getPrev()\n        {\n            return prev;\n        }\n    }\n}\n",
            "file_name": "DoublyLinkedList.java",
            "human_label": "Remove the doubly circular linked list node.If success return true,otherwise return false.",
            "level": "class_runnable",
            "lineno": "240",
            "name": "unlink",
            "oracle_context": "{ \"apis\" : \"[removeListNode, link, ListNodeImpl, size]\", \"classes\" : \"[ListNodeImpl<E>]\", \"vars\" : \"[size, head]\" }",
            "package": "org.jgrapht.util",
            "project": "jgrapht-master"
        },
        {
            "_id": "636766fa1a6d9265ec01779c",
            "all_context": "{ \"class_level\" : \"import net.hasor.web.upload.util.MimeUtility;\\nimport java.io.UnsupportedEncodingException;\\nimport java.util.HashMap;\\nimport java.util.Locale;\\nimport java.util.Map;\\nchar[] chars;\\nint pos;\\nint len;\\nint i1;\\nint i2;\\nboolean lowerCaseNames;\\nParameterParser();\\ngetToken(boolean quoted);\\nisOneOf(char ch,char[] charray);\\nparseToken(char[] terminators);\\nparseQuotedToken(char[] terminators);\\nisLowerCaseNames();\\nsetLowerCaseNames(boolean b);\\nparse(String str,char[] separators);\\nparse(String str,char separator);\\nparse(char[] charArray,char separator);\\nparse(char[] charArray,int offset,int length,char separator);\\nhasChar();\\n\", \"repo_level\" : \"public interface MimeUtility {static String decodeText(String text);\\n }\\n\" }",
            "class_name": "ParameterParser",
            "code": "private String parseToken(final char[] terminators){\n  char ch;\n  i1=pos;\n  i2=pos;\n  while (hasChar()) {\n    ch=chars[pos];\n    if (isOneOf(ch,terminators)) {\n      break;\n    }\n    i2++;\n    pos++;\n  }\n  return getToken(false);\n}\n",
            "docstring": "/** \n * Parses out a token until any of the given terminators is encountered.\n * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n * @return the token\n */\n",
            "end_lineno": "131",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.web.upload;\nimport net.hasor.web.upload.util.MimeUtility;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\n/**\n * A simple parser intended to parse sequences of name/value pairs.\n *\n * Parameter values are expected to be enclosed in quotes if they\n * contain unsafe characters, such as '=' characters or separators.\n * Parameter values are optional and can be omitted.\n *\n * <p>\n *  <code>param1 = value; param2 = \"anything goes; really\"; param3</code>\n * </p>\n *\n * @version $Id: ParameterParser.java 1565253 2014-02-06 13:48:16Z ggregory $\n */\nclass ParameterParser {\n    /** String to be parsed. */\n    private char[]  chars          = null;\n    /** Current position in the string. */\n    private int     pos            = 0;\n    /** Maximum position in the string. */\n    private int     len            = 0;\n    /** Start of a token. */\n    private int     i1             = 0;\n    /** End of a token. */\n    private int     i2             = 0;\n    /** Whether names stored in the map should be converted to lower case. */\n    private boolean lowerCaseNames = false;\n\n    /** Default ParameterParser constructor. */\n    public ParameterParser() {\n        super();\n    }\n\n    /**\n     * Are there any characters left to parse?\n     * @return <tt>true</tt> if there are unparsed characters,\n     *         <tt>false</tt> otherwise.\n     */\n    private boolean hasChar() {\n        return this.pos < this.len;\n    }\n\n    /**\n     * A helper method to process the parsed token. This method removes\n     * leading and trailing blanks as well as enclosing quotation marks,\n     * when necessary.\n     * @param quoted <tt>true</tt> if quotation marks are expected,\n     *               <tt>false</tt> otherwise.\n     * @return the token\n     */\n    private String getToken(boolean quoted) {\n        // Trim leading white spaces\n        while ((i1 < i2) && (Character.isWhitespace(chars[i1]))) {\n            i1++;\n        }\n        // Trim trailing white spaces\n        while ((i2 > i1) && (Character.isWhitespace(chars[i2 - 1]))) {\n            i2--;\n        }\n        // Strip away quotation marks if necessary\n        if (quoted && ((i2 - i1) >= 2) && (chars[i1] == '\"') && (chars[i2 - 1] == '\"')) {\n            i1++;\n            i2--;\n        }\n        String result = null;\n        if (i2 > i1) {\n            result = new String(chars, i1, i2 - i1);\n        }\n        return result;\n    }\n\n    /**\n     * Tests if the given character is present in the array of characters.\n     * @param ch the character to test for presense in the array of characters\n     * @param charray the array of characters to test against\n     * @return <tt>true</tt> if the character is present in the array of\n     *   characters, <tt>false</tt> otherwise.\n     */\n    private boolean isOneOf(char ch, final char[] charray) {\n        boolean result = false;\n        for (char element : charray) {\n            if (ch == element) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Parses out a token until any of the given terminators is encountered.\n     * @param terminators the array of terminating characters. Any of these characters when encountered signify the end of the token\n     * @return the token\n     */\n    private String parseToken(final char[] terminators) {\n        char ch;\n        i1 = pos;\n        i2 = pos;\n        while (hasChar()) {\n            ch = chars[pos];\n            if (isOneOf(ch, terminators)) {\n                break;\n            }\n            i2++;\n            pos++;\n        }\n        return getToken(false);\n    }\n\n    /**\n     * Parses out a token until any of the given terminators is encountered outside the quotation marks.\n     * @param terminators the array of terminating characters. Any of these characters when encountered outside the quotation marks signify the end of the token\n     * @return the token\n     */\n    private String parseQuotedToken(final char[] terminators) {\n        char ch;\n        i1 = pos;\n        i2 = pos;\n        boolean quoted = false;\n        boolean charEscaped = false;\n        while (hasChar()) {\n            ch = chars[pos];\n            if (!quoted && isOneOf(ch, terminators)) {\n                break;\n            }\n            if (!charEscaped && ch == '\"') {\n                quoted = !quoted;\n            }\n            charEscaped = (!charEscaped && ch == '\\\\');\n            i2++;\n            pos++;\n        }\n        return getToken(true);\n    }\n\n    /**\n     * @return <tt>true</tt> if parameter names are to be converted to lower case when name/value pairs are parsed. Otherwise returns <tt>false</tt>\n     */\n    public boolean isLowerCaseNames() {\n        return this.lowerCaseNames;\n    }\n\n    /**\n     * Sets the flag if parameter names are to be converted to lower case when name/value pairs are parsed.\n     * @param b <tt>true</tt> if parameter names are to be converted to lower case when name/value pairs are parsed.\n     * <tt>false</tt> otherwise.\n     */\n    public void setLowerCaseNames(boolean b) {\n        this.lowerCaseNames = b;\n    }\n\n    /**\n     * Extracts a map of name/value pairs from the given string. Names are\n     * expected to be unique. Multiple separators may be specified and\n     * the earliest found in the input string is used.\n     * @param str the string that contains a sequence of name/value pairs\n     * @param separators the name/value pairs separators\n     * @return a map of name/value pairs\n     */\n    public Map<String, String> parse(final String str, char[] separators) {\n        if (separators == null || separators.length == 0) {\n            return new HashMap<>();\n        }\n        char separator = separators[0];\n        if (str != null) {\n            int idx = str.length();\n            for (char separator2 : separators) {\n                int tmp = str.indexOf(separator2);\n                if (tmp != -1 && tmp < idx) {\n                    idx = tmp;\n                    separator = separator2;\n                }\n            }\n        }\n        return parse(str, separator);\n    }\n\n    /**\n     * Extracts a map of name/value pairs from the given string. Names are expected to be unique.\n     * @param str the string that contains a sequence of name/value pairs\n     * @param separator the name/value pairs separator\n     * @return a map of name/value pairs\n     */\n    public Map<String, String> parse(final String str, char separator) {\n        if (str == null) {\n            return new HashMap<>();\n        }\n        return parse(str.toCharArray(), separator);\n    }\n\n    /**\n     * Extracts a map of name/value pairs from the given array of characters. Names are expected to be unique.\n     * @param charArray the array of characters that contains a sequence of name/value pairs\n     * @param separator the name/value pairs separator\n     * @return a map of name/value pairs\n     */\n    public Map<String, String> parse(final char[] charArray, char separator) {\n        if (charArray == null) {\n            return new HashMap<>();\n        }\n        return parse(charArray, 0, charArray.length, separator);\n    }\n\n    /**\n     * Extracts a map of name/value pairs from the given array of characters. Names are expected to be unique.\n     *\n     * @param charArray the array of characters that contains a sequence of\n     * name/value pairs\n     * @param offset - the initial offset.\n     * @param length - the length.\n     * @param separator the name/value pairs separator\n     * @return a map of name/value pairs\n     */\n    public Map<String, String> parse(final char[] charArray, int offset, int length, char separator) {\n        if (charArray == null) {\n            return new HashMap<>();\n        }\n        HashMap<String, String> params = new HashMap<>();\n        this.chars = charArray;\n        this.pos = offset;\n        this.len = length;\n        String paramName = null;\n        String paramValue = null;\n        while (hasChar()) {\n            paramName = parseToken(new char[] { '=', separator });\n            paramValue = null;\n            if (hasChar() && (charArray[pos] == '=')) {\n                pos++; // skip '='\n                paramValue = parseQuotedToken(new char[] { separator });\n                if (paramValue != null) {\n                    try {\n                        paramValue = MimeUtility.decodeText(paramValue);\n                    } catch (UnsupportedEncodingException e) {\n                        // let's keep the original value in this case\n                    }\n                }\n            }\n            if (hasChar() && (charArray[pos] == separator)) {\n                pos++; // skip separator\n            }\n            if ((paramName != null) && (paramName.length() > 0)) {\n                if (this.lowerCaseNames) {\n                    paramName = paramName.toLowerCase(Locale.ENGLISH);\n                }\n                params.put(paramName, paramValue);\n            }\n        }\n        return params;\n    }\n}",
            "file_name": "ParameterParser.java",
            "human_label": "Parses out a token until any of the given terminators is encountered and then return the token.",
            "level": "class_runnable",
            "lineno": "113",
            "name": "parseToken",
            "oracle_context": "{ \"apis\" : \"[hasChar, isOneOf, getToken]\", \"classes\" : \"[]\", \"vars\" : \"[i1, pos, i2, chars]\" }",
            "package": "net.hasor.web.upload",
            "project": "hasor-master"
        },
        {
            "_id": "636767691a6d9265ec0181a7",
            "all_context": "{ \"class_level\" : \"import java.nio.charset.Charset;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nimport java.util.Enumeration;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Locale;\\nimport java.util.Properties;\\nimport java.util.Set;\\nimport java.util.StringTokenizer;\\nimport java.util.TreeSet;\\nString FOLDER_SEPARATOR;\\nString WINDOWS_FOLDER_SEPARATOR;\\nString TOP_PATH;\\nString CURRENT_PATH;\\nchar EXTENSION_SEPARATOR;\\nCharset UTF_8;\\nStrings();\\nhasLength(String str);\\nhasText(CharSequence str);\\nhasText(String str);\\ncontainsWhitespace(CharSequence str);\\ncontainsWhitespace(String str);\\ntrimWhitespace(String str);\\ntrimWhitespace(CharSequence str);\\nclean(String str);\\nclean(CharSequence str);\\ntrimAllWhitespace(String str);\\ntrimLeadingWhitespace(String str);\\ntrimTrailingWhitespace(String str);\\ntrimLeadingCharacter(String str,char leadingCharacter);\\ntrimTrailingCharacter(String str,char trailingCharacter);\\nstartsWithIgnoreCase(String str,String prefix);\\nendsWithIgnoreCase(String str,String suffix);\\nsubstringMatch(CharSequence str,int index,CharSequence substring);\\ncountOccurrencesOf(String str,String sub);\\nreplace(String inString,String oldPattern,String newPattern);\\ndelete(String inString,String pattern);\\ndeleteAny(String inString,String charsToDelete);\\nquote(String str);\\nquoteIfString(Object obj);\\nunqualify(String qualifiedName);\\nunqualify(String qualifiedName,char separator);\\ncapitalize(String str);\\nuncapitalize(String str);\\nchangeFirstCharacterCase(String str,boolean capitalize);\\ngetFilename(String path);\\ngetFilenameExtension(String path);\\nstripFilenameExtension(String path);\\napplyRelativePath(String path,String relativePath);\\ncleanPath(String path);\\npathEquals(String path1,String path2);\\nparseLocaleString(String localeString);\\nvalidateLocalePart(String localePart);\\ntoLanguageTag(Locale locale);\\naddStringToArray(String[] array,String str);\\nconcatenateStringArrays(String[] array1,String[] array2);\\nmergeStringArrays(String[] array1,String[] array2);\\nsortStringArray(String[] array);\\ntoStringArray(Collection collection);\\ntoStringArray(Enumeration enumeration);\\ntrimArrayElements(String[] array);\\nremoveDuplicateStrings(String[] array);\\nsplit(String toSplit,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter,String charsToDelete);\\ntokenizeToStringArray(String str,String delimiters);\\ntokenizeToStringArray(String str,String delimiters,boolean trimTokens,boolean ignoreEmptyTokens);\\ndelimitedListToStringArray(String str,String delimiter);\\ndelimitedListToStringArray(String str,String delimiter,String charsToDelete);\\ncommaDelimitedListToStringArray(String str);\\ncommaDelimitedListToSet(String str);\\ncollectionToDelimitedString(Collection coll,String delim,String prefix,String suffix);\\ncollectionToDelimitedString(Collection coll,String delim);\\ncollectionToCommaDelimitedString(Collection coll);\\narrayToDelimitedString(Object[] arr,String delim);\\narrayToCommaDelimitedString(Object[] arr);\\nhasLength(CharSequence str);\\n\", \"repo_level\" : \"\" }",
            "class_name": "Strings",
            "code": "public static String trimLeadingCharacter(String str,char leadingCharacter){\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb=new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}\n",
            "docstring": "/** \n * Trim all occurrences of the supplied leading character from the given String.\n * @param str the String to check\n * @param leadingCharacter the leading character to be trimmed\n * @return the trimmed String\n */\n",
            "end_lineno": "270",
            "file_content": "/*\n * Copyright (C) 2014 jsonwebtoken.io\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.jsonwebtoken.lang;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic final class Strings {\n\n    private static final String FOLDER_SEPARATOR = \"/\";\n\n    private static final String WINDOWS_FOLDER_SEPARATOR = \"\\\\\";\n\n    private static final String TOP_PATH = \"..\";\n\n    private static final String CURRENT_PATH = \".\";\n\n    private static final char EXTENSION_SEPARATOR = '.';\n\n    public static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    private Strings(){} //prevent instantiation\n\n    //---------------------------------------------------------------------\n    // General convenience methods for working with Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Check that the given CharSequence is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a CharSequence that purely consists of whitespace.\n     * <pre>\n     * Strings.hasLength(null) = false\n     * Strings.hasLength(\"\") = false\n     * Strings.hasLength(\" \") = true\n     * Strings.hasLength(\"Hello\") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(CharSequence str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasLength(CharSequence)\n     */\n    public static boolean hasLength(String str) {\n        return hasLength((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <pre>\n     * Strings.hasText(null) = false\n     * Strings.hasText(\"\") = false\n     * Strings.hasText(\" \") = false\n     * Strings.hasText(\"12345\") = true\n     * Strings.hasText(\" 12345 \") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not <code>null</code>,\n     * its length is greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     * greater than 0, and it does not contain whitespace only\n     * @see #hasText(CharSequence)\n     */\n    public static boolean hasText(String str) {\n        return hasText((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence contains any whitespace characters.\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not empty and\n     * contains at least 1 whitespace character\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean containsWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String contains any whitespace characters.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not empty and\n     * contains at least 1 whitespace character\n     * @see #containsWhitespace(CharSequence)\n     */\n    public static boolean containsWhitespace(String str) {\n        return containsWhitespace((CharSequence) str);\n    }\n\n    /**\n     * Trim leading and trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimWhitespace(String str) {\n        return (String) trimWhitespace((CharSequence)str);\n    }\n    \n    \n    private static CharSequence trimWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        final int length = str.length();\n\n        int start = 0;\n\t\twhile (start < length && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        \n\t\tint end = length;\n        while (start < length && Character.isWhitespace(str.charAt(end - 1))) {\n            end--;\n        }\n        \n        return ((start > 0) || (end < length)) ? str.subSequence(start, end) : str;\n    }\n\n    public static String clean(String str) {\n    \tCharSequence result = clean((CharSequence) str);\n        \n        return result!=null?result.toString():null;\n    }\n    \n    public static CharSequence clean(CharSequence str) {\n        str = trimWhitespace(str);\n        if (!hasLength(str)) {\n            return null;\n        }\n        return str;\n    }\n\n    /**\n     * Trim <i>all</i> whitespace from the given String:\n     * leading, trailing, and intermediate characters.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimAllWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        int index = 0;\n        while (sb.length() > index) {\n            if (Character.isWhitespace(sb.charAt(index))) {\n                sb.deleteCharAt(index);\n            }\n            else {\n                index++;\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim leading whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimLeadingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimTrailingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied leading character from the given String.\n     * @param str the String to check\n     * @param leadingCharacter the leading character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimLeadingCharacter(String str, char leadingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied trailing character from the given String.\n     * @param str the String to check\n     * @param trailingCharacter the trailing character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimTrailingCharacter(String str, char trailingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n\n    /**\n     * Returns {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @param str the String to check\n     * @param prefix the prefix to look for\n     * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @param str the String to check\n     * @param suffix the suffix to look for\n     * @return {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @see java.lang.String#endsWith\n     */\n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        if (str == null || suffix == null) {\n            return false;\n        }\n        if (str.endsWith(suffix)) {\n            return true;\n        }\n        if (str.length() < suffix.length()) {\n            return false;\n        }\n\n        String lcStr = str.substring(str.length() - suffix.length()).toLowerCase();\n        String lcSuffix = suffix.toLowerCase();\n        return lcStr.equals(lcSuffix);\n    }\n\n    /**\n     * Returns {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     * @param str the original string (or StringBuilder)\n     * @param index the index in the original string to start matching against\n     * @param substring the substring to match at the given index\n     * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     */\n    public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n        for (int j = 0; j < substring.length(); j++) {\n            int i = index + j;\n            if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the number of occurrences the substring {@code sub} appears in string {@code str}.\n     * @param str string to search in. Return 0 if this is null.\n     * @param sub string to search for. Return 0 if this is null.\n     * @return the number of occurrences the substring {@code sub} appears in string {@code str}.\n     */\n    public static int countOccurrencesOf(String str, String sub) {\n        if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n            return 0;\n        }\n        int count = 0;\n        int pos = 0;\n        int idx;\n        while ((idx = str.indexOf(sub, pos)) != -1) {\n            ++count;\n            pos = idx + sub.length();\n        }\n        return count;\n    }\n\n    /**\n     * Replace all occurrences of a substring within a string with\n     * another string.\n     * @param inString String to examine\n     * @param oldPattern String to replace\n     * @param newPattern String to insert\n     * @return a String with the replacements\n     */\n    public static String replace(String inString, String oldPattern, String newPattern) {\n        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        int pos = 0; // our position in the old string\n        int index = inString.indexOf(oldPattern);\n        // the index of an occurrence we've found, or -1\n        int patLen = oldPattern.length();\n        while (index >= 0) {\n            sb.append(inString.substring(pos, index));\n            sb.append(newPattern);\n            pos = index + patLen;\n            index = inString.indexOf(oldPattern, pos);\n        }\n        sb.append(inString.substring(pos));\n        // remember to append any characters to the right of a match\n        return sb.toString();\n    }\n\n    /**\n     * Delete all occurrences of the given substring.\n     * @param inString the original String\n     * @param pattern the pattern to delete all occurrences of\n     * @return the resulting String\n     */\n    public static String delete(String inString, String pattern) {\n        return replace(inString, pattern, \"\");\n    }\n\n    /**\n     * Delete any character in a given String.\n     * @param inString the original String\n     * @param charsToDelete a set of characters to delete.\n     * E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n     * @return the resulting String\n     */\n    public static String deleteAny(String inString, String charsToDelete) {\n        if (!hasLength(inString) || !hasLength(charsToDelete)) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < inString.length(); i++) {\n            char c = inString.charAt(i);\n            if (charsToDelete.indexOf(c) == -1) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with formatted Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Quote the given String with single quotes.\n     * @param str the input String (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or <code>null</code> if the input was <code>null</code>\n     */\n    public static String quote(String str) {\n        return (str != null ? \"'\" + str + \"'\" : null);\n    }\n\n    /**\n     * Turn the given Object into a String with single quotes\n     * if it is a String; keeping the Object as-is else.\n     * @param obj the input Object (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or the input object as-is if not a String\n     */\n    public static Object quoteIfString(Object obj) {\n        return (obj instanceof String ? quote((String) obj) : obj);\n    }\n\n    /**\n     * Unqualify a string qualified by a '.' dot character. For example,\n     * \"this.name.is.qualified\", returns \"qualified\".\n     * @param qualifiedName the qualified name\n     * @return an unqualified string by stripping all previous text before (and including) the last period character.\n     */\n    public static String unqualify(String qualifiedName) {\n        return unqualify(qualifiedName, '.');\n    }\n\n    /**\n     * Unqualify a string qualified by a separator character. For example,\n     * \"this:name:is:qualified\" returns \"qualified\" if using a ':' separator.\n     * @param qualifiedName the qualified name\n     * @param separator the separator\n     * @return an unqualified string by stripping all previous text before and including the last {@code separator} character.\n     */\n    public static String unqualify(String qualifiedName, char separator) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);\n    }\n\n    /**\n     * Capitalize a <code>String</code>, changing the first letter to\n     * upper case as per {@link Character#toUpperCase(char)}.\n     * No other letters are changed.\n     * @param str the String to capitalize, may be <code>null</code>\n     * @return the capitalized String, <code>null</code> if null\n     */\n    public static String capitalize(String str) {\n        return changeFirstCharacterCase(str, true);\n    }\n\n    /**\n     * Uncapitalize a <code>String</code>, changing the first letter to\n     * lower case as per {@link Character#toLowerCase(char)}.\n     * No other letters are changed.\n     * @param str the String to uncapitalize, may be <code>null</code>\n     * @return the uncapitalized String, <code>null</code> if null\n     */\n    public static String uncapitalize(String str) {\n        return changeFirstCharacterCase(str, false);\n    }\n\n    private static String changeFirstCharacterCase(String str, boolean capitalize) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str.length());\n        if (capitalize) {\n            sb.append(Character.toUpperCase(str.charAt(0)));\n        }\n        else {\n            sb.append(Character.toLowerCase(str.charAt(0)));\n        }\n        sb.append(str.substring(1));\n        return sb.toString();\n    }\n\n    /**\n     * Extract the filename from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"myfile.txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename, or <code>null</code> if none\n     */\n    public static String getFilename(String path) {\n        if (path == null) {\n            return null;\n        }\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);\n    }\n\n    /**\n     * Extract the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename extension, or <code>null</code> if none\n     */\n    public static String getFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return null;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return null;\n        }\n        return path.substring(extIndex + 1);\n    }\n\n    /**\n     * Strip the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"mypath/myfile\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the path with stripped filename extension,\n     * or <code>null</code> if none\n     */\n    public static String stripFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return path;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return path;\n        }\n        return path.substring(0, extIndex);\n    }\n\n    /**\n     * Apply the given relative path to the given path,\n     * assuming standard Java folder separation (i.e. \"/\" separators).\n     * @param path the path to start from (usually a full file path)\n     * @param relativePath the relative path to apply\n     * (relative to the full file path above)\n     * @return the full file path that results from applying the relative path\n     */\n    public static String applyRelativePath(String path, String relativePath) {\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (separatorIndex != -1) {\n            String newPath = path.substring(0, separatorIndex);\n            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n                newPath += FOLDER_SEPARATOR;\n            }\n            return newPath + relativePath;\n        }\n        else {\n            return relativePath;\n        }\n    }\n\n    /**\n     * Normalize the path by suppressing sequences like \"path/..\" and\n     * inner simple dots.\n     * <p>The result is convenient for path comparison. For other uses,\n     * notice that Windows separators (\"\\\") are replaced by simple slashes.\n     * @param path the original path\n     * @return the normalized path\n     */\n    public static String cleanPath(String path) {\n        if (path == null) {\n            return null;\n        }\n        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);\n\n        // Strip prefix from path to analyze, to not treat it as part of the\n        // first path element. This is necessary to correctly parse paths like\n        // \"file:core/../core/io/Resource.class\", where the \"..\" should just\n        // strip the first \"core\" directory while keeping the \"file:\" prefix.\n        int prefixIndex = pathToUse.indexOf(\":\");\n        String prefix = \"\";\n        if (prefixIndex != -1) {\n            prefix = pathToUse.substring(0, prefixIndex + 1);\n            pathToUse = pathToUse.substring(prefixIndex + 1);\n        }\n        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {\n            prefix = prefix + FOLDER_SEPARATOR;\n            pathToUse = pathToUse.substring(1);\n        }\n\n        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);\n        List<String> pathElements = new LinkedList<String>();\n        int tops = 0;\n\n        for (int i = pathArray.length - 1; i >= 0; i--) {\n            String element = pathArray[i];\n            if (CURRENT_PATH.equals(element)) {\n                // Points to current directory - drop it.\n            }\n            else if (TOP_PATH.equals(element)) {\n                // Registering top path found.\n                tops++;\n            }\n            else {\n                if (tops > 0) {\n                    // Merging path element with element corresponding to top path.\n                    tops--;\n                }\n                else {\n                    // Normal path element found.\n                    pathElements.add(0, element);\n                }\n            }\n        }\n\n        // Remaining top paths need to be retained.\n        for (int i = 0; i < tops; i++) {\n            pathElements.add(0, TOP_PATH);\n        }\n\n        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);\n    }\n\n    /**\n     * Compare two paths after normalization of them.\n     * @param path1 first path for comparison\n     * @param path2 second path for comparison\n     * @return whether the two paths are equivalent after normalization\n     */\n    public static boolean pathEquals(String path1, String path2) {\n        return cleanPath(path1).equals(cleanPath(path2));\n    }\n\n    /**\n     * Parse the given <code>localeString</code> value into a {@link java.util.Locale}.\n     * <p>This is the inverse operation of {@link java.util.Locale#toString Locale's toString}.\n     * @param localeString the locale string, following <code>Locale's</code>\n     * <code>toString()</code> format (\"en\", \"en_UK\", etc);\n     * also accepts spaces as separators, as an alternative to underscores\n     * @return a corresponding <code>Locale</code> instance\n     */\n    public static Locale parseLocaleString(String localeString) {\n        String[] parts = tokenizeToStringArray(localeString, \"_ \", false, false);\n        String language = (parts.length > 0 ? parts[0] : \"\");\n        String country = (parts.length > 1 ? parts[1] : \"\");\n        validateLocalePart(language);\n        validateLocalePart(country);\n        String variant = \"\";\n        if (parts.length >= 2) {\n            // There is definitely a variant, and it is everything after the country\n            // code sans the separator between the country code and the variant.\n            int endIndexOfCountryCode = localeString.indexOf(country) + country.length();\n            // Strip off any leading '_' and whitespace, what's left is the variant.\n            variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));\n            if (variant.startsWith(\"_\")) {\n                variant = trimLeadingCharacter(variant, '_');\n            }\n        }\n        return (language.length() > 0 ? new Locale(language, country, variant) : null);\n    }\n\n    private static void validateLocalePart(String localePart) {\n        for (int i = 0; i < localePart.length(); i++) {\n            char ch = localePart.charAt(i);\n            if (ch != '_' && ch != ' ' && !Character.isLetterOrDigit(ch)) {\n                throw new IllegalArgumentException(\n                    \"Locale part \\\"\" + localePart + \"\\\" contains invalid characters\");\n            }\n        }\n    }\n\n    /**\n     * Determine the RFC 3066 compliant language tag,\n     * as used for the HTTP \"Accept-Language\" header.\n     * @param locale the Locale to transform to a language tag\n     * @return the RFC 3066 compliant language tag as String\n     */\n    public static String toLanguageTag(Locale locale) {\n        return locale.getLanguage() + (hasText(locale.getCountry()) ? \"-\" + locale.getCountry() : \"\");\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with String arrays\n    //---------------------------------------------------------------------\n\n    /**\n     * Append the given String to the given String array, returning a new array\n     * consisting of the input array contents plus the given String.\n     * @param array the array to append to (can be <code>null</code>)\n     * @param str the String to append\n     * @return the new array (never <code>null</code>)\n     */\n    public static String[] addStringToArray(String[] array, String str) {\n        if (Objects.isEmpty(array)) {\n            return new String[] {str};\n        }\n        String[] newArr = new String[array.length + 1];\n        System.arraycopy(array, 0, newArr, 0, array.length);\n        newArr[array.length] = str;\n        return newArr;\n    }\n\n    /**\n     * Concatenate the given String arrays into one,\n     * with overlapping array elements included twice.\n     * <p>The order of elements in the original arrays is preserved.\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        String[] newArr = new String[array1.length + array2.length];\n        System.arraycopy(array1, 0, newArr, 0, array1.length);\n        System.arraycopy(array2, 0, newArr, array1.length, array2.length);\n        return newArr;\n    }\n\n    /**\n     * Merge the given String arrays into one, with overlapping\n     * array elements only included once.\n     * <p>The order of elements in the original arrays is preserved\n     * (with the exception of overlapping elements, which are only\n     * included on their first occurrence).\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] mergeStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        List<String> result = new ArrayList<String>();\n        result.addAll(Arrays.asList(array1));\n        for (String str : array2) {\n            if (!result.contains(str)) {\n                result.add(str);\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Turn given source String array into sorted array.\n     * @param array the source array\n     * @return the sorted array (never <code>null</code>)\n     */\n    public static String[] sortStringArray(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        Arrays.sort(array);\n        return array;\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Collection was <code>null</code>)\n     */\n    public static String[] toStringArray(Collection<String> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new String[collection.size()]);\n    }\n\n    /**\n     * Copy the given Enumeration into a String array.\n     * The Enumeration must contain String elements only.\n     * @param enumeration the Enumeration to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Enumeration was <code>null</code>)\n     */\n    public static String[] toStringArray(Enumeration<String> enumeration) {\n        if (enumeration == null) {\n            return null;\n        }\n        List<String> list = java.util.Collections.list(enumeration);\n        return list.toArray(new String[list.size()]);\n    }\n\n    /**\n     * Trim the elements of the given String array,\n     * calling <code>String.trim()</code> on each of them.\n     * @param array the original String array\n     * @return the resulting array (of the same size) with trimmed elements\n     */\n    public static String[] trimArrayElements(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        String[] result = new String[array.length];\n        for (int i = 0; i < array.length; i++) {\n            String element = array[i];\n            result[i] = (element != null ? element.trim() : null);\n        }\n        return result;\n    }\n\n    /**\n     * Remove duplicate Strings from the given array.\n     * Also sorts the array, as it uses a TreeSet.\n     * @param array the String array\n     * @return an array without duplicates, in natural sort order\n     */\n    public static String[] removeDuplicateStrings(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return array;\n        }\n        Set<String> set = new TreeSet<String>();\n        for (String element : array) {\n            set.add(element);\n        }\n        return toStringArray(set);\n    }\n\n    /**\n     * Split a String at the first occurrence of the delimiter.\n     * Does not include the delimiter in the result.\n     * @param toSplit the string to split\n     * @param delimiter to split the string up with\n     * @return a two element array with index 0 being before the delimiter, and\n     * index 1 being after the delimiter (neither element includes the delimiter);\n     * or <code>null</code> if the delimiter wasn't found in the given input String\n     */\n    public static String[] split(String toSplit, String delimiter) {\n        if (!hasLength(toSplit) || !hasLength(delimiter)) {\n            return null;\n        }\n        int offset = toSplit.indexOf(delimiter);\n        if (offset < 0) {\n            return null;\n        }\n        String beforeDelimiter = toSplit.substring(0, offset);\n        String afterDelimiter = toSplit.substring(offset + delimiter.length());\n        return new String[] {beforeDelimiter, afterDelimiter};\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was null or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {\n        return splitArrayElementsIntoProperties(array, delimiter, null);\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @param charsToDelete one or more characters to remove from each element\n     * prior to attempting the split operation (typically the quotation mark\n     * symbol), or <code>null</code> if no removal should occur\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was <code>null</code> or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(\n        String[] array, String delimiter, String charsToDelete) {\n\n        if (Objects.isEmpty(array)) {\n            return null;\n        }\n        Properties result = new Properties();\n        for (String element : array) {\n            if (charsToDelete != null) {\n                element = deleteAny(element, charsToDelete);\n            }\n            String[] splittedElement = split(element, delimiter);\n            if (splittedElement == null) {\n                continue;\n            }\n            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n        }\n        return result;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter)\n     * @param trimTokens trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     * (only applies to tokens that are empty after trimming; StringTokenizer\n     * will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     * was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(\n        String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List<String> tokens = new ArrayList<String>();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter) {\n        return delimitedListToStringArray(str, delimiter, null);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @param charsToDelete a set of characters to delete. Useful for deleting unwanted\n     * line breaks: e.g. \"\\r\\n\\f\" will delete all new lines and line feeds in a String.\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {\n        if (str == null) {\n            return new String[0];\n        }\n        if (delimiter == null) {\n            return new String[] {str};\n        }\n        List<String> result = new ArrayList<String>();\n        if (\"\".equals(delimiter)) {\n            for (int i = 0; i < str.length(); i++) {\n                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));\n            }\n        }\n        else {\n            int pos = 0;\n            int delPos;\n            while ((delPos = str.indexOf(delimiter, pos)) != -1) {\n                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));\n                pos = delPos + delimiter.length();\n            }\n            if (str.length() > 0 && pos <= str.length()) {\n                // Add rest of String, but not in case of empty input.\n                result.add(deleteAny(str.substring(pos), charsToDelete));\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Convert a CSV list into an array of Strings.\n     * @param str the input String\n     * @return an array of Strings, or the empty array in case of empty input\n     */\n    public static String[] commaDelimitedListToStringArray(String str) {\n        return delimitedListToStringArray(str, \",\");\n    }\n\n    /**\n     * Convenience method to convert a CSV string list to a set.\n     * Note that this will suppress duplicates.\n     * @param str the input String\n     * @return a Set of String entries in the list\n     */\n    public static Set<String> commaDelimitedListToSet(String str) {\n        Set<String> set = new TreeSet<String>();\n        String[] tokens = commaDelimitedListToStringArray(str);\n        for (String token : tokens) {\n            set.add(token);\n        }\n        return set;\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @param prefix the String to start each element with\n     * @param suffix the String to end each element with\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {\n        if (Collections.isEmpty(coll)) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        Iterator<?> it = coll.iterator();\n        while (it.hasNext()) {\n            sb.append(prefix).append(it.next()).append(suffix);\n            if (it.hasNext()) {\n                sb.append(delim);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim) {\n        return collectionToDelimitedString(coll, delim, \"\", \"\");\n    }\n\n    /**\n     * Convenience method to return a Collection as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @return the delimited String\n     */\n    public static String collectionToCommaDelimitedString(Collection<?> coll) {\n        return collectionToDelimitedString(coll, \",\");\n    }\n\n    /**\n     * Convenience method to return a String array as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String arrayToDelimitedString(Object[] arr, String delim) {\n        if (Objects.isEmpty(arr)) {\n            return \"\";\n        }\n        if (arr.length == 1) {\n            return Objects.nullSafeToString(arr[0]);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < arr.length; i++) {\n            if (i > 0) {\n                sb.append(delim);\n            }\n            sb.append(arr[i]);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a String array as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @return the delimited String\n     */\n    public static String arrayToCommaDelimitedString(Object[] arr) {\n        return arrayToDelimitedString(arr, \",\");\n    }\n\n}\n\n",
            "file_name": "Strings.java",
            "human_label": "Trim all the characters which are equal to the given character and appear at the beginning of the given string,and return the trimmed string.",
            "level": "class_runnable",
            "lineno": "255",
            "name": "trimLeadingCharacter",
            "oracle_context": "{ \"apis\" : \"[hasLength, length, charAt, deleteCharAt, toString]\", \"classes\" : \"[StringBuilder]\", \"vars\" : \"[]\" }",
            "package": "io.jsonwebtoken.lang",
            "project": "jjwt-master"
        },
        {
            "_id": "636767461a6d9265ec017d0e",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.alg.util.Pair;\\nimport java.util.*;\\nimport java.util.function.Function;\\nRandom rng;\\nList<Function<K,Integer>> lowerBounds;\\nList<Function<K,Integer>> upperBounds;\\nDistributor();\\nDistributor(long seed);\\nDistributor(Random rng);\\naddLowerBound(Function lowerBound);\\ncomputeLowerBounds(List keys);\\ncomputeUpperBounds(List keys);\\ncomputeSuffixSum(List bounds);\\ngetDistribution(List keys,int valueNum);\\naddUpperBound(Function upperBound);\\n\", \"repo_level\" : \"public interface Pair {public A getFirst();\\npublic B getSecond();\\npublic void setFirst(A f);\\npublic void setSecond(B s);\\npublic boolean hasElement(E e);\\npublic String toString();\\npublic boolean equals(Object o);\\npublic int hashCode();\\nstatic Pair<A,B> of(A a,B b);\\n }\\n\" }",
            "class_name": "Distributor",
            "code": "private Pair<List<Integer>,Long> computeSuffixSum(List<Integer> bounds){\n  List<Integer> suffixSum=new ArrayList<>(Collections.nCopies(bounds.size(),0));\n  long sum=0;\n  for (int i=bounds.size() - 1; i >= 0; i--) {\n    suffixSum.set(i,(int)Math.min(Integer.MAX_VALUE,sum));\n    sum+=bounds.get(i);\n  }\n  return Pair.of(suffixSum,sum);\n}\n",
            "docstring": "/** \n * Computes a suffix sum of the  {@code bounds}. Returns computed suffix sum and the sum of all elements in the  {@code bounds list}.\n * @param bounds list of integers.\n * @return computed pair of suffix sum list and a sum of all elements.\n */\n",
            "end_lineno": "159",
            "file_content": "/*\n * (C) Copyright 2020-2021, by Timofey Chudakov and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.generate.netgen;\n\nimport org.jgrapht.alg.util.Pair;\n\nimport java.util.*;\nimport java.util.function.Function;\n\n/**\n * Distributes value units among keys given lower and upper bound constraints.\n * <p>\n * Let's define a set of elements $\\{k_1, k_2, \\dots, k_n\\}$. For every element a set of lower\n * bounds $\\{l_1, l_2, \\dots, l_t\\}$ and upper bounds $\\{u_1, u_2, \\dots, u_p\\}$ is specified. The\n * problem is to randomly distribute a number of abstract value units $V$ among keys such that the\n * lower bound and upper bound constraints are satisfied. This class solves this problem.\n *\n * @param <K> the element type.\n * @author Timofey Chudakov\n * @see NetworkGenerator\n */\npublic class Distributor<K>\n{\n    /**\n     * Random number generator used by this distributor.\n     */\n    private final Random rng;\n    /**\n     * Lower bounds.\n     */\n    private final List<Function<K, Integer>> lowerBounds;\n    /**\n     * Upper bounds.\n     */\n    private final List<Function<K, Integer>> upperBounds;\n\n    /**\n     * Creates a Distributor using random seed.\n     */\n    public Distributor()\n    {\n        this(System.nanoTime());\n    }\n\n    /**\n     * Creates a distributor using the specified {@code seed}.\n     *\n     * @param seed the seed for the random number generator.\n     */\n    public Distributor(long seed)\n    {\n        this(new Random(seed));\n    }\n\n    /**\n     * Creates a distributor which uses the random number generatow {@code rng}.\n     *\n     * @param rng a random number generator to use.\n     */\n    public Distributor(Random rng)\n    {\n        this.rng = rng;\n        this.lowerBounds = new ArrayList<>();\n        this.upperBounds = new ArrayList<>();\n    }\n\n    /**\n     * Adds an upper bounding function. This function must be defined for all keys.\n     *\n     * @param upperBound an upper bound function.\n     */\n    public void addUpperBound(Function<K, Integer> upperBound)\n    {\n        this.upperBounds.add(upperBound);\n    }\n\n    /**\n     * Adds a lower bound function. This function must be defined for all keys.\n     *\n     * @param lowerBound a lower bound function.\n     */\n    public void addLowerBound(Function<K, Integer> lowerBound)\n    {\n        this.lowerBounds.add(lowerBound);\n    }\n\n    /**\n     * Finds a maximum lower bound for every key.\n     *\n     * @param keys list of keys.\n     * @return the computed key lower bounds.\n     */\n    private List<Integer> computeLowerBounds(List<K> keys)\n    {\n        List<Integer> keyLowerBounds = new ArrayList<>(keys.size());\n        for (K key : keys) {\n            int lowerBound = 0;\n            for (Function<K, Integer> lowerBoundFunction : lowerBounds) {\n                lowerBound = Math.max(lowerBound, lowerBoundFunction.apply(key));\n            }\n            keyLowerBounds.add(lowerBound);\n        }\n\n        return keyLowerBounds;\n    }\n\n    /**\n     * Finds a minimum lower bound for every key.\n     *\n     * @param keys a list of keys.\n     * @return the computed key upper bound.\n     */\n    private List<Integer> computeUpperBounds(List<K> keys)\n    {\n        List<Integer> keyUpperBounds = new ArrayList<>(keys.size());\n        for (K key : keys) {\n            int upperBound = Integer.MAX_VALUE;\n            for (Function<K, Integer> upperBoundFunction : upperBounds) {\n                upperBound = Math.min(upperBound, upperBoundFunction.apply(key));\n            }\n            keyUpperBounds.add(upperBound);\n        }\n\n        return keyUpperBounds;\n    }\n\n    /**\n     * Computes a suffix sum of the {@code bounds}. Returns computed suffix sum and the sum of all\n     * elements in the {@code bounds list}.\n     *\n     * @param bounds list of integers.\n     * @return computed pair of suffix sum list and a sum of all elements.\n     */\n    private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds)\n    {\n        List<Integer> suffixSum = new ArrayList<>(Collections.nCopies(bounds.size(), 0));\n        long sum = 0;\n        for (int i = bounds.size() - 1; i >= 0; i--) {\n            suffixSum.set(i, (int) Math.min(Integer.MAX_VALUE, sum));\n            sum += bounds.get(i);\n        }\n\n        return Pair.of(suffixSum, sum);\n    }\n\n    /**\n     * Computes and returns a value distribution for the list of keys. The resulting distribution\n     * will satisfy the (possibly empty) sets of lower and upper bound constraints. Distributed\n     * values will be in the same order as the keys in the key list.\n     *\n     * @param keys the list of keys.\n     * @param valueNum the number of abstract value units to distribute.\n     * @return the computed value distribution.\n     */\n    public List<Integer> getDistribution(List<K> keys, final int valueNum)\n    {\n        List<Integer> keyLowerBounds = computeLowerBounds(keys);\n        List<Integer> keyUpperBounds = computeUpperBounds(keys);\n\n        Pair<List<Integer>, Long> lbSufSumP = computeSuffixSum(keyLowerBounds);\n        Pair<List<Integer>, Long> ubSufSumP = computeSuffixSum(keyUpperBounds);\n\n        List<Integer> lbSufSum = lbSufSumP.getFirst();\n        List<Integer> ubSufSum = ubSufSumP.getFirst();\n\n        long lbSum = lbSufSumP.getSecond();\n        long ubSum = ubSufSumP.getSecond();\n\n        if (lbSum > valueNum) {\n            throw new IllegalArgumentException(\n                \"Can't distribute values among keys: the sum of lower bounds is greater than the number of values\");\n        } else if (ubSum < valueNum) {\n            throw new IllegalArgumentException(\n                \"Can't distribute values among keys: the sum of upper bounds is smaller than the number of values\");\n        }\n\n        int remainingValues = valueNum;\n        List<Integer> resultingDistribution = new ArrayList<>();\n        for (int i = 0; i < keyLowerBounds.size(); i++) {\n            int lowerBound = keyLowerBounds.get(i);\n            int upperBound = keyUpperBounds.get(i);\n\n            int valueNumUpperBound = remainingValues - lbSufSum.get(i);\n            int valueNumLowerBound = remainingValues - ubSufSum.get(i);\n\n            lowerBound = Math.max(lowerBound, valueNumLowerBound);\n            upperBound = Math.min(upperBound, valueNumUpperBound);\n\n            if (lowerBound > upperBound) {\n                throw new IllegalArgumentException(\n                    \"Infeasible bound specified for the key: \" + keys.get(i));\n            }\n\n            int allocatedValues = rng.nextInt(upperBound - lowerBound + 1) + lowerBound;\n            resultingDistribution.add(allocatedValues);\n            remainingValues -= allocatedValues;\n        }\n\n        return resultingDistribution;\n    }\n\n}\n",
            "file_name": "Distributor.java",
            "human_label": "Return a pair of the list of suffix sum and the sum of all elements of bounds.",
            "level": "project_runnable",
            "lineno": "142",
            "name": "computeSuffixSum",
            "oracle_context": "{ \"apis\" : \"[nCopies, size, set, min, get, of]\", \"classes\" : \"[List<Integer>, Integer]\", \"vars\" : \"[MAX_VALUE]\" }",
            "package": "org.jgrapht.generate.netgen",
            "project": "jgrapht-master"
        },
        {
            "_id": "636767491a6d9265ec017d90",
            "all_context": "{ \"class_level\" : \"ArrayUtil();\\nreverse(int[] arr,int from,int to);\\nswap(V[] arr,int i,int j);\\n\", \"repo_level\" : \"\" }",
            "class_name": "ArrayUtil",
            "code": "public static final <V>void reverse(V[] arr,int from,int to){\n  for (int i=from, j=to; i < j; ++i, --j) {\n    swap(arr,i,j);\n  }\n}\n",
            "docstring": "/** \n * Reverses the order of the elements in the specified range within the given array.\n * @param < V > the type of elements in the array\n * @param arr the array\n * @param from the index of the first element (inclusive) inside the range to reverse\n * @param to the index of the last element (inclusive) inside the range to reverse\n */\n",
            "end_lineno": "45",
            "file_content": "/*\n * (C) Copyright 2021-2021, by Hannes Wellmann and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.util;\n\n/**\n * Utility class to simplify handling of arrays.\n *\n * @author Hannes Wellmann\n *\n */\npublic class ArrayUtil\n{\n    private ArrayUtil()\n    { // static use only\n    }\n\n    /**\n     * Reverses the order of the elements in the specified range within the given array.\n     *\n     * @param <V> the type of elements in the array\n     * @param arr the array\n     * @param from the index of the first element (inclusive) inside the range to reverse\n     * @param to the index of the last element (inclusive) inside the range to reverse\n     */\n    public static final <V> void reverse(V[] arr, int from, int to)\n    {\n        for (int i = from, j = to; i < j; ++i, --j) {\n            swap(arr, i, j);\n        }\n    }\n\n    /**\n     * Reverses the order of the elements in the specified range within the given array.\n     *\n     * @param arr the array\n     * @param from the index of the first element (inclusive) inside the range to reverse\n     * @param to the index of the last element (inclusive) inside the range to reverse\n     */\n    public static final void reverse(int[] arr, int from, int to)\n    {\n        for (int i = from, j = to; i < j; ++i, --j) {\n            int tmp = arr[j];\n            arr[j] = arr[i];\n            arr[i] = tmp;\n        }\n    }\n\n    /**\n     * Swaps the two elements at the specified indices in the given array.\n     *\n     * @param <V> the type of elements in the array\n     * @param arr the array\n     * @param i the index of the first element\n     * @param j the index of the second element\n     */\n    public static final <V> void swap(V[] arr, int i, int j)\n    {\n        V tmp = arr[j];\n        arr[j] = arr[i];\n        arr[i] = tmp;\n    }\n}\n",
            "file_name": "ArrayUtil.java",
            "human_label": "Reverse the order of the given elements in the specified range.",
            "level": "class_runnable",
            "lineno": "32",
            "name": "reverse",
            "oracle_context": "{ \"apis\" : \"[swap]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
            "package": "org.jgrapht.util",
            "project": "jgrapht-master"
        },
        {
            "_id": "6367674a1a6d9265ec017da9",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.alg.util.*;\\nimport java.util.*;\\nimport java.util.function.*;\\nListNodeImpl<E> head;\\nint size;\\nint nextIndex;\\nListNodeImpl<E> next;\\nListNodeImpl<E> last;\\nint expectedModCount;\\nV value;\\nDoublyLinkedList<V> list;\\nListNodeImpl<V> next;\\nListNodeImpl<V> prev;\\ntail();\\nsize();\\nclear();\\naddListNode(ListNodeImpl node);\\nmoveAllListNodes(DoublyLinkedList list);\\nremoveListNode(ListNodeImpl node);\\nlink(ListNodeImpl predecessor,ListNodeImpl successor);\\nlinkBefore(ListNodeImpl node,ListNodeImpl successor);\\nlinkLast(ListNodeImpl node);\\nlinkListIntoThisBefore(int index,DoublyLinkedList list);\\nunlink(ListNodeImpl node);\\naddNode(int index,ListNode node);\\naddNodeFirst(ListNode node);\\naddNodeLast(ListNode node);\\naddNodeBefore(ListNode node,ListNode successor);\\ngetFirstNode();\\ngetLastNode();\\ngetNode(int index);\\ngetNodeAt(int index);\\nindexOfNode(ListNode node);\\ncontainsNode(ListNode node);\\nremoveNode(ListNode node);\\nnodeOf(Object element);\\nlastNodeOf(Object element);\\nsearchNode(Supplier first,UnaryOperator next,Object element);\\naddElementFirst(E element);\\naddElementLast(E element);\\naddElementBeforeNode(ListNode successor,E element);\\nadd(int index,E element);\\nget(int index);\\nremove(int index);\\naddFirst(E e);\\naddLast(E e);\\nofferFirst(E e);\\nofferLast(E e);\\nremoveFirst();\\nremoveLast();\\npollFirst();\\npollLast();\\ngetFirst();\\ngetLast();\\npeekFirst();\\npeekLast();\\nremoveFirstOccurrence(Object o);\\nremoveLastOccurrence(Object o);\\noffer(E e);\\nremove();\\npoll();\\nelement();\\npeek();\\npush(E e);\\npop();\\ninvert();\\nmoveFrom(int index,DoublyLinkedList movedList);\\nappend(DoublyLinkedList movedList);\\nprepend(DoublyLinkedList movedList);\\ncircularIterator(E firstElement);\\nreverseCircularIterator(E firstElement);\\ndescendingIterator();\\niterator();\\nlistIterator();\\nlistIterator(int index);\\nlistIterator(E element);\\nnext();\\nnextNode();\\nprevious();\\npreviousNode();\\nListNodeIteratorImpl(int startIndex);\\nListNodeIteratorImpl(int startIndex,ListNodeImpl startNode);\\nhasNext();\\nhasPrevious();\\nnextIndex();\\npreviousIndex();\\nadd(E e);\\nset(E e);\\ncheckForComodification();\\nreverseIterator(ListNodeIterator listIterator);\\ngetValue();\\ngetNext();\\ngetPrev();\\nListNodeImpl(V value);\\ntoString();\\nisEmpty();\\n\", \"repo_level\" : \"\" }",
            "class_name": "DoublyLinkedList",
            "code": "private void moveAllListNodes(DoublyLinkedList<E> list){\n  for (ListNodeIteratorImpl it=list.new ListNodeIteratorImpl(0); it.hasNext(); ) {\n    ListNodeImpl<E> node=it.nextNode();\n    assert node.list == list;\n    node.list=this;\n  }\n  size+=list.size;\n  list.size=0;\n  modCount++;\n  list.modCount++;\n}\n",
            "docstring": "/** \n * Atomically moves all  {@link ListNode ListNodes} from {@code list} to this list as if eachnode was removed with  {@link #removeListNode(ListNodeImpl)} from {@code list} andsubsequently added to this list by  {@link #addListNode(ListNodeImpl)}.\n */\n",
            "end_lineno": "154",
            "file_content": "/*\n * (C) Copyright 2018-2021, by Timofey Chudakov and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.util;\n\nimport org.jgrapht.alg.util.*;\n\nimport java.util.*;\nimport java.util.function.*;\n\n/**\n * {@code DoublyLinkedList} implements a doubly linked {@link List} data structure, that exposes its\n * {@link ListNode ListNodes} where the data is stored in.\n * <p>\n * An element holding {@code ListNode} can be removed or added to a {@code DoublyLinkedList} in\n * constant time O(1). Other methods that operate on {@code ListNodes} directly also have constant\n * runtime. This is also the case for methods that operate on the first(head) and last(tail) node or\n * element. Random access methods have a runtime O(n) that is linearly dependent on the size of the\n * {@code DoublyLinkedList}.\n * </p>\n * <p>\n * A {@code DoublyLinkedList} supports {@code null} elements but does not support\n * {@code null ListNodes}. This class is not thread safe and needs to be synchronized externally if\n * modified by concurrent threads.\n * </p>\n * <p>\n * The iterators over this list have a <i>fail-fast</i> behavior meaning that they throw a\n * {@link ConcurrentModificationException} after they detect a structural modification of the list,\n * that they're not responsible for.\n * </p>\n * <p>\n * This class is similar to {@link LinkedList}. The general difference is that the {@code ListNodes}\n * of this {@code List} are accessible and can be removed or added directly. To ensure the integrity\n * of the {@code List} nodes of this List have a reference to the List they belong to. This\n * increases the memory occupied by this list implementation compared to {@code LinkedList} for the\n * same elements. Instances of {@code LinkedList.Node} have three references each (the element, next\n * and previous), instances of {@code DoublyLinkedList.ListNode} have four (the element, next,\n * previous and the list).\n * </p>\n *\n * @param <E> the list element type\n * @author Timofey Chudakov\n * @author Hannes Wellmann\n */\npublic class DoublyLinkedList<E>\n    extends\n    AbstractSequentialList<E>\n    implements\n    Deque<E>\n{\n    /** The first element of the list, {@code null} if this list is empty. */\n    private ListNodeImpl<E> head = null;\n    private int size;\n\n    private ListNodeImpl<E> tail()\n    {\n        return head.prev;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isEmpty()\n    {\n        return head == null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int size()\n    {\n        return size;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void clear()\n    {\n        if (!isEmpty()) {\n            ListNodeImpl<E> node = head;\n            do {\n                ListNodeImpl<E> next = node.next;\n                boolean removed = removeListNode(node); // clears all links of removed node\n                assert removed;\n                node = next;\n            } while (node != head);\n\n            head = null;\n            assert size == 0;\n        }\n    }\n\n    // internal modification methods\n\n    /**\n     * Adds the given {@link ListNode} to this {@code List}.\n     * <p>\n     * Sets the {@code list} reference of {@code node} to this list, increases this lists\n     * {@code size} and {@code modcount} by one.\n     * </p>\n     * \n     * @param node the node to add to this list\n     * @throws IllegalArgumentException if {@code node} is already contained in this or another\n     *         {@code DoublyLinkedList}\n     */\n    private void addListNode(ListNodeImpl<E> node)\n    { // call this before any modification of this list is done\n        if (node.list != null) {\n            String list = (node.list == this) ? \"this\" : \"other\";\n            throw new IllegalArgumentException(\n                \"Node <\" + node + \"> already contained in \" + list + \" list\");\n        }\n        node.list = this;\n        size++;\n        modCount++;\n    }\n\n    /**\n     * Atomically moves all {@link ListNode ListNodes} from {@code list} to this list as if each\n     * node was removed with {@link #removeListNode(ListNodeImpl)} from {@code list} and\n     * subsequently added to this list by {@link #addListNode(ListNodeImpl)}.\n     */\n    private void moveAllListNodes(DoublyLinkedList<E> list)\n    { // call this before any modification of this list is done\n\n        for (ListNodeIteratorImpl it = list.new ListNodeIteratorImpl(0); it.hasNext();) {\n            ListNodeImpl<E> node = it.nextNode();\n            assert node.list == list;\n            node.list = this;\n        }\n        size += list.size;\n        list.size = 0;\n        modCount++;\n        list.modCount++;\n    }\n\n    /**\n     * Removes the given {@link ListNode} from this {@code List}, if it is contained in this\n     * {@code List}.\n     * <p>\n     * If {@code node} is contained in this list, sets the {@code list}, {@code next} and\n     * {@code prev} reference of {@code node} to {@code null} decreases this list's {@code size} and\n     * increases the {@code modcount} by one.\n     * </p>\n     * \n     * @param node the node to remove from this list\n     * @return true if {@code node} was removed from this list, else false\n     */\n    private boolean removeListNode(ListNodeImpl<E> node)\n    { // call this before any modification of this list is done\n        if (node.list == this) {\n\n            node.list = null;\n            node.next = null;\n            node.prev = null;\n\n            size--;\n            modCount++;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Establishes the links between the given {@link ListNodeImpl nodes} in such a way that the\n     * {@code predecessor} is linked before the {@code successor}.\n     * \n     * @param predecessor the first node linked before the other\n     * @param successor the second node linked after the other\n     */\n    private void link(ListNodeImpl<E> predecessor, ListNodeImpl<E> successor)\n    {\n        predecessor.next = successor;\n        successor.prev = predecessor;\n    }\n\n    /** Insert non null {@code node} before non null {@code successor} into the list. */\n    private void linkBefore(ListNodeImpl<E> node, ListNodeImpl<E> successor)\n    {\n        addListNode(node);\n        link(successor.prev, node);\n        link(node, successor);\n    }\n\n    /** Insert non null {@code node} as last node into the list. */\n    private void linkLast(ListNodeImpl<E> node)\n    {\n        if (isEmpty()) { // node will be the first and only one\n            addListNode(node);\n            link(node, node); // self link\n            head = node;\n        } else {\n            linkBefore(node, head);\n        }\n    }\n\n    /** Insert non null {@code list} before node at {@code index} into the list. */\n    private void linkListIntoThisBefore(int index, DoublyLinkedList<E> list)\n    {\n        int previousSize = size;\n        moveAllListNodes(list);\n\n        // link list's node into this list\n        if (previousSize == 0) {\n            head = list.head; // head and tail already linked together\n        } else {\n            ListNodeImpl<E> refNode = (index == previousSize) ? head : getNodeAt(index);\n\n            ListNodeImpl<E> listTail = list.tail();\n            link(refNode.prev, list.head); // changes list.tail()\n            link(listTail, refNode);\n\n            if (index == 0) {\n                head = list.head;\n            }\n        }\n        // clear list but do not call list.clear(), since their nodes are still used\n        list.head = null;\n    }\n\n    /** Remove the non null {@code node} from the list. */\n    private boolean unlink(ListNodeImpl<E> node)\n    {\n        ListNodeImpl<E> prev = node.prev;\n        ListNodeImpl<E> next = node.next;\n        if (removeListNode(node)) { // clears prev and next of node\n            if (size == 0) {\n                head = null;\n            } else {\n                // list is circular, don't have to worry about null values\n                link(prev, next);\n\n                if (head == node) {\n                    head = next;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // ----------------------------------------------------------------------------\n    // public modification and access methods\n\n    // ListNode methods:\n    // Base methods to access, add and remove nodes to/from this list.\n    // Used by all public methods if possible\n\n    /**\n     * Inserts the specified {@link ListNode node} at the specified position in this list.\n     * <p>\n     * This method has a linear runtime complexity O(n) that depends linearly on the distance of the\n     * index to the nearest end. Adding {@code node} as first or last takes only constant time O(1).\n     * </p>\n     * \n     * @param index index at which the specified {@code node} is to be inserted\n     * @param node the node to add\n     * @throws IndexOutOfBoundsException if the index is out of range\n     *         ({@code index < 0 || index > size()})\n     * @throws IllegalArgumentException if {@code node} is already part of this or another\n     *         {@code DoublyLinkedList}\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public void addNode(int index, ListNode<E> node)\n    {\n        ListNodeImpl<E> nodeImpl = (ListNodeImpl<E>) node;\n        if (index == size) { // also true if this is empty\n            linkLast(nodeImpl);\n        } else {\n            ListNodeImpl<E> successor = index == 0 ? head : getNodeAt(index);\n            linkBefore(nodeImpl, successor);\n            if (head == successor) {\n                head = nodeImpl;\n            }\n        }\n    }\n\n    /**\n     * Inserts the specified {@link ListNode node} at the front of this list.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @param node the node to add\n     * @throws IllegalArgumentException if {@code node} is already part of this or another\n     *         {@code DoublyLinkedList}\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public void addNodeFirst(ListNode<E> node)\n    {\n        addNode(0, node);\n    }\n\n    /**\n     * Inserts the specified {@link ListNode node} at the end of this list.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @param node the node to add\n     * @throws IllegalArgumentException if {@code node} is already part of this or another\n     *         {@code DoublyLinkedList}\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public void addNodeLast(ListNode<E> node)\n    {\n        addNode(size, node);\n    }\n\n    /**\n     * Inserts the specified {@link ListNode node} before the specified {@code successor} in this\n     * list.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @param node the node to add\n     * @param successor {@code ListNode} before which the {@code node} is inserted\n     * @throws IllegalArgumentException if {@code node} is already contained in this or another\n     *         {@code DoublyLinkedList} or {@code successor} is not contained in this list\n     * @throws NullPointerException if {@code successor} or {@code node} is {@code null}\n     */\n    public void addNodeBefore(ListNode<E> node, ListNode<E> successor)\n    {\n        ListNodeImpl<E> successorImpl = (ListNodeImpl<E>) successor;\n        ListNodeImpl<E> nodeImpl = (ListNodeImpl<E>) node;\n\n        if (successorImpl.list != this) {\n            throw new IllegalArgumentException(\"Node <\" + successorImpl + \"> not in this list\");\n        }\n        linkBefore(nodeImpl, successorImpl);\n        if (head == successorImpl) {\n            head = nodeImpl;\n        }\n    }\n\n    /**\n     * Returns the first {@link ListNode node} of this list.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @return the first {@code ListNode} of this list\n     * @throws NoSuchElementException if this list is empty\n     */\n    public ListNode<E> getFirstNode()\n    {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        return head;\n    }\n\n    /**\n     * Returns the last {@link ListNode node} of this list.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @return the last {@code ListNode} of this list\n     * @throws NoSuchElementException if this list is empty\n     */\n    public ListNode<E> getLastNode()\n    {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        return tail();\n    }\n\n    /**\n     * Returns the {@link ListNode node} at the specified position in this list.\n     * <p>\n     * This method has linear runtime complexity O(n).\n     * </p>\n     * \n     * @param index index of the {@code ListNode} to return\n     * @return the {@code ListNode} at the specified position in this list\n     * @throws IndexOutOfBoundsException if the index is out of range\n     *         ({@code index < 0 || index >= size()})\n     */\n    public ListNode<E> getNode(int index)\n    {\n        return getNodeAt(index);\n    }\n\n    /**\n     * Returns the {@link ListNodeImpl node} at the specified position in this list.\n     * \n     * @param index index of the {@code ListNodeImpl} to return\n     * @return the {@code ListNode} at the specified position in this list\n     * @throws IndexOutOfBoundsException if the index is out of range\n     *         ({@code index < 0 || index >= size()})\n     */\n    private ListNodeImpl<E> getNodeAt(int index)\n    {\n        if (index < 0 || size <= index) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index);\n        }\n        ListNodeImpl<E> node;\n        if (index < size / 2) {\n            node = head;\n            for (int i = 0; i < index; i++) {\n                node = node.next;\n            }\n        } else {\n            node = tail();\n            for (int i = size - 1; index < i; i--) {\n                node = node.prev;\n            }\n        }\n        return node;\n    }\n\n    /**\n     * Returns the index of the specified {@link ListNode node} in this list, or -1 if this list\n     * does not contain the {@code node}.\n     * <p>\n     * More formally, returns the index {@code i} such that {@code node == getNode(i)}, or -1 if\n     * there is no such index. Because a {@code ListNode} is contained in at most one list exactly\n     * once, the returned index (if not -1) is the only occurrence of that {@code node}.\n     * </p>\n     * <p>\n     * This method has linear runtime complexity O(n) to find {@code node} but returns in constant\n     * time O(1) if {@code node} is not {@link #containsNode(ListNode) contained} in this list.\n     * </p>\n     * \n     * @param node the node to search for\n     * @return the index of the specified {@code node} in this list, or -1 if this list does not\n     *         contain {@code node}\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public int indexOfNode(ListNode<E> node)\n    {\n        if (!containsNode(node)) {\n            return -1;\n        }\n        ListNodeImpl<E> current = head;\n        for (int i = 0; i < size; i++) {\n            if (current == node) {\n                return i;\n            }\n            current = current.next;\n        }\n        // should never happen:\n        throw new IllegalStateException(\"Node contained in list not found: \" + node);\n    }\n\n    /**\n     * Returns true if this {@code DoublyLinkedList} contains the specified {@link ListNode}.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     * \n     * @param node the node whose presence in this {@code DoublyLinkedList} is to be tested\n     * @return true if this {@code DoublyLinkedList} contains the {@link ListNode}\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public boolean containsNode(ListNode<E> node)\n    {\n        return ((ListNodeImpl<E>) node).list == this;\n    }\n\n    /**\n     * Removes the {@link ListNode node} from this list. Returns true if {@code node} was in this\n     * list and is now removed. If {@code node} is not contained in this list, the list is left\n     * unchanged.\n     * <p>\n     * This method has constant runtime complexity O(1).\n     * </p>\n     *\n     * @param node the node to remove from this list\n     * @return true if node was removed from this list\n     * @throws NullPointerException if {@code node} is {@code null}\n     */\n    public boolean removeNode(ListNode<E> node)\n    {\n        return unlink((ListNodeImpl<E>) node);\n    }\n\n    /**\n     * Returns the first {@link ListNode node} holding the specified {@code element} in this list.\n     * More formally, returns the first {@code ListNode} such that\n     * {@code Objects.equals(element, node.getValue())}, or {@code null} if there is no such node.\n     * <p>\n     * This method has linear runtime complexity O(n).\n     * </p>\n     * \n     * @param element the element whose {@code ListNode} is to return\n     * @return the first {@code ListNode} holding the {@code element} or null if no node was found\n     */\n    public ListNode<E> nodeOf(Object element)\n    {\n        return searchNode(() -> head, n -> n.next, element).getFirst();\n    }\n\n    /**\n     * Returns the last {@link ListNode node} holding the specified {@code element} in this list.\n     * More formally, returns the last {@code ListNode} such that\n     * {@code Objects.equals(element, node.getValue())}, or {@code null} if there is no such node.\n     * <p>\n     * This method has linear runtime complexity O(n).\n     * </p>\n     * \n     * @param element the element whose {@code ListNode} is to return\n     * @return the last {@code ListNode} holding the {@code element} or null if no node was found\n     */\n    public ListNode<E> lastNodeOf(Object element)\n    {\n        return searchNode(this::tail, n -> n.prev, element).getFirst();\n    }\n\n    /**\n     * Returns a {@link Pair} of the first encountered {@link ListNode} in this list, whose\n     * {@code value} is equal to the given {@code element}, and its index. Or if this list does not\n     * contain such node a Pair of {@code null} and {@code -1};\n     * <p>\n     * The search starts at the node supplied by {@code first} and advances in the direction induced\n     * by the specified {@code next} operator.\n     * </p>\n     * \n     * @param first supplier of the first node to check if this list is not empty\n     * @param next {@code Function} to get from the current node the next node to check\n     * @param element the element for that the first node with equal value is searched.\n     * @return a {@link Pair} of the first encountered {@code ListNode} holding a {@code value}\n     *         equal to {@code element} and its index, or if no such node was found a\n     *         {@code Pair.of(null, -1)}\n     */\n    private Pair<ListNodeImpl<E>, Integer> searchNode(\n        Supplier<ListNodeImpl<E>> first, UnaryOperator<ListNodeImpl<E>> next, Object element)\n    {\n        if (!isEmpty()) {\n            int index = 0;\n            ListNodeImpl<E> firstNode = first.get();\n            ListNodeImpl<E> node = firstNode;\n            do {\n                if (Objects.equals(node.value, element)) {\n                    return Pair.of(node, index);\n                }\n                index++;\n                node = next.apply(node);\n            } while (node != firstNode);\n        }\n        return Pair.of(null, -1);\n    }\n\n    /**\n     * Inserts the specified element at the front of this list. Returns the {@link ListNode}\n     * allocated to store the {@code value}. The returned {@code ListNode} is the new head of the\n     * list.\n     * <p>\n     * This method is equivalent to {@link #addFirst(Object)} but returns the allocated\n     * {@code ListNode}.\n     * </p>\n     * \n     * @param element the element to add\n     * @return the {@code ListNode} allocated to store the {@code value}\n     */\n    public ListNode<E> addElementFirst(E element)\n    {\n        ListNode<E> node = new ListNodeImpl<>(element);\n        addNode(0, node);\n        return node;\n    }\n\n    /**\n     * Inserts the specified element at the end of this list. Returns the {@link ListNode} allocated\n     * to store the {@code value}. The returned {@code ListNode} is the new tail of the list.\n     * <p>\n     * This method is equivalent to {@link #addLast(Object)} but returns the allocated\n     * {@code ListNode}.\n     * </p>\n     * \n     * @param element the element to add\n     * @return the {@code ListNode} allocated to store the {@code value}\n     */\n    public ListNode<E> addElementLast(E element)\n    {\n        ListNode<E> node = new ListNodeImpl<>(element);\n        addNode(size, node);\n        return node;\n    }\n\n    /**\n     * Inserts the specified element before the specified {@link ListNode successor} in this list.\n     * Returns the {@code ListNode} allocated to store the {@code value}.\n     *\n     * @param successor {@code ListNode} before which the node holding {@code value} is inserted\n     * @param element the element to add\n     * @return the {@code ListNode} allocated to store the {@code value}\n     * @throws IllegalArgumentException if {@code successor} is not contained in this list\n     * @throws NullPointerException if {@code successor} is {@code null}\n     */\n    public ListNode<E> addElementBeforeNode(ListNode<E> successor, E element)\n    {\n        ListNode<E> node = new ListNodeImpl<>(element);\n        addNodeBefore(node, successor);\n        return node;\n    }\n\n    // List methods (shortcut for most commonly used methods to avoid iterator creation)\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void add(int index, E element)\n    {\n        if (index == size) { // also true if this is empty\n            addElementLast(element);\n        } else {\n            addElementBeforeNode(getNode(index), element);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E get(int index)\n    {\n        return getNodeAt(index).value;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E remove(int index)\n    {\n        ListNode<E> node = getNode(index);\n        removeNode(node);\n        return node.getValue();\n    }\n\n    // Deque methods\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void addFirst(E e)\n    {\n        addElementFirst(e);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void addLast(E e)\n    {\n        addElementLast(e);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean offerFirst(E e)\n    {\n        addElementFirst(e);\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean offerLast(E e)\n    {\n        addElementLast(e);\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E removeFirst()\n    {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n\n        ListNode<E> node = head;\n        removeNode(node); // changes head\n        return node.getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E removeLast()\n    {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n\n        ListNode<E> node = tail();\n        removeNode(node); // changes tail\n        return node.getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E pollFirst()\n    {\n        if (isEmpty()) {\n            return null;\n        }\n        ListNode<E> node = head;\n        removeNode(node); // changes head\n        return node.getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E pollLast()\n    {\n        if (isEmpty()) {\n            return null;\n        }\n        ListNode<E> node = tail();\n        removeNode(node); // changes tail()\n        return node.getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E getFirst()\n    {\n        return getFirstNode().getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E getLast()\n    {\n        return getLastNode().getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E peekFirst()\n    {\n        return isEmpty() ? null : getFirst();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E peekLast()\n    {\n        return isEmpty() ? null : getLast();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean removeFirstOccurrence(Object o)\n    {\n        ListNode<E> node = nodeOf(o);\n        if (node != null) {\n            removeNode(node);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean removeLastOccurrence(Object o)\n    {\n        ListNode<E> node = lastNodeOf(o);\n        if (node != null) {\n            removeNode(node);\n            return true;\n        }\n        return false;\n    }\n\n    // Queue methods\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean offer(E e)\n    {\n        return offerLast(e);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E remove()\n    {\n        return removeFirst();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E poll()\n    {\n        return pollFirst();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E element()\n    {\n        return getFirst();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E peek()\n    {\n        return peekFirst();\n    }\n\n    // Stack methods\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void push(E e)\n    {\n        addFirst(e);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public E pop()\n    {\n        return removeFirst();\n    }\n\n    // special bulk methods\n\n    /**\n     * Inverts the list. For instance, calling this method on the list $(a,b,c,\\dots,x,y,z)$ will\n     * result in the list $(z,y,x,\\dots,c,b,a)$. This method does only pointer manipulation, meaning\n     * that all the list nodes allocated for the previously added elements are valid after this\n     * method finishes.\n     */\n    public void invert()\n    {\n        if (size < 2) {\n            return;\n        }\n        ListNodeImpl<E> newHead = tail();\n        ListNodeImpl<E> current = head;\n        do {\n            ListNodeImpl<E> next = current.next;\n\n            current.next = current.prev;\n            current.prev = next;\n\n            current = next;\n        } while (current != head);\n        head = newHead;\n        ++modCount;\n    }\n\n    /**\n     * Moves all {@link ListNode ListNodes} of the given {@code sourceList} to this list and inserts\n     * them all before the node previously at the given position. All the {@code nodes} of\n     * {@code movedList} are moved to this list. When this method terminates this list contains all\n     * nodes of {@code movedList} and {@code movedList} is empty.\n     *\n     * @param index index of the first element of {@code list} in this {@code list} after it was\n     *        added\n     * @param movedList the {@code DoublyLinkedList} to move to this one\n     * @throws NullPointerException if {@code movedList} is {@code null}\n     */\n    public void moveFrom(int index, DoublyLinkedList<E> movedList)\n    {\n        linkListIntoThisBefore(index, movedList);\n    }\n\n    /**\n     * Appends the {@code movedList} to the end of this list. All the elements from\n     * {@code movedList} are transferred to this list, i.e. the {@code list} is empty after calling\n     * this method.\n     *\n     * @param movedList the {@code DoublyLinkedList} to append to this one\n     * @throws NullPointerException if {@code movedList} is {@code null}\n     */\n    public void append(DoublyLinkedList<E> movedList)\n    {\n        moveFrom(size, movedList);\n    }\n\n    /**\n     * Prepends the {@code movedList} to the beginning of this list. All the elements from\n     * {@code movedList} are transferred to this list, i.e. the {@code movedList} is empty after\n     * calling this method.\n     *\n     * @param movedList the {@code DoublyLinkedList} to prepend to this one\n     * @throws NullPointerException if {@code movedList} is {@code null}\n     */\n    public void prepend(DoublyLinkedList<E> movedList)\n    {\n        moveFrom(0, movedList);\n    }\n\n    // ----------------------------------------------------------------------------\n    // (List)Iterators\n\n    /**\n     * Returns a {@link NodeIterator} that starts at the first {@link ListNode} of this list that is\n     * equal to the specified {@code firstElement}, iterates in forward direction over the end of\n     * this list until the first node.\n     * <p>\n     * The first call to {@link NodeIterator#nextNode()} returns the first {@code node} that holds a\n     * value such that {@code Objects.equals(node.getValue, firstElement)} returns {@code true}. The\n     * returned {@code NodeIterator} iterates in forward direction returning the respective next\n     * element in subsequent calls to {@code next(Node)}. The returned iterator ignores the actual\n     * bounds of this {@code DoublyLinkedList} and iterates until the node before the first one is\n     * reached. Its {@link NodeIterator#hasNext() hasNext()} returns {@code false} if the next node\n     * would be the first one.\n     * </p>\n     * \n     * @param firstElement the element equal to the first {@code next()}\n     * @return a circular {@code NodeIterator} iterating forward from {@code firstElement}\n     */\n    public NodeIterator<E> circularIterator(E firstElement)\n    {\n        ListNodeImpl<E> startNode = (ListNodeImpl<E>) nodeOf(firstElement);\n        if (startNode == null) {\n            throw new NoSuchElementException();\n        }\n        return new ListNodeIteratorImpl(0, startNode);\n    }\n\n    /**\n     * Returns a {@link NodeIterator} that starts at the first {@link ListNode} of this list that is\n     * equal to the specified {@code firstElement}, iterates in reverse direction over the end of\n     * this list until the first node.\n     * <p>\n     * The first call to {@link NodeIterator#nextNode()} returns the first {@code node} that holds a\n     * value such that {@code Objects.equals(node.getValue, firstElement)} returns {@code true}. The\n     * returned {@code NodeIterator} iterates in reverse direction returning the respective previous\n     * element in subsequent calls to {@code next(Node)}. The returned iterator ignores the actual\n     * bounds of this {@code DoublyLinkedList} and iterates until the node before the first one is\n     * reached. Its {@link NodeIterator#hasNext() hasNext()} returns {@code false} if the next node\n     * would be the first one.\n     * </p>\n     * \n     * @param firstElement the element equal to the first {@code next()}\n     * @return a circular {@code NodeIterator} iterating backwards from {@code firstElement}\n     */\n    public NodeIterator<E> reverseCircularIterator(E firstElement)\n    {\n        ListNodeImpl<E> startNode = (ListNodeImpl<E>) nodeOf(firstElement);\n        if (startNode == null) {\n            throw new NoSuchElementException();\n        }\n        return reverseIterator(new ListNodeIteratorImpl(size, startNode.next));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public NodeIterator<E> descendingIterator()\n    {\n        return reverseIterator(listIterator(size));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public NodeIterator<E> iterator()\n    {\n        return listIterator();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public ListNodeIterator<E> listIterator()\n    {\n        return listIterator(0);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public ListNodeIterator<E> listIterator(int index)\n    {\n        return new ListNodeIteratorImpl(index);\n    }\n\n    /**\n     * Returns a {@link ListNodeIterator} over the elements in this list (in proper sequence)\n     * starting with the first {@link ListNode} whose value is equal to the specified\n     * {@code element}.\n     *\n     * @param element the first element to be returned from the list iterator (by a call to the\n     *        {@code next} method)\n     * @return a list iterator over the elements in this list (in proper sequence)\n     * @throws NoSuchElementException if {@code element} is not in the list\n     */\n    public ListNodeIterator<E> listIterator(E element)\n    {\n        Pair<ListNodeImpl<E>, Integer> startPair = searchNode(() -> head, n -> n.next, element);\n        ListNodeImpl<E> startNode = startPair.getFirst();\n        int startIndex = startPair.getSecond();\n        if (startNode == null) {\n            throw new NoSuchElementException();\n        }\n        return new ListNodeIteratorImpl(startIndex, startNode);\n    }\n\n    /**\n     * An extension of the {@link Iterator} interface for {@link DoublyLinkedList DoublyLinkedLists}\n     * exposing their {@link ListNode ListNodes}.\n     *\n     * @param <E> the list element type\n     */\n    public interface NodeIterator<E>\n        extends\n        Iterator<E>\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        default E next()\n        {\n            return nextNode().getValue();\n        }\n\n        /**\n         * Returns the next {@link ListNode} in the list and advances the cursor position.\n         *\n         * @return the next {@code ListNode}\n         * @see ListIterator#next()\n         */\n        ListNode<E> nextNode();\n\n    }\n\n    /**\n     * An extension of the {@link ListIterator} interface for {@link DoublyLinkedList\n     * DoublyLinkedLists} exposing their {@link ListNode ListNodes}.\n     *\n     * @param <E> the list element type\n     */\n    public interface ListNodeIterator<E>\n        extends\n        ListIterator<E>,\n        NodeIterator<E>\n    {\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        default E next()\n        {\n            return nextNode().getValue();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        default E previous()\n        {\n            return previousNode().getValue();\n        }\n\n        /**\n         * Returns the previous {@link ListNode} in the list and moves the cursor position\n         * backwards.\n         *\n         * @return the previous {@code ListNode}\n         * @see ListIterator#previous()\n         */\n        ListNode<E> previousNode();\n\n    }\n\n    /**\n     * An implementation of the {@link DoublyLinkedList.ListNodeIterator} interface.\n     */\n    private class ListNodeIteratorImpl\n        implements\n        ListNodeIterator<E>\n    {\n        /** Index in this list of the ListNode returned next. */\n        private int nextIndex;\n        /** ListNode this iterator will return next. Null if this list is empty. */\n        private ListNodeImpl<E> next;\n        /** ListNode this iterator returned last. */\n        private ListNodeImpl<E> last = null;\n\n        /**\n         * The number of modifications the list have had at the moment when this iterator was\n         * created\n         */\n        private int expectedModCount = modCount;\n\n        private ListNodeIteratorImpl(int startIndex)\n        {\n            this.nextIndex = startIndex;\n            if (startIndex == size) {\n                this.next = isEmpty() ? null : head;\n            } else {\n                this.next = getNodeAt(startIndex);\n            }\n        }\n\n        private ListNodeIteratorImpl(int startIndex, ListNodeImpl<E> startNode)\n        {\n            this.nextIndex = startIndex;\n            this.next = startNode;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean hasNext()\n        {\n            return nextIndex < size;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean hasPrevious()\n        {\n            return nextIndex > 0;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int nextIndex()\n        {\n            return nextIndex;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int previousIndex()\n        {\n            return nextIndex - 1;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public ListNodeImpl<E> nextNode()\n        {\n            checkForComodification();\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n\n            last = next;\n            next = next.next;\n            nextIndex++;\n            return last;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public ListNode<E> previousNode()\n        {\n            checkForComodification();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException();\n            }\n\n            last = next = next.prev;\n            nextIndex--;\n            return last;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void add(E e)\n        {\n            checkForComodification();\n\n            if (nextIndex == size) {\n                addElementLast(e); // sets head to new node of e if was empty\n                if (size == 1) { // was empty\n                    next = head; // jump over head threshold, so cursor is at the end\n                }\n            } else {\n                addElementBeforeNode(next, e);\n            }\n            last = null;\n            nextIndex++;\n            expectedModCount++;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void set(E e)\n        {\n            if (last == null) {\n                throw new IllegalStateException();\n            }\n            checkForComodification();\n            // replace node returned last with a new node holding e\n\n            ListNode<E> nextNode = last.next;\n            boolean wasLast = last == tail();\n            removeNode(last);\n            if (wasLast) { // or the sole node\n                last = (ListNodeImpl<E>) addElementLast(e);\n            } else {\n                last = (ListNodeImpl<E>) addElementBeforeNode(nextNode, e);\n            }\n            expectedModCount += 2; // because of unlink and add\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void remove()\n        {\n            if (last == null) {\n                throw new IllegalStateException();\n            }\n            checkForComodification();\n\n            ListNodeImpl<E> lastsNext = last.next;\n            removeNode(last);\n            if (next == last) { // previousNode() called before\n                // removed element after cursor (which would have been next)\n                next = lastsNext;\n            } else { // nextNode() called before\n                // removed element before cursor (next is unaffected but the index decreases)\n                nextIndex--;\n            }\n            last = null;\n            expectedModCount++;\n        }\n\n        /**\n         * Verifies that the list structure hasn't been changed since the iteration started\n         */\n        private void checkForComodification()\n        {\n            if (expectedModCount != modCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n    }\n\n    /**\n     * Returns a {@link NodeIterator} that iterates in reverse order, assuming the cursor of the\n     * specified {@link ListNodeIterator} is behind the tail of the list.\n     */\n    private static <E> NodeIterator<E> reverseIterator(ListNodeIterator<E> listIterator)\n    {\n        return new NodeIterator<E>()\n        {\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public boolean hasNext()\n            {\n                return listIterator.hasPrevious();\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public ListNode<E> nextNode()\n            {\n                return listIterator.previousNode();\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public void remove()\n            {\n                listIterator.remove();\n            }\n        };\n    }\n\n    /**\n     * Container for the elements stored in a {@link DoublyLinkedList}.\n     * <p>\n     * A {@link ListNode} is either contained exactly once in exactly one {@code DoublyLinkedList}\n     * or contained in no {@code DoublyLinkedList}.\n     * </p>\n     * \n     * @param <V> the type of the element stored in this node\n     */\n    public interface ListNode<V>\n    {\n        /**\n         * Returns the immutable value this {@code ListNode} contains.\n         *\n         * @return the value this list node contains\n         */\n        V getValue();\n\n        /**\n         * Returns the next node in the list structure with respect to this node\n         *\n         * @return the next node in the list structure with respect to this node\n         */\n        ListNode<V> getNext();\n\n        /**\n         * Returns the previous node in the list structure with respect to this node\n         *\n         * @return the previous node in the list structure with respect to this node\n         */\n        ListNode<V> getPrev();\n    }\n\n    /**\n     * The default {@link ListNode} implementation that enables checks and enforcement of a single\n     * container list policy.\n     */\n    private static class ListNodeImpl<V>\n        implements\n        ListNode<V>\n    {\n        private final V value;\n        private DoublyLinkedList<V> list = null;\n        private ListNodeImpl<V> next = null;\n        private ListNodeImpl<V> prev = null;\n\n        /**\n         * Creates new list node\n         *\n         * @param value the value this list node stores\n         */\n        ListNodeImpl(V value)\n        {\n            this.value = value;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            if (list == null) {\n                return \" - \" + value + \" - \"; // not in a list\n            } else {\n                return prev.value + \" -> \" + value + \" -> \" + next.value;\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public V getValue()\n        {\n            return value;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public ListNodeImpl<V> getNext()\n        {\n            return next;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public ListNodeImpl<V> getPrev()\n        {\n            return prev;\n        }\n    }\n}\n",
            "file_name": "DoublyLinkedList.java",
            "human_label": "Move the nodes of the given doubly linked list to a new list sequentially.",
            "level": "class_runnable",
            "lineno": "137",
            "name": "moveAllListNodes",
            "oracle_context": "{ \"apis\" : \"[hasNext, nextNode, ListNodeIteratorImpl, ListNodeImpl, size]\", \"classes\" : \"[ListNodeImpl<E>]\", \"vars\" : \"[size, modCount]\" }",
            "package": "org.jgrapht.util",
            "project": "jgrapht-master"
        },
        {
            "_id": "636766fe1a6d9265ec01781c",
            "all_context": "{ \"class_level\" : \"String CHAR_STRING;\\nString[] CHAR_STRING_ARRAY;\\nCharacter[] CHAR_ARRAY;\\nchar LF;\\nchar CR;\\nCharUtils();\\ntoCharacterObject(String str);\\ntoChar(Character ch);\\ntoChar(Character ch,char defaultValue);\\ntoChar(String str);\\ntoChar(String str,char defaultValue);\\ntoIntValue(char ch);\\ntoIntValue(char ch,int defaultValue);\\ntoIntValue(Character ch);\\ntoIntValue(Character ch,int defaultValue);\\ntoString(char ch);\\ntoString(Character ch);\\nunicodeEscaped(char ch);\\nunicodeEscaped(Character ch);\\nisAscii(char ch);\\nisAsciiPrintable(char ch);\\nisAsciiControl(char ch);\\nisAsciiAlpha(char ch);\\nisAsciiAlphaUpper(char ch);\\nisAsciiAlphaLower(char ch);\\nisAsciiNumeric(char ch);\\nisAsciiAlphanumeric(char ch);\\nisHighSurrogate(char ch);\\nisCharType(Class targetType);\\n\", \"repo_level\" : \"\" }",
            "class_name": "CharUtils",
            "code": "public static Character toCharacterObject(final char ch){\n  if (ch < CharUtils.CHAR_ARRAY.length) {\n    return CharUtils.CHAR_ARRAY[ch];\n  }\n  return new Character(ch);\n}\n",
            "docstring": "/** \n * <p>Converts the character to a Character.</p> <p>For ASCII 7 bit characters, this uses a cache that will return the same Character object each time.</p> <pre> CharUtils.toCharacterObject(' ')  = ' ' CharUtils.toCharacterObject('A')  = 'A' </pre>\n * @param ch  the character to convert\n * @return a Character of the specified character\n */\n",
            "end_lineno": "106",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils;\n/**\n * <p>Operations on char primitives and Character objects.</p>\n *\n * <p>This class tries to handle <code>null</code> input gracefully.\n * An exception will not be thrown for a <code>null</code> input.\n * Each method documents its behaviour in more detail.</p>\n *\n * <p>#ThreadSafe#</p>\n * @author Apache Software Foundation\n * @since 2.1\n * @version $Id: CharUtils.java 1056988 2011-01-09 17:58:53Z niallp $\n */\npublic class CharUtils {\n    private static final String      CHAR_STRING       =        //\n            \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\" +//\n                    \"\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\" + //\n                    \"\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\" + //\n                    \"\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\" +//\n                    \"\\u0020\\u0021\\\"\\u0023\\u0024\\u0025\\u0026\\u0027\" + //\n                    \"\\u0028\\u0029\\u002a\\u002b\\u002c\\u002d\\u002e\\u002f\" + //\n                    \"\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\" + //\n                    \"\\u0038\\u0039\\u003a\\u003b\\u003c\\u003d\\u003e\\u003f\" + //\n                    \"\\u0040\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\" + //\n                    \"\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\" + //\n                    \"\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\" +//\n                    \"\\u0058\\u0059\\u005a\\u005b\\\\\\u005d\\u005e\\u005f\" + //\n                    \"\\u0060\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\" +//\n                    \"\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\" +//\n                    \"\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\" +//\n                    \"\\u0078\\u0079\\u007a\\u007b\\u007c\\u007d\\u007e\\u007f\";\n    private static final String[]    CHAR_STRING_ARRAY = new String[128];\n    private static final Character[] CHAR_ARRAY        = new Character[128];\n    /**\n     * <code>\n     </code> linefeed LF ('\\n').\n     *\n     * @see <a href=\"http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#101089\">JLF: Escape Sequences\n     *      for Character and String Literals</a>\n     * @since 2.2\n     */\n    public static final  char        LF                = '\\n';\n    /**\n     * <code>     </code> carriage return CR ('\\r').\n     *\n     * @see <a href=\"http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#101089\">JLF: Escape Sequences\n     *      for Character and String Literals</a>\n     * @since 2.2\n     */\n    public static final  char        CR                = '\\r';\n\n    static {\n        for (int i = 127; i >= 0; i--) {\n            CharUtils.CHAR_STRING_ARRAY[i] = CharUtils.CHAR_STRING.substring(i, i + 1);\n            CharUtils.CHAR_ARRAY[i] = new Character((char) i);\n        }\n    }\n\n    /**\n     * <p><code>CharUtils</code> instances should NOT be constructed in standard programming.\n     * Instead, the class should be used as <code>CharUtils.toString('c');</code>.</p>\n     *\n     * <p>This constructor i public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     */\n    public CharUtils() {\n        super();\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts the character to a Character.</p>\n     *\n     * <p>For ASCII 7 bit characters, this uses a cache that will return the\n     * same Character object each time.</p>\n     *\n     * <pre>\n     *   CharUtils.toCharacterObject(' ')  = ' '\n     *   CharUtils.toCharacterObject('A')  = 'A'\n     * </pre>\n     *\n     * @param ch  the character to convert\n     * @return a Character of the specified character\n     */\n    public static Character toCharacterObject(final char ch) {\n        if (ch < CharUtils.CHAR_ARRAY.length) {\n            return CharUtils.CHAR_ARRAY[ch];\n        }\n        return new Character(ch);\n    }\n\n    /**\n     * <p>Converts the String to a Character using the first character, returning\n     * null for empty Strings.</p>\n     *\n     * <p>For ASCII 7 bit characters, this uses a cache that will return the\n     * same Character object each time.</p>\n     *\n     * <pre>\n     *   CharUtils.toCharacterObject(null) = null\n     *   CharUtils.toCharacterObject(\"\")   = null\n     *   CharUtils.toCharacterObject(\"A\")  = 'A'\n     *   CharUtils.toCharacterObject(\"BA\") = 'B'\n     * </pre>\n     *\n     * @param str  the character to convert\n     * @return the Character value of the first letter of the String\n     */\n    public static Character toCharacterObject(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return null;\n        }\n        return CharUtils.toCharacterObject(str.charAt(0));\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts the Character to a char throwing an exception for <code>null</code>.</p>\n     *\n     * <pre>\n     *   CharUtils.toChar(null) = IllegalArgumentException\n     *   CharUtils.toChar(' ')  = ' '\n     *   CharUtils.toChar('A')  = 'A'\n     * </pre>\n     *\n     * @param ch  the character to convert\n     * @return the char value of the Character\n     * @throws IllegalArgumentException if the Character is null\n     */\n    public static char toChar(final Character ch) {\n        if (ch == null) {\n            throw new IllegalArgumentException(\"The Character must not be null\");\n        }\n        return ch.charValue();\n    }\n\n    /**\n     * <p>Converts the Character to a char handling <code>null</code>.</p>\n     *\n     * <pre>\n     *   CharUtils.toChar(null, 'X') = 'X'\n     *   CharUtils.toChar(' ', 'X')  = ' '\n     *   CharUtils.toChar('A', 'X')  = 'A'\n     * </pre>\n     *\n     * @param ch  the character to convert\n     * @param defaultValue  the value to use if the  Character is null\n     * @return the char value of the Character or the default if null\n     */\n    public static char toChar(final Character ch, final char defaultValue) {\n        if (ch == null) {\n            return defaultValue;\n        }\n        return ch.charValue();\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts the String to a char using the first character, throwing\n     * an exception on empty Strings.</p>\n     *\n     * <pre>\n     *   CharUtils.toChar(null) = IllegalArgumentException\n     *   CharUtils.toChar(\"\")   = IllegalArgumentException\n     *   CharUtils.toChar(\"A\")  = 'A'\n     *   CharUtils.toChar(\"BA\") = 'B'\n     * </pre>\n     *\n     * @param str  the character to convert\n     * @return the char value of the first letter of the String\n     * @throws IllegalArgumentException if the String is empty\n     */\n    public static char toChar(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            throw new IllegalArgumentException(\"The String must not be empty\");\n        }\n        return str.charAt(0);\n    }\n\n    /**\n     * <p>Converts the String to a char using the first character, defaulting\n     * the value on empty Strings.</p>\n     *\n     * <pre>\n     *   CharUtils.toChar(null, 'X') = 'X'\n     *   CharUtils.toChar(\"\", 'X')   = 'X'\n     *   CharUtils.toChar(\"A\", 'X')  = 'A'\n     *   CharUtils.toChar(\"BA\", 'X') = 'B'\n     * </pre>\n     *\n     * @param str  the character to convert\n     * @param defaultValue  the value to use if the  Character is null\n     * @return the char value of the first letter of the String or the default if null\n     */\n    public static char toChar(final String str, final char defaultValue) {\n        if (StringUtils.isEmpty(str)) {\n            return defaultValue;\n        }\n        return str.charAt(0);\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts the character to the Integer it represents, throwing an\n     * exception if the character is not numeric.</p>\n     *\n     * <p>This method coverts the char '1' to the int 1 and so on.</p>\n     *\n     * <pre>\n     *   CharUtils.toIntValue('3')  = 3\n     *   CharUtils.toIntValue('A')  = IllegalArgumentException\n     * </pre>\n     *\n     * @param ch  the character to convert\n     * @return the int value of the character\n     * @throws IllegalArgumentException if the character is not ASCII numeric\n     */\n    public static int toIntValue(final char ch) {\n        if (CharUtils.isAsciiNumeric(ch) == false) {\n            throw new IllegalArgumentException(\"The character \" + ch + \" is not in the range '0' - '9'\");\n        }\n        return ch - 48;\n    }\n\n    /**\n     * <p>Converts the character to the Integer it represents, throwing an\n     * exception if the character is not numeric.</p>\n     *\n     * <p>This method coverts the char '1' to the int 1 and so on.</p>\n     *\n     * <pre>\n     *   CharUtils.toIntValue('3', -1)  = 3\n     *   CharUtils.toIntValue('A', -1)  = -1\n     * </pre>\n     *\n     * @param ch  the character to convert\n     * @param defaultValue  the default value to use if the character is not numeric\n     * @return the int value of the character\n     */\n    public static int toIntValue(final char ch, final int defaultValue) {\n        if (CharUtils.isAsciiNumeric(ch) == false) {\n            return defaultValue;\n        }\n        return ch - 48;\n    }\n\n    /**\n     * <p>Converts the character to the Integer it represents, throwing an\n     * exception if the character is not numeric.</p>\n     *\n     * <p>This method coverts the char '1' to the int 1 and so on.</p>\n     *\n     * <pre>\n     *   CharUtils.toIntValue(null) = IllegalArgumentException\n     *   CharUtils.toIntValue('3')  = 3\n     *   CharUtils.toIntValue('A')  = IllegalArgumentException\n     * </pre>\n     *\n     * @param ch  the character to convert, not null\n     * @return the int value of the character\n     * @throws IllegalArgumentException if the Character is not ASCII numeric or is null\n     */\n    public static int toIntValue(final Character ch) {\n        if (ch == null) {\n            throw new IllegalArgumentException(\"The character must not be null\");\n        }\n        return CharUtils.toIntValue(ch.charValue());\n    }\n\n    /**\n     * <p>Converts the character to the Integer it represents, throwing an\n     * exception if the character is not numeric.</p>\n     *\n     * <p>This method coverts the char '1' to the int 1 and so on.</p>\n     *\n     * <pre>\n     *   CharUtils.toIntValue(null, -1) = -1\n     *   CharUtils.toIntValue('3', -1)  = 3\n     *   CharUtils.toIntValue('A', -1)  = -1\n     * </pre>\n     *\n     * @param ch  the character to convert\n     * @param defaultValue  the default value to use if the character is not numeric\n     * @return the int value of the character\n     */\n    public static int toIntValue(final Character ch, final int defaultValue) {\n        if (ch == null) {\n            return defaultValue;\n        }\n        return CharUtils.toIntValue(ch.charValue(), defaultValue);\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * <p>Converts the character to a String that contains the one character.</p>\n     *\n     * <p>For ASCII 7 bit characters, this uses a cache that will return the\n     * same String object each time.</p>\n     *\n     * <pre>\n     *   CharUtils.toString(' ')  = \" \"\n     *   CharUtils.toString('A')  = \"A\"\n     * </pre>\n     *\n     * @param ch  the character to convert\n     * @return a String containing the one specified character\n     */\n    public static String toString(final char ch) {\n        if (ch < 128) {\n            return CharUtils.CHAR_STRING_ARRAY[ch];\n        }\n        return new String(new char[] { ch });\n    }\n\n    /**\n     * <p>Converts the character to a String that contains the one character.</p>\n     *\n     * <p>For ASCII 7 bit characters, this uses a cache that will return the\n     * same String object each time.</p>\n     *\n     * <p>If <code>null</code> is passed in, <code>null</code> will be returned.</p>\n     *\n     * <pre>\n     *   CharUtils.toString(null) = null\n     *   CharUtils.toString(' ')  = \" \"\n     *   CharUtils.toString('A')  = \"A\"\n     * </pre>\n     *\n     * @param ch  the character to convert\n     * @return a String containing the one specified character\n     */\n    public static String toString(final Character ch) {\n        if (ch == null) {\n            return null;\n        }\n        return CharUtils.toString(ch.charValue());\n    }\n    //--------------------------------------------------------------------------\n\n    /**\n     * <p>Converts the string to the unicode format '\\u0020'.</p>\n     *\n     * <p>This format is the Java source code format.</p>\n     *\n     * <pre>\n     *   CharUtils.unicodeEscaped(' ') = \"\\u0020\"\n     *   CharUtils.unicodeEscaped('A') = \"\\u0041\"\n     * </pre>\n     *\n     * @param ch  the character to convert\n     * @return the escaped unicode string\n     */\n    public static String unicodeEscaped(final char ch) {\n        if (ch < 0x10) {\n            return \"\\\\u000\" + Integer.toHexString(ch);\n        } else if (ch < 0x100) {\n            return \"\\\\u00\" + Integer.toHexString(ch);\n        } else if (ch < 0x1000) {\n            return \"\\\\u0\" + Integer.toHexString(ch);\n        }\n        return \"\\\\u\" + Integer.toHexString(ch);\n    }\n\n    /**\n     * <p>Converts the string to the unicode format '\\u0020'.</p>\n     *\n     * <p>This format is the Java source code format.</p>\n     *\n     * <p>If <code>null</code> is passed in, <code>null</code> will be returned.</p>\n     *\n     * <pre>\n     *   CharUtils.unicodeEscaped(null) = null\n     *   CharUtils.unicodeEscaped(' ')  = \"\\u0020\"\n     *   CharUtils.unicodeEscaped('A')  = \"\\u0041\"\n     * </pre>\n     *\n     * @param ch  the character to convert, may be null\n     * @return the escaped unicode string, null if null input\n     */\n    public static String unicodeEscaped(final Character ch) {\n        if (ch == null) {\n            return null;\n        }\n        return CharUtils.unicodeEscaped(ch.charValue());\n    }\n    //--------------------------------------------------------------------------\n\n    /**\n     * <p>Checks whether the character is ASCII 7 bit.</p>\n     *\n     * <pre>\n     *   CharUtils.isAscii('a')  = true\n     *   CharUtils.isAscii('A')  = true\n     *   CharUtils.isAscii('3')  = true\n     *   CharUtils.isAscii('-')  = true\n     *   CharUtils.isAscii('\\n') = true\n     *   CharUtils.isAscii('&copy;') = false\n     * </pre>\n     *\n     * @param ch  the character to check\n     * @return true if less than 128\n     */\n    public static boolean isAscii(final char ch) {\n        return ch < 128;\n    }\n\n    /**\n     * <p>Checks whether the character is ASCII 7 bit printable.</p>\n     *\n     * <pre>\n     *   CharUtils.isAsciiPrintable('a')  = true\n     *   CharUtils.isAsciiPrintable('A')  = true\n     *   CharUtils.isAsciiPrintable('3')  = true\n     *   CharUtils.isAsciiPrintable('-')  = true\n     *   CharUtils.isAsciiPrintable('\\n') = false\n     *   CharUtils.isAsciiPrintable('&copy;') = false\n     * </pre>\n     *\n     * @param ch  the character to check\n     * @return true if between 32 and 126 inclusive\n     */\n    public static boolean isAsciiPrintable(final char ch) {\n        return ch >= 32 && ch < 127;\n    }\n\n    /**\n     * <p>Checks whether the character is ASCII 7 bit control.</p>\n     *\n     * <pre>\n     *   CharUtils.isAsciiControl('a')  = false\n     *   CharUtils.isAsciiControl('A')  = false\n     *   CharUtils.isAsciiControl('3')  = false\n     *   CharUtils.isAsciiControl('-')  = false\n     *   CharUtils.isAsciiControl('\\n') = true\n     *   CharUtils.isAsciiControl('&copy;') = false\n     * </pre>\n     *\n     * @param ch  the character to check\n     * @return true if less than 32 or equals 127\n     */\n    public static boolean isAsciiControl(final char ch) {\n        return ch < 32 || ch == 127;\n    }\n\n    /**\n     * <p>Checks whether the character is ASCII 7 bit alphabetic.</p>\n     *\n     * <pre>\n     *   CharUtils.isAsciiAlpha('a')  = true\n     *   CharUtils.isAsciiAlpha('A')  = true\n     *   CharUtils.isAsciiAlpha('3')  = false\n     *   CharUtils.isAsciiAlpha('-')  = false\n     *   CharUtils.isAsciiAlpha('\\n') = false\n     *   CharUtils.isAsciiAlpha('&copy;') = false\n     * </pre>\n     *\n     * @param ch  the character to check\n     * @return true if between 65 and 90 or 97 and 122 inclusive\n     */\n    public static boolean isAsciiAlpha(final char ch) {\n        return ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z';\n    }\n\n    /**\n     * <p>Checks whether the character is ASCII 7 bit alphabetic upper case.</p>\n     *\n     * <pre>\n     *   CharUtils.isAsciiAlphaUpper('a')  = false\n     *   CharUtils.isAsciiAlphaUpper('A')  = true\n     *   CharUtils.isAsciiAlphaUpper('3')  = false\n     *   CharUtils.isAsciiAlphaUpper('-')  = false\n     *   CharUtils.isAsciiAlphaUpper('\\n') = false\n     *   CharUtils.isAsciiAlphaUpper('&copy;') = false\n     * </pre>\n     *\n     * @param ch  the character to check\n     * @return true if between 65 and 90 inclusive\n     */\n    public static boolean isAsciiAlphaUpper(final char ch) {\n        return ch >= 'A' && ch <= 'Z';\n    }\n\n    /**\n     * <p>Checks whether the character is ASCII 7 bit alphabetic lower case.</p>\n     *\n     * <pre>\n     *   CharUtils.isAsciiAlphaLower('a')  = true\n     *   CharUtils.isAsciiAlphaLower('A')  = false\n     *   CharUtils.isAsciiAlphaLower('3')  = false\n     *   CharUtils.isAsciiAlphaLower('-')  = false\n     *   CharUtils.isAsciiAlphaLower('\\n') = false\n     *   CharUtils.isAsciiAlphaLower('&copy;') = false\n     * </pre>\n     *\n     * @param ch  the character to check\n     * @return true if between 97 and 122 inclusive\n     */\n    public static boolean isAsciiAlphaLower(final char ch) {\n        return ch >= 'a' && ch <= 'z';\n    }\n\n    /**\n     * <p>Checks whether the character is ASCII 7 bit numeric.</p>\n     *\n     * <pre>\n     *   CharUtils.isAsciiNumeric('a')  = false\n     *   CharUtils.isAsciiNumeric('A')  = false\n     *   CharUtils.isAsciiNumeric('3')  = true\n     *   CharUtils.isAsciiNumeric('-')  = false\n     *   CharUtils.isAsciiNumeric('\\n') = false\n     *   CharUtils.isAsciiNumeric('&copy;') = false\n     * </pre>\n     *\n     * @param ch  the character to check\n     * @return true if between 48 and 57 inclusive\n     */\n    public static boolean isAsciiNumeric(final char ch) {\n        return ch >= '0' && ch <= '9';\n    }\n\n    /**\n     * <p>Checks whether the character is ASCII 7 bit numeric.</p>\n     *\n     * <pre>\n     *   CharUtils.isAsciiAlphanumeric('a')  = true\n     *   CharUtils.isAsciiAlphanumeric('A')  = true\n     *   CharUtils.isAsciiAlphanumeric('3')  = true\n     *   CharUtils.isAsciiAlphanumeric('-')  = false\n     *   CharUtils.isAsciiAlphanumeric('\\n') = false\n     *   CharUtils.isAsciiAlphanumeric('&copy;') = false\n     * </pre>\n     *\n     * @param ch  the character to check\n     * @return true if between 48 and 57 or 65 and 90 or 97 and 122 inclusive\n     */\n    public static boolean isAsciiAlphanumeric(final char ch) {\n        return ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z' || ch >= '0' && ch <= '9';\n    }\n    // ----------------- Following code copied from Apache Harmony (Character class)\n\n    /**\n     * Indicates whether {@code ch} is a high- (or leading-) surrogate code unit\n     * that is used for representing supplementary characters in UTF-16\n     * encoding.\n     *\n     * @param ch\n     *            the character to test.\n     * @return {@code true} if {@code ch} is a high-surrogate code unit;\n     *         {@code false} otherwise.\n     */\n    static boolean isHighSurrogate(final char ch) {\n        return '\\uD800' <= ch && '\\uDBFF' >= ch;\n    }\n\n    //\n    public static boolean isCharType(Class targetType) {\n        return targetType.equals(Character.class) || targetType.equals(Character.TYPE);\n    }\n}\n",
            "file_name": "CharUtils.java",
            "human_label": "Return the Character object converted from the given character.",
            "level": "class_runnable",
            "lineno": "87",
            "name": "toCharacterObject",
            "oracle_context": "{ \"apis\" : \"[CharUtils]\", \"classes\" : \"[CharUtils.CHAR_ARRAY, CharUtils]\", \"vars\" : \"[length, CHAR_ARRAY]\" }",
            "package": "net.hasor.utils",
            "project": "hasor-master"
        },
        {
            "_id": "636767781a6d9265ec018250",
            "all_context": "{ \"class_level\" : \"import org.apache.log4j.spi.Filter;\\nimport org.apache.log4j.spi.LoggingEvent;\\nimport org.apache.log4j.helpers.OptionConverter;\\nString STRING_TO_MATCH_OPTION;\\nString ACCEPT_ON_MATCH_OPTION;\\nboolean acceptOnMatch;\\nString stringToMatch;\\ngetOptionStrings();\\nsetOption(String key,String value);\\nsetStringToMatch(String s);\\ngetStringToMatch();\\nsetAcceptOnMatch(boolean acceptOnMatch);\\ngetAcceptOnMatch();\\n\", \"repo_level\" : \"public interface Filter {public void activateOptions();\\npublic int decide(LoggingEvent event);\\npublic void setNext(Filter next);\\npublic Filter getNext();\\n }\\npublic interface LoggingEvent {public LocationInfo getLocationInformation();\\npublic Level getLevel();\\npublic String getLoggerName();\\npublic Category getLogger();\\npublic Object getMessage();\\npublic String getNDC();\\npublic Object getMDC(String key);\\npublic void getMDCCopy();\\npublic String getRenderedMessage();\\nstatic long getStartTime();\\npublic String getThreadName();\\npublic ThrowableInformation getThrowableInformation();\\npublic String[] getThrowableStrRep();\\nfinal void setProperty(String propName,String propValue);\\nfinal String getProperty(String key);\\nfinal boolean locationInformationExists();\\nfinal long getTimeStamp();\\npublic Set getPropertyKeySet();\\npublic Map getProperties();\\npublic String getFQNOfLoggerClass();\\npublic Object removeProperty(String propName);\\n }\\npublic interface OptionConverter {static String[] concatanateArrays(String[] l,String[] r);\\nstatic String convertSpecialChars(String s);\\nstatic String getSystemProperty(String key,String def);\\nstatic Object instantiateByKey(Properties props,String key,Class superClass,Object defaultValue);\\nstatic boolean toBoolean(String value,boolean dEfault);\\nstatic int toInt(String value,int dEfault);\\nstatic Level toLevel(String value,Level defaultValue);\\nstatic long toFileSize(String value,long dEfault);\\nstatic String findAndSubst(String key,Properties props);\\nstatic Object instantiateByClassName(String className,Class superClass,Object defaultValue);\\nstatic String substVars(String val,Properties props);\\npublic void selectAndConfigure(InputStream inputStream,String clazz,LoggerRepository hierarchy);\\npublic void selectAndConfigure(URL url,String clazz,LoggerRepository hierarchy);\\n }\\n\" }",
            "class_name": "StringMatchFilter",
            "code": "public int decide(LoggingEvent event){\n  String msg=event.getRenderedMessage();\n  if (msg == null || stringToMatch == null)   return Filter.NEUTRAL;\n  if (msg.indexOf(stringToMatch) == -1) {\n    return Filter.NEUTRAL;\n  }\n else {\n    if (acceptOnMatch) {\n      return Filter.ACCEPT;\n    }\n else {\n      return Filter.DENY;\n    }\n  }\n}\n",
            "docstring": "/** \n * Returns  {@link Filter#NEUTRAL} is there is no string match.\n */\n",
            "end_lineno": "120",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j.varia;\n\nimport org.apache.log4j.spi.Filter;\nimport org.apache.log4j.spi.LoggingEvent;\nimport org.apache.log4j.helpers.OptionConverter;\n\n/**\n * This is a very simple filter based on string matching.\n *\n * <p>The filter admits two options <b>StringToMatch</b> and\n * <b>AcceptOnMatch</b>. If there is a match between the value of the\n * StringToMatch option and the message of the {@link org.apache.log4j.spi.LoggingEvent},\n * then the {@link #decide(LoggingEvent)} method returns {@link org.apache.log4j.spi.Filter#ACCEPT} if\n * the <b>AcceptOnMatch</b> option value is true, if it is false then\n * {@link org.apache.log4j.spi.Filter#DENY} is returned. If there is no match, {@link\n * org.apache.log4j.spi.Filter#NEUTRAL} is returned.\n *\n * @author Ceki G&uuml;lc&uuml;\n * @since 0.9.0 \n */\npublic class StringMatchFilter extends Filter {\n  \n  /**\n     @deprecated Options are now handled using the JavaBeans paradigm.\n     This constant is not longer needed and will be removed in the\n     <em>near</em> term.\n   */\n  public static final String STRING_TO_MATCH_OPTION = \"StringToMatch\";\n\n  /**\n     @deprecated Options are now handled using the JavaBeans paradigm.\n     This constant is not longer needed and will be removed in the\n     <em>near</em> term.\n   */\n  public static final String ACCEPT_ON_MATCH_OPTION = \"AcceptOnMatch\";\n  \n  boolean acceptOnMatch = true;\n  String stringToMatch;\n  \n  /**\n     @deprecated We now use JavaBeans introspection to configure\n     components. Options strings are no longer needed.\n  */\n  public\n  String[] getOptionStrings() {\n    return new String[] {STRING_TO_MATCH_OPTION, ACCEPT_ON_MATCH_OPTION};\n  }\n\n  /**\n     @deprecated Use the setter method for the option directly instead\n     of the generic <code>setOption</code> method. \n  */\n  public\n  void setOption(String key, String value) { \n    \n    if(key.equalsIgnoreCase(STRING_TO_MATCH_OPTION)) {\n      stringToMatch = value;\n    } else if (key.equalsIgnoreCase(ACCEPT_ON_MATCH_OPTION)) {\n      acceptOnMatch = OptionConverter.toBoolean(value, acceptOnMatch);\n    }\n  }\n  \n  public\n  void setStringToMatch(String s) {\n    stringToMatch = s;\n  }\n  \n  public\n  String getStringToMatch() {\n    return stringToMatch;\n  }\n  \n  public\n  void setAcceptOnMatch(boolean acceptOnMatch) {\n    this.acceptOnMatch = acceptOnMatch;\n  }\n  \n  public\n  boolean getAcceptOnMatch() {\n    return acceptOnMatch;\n  }\n\n  /**\n     Returns {@link Filter#NEUTRAL} is there is no string match.\n   */\n  public\n  int decide(LoggingEvent event) {\n    String msg = event.getRenderedMessage();\n\n    if(msg == null ||  stringToMatch == null)\n      return Filter.NEUTRAL;\n    \n\n    if( msg.indexOf(stringToMatch) == -1 ) {\n      return Filter.NEUTRAL;\n    } else { // we've got a match\n      if(acceptOnMatch) {\n\treturn Filter.ACCEPT;\n      } else {\n\treturn Filter.DENY;\n      }\n    }\n  }\n}\n",
            "file_name": "StringMatchFilter.java",
            "human_label": "Return a decision based on the message generated by the event and whether the given string is matched.",
            "level": "project_runnable",
            "lineno": "100",
            "name": "decide",
            "oracle_context": "{ \"apis\" : \"[getRenderedMessage, indexOf]\", \"classes\" : \"[String, Filter]\", \"vars\" : \"[NEUTRAL, ACCEPT, DENY, stringToMatch, acceptOnMatch]\" }",
            "package": "org.apache.log4j.varia",
            "project": "logging-log4j1-main"
        },
        {
            "_id": "636767071a6d9265ec017962",
            "all_context": "{ \"class_level\" : \"import net.hasor.utils.BeanUtils;\\nimport java.beans.BeanInfo;\\nimport java.beans.IntrospectionException;\\nimport java.beans.Introspector;\\nimport java.beans.PropertyDescriptor;\\nimport java.lang.reflect.Constructor;\\nimport java.lang.reflect.InvocationTargetException;\\nimport java.lang.reflect.Method;\\nimport java.util.*;\\nObject bean;\\nMap<String,Method> readMethods;\\nMap<String,Method> writeMethods;\\nMap<String,Class<?>> types;\\nObject[] NULL_ARGUMENTS;\\nMap<Class<?>,Transformer> typeTransformers;\\nBeanMap owner;\\ncreateTypeTransformers();\\nBeanMap();\\nBeanMap(Object bean);\\nclone();\\nputAllWriteable(BeanMap map);\\nclear();\\ncontainsKey(Object name);\\ncontainsValue(Object value);\\nget(Object name);\\nput(String name,Object value);\\nsize();\\nkeySet();\\nentrySet();\\niterator();\\nvalues();\\ngetType(String name);\\nkeyIterator();\\nvalueIterator();\\nhasNext();\\nnext();\\nremove();\\nentryIterator();\\ngetBean();\\nsetBean(Object newBean);\\ngetReadMethod(String name);\\ngetWriteMethod(String name);\\ngetReadMethod(Object name);\\ngetWriteMethod(Object name);\\nreinitialise();\\ninitialise();\\nfirePropertyChange(Object key,Object oldValue,Object newValue);\\nEntry(BeanMap owner,String key,Object value);\\nsetValue(Object value);\\ncreateWriteMethodArguments(Method method,Object value);\\nconvertType(Class newType,Object value);\\ngetTypeTransformer(Class aType);\\nlogInfo(Exception ex);\\nlogWarn(Exception ex);\\ntoString();\\n\", \"repo_level\" : \"public interface BeanUtils {static Object getDefaultValue(Class returnType);\\nstatic Object[] getDefaultValue(Class<?>[] paramArray);\\nstatic Object invokeMethod(Object target,String methodName,Object objects);\\nstatic List<Field> findALLFields(Class target);\\nstatic List<Method> findALLMethods(Class target);\\nstatic List<Field> getFields(Class type);\\nstatic List<Method> getMethods(Class type);\\nstatic Field getField(String fieldName,Class type);\\nstatic Method getMethod(Class atClass,String name,Class<?>[] paramType);\\nstatic List<String> getPropertiesAndFields(Class target);\\nstatic List<String> getProperties(Class target);\\nstatic PropertyDescriptor[] getPropertyDescriptors(Class defineType);\\nstatic Method getReadMethod(String property,Class target);\\nstatic Method getWriteMethod(String property,Class target);\\nstatic boolean hasProperty(String propertyName,Class target);\\nstatic boolean hasField(String propertyName,Class target);\\nstatic boolean hasPropertyOrField(String name,Class target);\\nstatic boolean canReadProperty(String propertyName,Class target);\\nstatic boolean canReadPropertyOrField(String propertyName,Class target);\\nstatic boolean canWriteProperty(String propertyName,Class target);\\nstatic boolean canWriteField(String propertyName,Class target);\\nstatic boolean canWritePropertyOrField(String propertyName,Class target);\\nstatic boolean writeProperty(Object object,String attName,Object value);\\nstatic boolean writeField(Object object,String fieldName,Object value);\\nstatic boolean writePropertyOrField(Object object,String attName,Object value);\\nstatic Object readProperty(Object object,String attName);\\nstatic Object readField(Object object,String fieldName);\\nstatic Object readPropertyOrField(Object object,String attName);\\nstatic Class<?> getPropertyType(Class defineType,String attName);\\nstatic Class<?> getFieldType(Class defineType,String attName);\\nstatic Class<?> getPropertyOrFieldType(Class defineType,String attName);\\nstatic void copyProperties(Object dest,Object orig);\\nstatic void copyProperty(Object dest,Object orig,String propertyName);\\n }\\n\" }",
            "class_name": "BeanMap",
            "code": "public void putAllWriteable(BeanMap map){\n  Iterator<String> readableKeys=map.readMethods.keySet().iterator();\n  while (readableKeys.hasNext()) {\n    String key=readableKeys.next();\n    if (getWriteMethod(key) != null) {\n      this.put(key,map.get(key));\n    }\n  }\n}\n",
            "docstring": "/** \n * Puts all of the writable properties from the given BeanMap into this BeanMap. Read-only and Write-only properties will be ignored.\n * @param map  the BeanMap whose properties to put\n */\n",
            "end_lineno": "166",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.ref;\nimport net.hasor.utils.BeanUtils;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.*;\n\n/**\n * An implementation of Map for JavaBeans which uses introspection to\n * get and put properties in the bean.\n * <p>\n * If an exception occurs during attempts to get or set a property then the\n * property is considered non existent in the Map\n *\n * @version $Revision: 812176 $ $Date: 2009-09-07 15:59:25 +0100 (Mon, 07 Sep 2009) $\n *\n * @author James Strachan\n * @author Stephen Colebourne\n */\npublic class BeanMap extends AbstractMap<String, Object> implements Cloneable {\n    private transient    Object                     bean;\n    private transient    Map<String, Method>        readMethods      = new LinkedHashMap<>();\n    private transient    Map<String, Method>        writeMethods     = new LinkedHashMap<>();\n    private transient    Map<String, Class<?>>      types            = new LinkedHashMap<>();\n    /** An empty array.  Used to invoke accessors via reflection. */\n    public static final  Object[]                   NULL_ARGUMENTS   = {};\n    /**\n     * Maps primitive Class types to transformers.  The transformer\n     * transform strings into the appropriate primitive wrapper.\n     * N.B. private & unmodifiable replacement for the (public & static) defaultTransformers instance.\n     */\n    private static final Map<Class<?>, Transformer> typeTransformers = Collections.unmodifiableMap(createTypeTransformers());\n\n    private static Map<Class<?>, Transformer> createTypeTransformers() {\n        Map<Class<?>, Transformer> defaultTransformers = new HashMap<>();\n        defaultTransformers.put(Boolean.TYPE, input -> Boolean.valueOf(input.toString()));\n        defaultTransformers.put(Character.TYPE, input -> input.toString().charAt(0));\n        defaultTransformers.put(Byte.TYPE, input -> Byte.valueOf(input.toString()));\n        defaultTransformers.put(Short.TYPE, input -> Short.valueOf(input.toString()));\n        defaultTransformers.put(Integer.TYPE, input -> Integer.valueOf(input.toString()));\n        defaultTransformers.put(Long.TYPE, input -> Long.valueOf(input.toString()));\n        defaultTransformers.put(Float.TYPE, input -> Float.valueOf(input.toString()));\n        defaultTransformers.put(Double.TYPE, input -> Double.valueOf(input.toString()));\n        return defaultTransformers;\n    }\n    // Constructors\n    //-------------------------------------------------------------------------\n\n    /** Constructs a new empty <code>BeanMap</code>. */\n    public BeanMap() {\n    }\n\n    /**\n     * Constructs a new <code>BeanMap</code> that operates on the specified bean.\n     * If the given bean is <code>null</code>, then this map will be empty.\n     * @param bean  the bean for this map to operate on\n     */\n    public BeanMap(Object bean) {\n        this.bean = bean;\n        initialise();\n    }\n    // Map interface\n    //-------------------------------------------------------------------------\n\n    /**\n     * Renders a string representation of this object.\n     * @return a <code>String</code> representation of this object\n     */\n    public String toString() {\n        return \"BeanMap<\" + bean + \">\";\n    }\n\n    /**\n     * Clone this bean map using the following process: \n     * <ul>\n     * <li>If there is no underlying bean, return a cloned BeanMap without a bean.\n     *\n     * <li>Since there is an underlying bean, try to instantiate a new bean of\n     * the same type using Class.newInstance().\n     *\n     * <li>If the instantiation fails, throw a CloneNotSupportedException\n     *\n     * <li>Clone the bean map and set the newly instantiated bean as the\n     * underlying bean for the bean map.\n     *\n     * <li>Copy each property that is both readable and writable from the\n     * existing object to a cloned bean map.  \n     *\n     * <li>If anything fails along the way, throw a CloneNotSupportedException.\n     * <ul>\n     *\n     * @return a cloned instance of this bean map\n     * @throws CloneNotSupportedException if the underlying bean cannot be cloned\n     */\n    public Object clone() throws CloneNotSupportedException {\n        BeanMap newMap = (BeanMap) super.clone();\n        if (bean == null) {\n            // no bean, just an empty bean map at the moment.  return a newly\n            // cloned and empty bean map.\n            return newMap;\n        }\n        Object newBean = null;\n        Class<?> beanClass = bean.getClass(); // Cannot throw Exception\n        try {\n            newBean = beanClass.newInstance();\n        } catch (Exception e) {\n            // unable to instantiate\n            throw new CloneNotSupportedException(\"Unable to instantiate the underlying bean \\\"\" + beanClass.getName() + \"\\\": \" + e);\n        }\n        try {\n            newMap.setBean(newBean);\n        } catch (Exception exception) {\n            throw new CloneNotSupportedException(\"Unable to set bean in the cloned bean map: \" + exception);\n        }\n        try {\n            // copy only properties that are readable and writable.  If its\n            // not readable, we can't get the value from the old map.  If\n            // its not writable, we can't write a value into the new map.\n            Iterator<String> readableKeys = readMethods.keySet().iterator();\n            while (readableKeys.hasNext()) {\n                String key = readableKeys.next();\n                if (getWriteMethod(key) != null) {\n                    newMap.put(key, get(key));\n                }\n            }\n        } catch (Exception exception) {\n            throw new CloneNotSupportedException(\"Unable to copy bean values to cloned bean map: \" + exception);\n        }\n        return newMap;\n    }\n\n    /**\n     * Puts all of the writable properties from the given BeanMap into this\n     * BeanMap. Read-only and Write-only properties will be ignored.\n     * @param map  the BeanMap whose properties to put\n     */\n    public void putAllWriteable(BeanMap map) {\n        Iterator<String> readableKeys = map.readMethods.keySet().iterator();\n        while (readableKeys.hasNext()) {\n            String key = readableKeys.next();\n            if (getWriteMethod(key) != null) {\n                this.put(key, map.get(key));\n            }\n        }\n    }\n\n    /**\n     * This method reinitializes the bean map to have default values for the\n     * bean's properties.  This is accomplished by constructing a new instance\n     * of the bean which the map uses as its underlying data source.\n     * This behavior for <code>clear()</code> differs from the Map contract in that\n     * the mappings are not actually removed from the map (the mappings for a BeanMap are fixed).\n     */\n    public void clear() {\n        if (bean == null) {\n            return;\n        }\n        Class<?> beanClass = null;\n        try {\n            beanClass = bean.getClass();\n            bean = beanClass.newInstance();\n        } catch (Exception e) {\n            throw new UnsupportedOperationException(\"Could not create new instance of class: \" + beanClass);\n        }\n    }\n\n    /**\n     * Returns true if the bean defines a property with the given name. <p>\n     * The given name must be a <code>String</code>; if not, this method\n     * returns false. This method will also return false if the bean\n     * does not define a property with that name. <p>\n     * Write-only properties will not be matched as the test operates against property read methods.\n     *\n     * @param name  the name of the property to check\n     * @return false if the given name is null or is not a <code>String</code>;\n     *   false if the bean does not define a property with that name; or\n     *   true if the bean does define a property with that name\n     */\n    public boolean containsKey(Object name) {\n        Method method = getReadMethod(name);\n        return method != null;\n    }\n\n    /**\n     * Returns true if the bean defines a property whose current value is the given object.\n     * @param value  the value to check\n     * @return false  true if the bean has at least one property whose current value is that object, false otherwise\n     */\n    public boolean containsValue(Object value) {\n        // use default implementation\n        return super.containsValue(value);\n    }\n\n    /**\n     * Returns the value of the bean's property with the given name. <p>\n     * The given name must be a {@link String} and must not be \n     * null; otherwise, this method returns <code>null</code>.\n     * If the bean defines a property with the given name, the value of\n     * that property is returned.  Otherwise, <code>null</code> is returned. <p>\n     * Write-only properties will not be matched as the test operates against property read methods.\n     *\n     * @param name  the name of the property whose value to return\n     * @return the value of the property with that name\n     */\n    public Object get(Object name) {\n        if (bean != null) {\n            Method method = getReadMethod(name);\n            if (method != null) {\n                try {\n                    return method.invoke(bean, NULL_ARGUMENTS);\n                } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | NullPointerException e) {\n                    logWarn(e);\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Sets the bean property with the given name to the given value.\n     * @param name  the name of the property to set\n     * @param value  the value to set that property to\n     * @return the previous value of that property\n     * @throws IllegalArgumentException  if the given name is null; \n     *   if the given name is not a {@link String}; if the bean doesn't\n     *   define a property with that name; or if the bean property with that name is read-only\n     * @throws ClassCastException if an error occurs creating the method args\n     */\n    public Object put(String name, Object value) throws IllegalArgumentException, ClassCastException {\n        if (bean != null) {\n            Object oldValue = get(name);\n            Method method = getWriteMethod(name);\n            if (method == null) {\n                throw new IllegalArgumentException(\"The bean of type: \" + bean.getClass().getName() + \" has no property called: \" + name);\n            }\n            try {\n                Object[] arguments = createWriteMethodArguments(method, value);\n                method.invoke(bean, arguments);\n                Object newValue = get(name);\n                firePropertyChange(name, oldValue, newValue);\n            } catch (InvocationTargetException | IllegalAccessException e) {\n                logInfo(e);\n                throw new IllegalArgumentException(e.getMessage());\n            }\n            return oldValue;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the number of properties defined by the bean.\n     * @return the number of properties defined by the bean\n     */\n    public int size() {\n        return readMethods.size();\n    }\n\n    /**\n     * Get the keys for this BeanMap. <p>\n     * Write-only properties are <b>not</b> included in the returned set of\n     * property names, although it is possible to set their value and to get their type.\n     * @return BeanMap keys.  The Set returned by this method is not modifiable.\n     */\n    public Set<String> keySet() {\n        return Collections.unmodifiableSet(readMethods.keySet());\n    }\n\n    /**\n     * Gets a Set of MapEntry objects that are the mappings for this BeanMap. <p>\n     * Each MapEntry can be set but not removed.\n     * @return the unmodifiable set of mappings\n     */\n    public Set<Map.Entry<String, Object>> entrySet() {\n        return Collections.unmodifiableSet(new AbstractSet<Map.Entry<String, Object>>() {\n            public Iterator<Map.Entry<String, Object>> iterator() {\n                return entryIterator();\n            }\n\n            public int size() {\n                return BeanMap.this.readMethods.size();\n            }\n        });\n    }\n\n    /**\n     * Returns the values for the BeanMap.\n     * @return values for the BeanMap. The returned collection is not modifiable.\n     */\n    public Collection<Object> values() {\n        ArrayList<Object> answer = new ArrayList<>(readMethods.size());\n        for (Iterator<Object> iter = valueIterator(); iter.hasNext(); ) {\n            answer.add(iter.next());\n        }\n        return Collections.unmodifiableList(answer);\n    }\n    // Helper methods\n    //-------------------------------------------------------------------------\n\n    /**\n     * Returns the type of the property with the given name.\n     * @param name  the name of the property\n     * @return the type of the property, or <code>null</code> if no such property exists\n     */\n    public Class<?> getType(String name) {\n        return types.get(name);\n    }\n\n    /**\n     * Convenience method for getting an iterator over the keys. <p>\n     * Write-only properties will not be returned in the iterator.\n     * @return an iterator over the keys\n     */\n    public Iterator<String> keyIterator() {\n        return readMethods.keySet().iterator();\n    }\n\n    /**\n     * Convenience method for getting an iterator over the values.\n     * @return an iterator over the values\n     */\n    public Iterator<Object> valueIterator() {\n        final Iterator<String> iter = keyIterator();\n        return new Iterator<Object>() {\n            public boolean hasNext() {\n                return iter.hasNext();\n            }\n\n            public Object next() {\n                Object key = iter.next();\n                return get(key);\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException(\"remove() not supported for BeanMap\");\n            }\n        };\n    }\n\n    /**\n     * Convenience method for getting an iterator over the entries.\n     * @return an iterator over the entries\n     */\n    public Iterator<Map.Entry<String, Object>> entryIterator() {\n        final Iterator<String> iter = keyIterator();\n        return new Iterator<Map.Entry<String, Object>>() {\n            public boolean hasNext() {\n                return iter.hasNext();\n            }\n\n            public Map.Entry<String, Object> next() {\n                String key = iter.next();\n                Object value = get(key);\n                return new Entry(BeanMap.this, key, value);\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException(\"remove() not supported for BeanMap\");\n            }\n        };\n    }\n    // Properties\n    //-------------------------------------------------------------------------\n\n    /**\n     * Returns the bean currently being operated on.  The return value may be null if this map is empty.\n     * @return the bean being operated on by this map\n     */\n    public Object getBean() {\n        return bean;\n    }\n\n    /**\n     * Sets the bean to be operated on by this map.  The given value may be null, in which case this map will be empty.\n     * @param newBean  the new bean to operate on\n     */\n    public void setBean(Object newBean) {\n        bean = newBean;\n        reinitialise();\n    }\n\n    /**\n     * Returns the accessor for the property with the given name.\n     * @param name  the name of the property \n     * @return the accessor method for the property, or null\n     */\n    public Method getReadMethod(String name) {\n        return readMethods.get(name);\n    }\n\n    /**\n     * Returns the mutator for the property with the given name.\n     * @param name  the name of the property\n     * @return the mutator method for the property, or null\n     */\n    public Method getWriteMethod(String name) {\n        return writeMethods.get(name);\n    }\n    // Implementation methods\n    //-------------------------------------------------------------------------\n\n    /**\n     * Returns the accessor for the property with the given name.\n     * @param name  the name of the property \n     * @return null if the name is null; null if the name is not a {@link String};\n     *      null if no such property exists; or the accessor method for that property\n     */\n    protected Method getReadMethod(Object name) {\n        return readMethods.get(name);\n    }\n\n    /**\n     * Returns the mutator for the property with the given name.\n     * @param name  the name of the \n     * @return null if the name is null; null if the name is not a {@link String};\n     *      null if no such property exists; null if the property is read-only; or the mutator method for that property\n     */\n    protected Method getWriteMethod(Object name) {\n        return writeMethods.get(name);\n    }\n\n    /** Reinitializes this bean.  Called during {@link #setBean(Object)}. Does introspection to find properties. */\n    protected void reinitialise() {\n        readMethods.clear();\n        writeMethods.clear();\n        types.clear();\n        initialise();\n    }\n\n    private void initialise() {\n        if (getBean() == null) {\n            return;\n        }\n        Class<?> beanClass = getBean().getClass();\n        try {\n            Map<String, PropertyDescriptor> pd = new LinkedHashMap<>();\n            // \n            BeanInfo beanInfo = Introspector.getBeanInfo(beanClass);\n            PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();\n            BeanUtils.getProperties(beanClass).forEach(s -> pd.put(s, null));\n            if (propertyDescriptors != null) {\n                for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {\n                    pd.put(propertyDescriptor.getName(), propertyDescriptor);\n                }\n            }\n            // \n            pd.forEach((name, propertyDescriptor) -> {\n                if (propertyDescriptor == null) {\n                    return;\n                }\n                Method readMethod = propertyDescriptor.getReadMethod();\n                Method writeMethod = propertyDescriptor.getWriteMethod();\n                Class<?> aType = propertyDescriptor.getPropertyType();\n                if (readMethod != null) {\n                    readMethods.put(name, readMethod);\n                }\n                if (writeMethod != null) {\n                    writeMethods.put(name, writeMethod);\n                }\n                types.put(name, aType);\n            });\n        } catch (IntrospectionException e) {\n            logWarn(e);\n        }\n    }\n\n    /**\n     * Called during a successful {@link #put(String, Object)} operation.\n     * Default implementation does nothing.  Override to be notified of\n     * property changes in the bean caused by this map.\n     *\n     * @param key  the name of the property that changed\n     * @param oldValue  the old value for that property\n     * @param newValue  the new value for that property\n     */\n    protected void firePropertyChange(Object key, Object oldValue, Object newValue) {\n    }\n    // Implementation classes\n    //-------------------------------------------------------------------------\n\n    /** Map entry used by {@link BeanMap}. */\n    protected static class Entry extends AbstractMapEntry<String, Object> {\n        private BeanMap owner;\n\n        /**\n         * Constructs a new <code>Entry</code>.\n         * @param owner  the BeanMap this entry belongs to\n         * @param key  the key for this entry\n         * @param value  the value for this entry\n         */\n        protected Entry(BeanMap owner, String key, Object value) {\n            super(key, value);\n            this.owner = owner;\n        }\n\n        /**\n         * Sets the value.\n         * @param value  the new value for the entry\n         * @return the old value for the entry\n         */\n        public Object setValue(Object value) {\n            String key = getKey();\n            Object oldValue = owner.get(key);\n            owner.put(key, value);\n            super.value = owner.get(key);\n            return oldValue;\n        }\n    }\n\n    /**\n     * Creates an array of parameters to pass to the given mutator method.\n     * If the given object is not the right type to pass to the method \n     * directly, it will be converted using {@link #convertType(Class, Object)}.\n     *\n     * @param method  the mutator method\n     * @param value  the value to pass to the mutator method\n     * @return an array containing one object that is either the given value or a transformed value\n     * @throws IllegalAccessException if {@link #convertType(Class, Object)} raises it\n     * @throws IllegalArgumentException if any other exception is raised by {@link #convertType(Class, Object)}\n     * @throws ClassCastException if an error occurs creating the method args\n     */\n    protected Object[] createWriteMethodArguments(Method method, Object value) throws IllegalAccessException, ClassCastException {\n        try {\n            if (value != null) {\n                Class<?>[] types = method.getParameterTypes();\n                if (types != null && types.length > 0) {\n                    Class<?> paramType = types[0];\n                    if (!paramType.isAssignableFrom(value.getClass())) {\n                        value = convertType(paramType, value);\n                    }\n                }\n            }\n            Object[] answer = { value };\n            return answer;\n        } catch (InvocationTargetException | InstantiationException e) {\n            logInfo(e);\n            throw new IllegalArgumentException(e.getMessage());\n        }\n    }\n\n    /**\n     * Converts the given value to the given type.  First, reflection is\n     * is used to find a public constructor declared by the given class \n     * that takes one argument, which must be the precise type of the \n     * given value.  If such a constructor is found, a new object is\n     * created by passing the given value to that constructor, and the\n     * newly constructed object is returned.<P>\n     *\n     * If no such constructor exists, and the given type is a primitive\n     * type, then the given value is converted to a string using its \n     * {@link Object#toString() toString()} method, and that string is\n     * parsed into the correct primitive type using, for instance, \n     * {@link Integer#valueOf(String)} to convert the string into an\n     * <code>int</code>.<P>\n     *\n     * If no special constructor exists and the given type is not a \n     * primitive type, this method returns the original value.\n     *\n     * @param newType  the type to convert the value to\n     * @param value  the value to convert\n     * @return the converted value\n     * @throws NumberFormatException if newType is a primitive type, and \n     *  the string representation of the given value cannot be converted to that type\n     * @throws InstantiationException  if the constructor found with \n     *  reflection raises it\n     * @throws InvocationTargetException  if the constructor found with\n     *  reflection raises it\n     * @throws IllegalAccessException  never\n     * @throws IllegalArgumentException  never\n     */\n    protected Object convertType(Class<?> newType, Object value) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n        // try call constructor\n        Class<?>[] types = { value.getClass() };\n        try {\n            Constructor<?> constructor = newType.getConstructor(types);\n            Object[] arguments = { value };\n            return constructor.newInstance(arguments);\n        } catch (NoSuchMethodException e) {\n            // try using the transformers\n            Transformer transformer = getTypeTransformer(newType);\n            if (transformer != null) {\n                return transformer.transform(value);\n            }\n            return value;\n        }\n    }\n\n    /**\n     * Returns a transformer for the given primitive type.\n     *\n     * @param aType  the primitive type whose transformer to return\n     * @return a transformer that will convert strings into that type,\n     *  or null if the given type is not a primitive type\n     */\n    protected Transformer getTypeTransformer(Class<?> aType) {\n        return typeTransformers.get(aType);\n    }\n\n    /**\n     * Logs the given exception to <code>System.out</code>.  Used to display\n     * warnings while accessing/mutating the bean.\n     *\n     * @param ex  the exception to log\n     */\n    protected void logInfo(Exception ex) {\n        // Deliberately do not use LOG4J or Commons Logging to avoid dependencies\n        System.out.println(\"INFO: Exception: \" + ex);\n    }\n\n    /**\n     * Logs the given exception to <code>System.err</code>.  Used to display\n     * errors while accessing/mutating the bean.\n     *\n     * @param ex  the exception to log\n     */\n    protected void logWarn(Exception ex) {\n        // Deliberately do not use LOG4J or Commons Logging to avoid dependencies\n        System.out.println(\"WARN: Exception: \" + ex);\n        ex.printStackTrace();\n    }\n}\n",
            "file_name": "BeanMap.java",
            "human_label": "Put all of the both readable and writable methods from the given map to this map.",
            "level": "class_runnable",
            "lineno": "153",
            "name": "putAllWriteable",
            "oracle_context": "{ \"apis\" : \"[iterator, keySet, hasNext, next, getWriteMethod, put, get, BeanMap]\", \"classes\" : \"[Iterator<String>, String]\", \"vars\" : \"[readMethods]\" }",
            "package": "net.hasor.utils.ref",
            "project": "hasor-master"
        },
        {
            "_id": "636766f81a6d9265ec017748",
            "all_context": "{ \"class_level\" : \"import java.nio.charset.StandardCharsets;\\nimport java.security.NoSuchAlgorithmException;\\nString Base64Chars;\\nbase64EncodeFoArray(byte[] s);\\nbase64Decode(String s);\\nbase64DecodeToArray(String s);\\nencodeMD5(byte[] source);\\ngetMD5(String source);\\ngetMD5(byte[] source);\\nstr2HexStr(String str);\\nhexStr2Str(String hexStr);\\nbyte2HexStr(byte[] b);\\nhexStr2Bytes(String src);\\nstringToUnicode(String strText);\\nunicodeToString(String hex);\\nuniteBytes(String src0,String src1);\\nbase64Encode(String s);\\n\", \"repo_level\" : \"\" }",
            "class_name": "CommonCodeUtils",
            "code": "public static String base64Decode(final String s){\n  byte[] b=Base64.base64DecodeToArray(s);\n  if (b == null) {\n    return null;\n  }\n  if (b.length == 0) {\n    return \"\";\n  }\n  return new String(b,StandardCharsets.UTF_8);\n}\n",
            "docstring": "/** \n * Decoding a string to a string follow the Base64 regular. \n */\n",
            "end_lineno": "101",
            "file_content": "/*\n * Copyright 2008-2009 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils;\nimport java.nio.charset.StandardCharsets;\nimport java.security.NoSuchAlgorithmException;\n\n/**\n *\n * @version : 2012-6-21\n * @author  (zyc@hasor.net)\n */\npublic class CommonCodeUtils {\n    /**\n     * Base64js\n     * @version 2009-4-28\n     * @author  (zyc@hasor.net)\n     */\n    public static abstract class Base64 {\n        protected static final String Base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@*-\"; // supplement\n        /***/\n        //    /**Base64JSbase64/*/\n        //    public static Reader getJSReader() throws UnsupportedEncodingException {\n        //        return new InputStreamReader(Base64.class.getResourceAsStream(\"/META-INF/resource/util/base64.js\"), \"utf-8\");\n        //    };\n\n        /**\n         * UTF-8Base64\n         * @param s \n         * @return \n         */\n        public static String base64Encode(final String s) {\n            if (s == null || s.length() == 0) {\n                return s;\n            }\n            byte[] b = null;\n            b = s.getBytes(StandardCharsets.UTF_8);\n            return Base64.base64EncodeFoArray(b);\n        }\n\n        /** Encoding a byte array to a string follow the Base64 regular. */\n        public static String base64EncodeFoArray(final byte[] s) {\n            if (s == null) {\n                return null;\n            }\n            if (s.length == 0) {\n                return \"\";\n            }\n            StringBuffer buf = new StringBuffer();\n            int b0, b1, b2, b3;\n            int len = s.length;\n            int i = 0;\n            while (i < len) {\n                byte tmp = s[i++];\n                b0 = (tmp & 0xfc) >> 2;\n                b1 = (tmp & 0x03) << 4;\n                if (i < len) {\n                    tmp = s[i++];\n                    b1 |= (tmp & 0xf0) >> 4;\n                    b2 = (tmp & 0x0f) << 2;\n                    if (i < len) {\n                        tmp = s[i++];\n                        b2 |= (tmp & 0xc0) >> 6;\n                        b3 = tmp & 0x3f;\n                    } else {\n                        b3 = 64; // 1 byte \"-\" is supplement\n                    }\n                } else {\n                    b2 = b3 = 64;// 2 bytes \"-\" are supplement\n                }\n                buf.append(Base64.Base64Chars.charAt(b0));\n                buf.append(Base64.Base64Chars.charAt(b1));\n                buf.append(Base64.Base64Chars.charAt(b2));\n                buf.append(Base64.Base64Chars.charAt(b3));\n            }\n            return buf.toString();\n        }\n\n        /** Decoding a string to a string follow the Base64 regular. */\n        public static String base64Decode(final String s) {\n            byte[] b = Base64.base64DecodeToArray(s);\n            if (b == null) {\n                return null;\n            }\n            if (b.length == 0) {\n                return \"\";\n            }\n            return new String(b, StandardCharsets.UTF_8);\n        }\n\n        /** Decoding a string to a byte array follow the Base64 regular */\n        public static byte[] base64DecodeToArray(final String s) {\n            if (s == null) {\n                return null;\n            }\n            int len = s.length();\n            if (len == 0) {\n                return new byte[0];\n            }\n            if (len % 4 != 0) {\n                throw new IllegalArgumentException(s);\n            }\n            byte[] b = new byte[len / 4 * 3];\n            int i = 0, j = 0, e = 0, c, tmp;\n            while (i < len) {\n                c = Base64.Base64Chars.indexOf(s.charAt(i++));\n                tmp = c << 18;\n                c = Base64.Base64Chars.indexOf(s.charAt(i++));\n                tmp |= c << 12;\n                c = Base64.Base64Chars.indexOf(s.charAt(i++));\n                if (c < 64) {\n                    tmp |= c << 6;\n                    c = Base64.Base64Chars.indexOf(s.charAt(i++));\n                    if (c < 64) {\n                        tmp |= c;\n                    } else {\n                        e = 1;\n                    }\n                } else {\n                    e = 2;\n                    i++;\n                }\n                b[j + 2] = (byte) (tmp & 0xff);\n                tmp >>= 8;\n                b[j + 1] = (byte) (tmp & 0xff);\n                tmp >>= 8;\n                b[j + 0] = (byte) (tmp & 0xff);\n                j += 3;\n            }\n            if (e != 0) {\n                len = b.length - e;\n                byte[] copy = new byte[len];\n                System.arraycopy(b, 0, copy, 0, len);\n                return copy;\n            }\n            return b;\n        }\n    }\n\n    /**\n     * MD5\n     * @version : 2011-11-7\n     * @author  (zyc@hasor.net)\n     */\n    public static abstract class MD5 {\n        public static String encodeMD5(final byte[] source) throws NoSuchAlgorithmException {\n            String s = null;\n            //  16 \n            char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source);\n            byte tmp[] = md.digest(); // MD5  128  16 \n            char str[] = new char[16 * 2]; //  16  16  32 \n            int k = 0; // \n            for (int i = 0; i < 16; i++) { //  MD5  16 \n                byte byte0 = tmp[i]; //  i \n                str[k++] = hexDigits[byte0 >>> 4 & 0xf]; //  4 , >>> \n                str[k++] = hexDigits[byte0 & 0xf]; //  4 \n            }\n            s = new String(str); // \n            return s;\n        }\n\n        public static String getMD5(final String source) throws NoSuchAlgorithmException {\n            return MD5.getMD5(source.getBytes());\n        }\n\n        public static String getMD5(final byte[] source) throws NoSuchAlgorithmException {\n            String s = null;\n            //  16 \n            char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source);\n            byte tmp[] = md.digest(); // MD5  128  16 \n            char str[] = new char[16 * 2]; //  16  16  32 \n            int k = 0; // \n            for (int i = 0; i < 16; i++) { //  MD5  16 \n                byte byte0 = tmp[i]; //  i \n                str[k++] = hexDigits[byte0 >>> 4 & 0xf]; //  4 , >>> \n                str[k++] = hexDigits[byte0 & 0xf]; //  4 \n            }\n            s = new String(str); // \n            return s;\n        }\n    }\n\n    /**\n     * \n     * @version : 2013-8-13\n     * @author  (zyc@hasor.net)\n     */\n    public static abstract class HexConversion {\n        /**  */\n        public static String str2HexStr(final String str) {\n            char[] chars = \"0123456789ABCDEF\".toCharArray();\n            StringBuilder sb = new StringBuilder(\"\");\n            byte[] bs = str.getBytes();\n            int bit;\n            for (byte element : bs) {\n                bit = (element & 0x0f0) >> 4;\n                sb.append(chars[bit]);\n                bit = element & 0x0f;\n                sb.append(chars[bit]);\n            }\n            return sb.toString();\n        }\n\n        /**  */\n        public static String hexStr2Str(final String hexStr) {\n            String str = \"0123456789ABCDEF\";\n            char[] hexs = hexStr.toCharArray();\n            byte[] bytes = new byte[hexStr.length() / 2];\n            int n;\n            for (int i = 0; i < bytes.length; i++) {\n                n = str.indexOf(hexs[2 * i]) * 16;\n                n += str.indexOf(hexs[2 * i + 1]);\n                bytes[i] = (byte) (n & 0xff);\n            }\n            return new String(bytes);\n        }\n\n        /** bytes */\n        public static String byte2HexStr(final byte[] b) {\n            String hs = \"\";\n            String stmp = \"\";\n            for (byte element : b) {\n                stmp = Integer.toHexString(element & 0XFF);\n                if (stmp.length() == 1) {\n                    hs = hs + \"0\" + stmp;\n                } else {\n                    hs = hs + stmp;\n                    //if (n<b.length-1) hs=hs+\":\";\n                }\n            }\n            return hs.toUpperCase();\n        }\n\n        /** bytes */\n        public static byte[] hexStr2Bytes(final String src) {\n            int m = 0, n = 0;\n            int l = src.length() / 2;\n            //System.out.println(l);\n            byte[] ret = new byte[l];\n            for (int i = 0; i < l; i++) {\n                m = i * 2 + 1;\n                n = m + 1;\n                ret[i] = HexConversion.uniteBytes(src.substring(i * 2, m), src.substring(m, n));\n            }\n            return ret;\n        }\n\n        /** StringunicodeString */\n        public static String stringToUnicode(final String strText) throws Exception {\n            char c;\n            String strRet = \"\";\n            int intAsc;\n            String strHex;\n            for (int i = 0; i < strText.length(); i++) {\n                c = strText.charAt(i);\n                intAsc = c;\n                strHex = Integer.toHexString(intAsc);\n                if (intAsc > 128) {\n                    strRet += \"\\\\u\" + strHex;\n                } else {\n                    // 00\n                    strRet += \"\\\\u00\" + strHex;\n                }\n            }\n            return strRet;\n        }\n\n        /** unicodeStringString */\n        public static String unicodeToString(final String hex) {\n            int t = hex.length() / 6;\n            StringBuilder str = new StringBuilder();\n            for (int i = 0; i < t; i++) {\n                String s = hex.substring(i * 6, (i + 1) * 6);\n                // 00\n                String s1 = s.substring(2, 4) + \"00\";\n                // \n                String s2 = s.substring(4);\n                // 16stringint\n                int n = Integer.valueOf(s1, 16) + Integer.valueOf(s2, 16);\n                // int\n                char[] chars = Character.toChars(n);\n                str.append(new String(chars));\n            }\n            return str.toString();\n        }\n\n        private static byte uniteBytes(final String src0, final String src1) {\n            byte b0 = Byte.decode(\"0x\" + src0).byteValue();\n            b0 = (byte) (b0 << 4);\n            byte b1 = Byte.decode(\"0x\" + src1).byteValue();\n            byte ret = (byte) (b0 | b1);\n            return ret;\n        }\n    }\n}",
            "file_name": "CommonCodeUtils.java",
            "human_label": "Decoding a string follow the Base64 regular to an array,and return a string  constructed from the array according to UTF_8.",
            "level": "class_runnable",
            "lineno": "91",
            "name": "base64Decode",
            "oracle_context": "{ \"apis\" : \"[base64DecodeToArray]\", \"classes\" : \"[byte[], StandardCharsets]\", \"vars\" : \"[length, UTF_8]\" }",
            "package": "net.hasor.utils",
            "project": "hasor-master"
        },
        {
            "_id": "6367667d1a6d9265ec0173ff",
            "all_context": "{ \"class_level\" : \"import org.slf4j.Logger;\\nimport org.slf4j.LoggerFactory;\\nimport javax.servlet.http.HttpServletRequest;\\nimport javax.servlet.http.HttpServletResponse;\\nimport java.util.List;\\nimport java.util.concurrent.TimeUnit;\\nimport java.util.concurrent.atomic.AtomicBoolean;\\nimport static org.atmosphere.cpr.AtmosphereResourceImpl.METEOR;\\nimport static org.atmosphere.cpr.FrameworkConfig.ATMOSPHERE_RESOURCE;\\nLogger logger;\\nAtmosphereResource r;\\nObject o;\\nAtomicBoolean isDestroyed;\\nMeteor(AtmosphereResource r,List l,Serializer s);\\nbuild(HttpServletRequest r);\\nbuild(HttpServletRequest r,Serializer s);\\nbuild(HttpServletRequest req,List l,Serializer s);\\nbuild(HttpServletRequest req,SCOPE scope,List l,Serializer s);\\nsuspend(long l);\\nresumeOnBroadcast(boolean resumeOnBroadcast);\\ntransport();\\nsuspend(long timeout,TimeUnit timeunit);\\nresume();\\nbroadcast(Object o);\\nschedule(Object o,long period);\\ndelayBroadadcast(Object o,long period);\\ngetBroadcaster();\\nsetBroadcaster(Broadcaster b);\\nattachement();\\nattach(Object o);\\naddListener(AtmosphereResourceEventListener e);\\nremoveListener(AtmosphereResourceEventListener e);\\ndestroy();\\ndestroyed();\\ngetAtmosphereResource();\\ngetAtmosphereConfig();\\n\", \"repo_level\" : \"\" }",
            "class_name": "Meteor",
            "code": "public static Meteor lookup(HttpServletRequest r){\n  Object o=r.getAttribute(METEOR);\n  return o == null ? null : Meteor.class.isAssignableFrom(o.getClass()) ? (Meteor)o : null;\n}\n",
            "docstring": "/** \n * Retrieve an instance of  {@link Meteor} based on the {@link HttpServletRequest}.\n * @param r {@link HttpServletRequest}\n * @return a {@link Meteor} or null if not found\n */\n",
            "end_lineno": "74",
            "file_content": "/*\n * Copyright 2008-2022 Async-IO.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage org.atmosphere.cpr;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.atmosphere.cpr.AtmosphereResourceImpl.METEOR;\nimport static org.atmosphere.cpr.FrameworkConfig.ATMOSPHERE_RESOURCE;\n\n/**\n * A {@link Meteor} is a simple class that can be used from a {@link javax.servlet.Servlet}\n * to suspend, broadcast and resume responses. A {@link Meteor} can be created by invoking\n * the build() method.\n * <p><code>\n * Meteor.build(HttpServletRequest).suspend(-1);\n * </code></p><p>\n * A Meteor is usually created when an application needs to suspend a response.\n * A Meteor instance can then be cached and re-used later for either\n * broadcasting a message, or when an application needs to resume the\n * suspended response.\n *\n * @author Jeanfrancois Arcand\n */\npublic class Meteor {\n\n    private static final Logger logger = LoggerFactory.getLogger(Meteor.class);\n\n    private final AtmosphereResource r;\n    private Object o;\n    private final AtomicBoolean isDestroyed = new AtomicBoolean(false);\n\n    private Meteor(AtmosphereResource r,\n                   List<BroadcastFilter> l, Serializer s) {\n\n        this.r = r;\n        this.r.setSerializer(s);\n        if (l != null) {\n            for (BroadcastFilter f : l) {\n                this.r.getBroadcaster().getBroadcasterConfig().addFilter(f);\n            }\n        }\n    }\n\n    /**\n     * Retrieve an instance of {@link Meteor} based on the {@link HttpServletRequest}.\n     *\n     * @param r {@link HttpServletRequest}\n     * @return a {@link Meteor} or null if not found\n     */\n    public static Meteor lookup(HttpServletRequest r) {\n        Object o = r.getAttribute(METEOR);\n        return o == null ? null : Meteor.class.isAssignableFrom(o.getClass()) ? (Meteor) o : null;\n    }\n\n    /**\n     * Create a {@link Meteor} using the {@link HttpServletRequest}.\n     *\n     * @param r an {@link HttpServletRequest}\n     * @return a {@link Meteor} than can be used to resume, suspend and broadcast {@link Object}\n     */\n    public static Meteor build(HttpServletRequest r) {\n        return build(r, null);\n    }\n\n    /**\n     * Create a {@link Meteor} using the {@link HttpServletRequest} and use the\n     * {@link Serializer} for writing the result of a broadcast operation using\n     * the {@link HttpServletResponse}.\n     *\n     * @param r an {@link HttpServletRequest}\n     * @param s a {@link Serializer} used when writing broadcast events\n     * @return a {@link Meteor} than can be used to resume, suspend and broadcast {@link Object}\n     */\n    public static Meteor build(HttpServletRequest r, Serializer s) {\n        return build(r, null, s);\n    }\n\n    /**\n     * Create a {@link Meteor} using the {@link HttpServletRequest} and use a list of\n     * {@link BroadcastFilter} and {@link Serializer} for writing the result\n     * of a broadcast operation the {@link HttpServletResponse}.\n     *\n     * @param req an {@link HttpServletRequest}\n     * @param l   a list of {@link BroadcastFilter}\n     * @param s   a {@link Serializer} used when writing broadcast events\n     * @return a {@link Meteor} than can be used to resume, suspend and broadcast {@link Object}\n     */\n    public static Meteor build(HttpServletRequest req, List<BroadcastFilter> l, Serializer s) {\n        return build(req, Broadcaster.SCOPE.APPLICATION, l, s);\n    }\n\n    /**\n     * Create a {@link Meteor} using the {@link HttpServletRequest} and use a list of\n     * {@link BroadcastFilter} and {@link Serializer} for writing the result\n     * of a broadcast operation the {@link HttpServletResponse}.\n     *\n     * @param req   an {@link HttpServletRequest}\n     * @param scope the {@link Broadcaster.SCOPE}}\n     * @param l     a list of {@link BroadcastFilter}\n     * @param s     a {@link Serializer} used when writing broadcast events\n     * @return a {@link Meteor} than can be used to resume, suspend and broadcast {@link Object}\n     */\n    public static Meteor build(HttpServletRequest req, Broadcaster.SCOPE scope,\n                               List<BroadcastFilter> l, Serializer s) {\n        AtmosphereResource r =\n                (AtmosphereResource)\n                        req.getAttribute(ATMOSPHERE_RESOURCE);\n        if (r == null) throw new IllegalStateException(\"MeteorServlet not defined in web.xml\");\n\n        Broadcaster b;\n        if (scope == Broadcaster.SCOPE.REQUEST) {\n            try {\n                BroadcasterFactory f = r.getAtmosphereConfig().getBroadcasterFactory();\n                b = f.get(DefaultBroadcaster.class, DefaultBroadcaster.class.getSimpleName()\n                        + r.getAtmosphereConfig().uuidProvider().generateUuid());\n            } catch (Throwable t) {\n                throw new RuntimeException(t);\n            }\n            b.setScope(scope);\n            r.setBroadcaster(b);\n            req.setAttribute(AtmosphereResourceImpl.SKIP_BROADCASTER_CREATION, Boolean.TRUE);\n        }\n\n        Meteor m = new Meteor(r, l, (s != null ? s : r.getSerializer()));\n        req.setAttribute(METEOR, m);\n        return m;\n    }\n\n    /**\n     * Suspend the underlying {@link HttpServletResponse}. Passing a value of -1\n     * suspends the response forever.\n     *\n     * @param l the maximum time a response stay suspended\n     * @return {@link Meteor}\n     */\n    public Meteor suspend(long l) {\n        if (destroyed()) return null;\n        r.suspend(l);\n        return this;\n    }\n\n    /**\n     * Resume the Meteor after the first broadcast operation. This is useful when long-polling is used.\n     *\n     * @param resumeOnBroadcast\n     * @return this\n     */\n    public Meteor resumeOnBroadcast(boolean resumeOnBroadcast) {\n        r.resumeOnBroadcast(resumeOnBroadcast);\n        return this;\n    }\n\n    /**\n     * Return the current {@link org.atmosphere.cpr.AtmosphereResource.TRANSPORT}. The transport needs to be\n     * explicitly set by the client by adding the appropriate {@link HeaderConfig#X_ATMOSPHERE_TRANSPORT} value,\n     * which can be long-polling, streaming, websocket or JSONP.\n     *\n     * @return\n     */\n    public AtmosphereResource.TRANSPORT transport() {\n        return r.transport();\n    }\n\n    /**\n     * Suspend the underlying {@link HttpServletResponse}. Passing a value of -1\n     * suspends the response forever.\n     *\n     * @param timeout  the maximum time a response stay suspended\n     * @param timeunit The time unit of the timeout value\n     * @return {@link Meteor}\n     */\n\n    public Meteor suspend(long timeout, TimeUnit timeunit) {\n        if (destroyed()) return null;\n        r.suspend(timeout, timeunit);\n        return this;\n    }\n\n    /**\n     * Resume the underlying {@link HttpServletResponse}.\n     *\n     * @return {@link Meteor}\n     */\n    public Meteor resume() {\n        if (destroyed()) return null;\n        r.resume();\n        return this;\n    }\n\n    /**\n     * Broadcast an {@link Object} to all suspended responses.\n     *\n     * @param o an {@link Object}\n     * @return {@link Meteor}\n     */\n    public Meteor broadcast(Object o) {\n        if (destroyed()) return null;\n        r.getBroadcaster().broadcast(o);\n        return this;\n    }\n\n    /**\n     * Schedule a periodic broadcast, in seconds.\n     *\n     * @param o      an {@link Object}\n     * @param period period in seconds\n     * @return {@link Meteor}\n     */\n    public Meteor schedule(Object o, long period) {\n        if (destroyed()) return null;\n        r.getBroadcaster().scheduleFixedBroadcast(o, period, TimeUnit.SECONDS);\n        return this;\n    }\n\n    /**\n     * Schedule a delayed broadcast, in seconds.\n     *\n     * @param o      an {@link Object}\n     * @param period period in seconds\n     * @return {@link Meteor}\n     */\n    public Meteor delayBroadadcast(Object o, long period) {\n        if (destroyed()) return null;\n        r.getBroadcaster().delayBroadcast(o, period, TimeUnit.SECONDS);\n        return this;\n    }\n\n    /**\n     * Return the underlying {@link Broadcaster}.\n     *\n     * @return\n     */\n    public Broadcaster getBroadcaster() {\n        if (destroyed()) return null;\n        return r.getBroadcaster();\n    }\n\n    /**\n     * Set a {@link Broadcaster} instance.\n     *\n     * @param b\n     */\n    public void setBroadcaster(Broadcaster b) {\n        if (destroyed()) return;\n        r.setBroadcaster(b);\n    }\n\n    /**\n     * Return an {@link Object} with this {@link Meteor}.\n     *\n     * @return the {@link Object}\n     */\n    public Object attachement() {\n        return o;\n    }\n\n    /**\n     * Attach an {@link Object} with this {@link Meteor}.\n     *\n     * @return the {@link Object}\n     */\n    public void attach(Object o) {\n        this.o = o;\n    }\n\n    /**\n     * Add a {@link AtmosphereResourceEventListener} which gets invoked when\n     * responses are resuming, when the remote client closes the connection or\n     * when the a {@link Broadcaster#broadcast} operations occurs.\n     *\n     * @param e an instance of {@link AtmosphereResourceEventListener}\n     */\n    public Meteor addListener(AtmosphereResourceEventListener e) {\n        if (!destroyed()) {\n            r.addEventListener(e);\n        }\n        return this;\n    }\n\n    /**\n     * Remove a {@link AtmosphereResourceEventListener} which gets invoked when\n     * a response is resuming, when the remote client closes the connection or\n     * when the a {@link Broadcaster#broadcast} operations occurs.\n     *\n     * @param e an instance of {@link AtmosphereResourceEventListener}\n     */\n    public Meteor removeListener(AtmosphereResourceEventListener e) {\n        if (!destroyed()) {\n            r.removeEventListener(e);\n        }\n        return this;\n    }\n\n    /**\n     * Mark this instance as destroyed. No more operations will be allowed.\n     */\n    public void destroy() {\n        isDestroyed.set(true);\n    }\n\n    private boolean destroyed() {\n        if (isDestroyed.get()) {\n            logger.debug(\"This Meteor is destroyed and cannot be used.\");\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Return the underlying {@link AtmosphereResource}.\n     *\n     * @return the underlying {@link AtmosphereResource}\n     */\n    public AtmosphereResource getAtmosphereResource() {\n        return r;\n    }\n\n    /**\n     * Return the {@link org.atmosphere.cpr.AtmosphereConfig}\n     * @return the {@link org.atmosphere.cpr.AtmosphereConfig}\n     */\n    public AtmosphereConfig getAtmosphereConfig() {\n        return r.getAtmosphereConfig();\n    }\n}\n",
            "file_name": "Meteor.java",
            "human_label": "Return a Meteor object based on the HttpServletRequest r.",
            "level": "class_runnable",
            "lineno": "65",
            "name": "lookup",
            "oracle_context": "{ \"apis\" : \"[getAttribute, isAssignableFrom, getClass, Meteor]\", \"classes\" : \"[Object]\", \"vars\" : \"[]\" }",
            "package": "org.atmosphere.cpr",
            "project": "atmosphere-atmosphere-2.7.x"
        },
        {
            "_id": "636767691a6d9265ec0181a6",
            "all_context": "{ \"class_level\" : \"import java.nio.charset.Charset;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nimport java.util.Enumeration;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Locale;\\nimport java.util.Properties;\\nimport java.util.Set;\\nimport java.util.StringTokenizer;\\nimport java.util.TreeSet;\\nString FOLDER_SEPARATOR;\\nString WINDOWS_FOLDER_SEPARATOR;\\nString TOP_PATH;\\nString CURRENT_PATH;\\nchar EXTENSION_SEPARATOR;\\nCharset UTF_8;\\nStrings();\\nhasLength(String str);\\nhasText(CharSequence str);\\nhasText(String str);\\ncontainsWhitespace(CharSequence str);\\ncontainsWhitespace(String str);\\ntrimWhitespace(String str);\\ntrimWhitespace(CharSequence str);\\nclean(String str);\\nclean(CharSequence str);\\ntrimAllWhitespace(String str);\\ntrimLeadingWhitespace(String str);\\ntrimTrailingWhitespace(String str);\\ntrimLeadingCharacter(String str,char leadingCharacter);\\ntrimTrailingCharacter(String str,char trailingCharacter);\\nstartsWithIgnoreCase(String str,String prefix);\\nendsWithIgnoreCase(String str,String suffix);\\nsubstringMatch(CharSequence str,int index,CharSequence substring);\\ncountOccurrencesOf(String str,String sub);\\nreplace(String inString,String oldPattern,String newPattern);\\ndelete(String inString,String pattern);\\ndeleteAny(String inString,String charsToDelete);\\nquote(String str);\\nquoteIfString(Object obj);\\nunqualify(String qualifiedName);\\nunqualify(String qualifiedName,char separator);\\ncapitalize(String str);\\nuncapitalize(String str);\\nchangeFirstCharacterCase(String str,boolean capitalize);\\ngetFilename(String path);\\ngetFilenameExtension(String path);\\nstripFilenameExtension(String path);\\napplyRelativePath(String path,String relativePath);\\ncleanPath(String path);\\npathEquals(String path1,String path2);\\nparseLocaleString(String localeString);\\nvalidateLocalePart(String localePart);\\ntoLanguageTag(Locale locale);\\naddStringToArray(String[] array,String str);\\nconcatenateStringArrays(String[] array1,String[] array2);\\nmergeStringArrays(String[] array1,String[] array2);\\nsortStringArray(String[] array);\\ntoStringArray(Collection collection);\\ntoStringArray(Enumeration enumeration);\\ntrimArrayElements(String[] array);\\nremoveDuplicateStrings(String[] array);\\nsplit(String toSplit,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter);\\nsplitArrayElementsIntoProperties(String[] array,String delimiter,String charsToDelete);\\ntokenizeToStringArray(String str,String delimiters);\\ntokenizeToStringArray(String str,String delimiters,boolean trimTokens,boolean ignoreEmptyTokens);\\ndelimitedListToStringArray(String str,String delimiter);\\ndelimitedListToStringArray(String str,String delimiter,String charsToDelete);\\ncommaDelimitedListToStringArray(String str);\\ncommaDelimitedListToSet(String str);\\ncollectionToDelimitedString(Collection coll,String delim,String prefix,String suffix);\\ncollectionToDelimitedString(Collection coll,String delim);\\ncollectionToCommaDelimitedString(Collection coll);\\narrayToDelimitedString(Object[] arr,String delim);\\narrayToCommaDelimitedString(Object[] arr);\\nhasLength(CharSequence str);\\n\", \"repo_level\" : \"\" }",
            "class_name": "Strings",
            "code": "public static String[] split(String toSplit,String delimiter){\n  if (!hasLength(toSplit) || !hasLength(delimiter)) {\n    return null;\n  }\n  int offset=toSplit.indexOf(delimiter);\n  if (offset < 0) {\n    return null;\n  }\n  String beforeDelimiter=toSplit.substring(0,offset);\n  String afterDelimiter=toSplit.substring(offset + delimiter.length());\n  return new String[]{beforeDelimiter,afterDelimiter};\n}\n",
            "docstring": "/** \n * Split a String at the first occurrence of the delimiter. Does not include the delimiter in the result.\n * @param toSplit the string to split\n * @param delimiter to split the string up with\n * @return a two element array with index 0 being before the delimiter, andindex 1 being after the delimiter (neither element includes the delimiter); or <code>null</code> if the delimiter wasn't found in the given input String\n */\n",
            "end_lineno": "881",
            "file_content": "/*\n * Copyright (C) 2014 jsonwebtoken.io\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.jsonwebtoken.lang;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic final class Strings {\n\n    private static final String FOLDER_SEPARATOR = \"/\";\n\n    private static final String WINDOWS_FOLDER_SEPARATOR = \"\\\\\";\n\n    private static final String TOP_PATH = \"..\";\n\n    private static final String CURRENT_PATH = \".\";\n\n    private static final char EXTENSION_SEPARATOR = '.';\n\n    public static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    private Strings(){} //prevent instantiation\n\n    //---------------------------------------------------------------------\n    // General convenience methods for working with Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Check that the given CharSequence is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a CharSequence that purely consists of whitespace.\n     * <pre>\n     * Strings.hasLength(null) = false\n     * Strings.hasLength(\"\") = false\n     * Strings.hasLength(\" \") = true\n     * Strings.hasLength(\"Hello\") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not null and has length\n     * @see #hasText(String)\n     */\n    public static boolean hasLength(CharSequence str) {\n        return (str != null && str.length() > 0);\n    }\n\n    /**\n     * Check that the given String is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a String that purely consists of whitespace.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not null and has length\n     * @see #hasLength(CharSequence)\n     */\n    public static boolean hasLength(String str) {\n        return hasLength((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <pre>\n     * Strings.hasText(null) = false\n     * Strings.hasText(\"\") = false\n     * Strings.hasText(\" \") = false\n     * Strings.hasText(\"12345\") = true\n     * Strings.hasText(\" 12345 \") = true\n     * </pre>\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not <code>null</code>,\n     * its length is greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean hasText(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     * greater than 0, and it does not contain whitespace only\n     * @see #hasText(CharSequence)\n     */\n    public static boolean hasText(String str) {\n        return hasText((CharSequence) str);\n    }\n\n    /**\n     * Check whether the given CharSequence contains any whitespace characters.\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not empty and\n     * contains at least 1 whitespace character\n     * @see java.lang.Character#isWhitespace\n     */\n    public static boolean containsWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return false;\n        }\n        int strLen = str.length();\n        for (int i = 0; i < strLen; i++) {\n            if (Character.isWhitespace(str.charAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check whether the given String contains any whitespace characters.\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not empty and\n     * contains at least 1 whitespace character\n     * @see #containsWhitespace(CharSequence)\n     */\n    public static boolean containsWhitespace(String str) {\n        return containsWhitespace((CharSequence) str);\n    }\n\n    /**\n     * Trim leading and trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimWhitespace(String str) {\n        return (String) trimWhitespace((CharSequence)str);\n    }\n    \n    \n    private static CharSequence trimWhitespace(CharSequence str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        final int length = str.length();\n\n        int start = 0;\n\t\twhile (start < length && Character.isWhitespace(str.charAt(start))) {\n            start++;\n        }\n        \n\t\tint end = length;\n        while (start < length && Character.isWhitespace(str.charAt(end - 1))) {\n            end--;\n        }\n        \n        return ((start > 0) || (end < length)) ? str.subSequence(start, end) : str;\n    }\n\n    public static String clean(String str) {\n    \tCharSequence result = clean((CharSequence) str);\n        \n        return result!=null?result.toString():null;\n    }\n    \n    public static CharSequence clean(CharSequence str) {\n        str = trimWhitespace(str);\n        if (!hasLength(str)) {\n            return null;\n        }\n        return str;\n    }\n\n    /**\n     * Trim <i>all</i> whitespace from the given String:\n     * leading, trailing, and intermediate characters.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimAllWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        int index = 0;\n        while (sb.length() > index) {\n            if (Character.isWhitespace(sb.charAt(index))) {\n                sb.deleteCharAt(index);\n            }\n            else {\n                index++;\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim leading whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimLeadingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim trailing whitespace from the given String.\n     * @param str the String to check\n     * @return the trimmed String\n     * @see java.lang.Character#isWhitespace\n     */\n    public static String trimTrailingWhitespace(String str) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied leading character from the given String.\n     * @param str the String to check\n     * @param leadingCharacter the leading character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimLeadingCharacter(String str, char leadingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Trim all occurrences of the supplied trailing character from the given String.\n     * @param str the String to check\n     * @param trailingCharacter the trailing character to be trimmed\n     * @return the trimmed String\n     */\n    public static String trimTrailingCharacter(String str, char trailingCharacter) {\n        if (!hasLength(str)) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str);\n        while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n\n    /**\n     * Returns {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @param str the String to check\n     * @param prefix the prefix to look for\n     * @return {@code true} if the given string starts with the specified case-insensitive prefix, {@code false} otherwise.\n     * @see java.lang.String#startsWith\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null) {\n            return false;\n        }\n        if (str.startsWith(prefix)) {\n            return true;\n        }\n        if (str.length() < prefix.length()) {\n            return false;\n        }\n        String lcStr = str.substring(0, prefix.length()).toLowerCase();\n        String lcPrefix = prefix.toLowerCase();\n        return lcStr.equals(lcPrefix);\n    }\n\n    /**\n     * Returns {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @param str the String to check\n     * @param suffix the suffix to look for\n     * @return {@code true} if the given string ends with the specified case-insensitive suffix, {@code false} otherwise.\n     * @see java.lang.String#endsWith\n     */\n    public static boolean endsWithIgnoreCase(String str, String suffix) {\n        if (str == null || suffix == null) {\n            return false;\n        }\n        if (str.endsWith(suffix)) {\n            return true;\n        }\n        if (str.length() < suffix.length()) {\n            return false;\n        }\n\n        String lcStr = str.substring(str.length() - suffix.length()).toLowerCase();\n        String lcSuffix = suffix.toLowerCase();\n        return lcStr.equals(lcSuffix);\n    }\n\n    /**\n     * Returns {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     * @param str the original string (or StringBuilder)\n     * @param index the index in the original string to start matching against\n     * @param substring the substring to match at the given index\n     * @return {@code true} if the given string matches the given substring at the given index, {@code false} otherwise.\n     */\n    public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n        for (int j = 0; j < substring.length(); j++) {\n            int i = index + j;\n            if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the number of occurrences the substring {@code sub} appears in string {@code str}.\n     * @param str string to search in. Return 0 if this is null.\n     * @param sub string to search for. Return 0 if this is null.\n     * @return the number of occurrences the substring {@code sub} appears in string {@code str}.\n     */\n    public static int countOccurrencesOf(String str, String sub) {\n        if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n            return 0;\n        }\n        int count = 0;\n        int pos = 0;\n        int idx;\n        while ((idx = str.indexOf(sub, pos)) != -1) {\n            ++count;\n            pos = idx + sub.length();\n        }\n        return count;\n    }\n\n    /**\n     * Replace all occurrences of a substring within a string with\n     * another string.\n     * @param inString String to examine\n     * @param oldPattern String to replace\n     * @param newPattern String to insert\n     * @return a String with the replacements\n     */\n    public static String replace(String inString, String oldPattern, String newPattern) {\n        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        int pos = 0; // our position in the old string\n        int index = inString.indexOf(oldPattern);\n        // the index of an occurrence we've found, or -1\n        int patLen = oldPattern.length();\n        while (index >= 0) {\n            sb.append(inString.substring(pos, index));\n            sb.append(newPattern);\n            pos = index + patLen;\n            index = inString.indexOf(oldPattern, pos);\n        }\n        sb.append(inString.substring(pos));\n        // remember to append any characters to the right of a match\n        return sb.toString();\n    }\n\n    /**\n     * Delete all occurrences of the given substring.\n     * @param inString the original String\n     * @param pattern the pattern to delete all occurrences of\n     * @return the resulting String\n     */\n    public static String delete(String inString, String pattern) {\n        return replace(inString, pattern, \"\");\n    }\n\n    /**\n     * Delete any character in a given String.\n     * @param inString the original String\n     * @param charsToDelete a set of characters to delete.\n     * E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n     * @return the resulting String\n     */\n    public static String deleteAny(String inString, String charsToDelete) {\n        if (!hasLength(inString) || !hasLength(charsToDelete)) {\n            return inString;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < inString.length(); i++) {\n            char c = inString.charAt(i);\n            if (charsToDelete.indexOf(c) == -1) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with formatted Strings\n    //---------------------------------------------------------------------\n\n    /**\n     * Quote the given String with single quotes.\n     * @param str the input String (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or <code>null</code> if the input was <code>null</code>\n     */\n    public static String quote(String str) {\n        return (str != null ? \"'\" + str + \"'\" : null);\n    }\n\n    /**\n     * Turn the given Object into a String with single quotes\n     * if it is a String; keeping the Object as-is else.\n     * @param obj the input Object (e.g. \"myString\")\n     * @return the quoted String (e.g. \"'myString'\"),\n     * or the input object as-is if not a String\n     */\n    public static Object quoteIfString(Object obj) {\n        return (obj instanceof String ? quote((String) obj) : obj);\n    }\n\n    /**\n     * Unqualify a string qualified by a '.' dot character. For example,\n     * \"this.name.is.qualified\", returns \"qualified\".\n     * @param qualifiedName the qualified name\n     * @return an unqualified string by stripping all previous text before (and including) the last period character.\n     */\n    public static String unqualify(String qualifiedName) {\n        return unqualify(qualifiedName, '.');\n    }\n\n    /**\n     * Unqualify a string qualified by a separator character. For example,\n     * \"this:name:is:qualified\" returns \"qualified\" if using a ':' separator.\n     * @param qualifiedName the qualified name\n     * @param separator the separator\n     * @return an unqualified string by stripping all previous text before and including the last {@code separator} character.\n     */\n    public static String unqualify(String qualifiedName, char separator) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);\n    }\n\n    /**\n     * Capitalize a <code>String</code>, changing the first letter to\n     * upper case as per {@link Character#toUpperCase(char)}.\n     * No other letters are changed.\n     * @param str the String to capitalize, may be <code>null</code>\n     * @return the capitalized String, <code>null</code> if null\n     */\n    public static String capitalize(String str) {\n        return changeFirstCharacterCase(str, true);\n    }\n\n    /**\n     * Uncapitalize a <code>String</code>, changing the first letter to\n     * lower case as per {@link Character#toLowerCase(char)}.\n     * No other letters are changed.\n     * @param str the String to uncapitalize, may be <code>null</code>\n     * @return the uncapitalized String, <code>null</code> if null\n     */\n    public static String uncapitalize(String str) {\n        return changeFirstCharacterCase(str, false);\n    }\n\n    private static String changeFirstCharacterCase(String str, boolean capitalize) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder(str.length());\n        if (capitalize) {\n            sb.append(Character.toUpperCase(str.charAt(0)));\n        }\n        else {\n            sb.append(Character.toLowerCase(str.charAt(0)));\n        }\n        sb.append(str.substring(1));\n        return sb.toString();\n    }\n\n    /**\n     * Extract the filename from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"myfile.txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename, or <code>null</code> if none\n     */\n    public static String getFilename(String path) {\n        if (path == null) {\n            return null;\n        }\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);\n    }\n\n    /**\n     * Extract the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"txt\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the extracted filename extension, or <code>null</code> if none\n     */\n    public static String getFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return null;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return null;\n        }\n        return path.substring(extIndex + 1);\n    }\n\n    /**\n     * Strip the filename extension from the given path,\n     * e.g. \"mypath/myfile.txt\" -&gt; \"mypath/myfile\".\n     * @param path the file path (may be <code>null</code>)\n     * @return the path with stripped filename extension,\n     * or <code>null</code> if none\n     */\n    public static String stripFilenameExtension(String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);\n        if (extIndex == -1) {\n            return path;\n        }\n        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (folderIndex > extIndex) {\n            return path;\n        }\n        return path.substring(0, extIndex);\n    }\n\n    /**\n     * Apply the given relative path to the given path,\n     * assuming standard Java folder separation (i.e. \"/\" separators).\n     * @param path the path to start from (usually a full file path)\n     * @param relativePath the relative path to apply\n     * (relative to the full file path above)\n     * @return the full file path that results from applying the relative path\n     */\n    public static String applyRelativePath(String path, String relativePath) {\n        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n        if (separatorIndex != -1) {\n            String newPath = path.substring(0, separatorIndex);\n            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n                newPath += FOLDER_SEPARATOR;\n            }\n            return newPath + relativePath;\n        }\n        else {\n            return relativePath;\n        }\n    }\n\n    /**\n     * Normalize the path by suppressing sequences like \"path/..\" and\n     * inner simple dots.\n     * <p>The result is convenient for path comparison. For other uses,\n     * notice that Windows separators (\"\\\") are replaced by simple slashes.\n     * @param path the original path\n     * @return the normalized path\n     */\n    public static String cleanPath(String path) {\n        if (path == null) {\n            return null;\n        }\n        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);\n\n        // Strip prefix from path to analyze, to not treat it as part of the\n        // first path element. This is necessary to correctly parse paths like\n        // \"file:core/../core/io/Resource.class\", where the \"..\" should just\n        // strip the first \"core\" directory while keeping the \"file:\" prefix.\n        int prefixIndex = pathToUse.indexOf(\":\");\n        String prefix = \"\";\n        if (prefixIndex != -1) {\n            prefix = pathToUse.substring(0, prefixIndex + 1);\n            pathToUse = pathToUse.substring(prefixIndex + 1);\n        }\n        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {\n            prefix = prefix + FOLDER_SEPARATOR;\n            pathToUse = pathToUse.substring(1);\n        }\n\n        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);\n        List<String> pathElements = new LinkedList<String>();\n        int tops = 0;\n\n        for (int i = pathArray.length - 1; i >= 0; i--) {\n            String element = pathArray[i];\n            if (CURRENT_PATH.equals(element)) {\n                // Points to current directory - drop it.\n            }\n            else if (TOP_PATH.equals(element)) {\n                // Registering top path found.\n                tops++;\n            }\n            else {\n                if (tops > 0) {\n                    // Merging path element with element corresponding to top path.\n                    tops--;\n                }\n                else {\n                    // Normal path element found.\n                    pathElements.add(0, element);\n                }\n            }\n        }\n\n        // Remaining top paths need to be retained.\n        for (int i = 0; i < tops; i++) {\n            pathElements.add(0, TOP_PATH);\n        }\n\n        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);\n    }\n\n    /**\n     * Compare two paths after normalization of them.\n     * @param path1 first path for comparison\n     * @param path2 second path for comparison\n     * @return whether the two paths are equivalent after normalization\n     */\n    public static boolean pathEquals(String path1, String path2) {\n        return cleanPath(path1).equals(cleanPath(path2));\n    }\n\n    /**\n     * Parse the given <code>localeString</code> value into a {@link java.util.Locale}.\n     * <p>This is the inverse operation of {@link java.util.Locale#toString Locale's toString}.\n     * @param localeString the locale string, following <code>Locale's</code>\n     * <code>toString()</code> format (\"en\", \"en_UK\", etc);\n     * also accepts spaces as separators, as an alternative to underscores\n     * @return a corresponding <code>Locale</code> instance\n     */\n    public static Locale parseLocaleString(String localeString) {\n        String[] parts = tokenizeToStringArray(localeString, \"_ \", false, false);\n        String language = (parts.length > 0 ? parts[0] : \"\");\n        String country = (parts.length > 1 ? parts[1] : \"\");\n        validateLocalePart(language);\n        validateLocalePart(country);\n        String variant = \"\";\n        if (parts.length >= 2) {\n            // There is definitely a variant, and it is everything after the country\n            // code sans the separator between the country code and the variant.\n            int endIndexOfCountryCode = localeString.indexOf(country) + country.length();\n            // Strip off any leading '_' and whitespace, what's left is the variant.\n            variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));\n            if (variant.startsWith(\"_\")) {\n                variant = trimLeadingCharacter(variant, '_');\n            }\n        }\n        return (language.length() > 0 ? new Locale(language, country, variant) : null);\n    }\n\n    private static void validateLocalePart(String localePart) {\n        for (int i = 0; i < localePart.length(); i++) {\n            char ch = localePart.charAt(i);\n            if (ch != '_' && ch != ' ' && !Character.isLetterOrDigit(ch)) {\n                throw new IllegalArgumentException(\n                    \"Locale part \\\"\" + localePart + \"\\\" contains invalid characters\");\n            }\n        }\n    }\n\n    /**\n     * Determine the RFC 3066 compliant language tag,\n     * as used for the HTTP \"Accept-Language\" header.\n     * @param locale the Locale to transform to a language tag\n     * @return the RFC 3066 compliant language tag as String\n     */\n    public static String toLanguageTag(Locale locale) {\n        return locale.getLanguage() + (hasText(locale.getCountry()) ? \"-\" + locale.getCountry() : \"\");\n    }\n\n\n    //---------------------------------------------------------------------\n    // Convenience methods for working with String arrays\n    //---------------------------------------------------------------------\n\n    /**\n     * Append the given String to the given String array, returning a new array\n     * consisting of the input array contents plus the given String.\n     * @param array the array to append to (can be <code>null</code>)\n     * @param str the String to append\n     * @return the new array (never <code>null</code>)\n     */\n    public static String[] addStringToArray(String[] array, String str) {\n        if (Objects.isEmpty(array)) {\n            return new String[] {str};\n        }\n        String[] newArr = new String[array.length + 1];\n        System.arraycopy(array, 0, newArr, 0, array.length);\n        newArr[array.length] = str;\n        return newArr;\n    }\n\n    /**\n     * Concatenate the given String arrays into one,\n     * with overlapping array elements included twice.\n     * <p>The order of elements in the original arrays is preserved.\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] concatenateStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        String[] newArr = new String[array1.length + array2.length];\n        System.arraycopy(array1, 0, newArr, 0, array1.length);\n        System.arraycopy(array2, 0, newArr, array1.length, array2.length);\n        return newArr;\n    }\n\n    /**\n     * Merge the given String arrays into one, with overlapping\n     * array elements only included once.\n     * <p>The order of elements in the original arrays is preserved\n     * (with the exception of overlapping elements, which are only\n     * included on their first occurrence).\n     * @param array1 the first array (can be <code>null</code>)\n     * @param array2 the second array (can be <code>null</code>)\n     * @return the new array (<code>null</code> if both given arrays were <code>null</code>)\n     */\n    public static String[] mergeStringArrays(String[] array1, String[] array2) {\n        if (Objects.isEmpty(array1)) {\n            return array2;\n        }\n        if (Objects.isEmpty(array2)) {\n            return array1;\n        }\n        List<String> result = new ArrayList<String>();\n        result.addAll(Arrays.asList(array1));\n        for (String str : array2) {\n            if (!result.contains(str)) {\n                result.add(str);\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Turn given source String array into sorted array.\n     * @param array the source array\n     * @return the sorted array (never <code>null</code>)\n     */\n    public static String[] sortStringArray(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        Arrays.sort(array);\n        return array;\n    }\n\n    /**\n     * Copy the given Collection into a String array.\n     * The Collection must contain String elements only.\n     * @param collection the Collection to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Collection was <code>null</code>)\n     */\n    public static String[] toStringArray(Collection<String> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new String[collection.size()]);\n    }\n\n    /**\n     * Copy the given Enumeration into a String array.\n     * The Enumeration must contain String elements only.\n     * @param enumeration the Enumeration to copy\n     * @return the String array (<code>null</code> if the passed-in\n     * Enumeration was <code>null</code>)\n     */\n    public static String[] toStringArray(Enumeration<String> enumeration) {\n        if (enumeration == null) {\n            return null;\n        }\n        List<String> list = java.util.Collections.list(enumeration);\n        return list.toArray(new String[list.size()]);\n    }\n\n    /**\n     * Trim the elements of the given String array,\n     * calling <code>String.trim()</code> on each of them.\n     * @param array the original String array\n     * @return the resulting array (of the same size) with trimmed elements\n     */\n    public static String[] trimArrayElements(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return new String[0];\n        }\n        String[] result = new String[array.length];\n        for (int i = 0; i < array.length; i++) {\n            String element = array[i];\n            result[i] = (element != null ? element.trim() : null);\n        }\n        return result;\n    }\n\n    /**\n     * Remove duplicate Strings from the given array.\n     * Also sorts the array, as it uses a TreeSet.\n     * @param array the String array\n     * @return an array without duplicates, in natural sort order\n     */\n    public static String[] removeDuplicateStrings(String[] array) {\n        if (Objects.isEmpty(array)) {\n            return array;\n        }\n        Set<String> set = new TreeSet<String>();\n        for (String element : array) {\n            set.add(element);\n        }\n        return toStringArray(set);\n    }\n\n    /**\n     * Split a String at the first occurrence of the delimiter.\n     * Does not include the delimiter in the result.\n     * @param toSplit the string to split\n     * @param delimiter to split the string up with\n     * @return a two element array with index 0 being before the delimiter, and\n     * index 1 being after the delimiter (neither element includes the delimiter);\n     * or <code>null</code> if the delimiter wasn't found in the given input String\n     */\n    public static String[] split(String toSplit, String delimiter) {\n        if (!hasLength(toSplit) || !hasLength(delimiter)) {\n            return null;\n        }\n        int offset = toSplit.indexOf(delimiter);\n        if (offset < 0) {\n            return null;\n        }\n        String beforeDelimiter = toSplit.substring(0, offset);\n        String afterDelimiter = toSplit.substring(offset + delimiter.length());\n        return new String[] {beforeDelimiter, afterDelimiter};\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was null or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {\n        return splitArrayElementsIntoProperties(array, delimiter, null);\n    }\n\n    /**\n     * Take an array Strings and split each element based on the given delimiter.\n     * A <code>Properties</code> instance is then generated, with the left of the\n     * delimiter providing the key, and the right of the delimiter providing the value.\n     * <p>Will trim both the key and value before adding them to the\n     * <code>Properties</code> instance.\n     * @param array the array to process\n     * @param delimiter to split each element using (typically the equals symbol)\n     * @param charsToDelete one or more characters to remove from each element\n     * prior to attempting the split operation (typically the quotation mark\n     * symbol), or <code>null</code> if no removal should occur\n     * @return a <code>Properties</code> instance representing the array contents,\n     * or <code>null</code> if the array to process was <code>null</code> or empty\n     */\n    public static Properties splitArrayElementsIntoProperties(\n        String[] array, String delimiter, String charsToDelete) {\n\n        if (Objects.isEmpty(array)) {\n            return null;\n        }\n        Properties result = new Properties();\n        for (String element : array) {\n            if (charsToDelete != null) {\n                element = deleteAny(element, charsToDelete);\n            }\n            String[] splittedElement = split(element, delimiter);\n            if (splittedElement == null) {\n                continue;\n            }\n            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n        }\n        return result;\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * Trims tokens and omits empty tokens.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter).\n     * @return an array of the tokens\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    /**\n     * Tokenize the given String into a String array via a StringTokenizer.\n     * <p>The given delimiters string is supposed to consist of any number of\n     * delimiter characters. Each of those characters can be used to separate\n     * tokens. A delimiter is always a single character; for multi-character\n     * delimiters, consider using <code>delimitedListToStringArray</code>\n     * @param str the String to tokenize\n     * @param delimiters the delimiter characters, assembled as String\n     * (each of those characters is individually considered as delimiter)\n     * @param trimTokens trim the tokens via String's <code>trim</code>\n     * @param ignoreEmptyTokens omit empty tokens from the result array\n     * (only applies to tokens that are empty after trimming; StringTokenizer\n     * will not consider subsequent delimiters as token in the first place).\n     * @return an array of the tokens (<code>null</code> if the input String\n     * was <code>null</code>)\n     * @see java.util.StringTokenizer\n     * @see java.lang.String#trim()\n     * @see #delimitedListToStringArray\n     */\n    public static String[] tokenizeToStringArray(\n        String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n\n        if (str == null) {\n            return null;\n        }\n        StringTokenizer st = new StringTokenizer(str, delimiters);\n        List<String> tokens = new ArrayList<String>();\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (trimTokens) {\n                token = token.trim();\n            }\n            if (!ignoreEmptyTokens || token.length() > 0) {\n                tokens.add(token);\n            }\n        }\n        return toStringArray(tokens);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter) {\n        return delimitedListToStringArray(str, delimiter, null);\n    }\n\n    /**\n     * Take a String which is a delimited list and convert it to a String array.\n     * <p>A single delimiter can consists of more than one character: It will still\n     * be considered as single delimiter string, rather than as bunch of potential\n     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.\n     * @param str the input String\n     * @param delimiter the delimiter between elements (this is a single delimiter,\n     * rather than a bunch individual delimiter characters)\n     * @param charsToDelete a set of characters to delete. Useful for deleting unwanted\n     * line breaks: e.g. \"\\r\\n\\f\" will delete all new lines and line feeds in a String.\n     * @return an array of the tokens in the list\n     * @see #tokenizeToStringArray\n     */\n    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {\n        if (str == null) {\n            return new String[0];\n        }\n        if (delimiter == null) {\n            return new String[] {str};\n        }\n        List<String> result = new ArrayList<String>();\n        if (\"\".equals(delimiter)) {\n            for (int i = 0; i < str.length(); i++) {\n                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));\n            }\n        }\n        else {\n            int pos = 0;\n            int delPos;\n            while ((delPos = str.indexOf(delimiter, pos)) != -1) {\n                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));\n                pos = delPos + delimiter.length();\n            }\n            if (str.length() > 0 && pos <= str.length()) {\n                // Add rest of String, but not in case of empty input.\n                result.add(deleteAny(str.substring(pos), charsToDelete));\n            }\n        }\n        return toStringArray(result);\n    }\n\n    /**\n     * Convert a CSV list into an array of Strings.\n     * @param str the input String\n     * @return an array of Strings, or the empty array in case of empty input\n     */\n    public static String[] commaDelimitedListToStringArray(String str) {\n        return delimitedListToStringArray(str, \",\");\n    }\n\n    /**\n     * Convenience method to convert a CSV string list to a set.\n     * Note that this will suppress duplicates.\n     * @param str the input String\n     * @return a Set of String entries in the list\n     */\n    public static Set<String> commaDelimitedListToSet(String str) {\n        Set<String> set = new TreeSet<String>();\n        String[] tokens = commaDelimitedListToStringArray(str);\n        for (String token : tokens) {\n            set.add(token);\n        }\n        return set;\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @param prefix the String to start each element with\n     * @param suffix the String to end each element with\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {\n        if (Collections.isEmpty(coll)) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        Iterator<?> it = coll.iterator();\n        while (it.hasNext()) {\n            sb.append(prefix).append(it.next()).append(suffix);\n            if (it.hasNext()) {\n                sb.append(delim);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String collectionToDelimitedString(Collection<?> coll, String delim) {\n        return collectionToDelimitedString(coll, delim, \"\", \"\");\n    }\n\n    /**\n     * Convenience method to return a Collection as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param coll the Collection to display\n     * @return the delimited String\n     */\n    public static String collectionToCommaDelimitedString(Collection<?> coll) {\n        return collectionToDelimitedString(coll, \",\");\n    }\n\n    /**\n     * Convenience method to return a String array as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     */\n    public static String arrayToDelimitedString(Object[] arr, String delim) {\n        if (Objects.isEmpty(arr)) {\n            return \"\";\n        }\n        if (arr.length == 1) {\n            return Objects.nullSafeToString(arr[0]);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < arr.length; i++) {\n            if (i > 0) {\n                sb.append(delim);\n            }\n            sb.append(arr[i]);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convenience method to return a String array as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     * @param arr the array to display\n     * @return the delimited String\n     */\n    public static String arrayToCommaDelimitedString(Object[] arr) {\n        return arrayToDelimitedString(arr, \",\");\n    }\n\n}\n\n",
            "file_name": "Strings.java",
            "human_label": "Split the given string toSplit at the first occurrence of the given delimiter,and return two substrings that don't include the delimiter.",
            "level": "class_runnable",
            "lineno": "861",
            "name": "split",
            "oracle_context": "{ \"apis\" : \"[hasLength, indexOf, substring, length]\", \"classes\" : \"[String]\", \"vars\" : \"[]\" }",
            "package": "io.jsonwebtoken.lang",
            "project": "jjwt-master"
        },
        {
            "_id": "636767601a6d9265ec0180e2",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.*;\\nimport org.jgrapht.alg.util.*;\\nimport org.jgrapht.generate.*;\\nimport org.jgrapht.graph.*;\\nimport org.jgrapht.util.*;\\nimport java.util.*;\\nint n;\\nint m;\\nGraph<V,E> graph;\\nMap<V,Integer> vertices;\\nList<V> indices;\\nBoolean weaklyChordal;\\nGraphPath<V,E> certificate;\\nWeakChordalityInspector(Graph graph);\\nisWeaklyChordal();\\ngetCertificate();\\nlazyComputeWeakChordality();\\ncomputeGlobalSeparatorList();\\nreformatSeparatorList(List separators,E edge);\\ngetLabeling(E edge);\\nsortSeparatorsList(List separators);\\nunequalSeparators(List sep1,List sep2);\\ncomputeCoConnectedComponents(Graph graph,List separator);\\nputToNextBucket(Integer vertex,Integer vertexLabel,List bucketsByLabel,List labels);\\nreload(List bucketsByLabel,List labels,int minLabel);\\ncheckLabels(List coConnectedComponents,List separator);\\nfindHole(V sourceInSeparator,V source,V target,V targetInSeparator);\\nfindAntiHole(V source,V targetInSeparator);\\nfindHole(Graph graph,V sourceInSeparator,V source,V target,V targetInSeparator);\\nfindCycle(Set visited,Graph graph,V tarInSep,V tar,V sour,V sourInSep);\\nminimizeCycle(Graph graph,List cycle,V tar,V tarInSep,V sour,V sourInSep);\\nfindSeparators(Graph graph,E edge);\\ngetSeparator(Graph graph,V startVertex,Map dfsMap);\\nneighborhoodSetOf(Graph g,E edge);\\ninitMappings();\\n\", \"repo_level\" : \"\" }",
            "class_name": "WeakChordalityInspector",
            "code": "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n  List<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<>();\n  for (  E edge : graph.edgeSet()) {\n    V source=graph.getEdgeSource(edge);\n    V target=graph.getEdgeTarget(edge);\n    if (source != target) {\n      List<Set<V>> edgeSeparators=findSeparators(graph,edge);\n      globalSeparatorList.addAll(reformatSeparatorList(edgeSeparators,edge));\n    }\n  }\n  return globalSeparatorList;\n}\n",
            "docstring": "/** \n * Computes the global separator list of the  {@code graph}. More precisely, for every edge $e$ in the $G = (V, E)$ computes list of minimal separators $S_e$ in the neighborhood of $e$ and then concatenates these lists. Note: the result may contain duplicates\n * @return the list of minimal separators of every edge $e$ in the inspected graph\n */\n",
            "end_lineno": "241",
            "file_content": "/*\n * (C) Copyright 2018-2021, by Timofey Chudakov and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.alg.cycle;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.util.*;\nimport org.jgrapht.generate.*;\nimport org.jgrapht.graph.*;\nimport org.jgrapht.util.*;\n\nimport java.util.*;\n\n/**\n * Tests whether a graph is <a href=\"http://www.graphclasses.org/classes/gc_14.html\">weakly\n * chordal</a>. Weakly chordal graphs are also known as weakly triangulated graphs. Triangulated in\n * the context of chordality has a different meaning than triangulated in the context of planarity,\n * where it refers to a maximal planar graph, see:\n * <a href=\"http://mathworld.wolfram.com/TriangulatedGraph.html\">\n * http://mathworld.wolfram.com/TriangulatedGraph.html</a>\n * <p>\n * The following definitions of are equivalent:\n * <ol>\n * <li>A graph is weakly chordal (weakly triangulated) if neither it nor its complement contains a\n * <a href=\"http://mathworld.wolfram.com/ChordlessCycle.html\">chordless cycles</a> with five or more\n * vertices.</li>\n * <li>A 2-pair in a graph is a pair of non-adjacent vertices $x$, $y$ such that every chordless\n * path has exactly two edges. A graph is weakly chordal if every connected\n * <a href=\"https://en.wikipedia.org/wiki/Induced_subgraph\">induced subgraph</a> $H$ that is not a\n * complete graph, contains a 2-pair.</li>\n * </ol>\n * Chordal and weakly chordal graphs are\n * <a href=\"http://mathworld.wolfram.com/PerfectGraph.html\">perfect</a>.<br>\n * For more details, refer to: Hayward, R.B. Weakly triangulated graphs, Journal of Combinatorial\n * Theory, Series B, vol 39, Issue 3, pp 200-208, 1985.\n * <p>\n * The implementation in this class is based on: Lars Severin Skeide (2002)\n * <a href=\"http://www.ii.uib.no/~skeide/rec_wcg.pdf\"><i>Recognizing weakly chordal graphs</i></a>.\n * Candidate Scientist Thesis in Informatics. Department of Informatics, University of Bergen,\n * Norway. The terminology used in this implementation is consistent with the one used in this\n * thesis.\n * <p>\n * Both the runtime complexity and space complexity of the algorithm implemented in this class is\n * $\\mathcal{O}(|E|^2)$.<br>\n * The inspected {@code graph} is specified at the construction time and cannot be modified. When\n * the graph is modified externally, the behavior of the {@code WeakChordalityInspector} is\n * undefined.\n * <p>\n * In the case the inspected graph in not weakly chordal, this inspector provides a certificate in\n * the form of some <a href = \"http://graphclasses.org/smallgraphs.html#holes\">hole</a> or\n * <a href=\"http://graphclasses.org/smallgraphs.html#antiholes\">anti-hole</a>. The running time of\n * finding a hole is $\\mathcal{O}(|V| + |E|)$ and of finding an anti-hole - $\\mathcal{O}(|E|^2)$ in\n * the worst case.\n *\n * @param <V> the graph vertex type\n * @param <E> the graph edge type\n * @author Timofey Chudakov\n */\npublic class WeakChordalityInspector<V, E>\n{\n    /**\n     * Vertex number\n     */\n    private final int n;\n    /**\n     * Edge number\n     */\n    private final int m;\n    /**\n     * The inspected graph\n     */\n    private Graph<V, E> graph;\n    /**\n     * Bijective mapping of vertices onto $\\left[0,n-1\\right]$\n     */\n    private Map<V, Integer> vertices;\n    /**\n     * Inverse of the bijective mapping of vertices onto $\\left[0,n-1\\right]$\n     */\n    private List<V> indices;\n    /**\n     * Contains true if the graph is weakly chordal, otherwise false. Is null before the first call\n     * to the {@link WeakChordalityInspector#isWeaklyChordal()}.\n     */\n    private Boolean weaklyChordal = null;\n    /**\n     * Contains a hole or an anti-hole of the graph, if it isn't weakly chordal\n     */\n    private GraphPath<V, E> certificate;\n\n    /**\n     * Creates a weak chordality inspector for the {@code graph}\n     *\n     * @param graph the inspected {@code graph}\n     */\n    public WeakChordalityInspector(Graph<V, E> graph)\n    {\n        this.graph = Objects.requireNonNull(graph);\n        if (graph.getType().isDirected()) {\n            this.graph = new AsUndirectedGraph<>(graph);\n        }\n        n = graph.vertexSet().size();\n        m = graph.edgeSet().size();\n        initMappings();\n    }\n\n    /**\n     * Initializes the mappings of the vertices\n     */\n    private void initMappings()\n    {\n        VertexToIntegerMapping<V> mapping = new VertexToIntegerMapping<>(graph.vertexSet());\n        vertices = mapping.getVertexMap();\n        indices = mapping.getIndexList();\n    }\n\n    /**\n     * Check whether the inspected {@code graph} is weakly chordal. Note: this value is computed\n     * lazily.\n     *\n     * @return true, if the inspected {@code graph} is weakly chordal, otherwise false.\n     */\n    public boolean isWeaklyChordal()\n    {\n        return lazyComputeWeakChordality();\n    }\n\n    /**\n     * Computes and returns the certificate in the form of a hole or anti-hole in the inspected\n     * {@code graph}. Returns null if the inspected graph is weakly chordal. Note: certificate is\n     * computed lazily.\n     *\n     * @return a <a href=\"http://graphclasses.org/smallgraphs.html#holes\">hole</a> or\n     *         <a href=\"http://graphclasses.org/smallgraphs.html#antiholes\">anti-hole</a> in the\n     *         inspected {@code graph}, null if the {@code graph} is weakly chordal\n     */\n    public GraphPath<V, E> getCertificate()\n    {\n        lazyComputeWeakChordality();\n        return certificate;\n    }\n\n    /**\n     * Lazily tests the weak chordality of the {@code graph} and returns the computed value.\n     *\n     * @return true, if the inspected {@code graph} is weakly chordal, otherwise false.\n     */\n    private boolean lazyComputeWeakChordality()\n    {\n        if (weaklyChordal == null) {\n            List<Pair<List<Pair<Integer, Integer>>, E>> globalSeparatorList =\n                computeGlobalSeparatorList();\n\n            if (globalSeparatorList.size() > 0) {\n                Pair<Integer, Integer> pair;\n                sortSeparatorsList(globalSeparatorList);\n\n                // Iterating over separators. Computing coconnected components only for distinct\n                // separators\n                int separatorsNum = 1;\n                List<Pair<Integer, Integer>> original = globalSeparatorList.get(0).getFirst();\n                List<List<Integer>> coConnectedComponents =\n                    computeCoConnectedComponents(graph, original);\n\n                for (Pair<List<Pair<Integer, Integer>>, E> separator : globalSeparatorList) {\n                    if (unequalSeparators(original, separator.getFirst())) {\n                        original = separator.getFirst();\n                        ++separatorsNum;\n                        if (n + m < separatorsNum) {\n                            return weaklyChordal = false;\n                        } else {\n                            coConnectedComponents = computeCoConnectedComponents(graph, original);\n                        }\n                    }\n                    if ((pair = checkLabels(coConnectedComponents, separator.getFirst())) != null) {\n                        // Found a pair of vertices which has labels 1 and 2. This means the graph\n                        // isn't weakly chordal. Start detecting a hole\n                        E holeFormer = separator.getSecond();\n                        V source = graph.getEdgeSource(holeFormer);\n                        V target = graph.getEdgeTarget(holeFormer);\n\n                        V sourceInSeparator = indices.get(pair.getFirst());\n                        V targetInSeparator = indices.get(pair.getSecond());\n\n                        if (!graph.containsEdge(source, sourceInSeparator)) {\n                            V t = sourceInSeparator;\n                            sourceInSeparator = targetInSeparator;\n                            targetInSeparator = t;\n                        }\n                        if (graph.containsEdge(sourceInSeparator, targetInSeparator)) {\n                            findAntiHole(source, targetInSeparator);\n                        } else {\n                            findHole(sourceInSeparator, source, target, targetInSeparator);\n                        }\n                        return weaklyChordal = false;\n                    }\n                }\n\n                return weaklyChordal = true;\n            } else {\n\n                return weaklyChordal = true;\n            }\n        }\n        return weaklyChordal;\n    }\n\n    /**\n     * Computes the global separator list of the {@code graph}. More precisely, for every edge $e$\n     * in the $G = (V, E)$ computes list of minimal separators $S_e$ in the neighborhood of $e$ and\n     * then concatenates these lists. Note: the result may contain duplicates\n     *\n     * @return the list of minimal separators of every edge $e$ in the inspected graph\n     */\n    private List<Pair<List<Pair<Integer, Integer>>, E>> computeGlobalSeparatorList()\n    {\n        List<Pair<List<Pair<Integer, Integer>>, E>> globalSeparatorList = new ArrayList<>();\n        for (E edge : graph.edgeSet()) {\n            V source = graph.getEdgeSource(edge);\n            V target = graph.getEdgeTarget(edge);\n            if (source != target) {\n                List<Set<V>> edgeSeparators = findSeparators(graph, edge);\n                globalSeparatorList.addAll(reformatSeparatorList(edgeSeparators, edge));\n            }\n        }\n        return globalSeparatorList;\n    }\n\n    /**\n     * Reformats the list o {@code separators} so that is can be conveniently used by this\n     * inspector. More precisely, in every separator from the list of minimal separators in the\n     * neighborhood of the {@code edge} substitutes all vertices for their indices in the numeration\n     * defined by {@code vertices}. Pairs every separator with the {@code edge}.\n     *\n     * @param separators the list of minimal separators in the neighborhood of the {@code edge}\n     * @param edge the edge, which neighborhood contains minimal separators from {@code separators}\n     * @return the reformatted list of minimal separators\n     */\n    private List<Pair<List<Pair<Integer, Integer>>, E>> reformatSeparatorList(\n        List<Set<V>> separators, E edge)\n    {\n        List<Integer> labeling = getLabeling(edge);\n        List<Pair<List<Pair<Integer, Integer>>, E>> reformattedSeparators = new ArrayList<>();\n        List<List<List<Pair<Integer, Integer>>>> vInSeparator = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            vInSeparator.add(new ArrayList<>());\n        }\n\n        for (Set<V> computedSeparator : separators) {\n            List<Pair<Integer, Integer>> reformattedSeparator =\n                new ArrayList<>(computedSeparator.size());\n            reformattedSeparators.add(new Pair<>(reformattedSeparator, edge));\n            for (V vertex : computedSeparator) {\n                int vertexIndex = vertices.get(vertex);\n                vInSeparator.get(vertexIndex).add(reformattedSeparator);\n            }\n        }\n\n        for (int vertex = 0; vertex < n; vertex++) {\n            List<List<Pair<Integer, Integer>>> listOfSeparators = vInSeparator.get(vertex);\n            for (List<Pair<Integer, Integer>> separator : listOfSeparators) {\n                separator.add(new Pair<>(vertex, labeling.get(vertex)));\n            }\n        }\n\n        return reformattedSeparators;\n\n    }\n\n    /**\n     * Computes the labeling of the neighborhood of {@code edge} on the vertices {@code source} and\n     * {@code target}. Vertex from the neighborhood is labeled with \"1\" if it sees only\n     * {@code source}, \"2\" is it sees only {@code target}, and \"3\" if it sees both vertices.\n     *\n     * @param edge the edge, whose neighborhood is to be labeled\n     * @return the computed labeling with the respect to the rule described above\n     */\n    private List<Integer> getLabeling(E edge)\n    {\n        V source = graph.getEdgeSource(edge);\n        V target = graph.getEdgeTarget(edge);\n        List<Integer> labeling = new ArrayList<>(Collections.nCopies(n, null));\n        for (E sourceEdge : graph.edgesOf(source)) {\n            labeling.set(vertices.get(Graphs.getOppositeVertex(graph, sourceEdge, source)), 1);\n        }\n        for (E targetEdge : graph.edgesOf(target)) {\n            Integer oppositeIndex =\n                vertices.get(Graphs.getOppositeVertex(graph, targetEdge, target));\n            if (labeling.get(oppositeIndex) != null) {\n                labeling.set(oppositeIndex, 3);\n            } else {\n                labeling.set(oppositeIndex, 2);\n            }\n        }\n        return labeling;\n    }\n\n    /**\n     * Sorts the {@code separators} using bucket sort\n     *\n     * @param separators the list of separators to be sorted\n     */\n    private void sortSeparatorsList(List<Pair<List<Pair<Integer, Integer>>, E>> separators)\n    {\n        Queue<Pair<List<Pair<Integer, Integer>>, E>> mainQueue = new ArrayDeque<>();\n        int maxSeparatorLength = 0;\n        for (Pair<List<Pair<Integer, Integer>>, E> separator : separators) {\n            if (separator.getFirst().size() > maxSeparatorLength) {\n                maxSeparatorLength = separator.getFirst().size();\n            }\n            mainQueue.add(separator);\n        }\n        separators.clear();\n        List<Queue<Pair<List<Pair<Integer, Integer>>, E>>> queues = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            queues.add(new LinkedList<>());\n        }\n        for (int i = 0; i < maxSeparatorLength; i++) {\n            while (!mainQueue.isEmpty()) {\n                Pair<List<Pair<Integer, Integer>>, E> separator = mainQueue.remove();\n                if (i >= separator.getFirst().size()) {\n                    separators.add(separator);\n                } else {\n                    queues\n                        .get(\n                            separator\n                                .getFirst().get(separator.getFirst().size() - i - 1).getFirst())\n                        .add(separator);\n                }\n            }\n            for (Queue<Pair<List<Pair<Integer, Integer>>, E>> queue : queues) {\n                mainQueue.addAll(queue);\n                queue.clear();\n            }\n        }\n        separators.addAll(mainQueue);\n    }\n\n    /**\n     * Compares two separators for inequality. Labeling of the vertices in the separators isn't\n     * considered\n     *\n     * @param sep1 first separator\n     * @param sep2 second separator\n     * @return true, if the separators are unequal, false otherwise\n     */\n    private boolean unequalSeparators(\n        List<Pair<Integer, Integer>> sep1, List<Pair<Integer, Integer>> sep2)\n    {\n        if (sep1.size() == sep2.size()) {\n            for (int i = 0; i < sep1.size(); i++) {\n                if (!sep2.get(i).getFirst().equals(sep1.get(i).getFirst())) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Computes the connected components of the complement of the graph induces by the vertices of\n     * the {@code separator}. They are also called \"coconnected components\". The running time is\n     * $\\mathcal{O}(|V| + |E|)$.\n     *\n     * @param separator the separators, whose coconnected components are computed\n     * @return the coconected of the {@code separator}\n     */\n    private List<List<Integer>> computeCoConnectedComponents(\n        Graph<V, E> graph, List<Pair<Integer, Integer>> separator)\n    {\n        List<List<Integer>> coConnectedComponents = new ArrayList<>();\n\n        // Initializing buckets, labels and set of unvisited vertices. Every vertex in separator is\n        // put\n        // to bucket with label 0\n        List<Set<Integer>> bucketsByLabel = new ArrayList<>(separator.size());\n        for (int i = 0; i < separator.size(); i++) {\n            bucketsByLabel.add(new HashSet<>());\n        }\n        List<Integer> labels = new ArrayList<>(Collections.nCopies(n, -1));\n        Set<Integer> unvisited = CollectionUtil.newHashSetWithExpectedSize(separator.size());\n        separator.forEach(pair -> {\n            unvisited.add(pair.getFirst());\n            labels.set(pair.getFirst(), 0);\n        });\n        bucketsByLabel.set(0, unvisited);\n        int minLabel = 0;\n\n        while (unvisited.size() > 0) {\n            List<Integer> coConnectedComponent = new ArrayList<>();\n            do {\n                // When minLabel = coConnectedComponent.size(), we've visited all vertices in some\n                // coconnected component in the separator. If there exist unvisited vertices, we\n                // start again\n                while (!bucketsByLabel.get(minLabel).isEmpty()) {\n                    Integer vertex = bucketsByLabel.get(minLabel).iterator().next();\n                    bucketsByLabel.get(minLabel).remove(vertex);\n                    coConnectedComponent.add(vertex);\n                    labels.set(vertex, -1);\n\n                    for (E edge : graph.edgesOf(indices.get(vertex))) {\n                        Integer opposite = vertices\n                            .get(Graphs.getOppositeVertex(graph, edge, indices.get(vertex)));\n                        Integer oppositeLabel = labels.get(opposite);\n                        if (oppositeLabel != -1) {\n                            putToNextBucket(opposite, oppositeLabel, bucketsByLabel, labels);\n                        }\n                    }\n                }\n                ++minLabel;\n            } while (minLabel != coConnectedComponent.size());\n            reload(bucketsByLabel, labels, minLabel);\n\n            coConnectedComponents.add(coConnectedComponent);\n            minLabel = 0;\n        }\n        return coConnectedComponents;\n    }\n\n    /**\n     * Moves the {@code vertex} to the next bucket.\n     *\n     * @param vertex the vertex to be moved\n     * @param vertexLabel the label of the {@code vertex}\n     * @param bucketsByLabel the buckets, in which vertices are stored\n     * @param labels the labels of the vertices\n     */\n    private void putToNextBucket(\n        Integer vertex, Integer vertexLabel, List<Set<Integer>> bucketsByLabel,\n        List<Integer> labels)\n    {\n        bucketsByLabel.get(vertexLabel).remove(vertex);\n        bucketsByLabel.get(vertexLabel + 1).add(vertex);\n        labels.set(vertex, vertexLabel + 1);\n    }\n\n    /**\n     * Moves all vertices from the bucket with label {@code minLabel} to the bucket with label 0.\n     * Clears the bucket with label {@code minLabel}. Updates the labeling accordingly.\n     *\n     * @param bucketsByLabel the buckets vertices are stored in\n     * @param labels the labels of the vertices\n     * @param minLabel the minimum value of the non-empty bucket\n     */\n    private void reload(List<Set<Integer>> bucketsByLabel, List<Integer> labels, int minLabel)\n    {\n        if (minLabel != 0 && minLabel < bucketsByLabel.size()) {\n            Set<Integer> bucket = bucketsByLabel.get(minLabel);\n            for (Integer vertex : bucket) {\n                labels.set(vertex, 0);\n                bucketsByLabel.get(0).add(vertex);\n            }\n            bucket.clear();\n        }\n    }\n\n    /**\n     * For a given coconnected component of the {@code separator} checks whether every vertex in it\n     * is seen by al least one vertex of the edge that is separated by the {@code separator}\n     *\n     * @param coConnectedComponents the set of the coconected components of the {@code separator}\n     * @param separator minimal separator of some edge in the {@code graph}\n     * @return true if the condition described above holds, false otherwise\n     */\n    private Pair<Integer, Integer> checkLabels(\n        List<List<Integer>> coConnectedComponents, List<Pair<Integer, Integer>> separator)\n    {\n        List<Integer> vertexLabels = new ArrayList<>(Collections.nCopies(n, null));\n        for (Pair<Integer, Integer> vertexAndLabel : separator) {\n            vertexLabels.set(vertexAndLabel.getFirst(), vertexAndLabel.getSecond());\n        }\n        for (List<Integer> coConnectedComponent : coConnectedComponents) {\n            int label = 0;\n            Integer labelVertex = null;\n            for (Integer vertex : coConnectedComponent) {\n                if (vertexLabels.get(vertex) != 3) {\n                    if (label != 0) {\n                        if (label != vertexLabels.get(vertex)) {\n                            return new Pair<>(labelVertex, vertex);\n                        }\n                    } else {\n                        label = vertexLabels.get(vertex);\n                        labelVertex = vertex;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Finds a hole in the inspected {@code graph}. Vertices {@code sourceInSeparator},\n     * {@code source}, {@code target} and {@code targetInSeparator} belong to the computes hole.\n     * They are used to correctly find a hole in the inspected graph.\n     *\n     * @param sourceInSeparator vertex on the hole\n     * @param source vertex on the hole\n     * @param target vertex on the hole\n     * @param targetInSeparator vertex on the hole\n     */\n    private void findHole(V sourceInSeparator, V source, V target, V targetInSeparator)\n    {\n        this.certificate = findHole(graph, sourceInSeparator, source, target, targetInSeparator);\n    }\n\n    /**\n     * Finds an anti-hole in the inspected {@code graph}. Vertices {@code source} and\n     * {@code targetInSeparator} specify an edge, which belongs to the anti-hole in the complement\n     * of the {@code graph}. Then the hole in the complement of the graph is computed in the graph's\n     * complement in the same way a hole is computed in the {@code graph}.\n     *\n     * @param source endpoint of the edge that belongs to the anti-hole\n     * @param targetInSeparator endpoint of the edge that belongs to the anti-hole\n     */\n    private void findAntiHole(V source, V targetInSeparator)\n    {\n        // Generating the complement of the inspected graph\n        ComplementGraphGenerator<V, E> generator = new ComplementGraphGenerator<>(graph, false);\n        Graph<V, E> complement = Pseudograph.<V, E> createBuilder(graph.getEdgeSupplier()).build();\n        generator.generateGraph(complement);\n\n        E cycleFormer = complement.getEdge(source, targetInSeparator);\n        V cycleSource = graph.getEdgeSource(cycleFormer);\n        V cycleTarget = graph.getEdgeTarget(cycleFormer);\n\n        // For edge cycleFormer we need to find the separator, which contains vertices with labels 1\n        // and 2\n        // After that the procedure of detecting a hole in the complement of the graph is identical\n        // to finding a hole in the graph itself\n        List<Set<V>> separators = findSeparators(complement, cycleFormer);\n        List<Pair<List<Pair<Integer, Integer>>, E>> reformatted =\n            reformatSeparatorList(separators, cycleFormer);\n\n        sortSeparatorsList(reformatted);\n\n        List<Pair<Integer, Integer>> original = reformatted.get(0).getFirst();\n        List<List<Integer>> coConnectedComponents =\n            computeCoConnectedComponents(complement, original);\n\n        Pair<Integer, Integer> pair;\n        for (Pair<List<Pair<Integer, Integer>>, E> separator : reformatted) {\n            if (unequalSeparators(separator.getFirst(), original)) {\n                original = separator.getFirst();\n                coConnectedComponents =\n                    computeCoConnectedComponents(complement, separator.getFirst());\n            }\n            if ((pair = checkLabels(coConnectedComponents, separator.getFirst())) != null) {\n                // Found a pair of vertices with labels 1 and 2\n                V cycleSourceInSeparator = indices.get(pair.getFirst());\n                V cycleTargetInSeparator = indices.get(pair.getSecond());\n                if (!complement.containsEdge(cycleSourceInSeparator, cycleSource)) {\n                    V t = cycleSourceInSeparator;\n                    cycleSourceInSeparator = cycleTargetInSeparator;\n                    cycleTargetInSeparator = t;\n                }\n                this.certificate = findHole(\n                    complement, cycleSourceInSeparator, cycleSource, cycleTarget,\n                    cycleTargetInSeparator);\n                return;\n            }\n        }\n    }\n\n    /**\n     * Finds a hole in the specified {@code graph}. Vertices {@code sourceInSeparator},\n     * {@code source}, {@code target} and {@code targetInSeparator} belong to the computes hole.\n     * They are used to correctly find a hole in the specified {@code graph}.\n     *\n     * @param sourceInSeparator vertex on the hole\n     * @param source vertex on the hole\n     * @param target vertex on the hole\n     * @param targetInSeparator vertex on the hole\n     * @return the computed hole on the {@code graph}\n     */\n    private GraphPath<V, E> findHole(\n        Graph<V, E> graph, V sourceInSeparator, V source, V target, V targetInSeparator)\n    {\n        Set<V> visited = CollectionUtil.newHashSetWithExpectedSize(graph.vertexSet().size());\n        visited.add(target);\n        visited.add(source);\n\n        // Obtaining some cycle, which can be minimized to a hole\n        List<V> cycle =\n            findCycle(visited, graph, targetInSeparator, target, source, sourceInSeparator);\n        cycle = minimizeCycle(graph, cycle, target, targetInSeparator, source, sourceInSeparator);\n\n        return new GraphWalk<>(graph, cycle, 0);\n    }\n\n    /**\n     * Starts the iterative depth-first traversal from {@code sourInSep} vertex. Tries to build a\n     * cycle with the vertices, which aren't adjacent to the {@code tar} and {@code sour}. This\n     * condition is used in order to ensure that the cycle contains a hole, to which it is later\n     * minimized.\n     *\n     * @param visited defines which vertices have been visited already\n     * @param graph the graph the search is performed on\n     * @param tarInSep the end point of the cycle\n     * @param tar the vertex, which can't be adjacent to the vertices in the cycle\n     * @param sour the vertex, which can't be adjacent to the vertices in the cycle\n     * @param sourInSep the vertex the search is started from\n     * @return the computed cycle, which contains a hole\n     */\n    private List<V> findCycle(\n        Set<V> visited, Graph<V, E> graph, V tarInSep, V tar, V sour, V sourInSep)\n    {\n        List<V> cycle = new ArrayList<>(Arrays.asList(tarInSep, tar, sour));\n        Deque<V> stack = new ArrayDeque<>();\n        stack.add(sourInSep);\n\n        while (!stack.isEmpty()) {\n            V currentVertex = stack.removeLast();\n            if (visited.add(currentVertex)) {\n\n                // trying to advance cycle from current vertex\n                // removing all vertices from the head of the cycle, which aren't adjacent to the\n                // current vertex\n                while (!graph.containsEdge(cycle.get(cycle.size() - 1), currentVertex)) {\n                    cycle.remove(cycle.size() - 1);\n                }\n                cycle.add(currentVertex);\n                if (tarInSep.equals(currentVertex)) {\n                    // the cycle is complete\n                    break;\n                } else {\n                    for (V neighbor : Graphs.neighborListOf(graph, currentVertex)) {\n                        // add a vertex to the stack if it hasn't been visited yet and it isn't\n                        // adjacent to the\n                        // source vertex and (it isn't adjacent to the target vertex or it is\n                        // targetInSeparator (the end of the cycle))\n                        if (!visited.contains(neighbor) && !graph.containsEdge(sour, neighbor)\n                            && (!graph.containsEdge(tar, neighbor) || neighbor.equals(tarInSep)))\n                        {\n                            stack.add(neighbor);\n                        }\n                    }\n                }\n            }\n        }\n        return cycle;\n    }\n\n    /**\n     * Minimizes the {@code cycle} so that it contains a hole in the {@code graph}. Vertices\n     * {@code tar}, {@code tarInSep}, {@code sour} and {@code sourInSep} belong to the final result.\n     *\n     * @param graph the graph, which contains vertices from {@code cycle}\n     * @param cycle the cycle to minimize\n     * @param tar vertex, which should belong to the final result\n     * @param tarInSep vertex, which should belong to the final result\n     * @param sour vertex, which should belong to the final result\n     * @param sourInSep vertex, which should belong to the final result\n     * @return a list of vertices, which defines a hole in the {@code graph}\n     */\n    private List<V> minimizeCycle(\n        Graph<V, E> graph, List<V> cycle, V tar, V tarInSep, V sour, V sourInSep)\n    {\n        List<V> minimizedCycle = new ArrayList<>(Arrays.asList(tarInSep, tar, sour));\n        Set<V> forwardVertices = new HashSet<>(cycle);\n        forwardVertices.remove(tar);\n        forwardVertices.remove(sour);\n        forwardVertices.remove(sourInSep);\n\n        for (int i = 3; i < cycle.size() - 1;) {\n            V current = cycle.get(i);\n            minimizedCycle.add(current);\n            forwardVertices.remove(current);\n\n            // Computing a set of vertices, which are adjacent to current and have greater index\n            // in the cycle than current\n            Set<V> currentForward = new HashSet<>();\n            for (V neighbor : Graphs.neighborListOf(graph, current)) {\n                if (forwardVertices.contains(neighbor)) {\n                    currentForward.add(neighbor);\n                }\n            }\n\n            // Jump to the forward vertex with the greatest index. Therefore we ensure, that\n            // the resulting cycle doesn't contain chords\n            for (V forwardVertex : currentForward) {\n                if (forwardVertices.contains(forwardVertex)) {\n                    do {\n                        forwardVertices.remove(cycle.get(i));\n                        i++;\n                    } while (i < cycle.size() && !cycle.get(i).equals(forwardVertex));\n                }\n            }\n        }\n        minimizedCycle.add(tarInSep);\n        return minimizedCycle;\n    }\n\n    /**\n     * Computes and returns all minimal separators in the neighborhood of the {@code edge} in the\n     * {@code graph}. The result may contain duplicate separators.\n     *\n     * @param graph the graph to search minimal separators in\n     * @param edge the edge, whose neighborhood is being explored\n     * @return the list of all minimal separators in the neighborhood of the {@code edge}. The\n     *         resulted list may contain duplicates.\n     */\n    private List<Set<V>> findSeparators(Graph<V, E> graph, E edge)\n    {\n        List<Set<V>> separators = new ArrayList<>();\n        V source = graph.getEdgeSource(edge);\n        V target = graph.getEdgeTarget(edge);\n        Set<V> neighborhood = neighborhoodSetOf(graph, edge);\n        Map<V, Byte> dfsMap = CollectionUtil.newHashMapWithExpectedSize(graph.vertexSet().size());\n\n        // 0 - unvisited (white), 1 - neighbor of the edge (red), 2 - visited (black)\n        for (V vertex : graph.vertexSet()) {\n            if (neighborhood.contains(vertex)) {\n                dfsMap.put(vertex, (byte) 1);\n            } else {\n                dfsMap.put(vertex, (byte) 0);\n            }\n        }\n        dfsMap.put(source, (byte) 2);\n        dfsMap.put(target, (byte) 2);\n\n        for (V vertex : graph.vertexSet()) {\n            if (dfsMap.get(vertex) == 0) {\n                // possible to find one more separator\n                Set<V> separator = getSeparator(graph, vertex, dfsMap);\n                if (!separator.isEmpty()) {\n                    separators.add(separator);\n                }\n            }\n        }\n\n        return separators;\n    }\n\n    /**\n     * Performs iterative depth-first search starting from the {@code startVertex} in the\n     * {@code graph}. Adds every encountered red vertex to the resulting separator. Doesn't process\n     * red vertices. Marks all white vertices with black color.\n     *\n     * @param graph the graph dfs is performed on\n     * @param startVertex the vertex to start depth-first traversal from\n     * @param dfsMap the depth-first vertex labeling\n     * @return the computed separator, which consists of all encountered red vertices\n     */\n    private Set<V> getSeparator(Graph<V, E> graph, V startVertex, Map<V, Byte> dfsMap)\n    {\n        Deque<V> stack = new ArrayDeque<>();\n        Set<V> separator = new HashSet<>();\n        stack.add(startVertex);\n\n        while (!stack.isEmpty()) {\n            V currentVertex = stack.removeLast();\n            if (dfsMap.get(currentVertex) == 0) {\n                dfsMap.put(currentVertex, (byte) 2);\n                for (E edge : graph.edgesOf(currentVertex)) {\n                    V opposite = Graphs.getOppositeVertex(graph, edge, currentVertex);\n                    if (dfsMap.get(opposite) == 0) {\n                        stack.add(opposite);\n                    } else if (dfsMap.get(opposite) == 1) {\n                        separator.add(opposite); // found red vertex, which belongs to the separator\n                    }\n                }\n            }\n        }\n\n        return separator;\n    }\n\n    /**\n     * Returns a set of vertices that are neighbors of the source of the specified edge or of the\n     * target of specified edge. The endpoints of the specified edge aren't included in the result.\n     *\n     * @param g the graph to look for neighbors in\n     * @param edge the edge to get the neighbors of\n     * @return a set of vertices that are neighbors of at least one endpoint of the specified edge.\n     *         The endpoints of the specified edge aren't included in the result\n     */\n    private Set<V> neighborhoodSetOf(Graph<V, E> g, E edge)\n    {\n        Set<V> neighborhood = new HashSet<>();\n\n        V source = g.getEdgeSource(edge);\n        V target = g.getEdgeTarget(edge);\n\n        for (E e : g.edgesOf(source)) {\n            neighborhood.add(Graphs.getOppositeVertex(g, e, source));\n        }\n        for (E e : g.edgesOf(target)) {\n            neighborhood.add(Graphs.getOppositeVertex(g, e, target));\n        }\n        neighborhood.remove(source);\n        neighborhood.remove(target);\n\n        return neighborhood;\n    }\n}\n",
            "file_name": "WeakChordalityInspector.java",
            "human_label": "Select an edge which isn't a circle in the graph,compute the list of the minimal separators in the neighborhood of the edge and put the pair of list and edge into the return list.Repeat for each edge in the graph and then return the final list.",
            "level": "class_runnable",
            "lineno": "222",
            "name": "computeGlobalSeparatorList",
            "oracle_context": "{ \"apis\" : \"[edgeSet, getEdgeSource, getEdgeTarget, findSeparators, addAll, reformatSeparatorList]\", \"classes\" : \"[List<Pair<List<Pair<Integer,Integer>>,E>>, V, List<Set<V>>]\", \"vars\" : \"[graph]\" }",
            "package": "org.jgrapht.alg.cycle",
            "project": "jgrapht-master"
        },
        {
            "_id": "636766a81a6d9265ec017596",
            "all_context": "{ \"class_level\" : \"byte[] data;\\nint length;\\nByteVector(int initialCapacity);\\nput11(int byteValue1,int byteValue2);\\nputShort(int shortValue);\\nput12(int byteValue,int shortValue);\\nputInt(int intValue);\\nput122(int byteValue,int shortValue1,int shortValue2);\\nputLong(long longValue);\\nputUTF8(String stringValue);\\nencodeUtf8(String stringValue,int offset,int maxByteLength);\\nputByteArray(byte[] byteArrayValue,int byteOffset,int byteLength);\\nenlarge(int size);\\nputByte(int byteValue);\\n\", \"repo_level\" : \"\" }",
            "class_name": "ByteVector",
            "code": "public ByteVector putInt(final int intValue){\n  int currentLength=length;\n  if (currentLength + 4 > data.length) {\n    enlarge(4);\n  }\n  byte[] currentData=data;\n  currentData[currentLength++]=(byte)(intValue >>> 24);\n  currentData[currentLength++]=(byte)(intValue >>> 16);\n  currentData[currentLength++]=(byte)(intValue >>> 8);\n  currentData[currentLength++]=(byte)intValue;\n  length=currentLength;\n  return this;\n}\n",
            "docstring": "/** \n * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param intValue an int.\n * @return this byte vector.\n */\n",
            "end_lineno": "155",
            "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage com.alibaba.fastjson2.internal.asm;\n\n/**\n * A dynamically extensible vector of bytes. This class is roughly equivalent to a DataOutputStream\n * on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n */\npublic class ByteVector {\n    /**\n     * The content of this vector. Only the first {@link #length} bytes contain real data.\n     */\n    byte[] data;\n\n    /**\n     * The actual number of bytes in this vector.\n     */\n    int length;\n//\n//    /**\n//     * Constructs a new {@link ByteVector} with a default initial capacity.\n//     */\n//    public ByteVector() {\n//        data = new byte[64];\n//    }\n\n    /**\n     * Constructs a new {@link ByteVector} with the given initial capacity.\n     *\n     * @param initialCapacity the initial capacity of the byte vector to be constructed.\n     */\n    public ByteVector(final int initialCapacity) {\n        data = new byte[initialCapacity];\n    }\n\n    /**\n     * Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue a byte.\n     * @return this byte vector.\n     */\n    public ByteVector putByte(final int byteValue) {\n        int currentLength = length;\n        if (currentLength + 1 > data.length) {\n            enlarge(1);\n        }\n        data[currentLength++] = (byte) byteValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue1 a byte.\n     * @param byteValue2 another byte.\n     * @return this byte vector.\n     */\n    final ByteVector put11(final int byteValue1, final int byteValue2) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue1;\n        currentData[currentLength++] = (byte) byteValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    public ByteVector putShort(final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteValue  a byte.\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    final ByteVector put12(final int byteValue, final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 3 > data.length) {\n            enlarge(3);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param intValue an int.\n     * @return this byte vector.\n     */\n    public ByteVector putInt(final int intValue) {\n        int currentLength = length;\n        if (currentLength + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\n     * if necessary.\n     *\n     * @param byteValue   a byte.\n     * @param shortValue1 a short.\n     * @param shortValue2 another short.\n     * @return this byte vector.\n     */\n    final ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) {\n        int currentLength = length;\n        if (currentLength + 5 > data.length) {\n            enlarge(5);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue1 >>> 8);\n        currentData[currentLength++] = (byte) shortValue1;\n        currentData[currentLength++] = (byte) (shortValue2 >>> 8);\n        currentData[currentLength++] = (byte) shortValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param longValue a long.\n     * @return this byte vector.\n     */\n    public ByteVector putLong(final long longValue) {\n        int currentLength = length;\n        if (currentLength + 8 > data.length) {\n            enlarge(8);\n        }\n        byte[] currentData = data;\n        int intValue = (int) (longValue >>> 32);\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        intValue = (int) longValue;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param stringValue a String whose UTF8 encoded length must be less than 65536.\n     * @return this byte vector.\n     */\n    // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\n    public ByteVector putUTF8(final String stringValue) {\n        int charLength = stringValue.length();\n        if (charLength > 65535) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        int currentLength = length;\n        if (currentLength + 2 + charLength > data.length) {\n            enlarge(2 + charLength);\n        }\n        byte[] currentData = data;\n        // Optimistic algorithm: instead of computing the byte length and then serializing the string\n        // (which requires two loops), we assume the byte length is equal to char length (which is the\n        // most frequent case), and we start serializing the string right away. During the\n        // serialization, if we find that this assumption is wrong, we continue with the general method.\n        currentData[currentLength++] = (byte) (charLength >>> 8);\n        currentData[currentLength++] = (byte) charLength;\n        for (int i = 0; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= '\\u0001' && charValue <= '\\u007F') {\n                currentData[currentLength++] = (byte) charValue;\n            } else {\n                length = currentLength;\n                return encodeUtf8(stringValue, i, 65535);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary. The string length is encoded in two bytes before the encoded characters, if there is\n     * space for that (i.e. if this.length - offset - 2 &gt;= 0).\n     *\n     * @param stringValue   the String to encode.\n     * @param offset        the index of the first character to encode. The previous characters are supposed\n     *                      to have already been encoded, using only one byte per character.\n     * @param maxByteLength the maximum byte length of the encoded string, including the already\n     *                      encoded characters.\n     * @return this byte vector.\n     */\n    final ByteVector encodeUtf8(final String stringValue, final int offset, final int maxByteLength) {\n        int charLength = stringValue.length();\n        int byteLength = offset;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                byteLength++;\n            } else if (charValue <= 0x07FF) {\n                byteLength += 2;\n            } else {\n                byteLength += 3;\n            }\n        }\n        if (byteLength > maxByteLength) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        // Compute where 'byteLength' must be stored in 'data', and store it at this location.\n        int byteLengthOffset = length - offset - 2;\n        if (byteLengthOffset >= 0) {\n            data[byteLengthOffset] = (byte) (byteLength >>> 8);\n            data[byteLengthOffset + 1] = (byte) byteLength;\n        }\n        if (length + byteLength - offset > data.length) {\n            enlarge(byteLength - offset);\n        }\n        int currentLength = length;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                data[currentLength++] = (byte) charValue;\n            } else if (charValue <= 0x07FF) {\n                data[currentLength++] = (byte) (0xC0 | charValue >> 6 & 0x1F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            } else {\n                data[currentLength++] = (byte) (0xE0 | charValue >> 12 & 0xF);\n                data[currentLength++] = (byte) (0x80 | charValue >> 6 & 0x3F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\n     *                       bytes into this byte vector.\n     * @param byteOffset     index of the first byte of byteArrayValue that must be copied.\n     * @param byteLength     number of bytes of byteArrayValue that must be copied.\n     * @return this byte vector.\n     */\n    public ByteVector putByteArray(\n            final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n        if (length + byteLength > data.length) {\n            enlarge(byteLength);\n        }\n        if (byteArrayValue != null) {\n            System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength);\n        }\n        length += byteLength;\n        return this;\n    }\n\n    /**\n     * Enlarges this byte vector so that it can receive 'size' more bytes.\n     *\n     * @param size number of additional bytes that this byte vector should be able to receive.\n     */\n    private void enlarge(final int size) {\n        int doubleCapacity = 2 * data.length;\n        int minimalCapacity = length + size;\n        byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\n        System.arraycopy(data, 0, newData, 0, length);\n        data = newData;\n    }\n}\n",
            "file_name": "ByteVector.java",
            "human_label": "Divide an int into four bytes and put the bytes into a byte vector called data in big endian order.The vector will be enlarged if necessary.And return the object.",
            "level": "class_runnable",
            "lineno": "137",
            "name": "putInt",
            "oracle_context": "{ \"apis\" : \"[enlarge, ByteVector]\", \"classes\" : \"[byte[], data]\", \"vars\" : \"[length, data]\" }",
            "package": "com.alibaba.fastjson2.internal.asm",
            "project": "fastjson2-main"
        },
        {
            "_id": "6367675f1a6d9265ec0180cf",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.*;\\nimport org.jgrapht.alg.connectivity.*;\\nimport org.jgrapht.graph.builder.*;\\nimport java.util.*;\\nimport java.util.Map.*;\\nGraph<V,E> graph;\\nGraph<V,E> chordalGraph;\\nSet<E> fillEdges;\\nLinkedList<V> meo;\\nList<V> generators;\\nSet<Set<V>> separators;\\nSet<Set<V>> atoms;\\nMap<Set<V>,Integer> fullComponentCount;\\nCliqueMinimalSeparatorDecomposition(Graph g);\\ngetMaxLabelVertex(Map vertexLabels);\\naddToReach(Integer k,V v,HashMap r);\\ncomputeAtoms();\\nisClique(Graph graph,Set vertices);\\ncopyAsSimpleGraph(Graph graph);\\nisChordal();\\ngetFillEdges();\\ngetMinimalTriangulation();\\ngetGenerators();\\ngetMeo();\\ngetFullComponentCount();\\ngetAtoms();\\ngetSeparators();\\ngetGraph();\\ncomputeMinimalTriangulation();\\n\", \"repo_level\" : \"\" }",
            "class_name": "CliqueMinimalSeparatorDecomposition",
            "code": "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n  for (  V v1 : vertices) {\n    for (    V v2 : vertices) {\n      if (!v1.equals(v2) && (graph.getEdge(v1,v2) == null)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n",
            "docstring": "/** \n * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code> is complete, i.e. a clique.\n * @param graph the graph.\n * @param vertices the vertices to induce the subgraph from.\n * @return true if the induced subgraph is a clique.\n */\n",
            "end_lineno": "309",
            "file_content": "/*\n * (C) Copyright 2015-2021, by Florian Buenzli and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.alg.clique;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.connectivity.*;\nimport org.jgrapht.graph.builder.*;\n\nimport java.util.*;\nimport java.util.Map.*;\n\n/**\n * Clique Minimal Separator Decomposition using MCS-M+ and Atoms algorithm as described in Berry et\n * al. An Introduction to Clique Minimal Separator Decomposition (2010), DOI:10.3390/a3020197,\n * <a href=\"http://www.mdpi.com/1999-4893/3/2/197\"> http://www.mdpi.com/1999-4893/3/2/197</a>\n *\n * <p>\n * The Clique Minimal Separator (CMS) Decomposition is a procedure that splits a graph into a set of\n * subgraphs separated by minimal clique separators, adding the separating clique to each component\n * produced by the separation. At the end we have a set of atoms. The CMS decomposition is unique\n * and yields the set of the atoms independent of the order of the decomposition.\n *\n * @param <V> the graph vertex type\n * @param <E> the graph edge type\n *\n * @author Florian Buenzli (fbuenzli@student.ethz.ch)\n * @author Thomas Tschager (thomas.tschager@inf.ethz.ch)\n * @author Tomas Hruz (tomas.hruz@inf.ethz.ch)\n * @author Philipp Hoppen\n */\npublic class CliqueMinimalSeparatorDecomposition<V, E>\n{\n    /**\n     * Source graph to operate on\n     */\n    private Graph<V, E> graph;\n\n    /**\n     * Minimal triangulation of graph\n     */\n    private Graph<V, E> chordalGraph;\n\n    /**\n     * Fill edges\n     */\n    private Set<E> fillEdges;\n\n    /**\n     * Minimal elimination ordering on the vertices of graph\n     */\n    private LinkedList<V> meo;\n\n    /**\n     * List of all vertices that generate a minimal separator of <code>\n     * chordGraph</code>\n     */\n    private List<V> generators;\n\n    /**\n     * Set of clique minimal separators\n     */\n    private Set<Set<V>> separators;\n\n    /**\n     * The atoms generated by the decomposition\n     */\n    private Set<Set<V>> atoms;\n\n    /**\n     * Map for each separator how many components it produces.\n     */\n    private Map<Set<V>, Integer> fullComponentCount = new HashMap<>();\n\n    /**\n     * Setup a clique minimal separator decomposition on undirected graph <code>\n     * g</code>. Loops and multiple (parallel) edges are removed, i.e. the graph is transformed to a\n     * simple graph.\n     *\n     * @param g The graph to decompose.\n     */\n    public CliqueMinimalSeparatorDecomposition(Graph<V, E> g)\n    {\n        this.graph = GraphTests.requireUndirected(g);\n        this.fillEdges = new HashSet<>();\n    }\n\n    /**\n     * Compute the minimal triangulation of the graph. Implementation of Algorithm MCS-M+ as\n     * described in Berry et al. (2010), DOI:10.3390/a3020197\n     * <a href=\"http://www.mdpi.com/1999-4893/3/2/197\"> http://www.mdpi.com/1999-4893/3/2/197</a>\n     */\n    private void computeMinimalTriangulation()\n    {\n        // initialize chordGraph with same vertices as graph\n        chordalGraph = GraphTypeBuilder\n            .<V, E> undirected().edgeSupplier(graph.getEdgeSupplier())\n            .vertexSupplier(graph.getVertexSupplier()).allowingMultipleEdges(false)\n            .allowingSelfLoops(false).buildGraph();\n\n        for (V v : graph.vertexSet()) {\n            chordalGraph.addVertex(v);\n        }\n\n        // initialize g' as subgraph of graph (same vertices and edges)\n        final Graph<V, E> gprime = copyAsSimpleGraph(graph);\n        int s = -1;\n        generators = new ArrayList<>();\n        meo = new LinkedList<>();\n\n        final Map<V, Integer> vertexLabels = new HashMap<>();\n        for (V v : gprime.vertexSet()) {\n            vertexLabels.put(v, 0);\n        }\n        for (int i = 1, n = graph.vertexSet().size(); i <= n; i++) {\n            V v = getMaxLabelVertex(vertexLabels);\n            LinkedList<V> neighborsY = new LinkedList<>(Graphs.neighborListOf(gprime, v));\n\n            if (vertexLabels.get(v) <= s) {\n                generators.add(v);\n            }\n\n            s = vertexLabels.get(v);\n\n            // Mark x reached and all other vertices of gprime unreached\n            HashSet<V> reached = new HashSet<>();\n            reached.add(v);\n\n            // mark neighborhood of x reached and add to reach(label(y))\n            HashMap<Integer, HashSet<V>> reach = new HashMap<>();\n\n            // mark y reached and add y to reach\n            for (V y : neighborsY) {\n                reached.add(y);\n                addToReach(vertexLabels.get(y), y, reach);\n            }\n\n            for (int j = 0; j < graph.vertexSet().size(); j++) {\n                if (!reach.containsKey(j)) {\n                    continue;\n                }\n                while (reach.get(j).size() > 0) {\n                    // remove a vertex y from reach(j)\n                    V y = reach.get(j).iterator().next();\n                    reach.get(j).remove(y);\n\n                    for (V z : Graphs.neighborListOf(gprime, y)) {\n                        if (!reached.contains(z)) {\n                            reached.add(z);\n                            if (vertexLabels.get(z) > j) {\n                                neighborsY.add(z);\n                                E fillEdge = graph.getEdgeSupplier().get();\n                                fillEdges.add(fillEdge);\n                                addToReach(vertexLabels.get(z), z, reach);\n                            } else {\n                                addToReach(j, z, reach);\n                            }\n                        }\n                    }\n                }\n            }\n\n            for (V y : neighborsY) {\n                chordalGraph.addEdge(v, y);\n                vertexLabels.put(y, vertexLabels.get(y) + 1);\n            }\n\n            meo.addLast(v);\n            gprime.removeVertex(v);\n            vertexLabels.remove(v);\n        }\n    }\n\n    /**\n     * Get the vertex with the maximal label.\n     *\n     * @param vertexLabels Map that gives a label for each vertex.\n     *\n     * @return Vertex with the maximal label.\n     */\n    private V getMaxLabelVertex(Map<V, Integer> vertexLabels)\n    {\n        Iterator<Entry<V, Integer>> iterator = vertexLabels.entrySet().iterator();\n        Entry<V, Integer> max = iterator.next();\n        while (iterator.hasNext()) {\n            Entry<V, Integer> e = iterator.next();\n            if (e.getValue() > max.getValue()) {\n                max = e;\n            }\n        }\n        return max.getKey();\n    }\n\n    /**\n     * Add a vertex to reach.\n     *\n     * @param k vertex' label\n     * @param v the vertex\n     * @param r the reach structure.\n     */\n    private void addToReach(Integer k, V v, HashMap<Integer, HashSet<V>> r)\n    {\n        if (r.containsKey(k)) {\n            r.get(k).add(v);\n        } else {\n            HashSet<V> set = new HashSet<>();\n            set.add(v);\n            r.put(k, set);\n        }\n    }\n\n    /**\n     * Compute the unique decomposition of the input graph $G$ (atoms of $G$). Implementation of\n     * algorithm Atoms as described in Berry et al. (2010), DOI:10.3390/a3020197,\n     * <a href=\"http://www.mdpi.com/1999-4893/3/2/197\"> http://www.mdpi.com/1999-4893/3/2/197</a>\n     */\n    private void computeAtoms()\n    {\n        if (chordalGraph == null) {\n            computeMinimalTriangulation();\n        }\n\n        separators = new HashSet<>();\n\n        // initialize g' as subgraph of graph (same vertices and edges)\n        Graph<V, E> gprime = copyAsSimpleGraph(graph);\n\n        // initialize h' as subgraph of chordalGraph (same vertices and edges)\n        Graph<V, E> hprime = copyAsSimpleGraph(chordalGraph);\n\n        atoms = new HashSet<>();\n\n        Iterator<V> iterator = meo.descendingIterator();\n        while (iterator.hasNext()) {\n            V v = iterator.next();\n            if (generators.contains(v)) {\n                Set<V> separator = new HashSet<>(Graphs.neighborListOf(hprime, v));\n\n                if (isClique(graph, separator)) {\n                    if (separator.size() > 0) {\n                        if (separators.contains(separator)) {\n                            fullComponentCount\n                                .put(separator, fullComponentCount.get(separator) + 1);\n                        } else {\n                            fullComponentCount.put(separator, 2);\n                            separators.add(separator);\n                        }\n                    }\n                    Graph<V, E> tmpGraph = copyAsSimpleGraph(gprime);\n\n                    tmpGraph.removeAllVertices(separator);\n                    ConnectivityInspector<V, E> con = new ConnectivityInspector<>(tmpGraph);\n                    if (con.isConnected()) {\n                        throw new RuntimeException(\"separator did not separate the graph\");\n                    }\n                    for (Set<V> component : con.connectedSets()) {\n                        if (component.contains(v)) {\n                            gprime.removeAllVertices(component);\n                            component.addAll(separator);\n                            atoms.add(new HashSet<>(component));\n                            assert (component.size() > 0);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            hprime.removeVertex(v);\n        }\n\n        if (gprime.vertexSet().size() > 0) {\n            atoms.add(new HashSet<>(gprime.vertexSet()));\n        }\n    }\n\n    /**\n     * Check whether the subgraph of <code>graph</code> induced by the given <code>vertices</code>\n     * is complete, i.e. a clique.\n     *\n     * @param graph the graph.\n     * @param vertices the vertices to induce the subgraph from.\n     *\n     * @return true if the induced subgraph is a clique.\n     */\n    private static <V, E> boolean isClique(Graph<V, E> graph, Set<V> vertices)\n    {\n        for (V v1 : vertices) {\n            for (V v2 : vertices) {\n                if (!v1.equals(v2) && (graph.getEdge(v1, v2) == null)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Create a copy of a graph for internal use.\n     *\n     * @param graph the graph to copy.\n     *\n     * @return A copy of the graph projected to a SimpleGraph.\n     */\n    private static <V, E> Graph<V, E> copyAsSimpleGraph(Graph<V, E> graph)\n    {\n        Graph<V,\n            E> copy = GraphTypeBuilder\n                .<V, E> undirected().edgeSupplier(graph.getEdgeSupplier())\n                .vertexSupplier(graph.getVertexSupplier()).allowingMultipleEdges(false)\n                .allowingSelfLoops(false).buildGraph();\n\n        if (graph.getType().isSimple()) {\n            Graphs.addGraph(copy, graph);\n        } else {\n            // project graph to SimpleGraph\n            Graphs.addAllVertices(copy, graph.vertexSet());\n            for (E e : graph.edgeSet()) {\n                V v1 = graph.getEdgeSource(e);\n                V v2 = graph.getEdgeTarget(e);\n                if (!v1.equals(v2) && !copy.containsEdge(e)) {\n                    copy.addEdge(v1, v2);\n                }\n            }\n        }\n        return copy;\n    }\n\n    /**\n     * Check if the graph is chordal.\n     *\n     * @return true if the graph is chordal, false otherwise.\n     */\n    public boolean isChordal()\n    {\n        if (chordalGraph == null) {\n            computeMinimalTriangulation();\n        }\n\n        return (chordalGraph.edgeSet().size() == graph.edgeSet().size());\n    }\n\n    /**\n     * Get the fill edges generated by the triangulation.\n     *\n     * @return Set of fill edges.\n     */\n    public Set<E> getFillEdges()\n    {\n        if (fillEdges == null) {\n            computeMinimalTriangulation();\n        }\n\n        return fillEdges;\n    }\n\n    /**\n     * Get the minimal triangulation of the graph.\n     *\n     * @return Triangulated graph.\n     */\n    public Graph<V, E> getMinimalTriangulation()\n    {\n        if (chordalGraph == null) {\n            computeMinimalTriangulation();\n        }\n\n        return chordalGraph;\n    }\n\n    /**\n     * Get the generators of the separators of the triangulated graph, i.e. all vertices that\n     * generate a minimal separator of triangulated graph.\n     *\n     * @return List of generators.\n     */\n    public List<V> getGenerators()\n    {\n        if (generators == null) {\n            computeMinimalTriangulation();\n        }\n\n        return generators;\n    }\n\n    /**\n     * Get the minimal elimination ordering produced by the triangulation.\n     *\n     * @return The minimal elimination ordering.\n     */\n    public LinkedList<V> getMeo()\n    {\n        if (meo == null) {\n            computeMinimalTriangulation();\n        }\n\n        return meo;\n    }\n\n    /**\n     * Get a map to know for each separator how many components it produces.\n     *\n     * @return A map from separators to integers (component count).\n     */\n    public Map<Set<V>, Integer> getFullComponentCount()\n    {\n        if (fullComponentCount == null) {\n            computeAtoms();\n        }\n\n        return fullComponentCount;\n    }\n\n    /**\n     * Get the atoms generated by the decomposition.\n     *\n     * @return Set of atoms, where each atom is described as the set of its vertices.\n     */\n    public Set<Set<V>> getAtoms()\n    {\n        if (atoms == null) {\n            computeAtoms();\n        }\n\n        return atoms;\n    }\n\n    /**\n     * Get the clique minimal separators.\n     *\n     * @return Set of separators, where each separator is described as the set of its vertices.\n     */\n    public Set<Set<V>> getSeparators()\n    {\n        if (separators == null) {\n            computeAtoms();\n        }\n\n        return separators;\n    }\n\n    /**\n     * Get the original graph.\n     *\n     * @return Original graph.\n     */\n    public Graph<V, E> getGraph()\n    {\n        return graph;\n    }\n}\n",
            "file_name": "CliqueMinimalSeparatorDecomposition.java",
            "human_label": "Return true if the subgraph of the given graph induced by the given vertices is a clique,otherwise return false.",
            "level": "class_runnable",
            "lineno": "290",
            "name": "isClique",
            "oracle_context": "{ \"apis\" : \"[equals, getEdge]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }",
            "package": "org.jgrapht.alg.clique",
            "project": "jgrapht-master"
        },
        {
            "_id": "636767431a6d9265ec017c88",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.alg.util.Pair;\\nimport java.util.*;\\nimport java.util.function.Function;\\nRandom rng;\\nList<Function<K,Integer>> lowerBounds;\\nList<Function<K,Integer>> upperBounds;\\nDistributor();\\nDistributor(long seed);\\nDistributor(Random rng);\\naddLowerBound(Function lowerBound);\\ncomputeLowerBounds(List keys);\\ncomputeUpperBounds(List keys);\\ncomputeSuffixSum(List bounds);\\ngetDistribution(List keys,int valueNum);\\naddUpperBound(Function upperBound);\\n\", \"repo_level\" : \"public interface Pair {public A getFirst();\\npublic B getSecond();\\npublic void setFirst(A f);\\npublic void setSecond(B s);\\npublic boolean hasElement(E e);\\npublic String toString();\\npublic boolean equals(Object o);\\npublic int hashCode();\\nstatic Pair<A,B> of(A a,B b);\\n }\\n\" }",
            "class_name": "Distributor",
            "code": "private List<Integer> computeLowerBounds(List<K> keys){\n  List<Integer> keyLowerBounds=new ArrayList<>(keys.size());\n  for (  K key : keys) {\n    int lowerBound=0;\n    for (    Function<K,Integer> lowerBoundFunction : lowerBounds) {\n      lowerBound=Math.max(lowerBound,lowerBoundFunction.apply(key));\n    }\n    keyLowerBounds.add(lowerBound);\n  }\n  return keyLowerBounds;\n}\n",
            "docstring": "/** \n * Finds a maximum lower bound for every key.\n * @param keys list of keys.\n * @return the computed key lower bounds.\n */\n",
            "end_lineno": "120",
            "file_content": "/*\n * (C) Copyright 2020-2021, by Timofey Chudakov and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.generate.netgen;\n\nimport org.jgrapht.alg.util.Pair;\n\nimport java.util.*;\nimport java.util.function.Function;\n\n/**\n * Distributes value units among keys given lower and upper bound constraints.\n * <p>\n * Let's define a set of elements $\\{k_1, k_2, \\dots, k_n\\}$. For every element a set of lower\n * bounds $\\{l_1, l_2, \\dots, l_t\\}$ and upper bounds $\\{u_1, u_2, \\dots, u_p\\}$ is specified. The\n * problem is to randomly distribute a number of abstract value units $V$ among keys such that the\n * lower bound and upper bound constraints are satisfied. This class solves this problem.\n *\n * @param <K> the element type.\n * @author Timofey Chudakov\n * @see NetworkGenerator\n */\npublic class Distributor<K>\n{\n    /**\n     * Random number generator used by this distributor.\n     */\n    private final Random rng;\n    /**\n     * Lower bounds.\n     */\n    private final List<Function<K, Integer>> lowerBounds;\n    /**\n     * Upper bounds.\n     */\n    private final List<Function<K, Integer>> upperBounds;\n\n    /**\n     * Creates a Distributor using random seed.\n     */\n    public Distributor()\n    {\n        this(System.nanoTime());\n    }\n\n    /**\n     * Creates a distributor using the specified {@code seed}.\n     *\n     * @param seed the seed for the random number generator.\n     */\n    public Distributor(long seed)\n    {\n        this(new Random(seed));\n    }\n\n    /**\n     * Creates a distributor which uses the random number generatow {@code rng}.\n     *\n     * @param rng a random number generator to use.\n     */\n    public Distributor(Random rng)\n    {\n        this.rng = rng;\n        this.lowerBounds = new ArrayList<>();\n        this.upperBounds = new ArrayList<>();\n    }\n\n    /**\n     * Adds an upper bounding function. This function must be defined for all keys.\n     *\n     * @param upperBound an upper bound function.\n     */\n    public void addUpperBound(Function<K, Integer> upperBound)\n    {\n        this.upperBounds.add(upperBound);\n    }\n\n    /**\n     * Adds a lower bound function. This function must be defined for all keys.\n     *\n     * @param lowerBound a lower bound function.\n     */\n    public void addLowerBound(Function<K, Integer> lowerBound)\n    {\n        this.lowerBounds.add(lowerBound);\n    }\n\n    /**\n     * Finds a maximum lower bound for every key.\n     *\n     * @param keys list of keys.\n     * @return the computed key lower bounds.\n     */\n    private List<Integer> computeLowerBounds(List<K> keys)\n    {\n        List<Integer> keyLowerBounds = new ArrayList<>(keys.size());\n        for (K key : keys) {\n            int lowerBound = 0;\n            for (Function<K, Integer> lowerBoundFunction : lowerBounds) {\n                lowerBound = Math.max(lowerBound, lowerBoundFunction.apply(key));\n            }\n            keyLowerBounds.add(lowerBound);\n        }\n\n        return keyLowerBounds;\n    }\n\n    /**\n     * Finds a minimum lower bound for every key.\n     *\n     * @param keys a list of keys.\n     * @return the computed key upper bound.\n     */\n    private List<Integer> computeUpperBounds(List<K> keys)\n    {\n        List<Integer> keyUpperBounds = new ArrayList<>(keys.size());\n        for (K key : keys) {\n            int upperBound = Integer.MAX_VALUE;\n            for (Function<K, Integer> upperBoundFunction : upperBounds) {\n                upperBound = Math.min(upperBound, upperBoundFunction.apply(key));\n            }\n            keyUpperBounds.add(upperBound);\n        }\n\n        return keyUpperBounds;\n    }\n\n    /**\n     * Computes a suffix sum of the {@code bounds}. Returns computed suffix sum and the sum of all\n     * elements in the {@code bounds list}.\n     *\n     * @param bounds list of integers.\n     * @return computed pair of suffix sum list and a sum of all elements.\n     */\n    private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds)\n    {\n        List<Integer> suffixSum = new ArrayList<>(Collections.nCopies(bounds.size(), 0));\n        long sum = 0;\n        for (int i = bounds.size() - 1; i >= 0; i--) {\n            suffixSum.set(i, (int) Math.min(Integer.MAX_VALUE, sum));\n            sum += bounds.get(i);\n        }\n\n        return Pair.of(suffixSum, sum);\n    }\n\n    /**\n     * Computes and returns a value distribution for the list of keys. The resulting distribution\n     * will satisfy the (possibly empty) sets of lower and upper bound constraints. Distributed\n     * values will be in the same order as the keys in the key list.\n     *\n     * @param keys the list of keys.\n     * @param valueNum the number of abstract value units to distribute.\n     * @return the computed value distribution.\n     */\n    public List<Integer> getDistribution(List<K> keys, final int valueNum)\n    {\n        List<Integer> keyLowerBounds = computeLowerBounds(keys);\n        List<Integer> keyUpperBounds = computeUpperBounds(keys);\n\n        Pair<List<Integer>, Long> lbSufSumP = computeSuffixSum(keyLowerBounds);\n        Pair<List<Integer>, Long> ubSufSumP = computeSuffixSum(keyUpperBounds);\n\n        List<Integer> lbSufSum = lbSufSumP.getFirst();\n        List<Integer> ubSufSum = ubSufSumP.getFirst();\n\n        long lbSum = lbSufSumP.getSecond();\n        long ubSum = ubSufSumP.getSecond();\n\n        if (lbSum > valueNum) {\n            throw new IllegalArgumentException(\n                \"Can't distribute values among keys: the sum of lower bounds is greater than the number of values\");\n        } else if (ubSum < valueNum) {\n            throw new IllegalArgumentException(\n                \"Can't distribute values among keys: the sum of upper bounds is smaller than the number of values\");\n        }\n\n        int remainingValues = valueNum;\n        List<Integer> resultingDistribution = new ArrayList<>();\n        for (int i = 0; i < keyLowerBounds.size(); i++) {\n            int lowerBound = keyLowerBounds.get(i);\n            int upperBound = keyUpperBounds.get(i);\n\n            int valueNumUpperBound = remainingValues - lbSufSum.get(i);\n            int valueNumLowerBound = remainingValues - ubSufSum.get(i);\n\n            lowerBound = Math.max(lowerBound, valueNumLowerBound);\n            upperBound = Math.min(upperBound, valueNumUpperBound);\n\n            if (lowerBound > upperBound) {\n                throw new IllegalArgumentException(\n                    \"Infeasible bound specified for the key: \" + keys.get(i));\n            }\n\n            int allocatedValues = rng.nextInt(upperBound - lowerBound + 1) + lowerBound;\n            resultingDistribution.add(allocatedValues);\n            remainingValues -= allocatedValues;\n        }\n\n        return resultingDistribution;\n    }\n\n}\n",
            "file_name": "Distributor.java",
            "human_label": "The type of key has several lower bounds conducted by different function,this function will return a list of the maximum lower bound of each key in the given list.",
            "level": "class_runnable",
            "lineno": "102",
            "name": "computeLowerBounds",
            "oracle_context": "{ \"apis\" : \"[size, max, apply, add]\", \"classes\" : \"[List<Integer>]\", \"vars\" : \"[lowerBounds]\" }",
            "package": "org.jgrapht.generate.netgen",
            "project": "jgrapht-master"
        },
        {
            "_id": "636767581a6d9265ec017fb4",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.alg.util.Pair;\\nimport java.util.*;\\nimport java.util.function.Function;\\nRandom rng;\\nList<Function<K,Integer>> lowerBounds;\\nList<Function<K,Integer>> upperBounds;\\nDistributor();\\nDistributor(long seed);\\nDistributor(Random rng);\\naddLowerBound(Function lowerBound);\\ncomputeLowerBounds(List keys);\\ncomputeUpperBounds(List keys);\\ncomputeSuffixSum(List bounds);\\ngetDistribution(List keys,int valueNum);\\naddUpperBound(Function upperBound);\\n\", \"repo_level\" : \"public interface Pair {public A getFirst();\\npublic B getSecond();\\npublic void setFirst(A f);\\npublic void setSecond(B s);\\npublic boolean hasElement(E e);\\npublic String toString();\\npublic boolean equals(Object o);\\npublic int hashCode();\\nstatic Pair<A,B> of(A a,B b);\\n }\\n\" }",
            "class_name": "Distributor",
            "code": "private List<Integer> computeUpperBounds(List<K> keys){\n  List<Integer> keyUpperBounds=new ArrayList<>(keys.size());\n  for (  K key : keys) {\n    int upperBound=Integer.MAX_VALUE;\n    for (    Function<K,Integer> upperBoundFunction : upperBounds) {\n      upperBound=Math.min(upperBound,upperBoundFunction.apply(key));\n    }\n    keyUpperBounds.add(upperBound);\n  }\n  return keyUpperBounds;\n}\n",
            "docstring": "/** \n * Finds a minimum lower bound for every key.\n * @param keys a list of keys.\n * @return the computed key upper bound.\n */\n",
            "end_lineno": "140",
            "file_content": "/*\n * (C) Copyright 2020-2021, by Timofey Chudakov and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.generate.netgen;\n\nimport org.jgrapht.alg.util.Pair;\n\nimport java.util.*;\nimport java.util.function.Function;\n\n/**\n * Distributes value units among keys given lower and upper bound constraints.\n * <p>\n * Let's define a set of elements $\\{k_1, k_2, \\dots, k_n\\}$. For every element a set of lower\n * bounds $\\{l_1, l_2, \\dots, l_t\\}$ and upper bounds $\\{u_1, u_2, \\dots, u_p\\}$ is specified. The\n * problem is to randomly distribute a number of abstract value units $V$ among keys such that the\n * lower bound and upper bound constraints are satisfied. This class solves this problem.\n *\n * @param <K> the element type.\n * @author Timofey Chudakov\n * @see NetworkGenerator\n */\npublic class Distributor<K>\n{\n    /**\n     * Random number generator used by this distributor.\n     */\n    private final Random rng;\n    /**\n     * Lower bounds.\n     */\n    private final List<Function<K, Integer>> lowerBounds;\n    /**\n     * Upper bounds.\n     */\n    private final List<Function<K, Integer>> upperBounds;\n\n    /**\n     * Creates a Distributor using random seed.\n     */\n    public Distributor()\n    {\n        this(System.nanoTime());\n    }\n\n    /**\n     * Creates a distributor using the specified {@code seed}.\n     *\n     * @param seed the seed for the random number generator.\n     */\n    public Distributor(long seed)\n    {\n        this(new Random(seed));\n    }\n\n    /**\n     * Creates a distributor which uses the random number generatow {@code rng}.\n     *\n     * @param rng a random number generator to use.\n     */\n    public Distributor(Random rng)\n    {\n        this.rng = rng;\n        this.lowerBounds = new ArrayList<>();\n        this.upperBounds = new ArrayList<>();\n    }\n\n    /**\n     * Adds an upper bounding function. This function must be defined for all keys.\n     *\n     * @param upperBound an upper bound function.\n     */\n    public void addUpperBound(Function<K, Integer> upperBound)\n    {\n        this.upperBounds.add(upperBound);\n    }\n\n    /**\n     * Adds a lower bound function. This function must be defined for all keys.\n     *\n     * @param lowerBound a lower bound function.\n     */\n    public void addLowerBound(Function<K, Integer> lowerBound)\n    {\n        this.lowerBounds.add(lowerBound);\n    }\n\n    /**\n     * Finds a maximum lower bound for every key.\n     *\n     * @param keys list of keys.\n     * @return the computed key lower bounds.\n     */\n    private List<Integer> computeLowerBounds(List<K> keys)\n    {\n        List<Integer> keyLowerBounds = new ArrayList<>(keys.size());\n        for (K key : keys) {\n            int lowerBound = 0;\n            for (Function<K, Integer> lowerBoundFunction : lowerBounds) {\n                lowerBound = Math.max(lowerBound, lowerBoundFunction.apply(key));\n            }\n            keyLowerBounds.add(lowerBound);\n        }\n\n        return keyLowerBounds;\n    }\n\n    /**\n     * Finds a minimum lower bound for every key.\n     *\n     * @param keys a list of keys.\n     * @return the computed key upper bound.\n     */\n    private List<Integer> computeUpperBounds(List<K> keys)\n    {\n        List<Integer> keyUpperBounds = new ArrayList<>(keys.size());\n        for (K key : keys) {\n            int upperBound = Integer.MAX_VALUE;\n            for (Function<K, Integer> upperBoundFunction : upperBounds) {\n                upperBound = Math.min(upperBound, upperBoundFunction.apply(key));\n            }\n            keyUpperBounds.add(upperBound);\n        }\n\n        return keyUpperBounds;\n    }\n\n    /**\n     * Computes a suffix sum of the {@code bounds}. Returns computed suffix sum and the sum of all\n     * elements in the {@code bounds list}.\n     *\n     * @param bounds list of integers.\n     * @return computed pair of suffix sum list and a sum of all elements.\n     */\n    private Pair<List<Integer>, Long> computeSuffixSum(List<Integer> bounds)\n    {\n        List<Integer> suffixSum = new ArrayList<>(Collections.nCopies(bounds.size(), 0));\n        long sum = 0;\n        for (int i = bounds.size() - 1; i >= 0; i--) {\n            suffixSum.set(i, (int) Math.min(Integer.MAX_VALUE, sum));\n            sum += bounds.get(i);\n        }\n\n        return Pair.of(suffixSum, sum);\n    }\n\n    /**\n     * Computes and returns a value distribution for the list of keys. The resulting distribution\n     * will satisfy the (possibly empty) sets of lower and upper bound constraints. Distributed\n     * values will be in the same order as the keys in the key list.\n     *\n     * @param keys the list of keys.\n     * @param valueNum the number of abstract value units to distribute.\n     * @return the computed value distribution.\n     */\n    public List<Integer> getDistribution(List<K> keys, final int valueNum)\n    {\n        List<Integer> keyLowerBounds = computeLowerBounds(keys);\n        List<Integer> keyUpperBounds = computeUpperBounds(keys);\n\n        Pair<List<Integer>, Long> lbSufSumP = computeSuffixSum(keyLowerBounds);\n        Pair<List<Integer>, Long> ubSufSumP = computeSuffixSum(keyUpperBounds);\n\n        List<Integer> lbSufSum = lbSufSumP.getFirst();\n        List<Integer> ubSufSum = ubSufSumP.getFirst();\n\n        long lbSum = lbSufSumP.getSecond();\n        long ubSum = ubSufSumP.getSecond();\n\n        if (lbSum > valueNum) {\n            throw new IllegalArgumentException(\n                \"Can't distribute values among keys: the sum of lower bounds is greater than the number of values\");\n        } else if (ubSum < valueNum) {\n            throw new IllegalArgumentException(\n                \"Can't distribute values among keys: the sum of upper bounds is smaller than the number of values\");\n        }\n\n        int remainingValues = valueNum;\n        List<Integer> resultingDistribution = new ArrayList<>();\n        for (int i = 0; i < keyLowerBounds.size(); i++) {\n            int lowerBound = keyLowerBounds.get(i);\n            int upperBound = keyUpperBounds.get(i);\n\n            int valueNumUpperBound = remainingValues - lbSufSum.get(i);\n            int valueNumLowerBound = remainingValues - ubSufSum.get(i);\n\n            lowerBound = Math.max(lowerBound, valueNumLowerBound);\n            upperBound = Math.min(upperBound, valueNumUpperBound);\n\n            if (lowerBound > upperBound) {\n                throw new IllegalArgumentException(\n                    \"Infeasible bound specified for the key: \" + keys.get(i));\n            }\n\n            int allocatedValues = rng.nextInt(upperBound - lowerBound + 1) + lowerBound;\n            resultingDistribution.add(allocatedValues);\n            remainingValues -= allocatedValues;\n        }\n\n        return resultingDistribution;\n    }\n\n}\n",
            "file_name": "Distributor.java",
            "human_label": "The type of key has several upper bounds conducted by different function,this function will return a list of the minimum upper bound of each key in the given list.",
            "level": "class_runnable",
            "lineno": "122",
            "name": "computeUpperBounds",
            "oracle_context": "{ \"apis\" : \"[size, min, apply, add]\", \"classes\" : \"[List<Integer>, Integer]\", \"vars\" : \"[MAX_VALUE, upperBounds]\" }",
            "package": "org.jgrapht.generate.netgen",
            "project": "jgrapht-master"
        },
        {
            "_id": "636767531a6d9265ec017ef1",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.alg.util.*;\\nimport java.util.function.*;\\nToleranceDoubleComparator TOLERANCE_DOUBLE_COMPARATOR;\\nadd(Point2D a,Point2D b);\\nsubtract(Point2D a,Point2D b);\\nnegate(Point2D a);\\nscalarMultiply(Point2D a,double scalar);\\nscalarMultiply(Point2D a,S scalar,BiFunction mult);\\nequals(Point2D p1,Point2D p2);\\nlength(Point2D v);\\n\", \"repo_level\" : \"\" }",
            "class_name": "Points",
            "code": "public static boolean equals(Point2D p1,Point2D p2){\n  int xEquals=TOLERANCE_DOUBLE_COMPARATOR.compare(p1.getX(),p2.getX());\n  if (xEquals != 0) {\n    return false;\n  }\n  return TOLERANCE_DOUBLE_COMPARATOR.compare(p1.getY(),p2.getY()) == 0;\n}\n",
            "docstring": "/** \n * Compare two points for equality using tolerance 1e-9.\n * @param p1 the first point\n * @param p2 the second point\n * @return whether the two points are equal or not\n */\n",
            "end_lineno": "122",
            "file_content": "/*\n * (C) Copyright 2018-2021, by Dimitrios Michail and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.alg.drawing.model;\n\nimport org.jgrapht.alg.util.*;\n\nimport java.util.function.*;\n\n/**\n * A collection of utilities to assist with point manipulation.\n * \n * @author Dimitrios Michail\n */\npublic abstract class Points\n{\n    private static final ToleranceDoubleComparator TOLERANCE_DOUBLE_COMPARATOR =\n        new ToleranceDoubleComparator(1e-9);\n\n    /**\n     * Compute the length of a vector. The length of vector $(x,y)$ is given by $\\sqrt{x^2+y^2}$.\n     * \n     * @param v the vector\n     * @return the length of a vector\n     */\n    public static double length(Point2D v)\n    {\n        return Math.sqrt(v.getX() * v.getX() + v.getY() * v.getY());\n    }\n\n    /**\n     * Add 2-dimensional vectors\n     * \n     * @param a the first vector\n     * @param b the second vector\n     * @return the vector $a+b$\n     */\n    public static Point2D add(Point2D a, Point2D b)\n    {\n        return Point2D.of(a.getX() + b.getX(), a.getY() + b.getY());\n    }\n\n    /**\n     * Subtract 2-dimensional vectors\n     * \n     * @param a the first vector\n     * @param b the second vector\n     * @return the vector $a-b$\n     */\n    public static Point2D subtract(Point2D a, Point2D b)\n    {\n        return Point2D.of(a.getX() - b.getX(), a.getY() - b.getY());\n    }\n\n    /**\n     * Given a vector $a$ compute $-a$.\n     * \n     * @param a the vector\n     * @return the vector $-a$\n     */\n    public static Point2D negate(Point2D a)\n    {\n        return scalarMultiply(a, -1.0);\n    }\n\n    /**\n     * Multiply a vector with a scalar.\n     * \n     * @param a the vector\n     * @param scalar the scalar\n     * @return the result of scalar multiplication\n     */\n    public static Point2D scalarMultiply(Point2D a, double scalar)\n    {\n        return scalarMultiply(a, scalar, (x, s) -> x * s);\n    }\n\n    /**\n     * Multiply a vector with a scalar.\n     * \n     * @param a the vector\n     * @param scalar the scalar\n     * @param mult the multiplication operator\n     * @return the result of scalar multiplication\n     * \n     * @param <S> the scalar type\n     */\n    public static <\n        S> Point2D scalarMultiply(Point2D a, S scalar, BiFunction<Double, S, Double> mult)\n    {\n        return Point2D.of(mult.apply(a.getX(), scalar), mult.apply(a.getY(), scalar));\n    }\n\n    /**\n     * Compare two points for equality using tolerance 1e-9.\n     * \n     * @param p1 the first point\n     * @param p2 the second point\n     * @return whether the two points are equal or not\n     */\n    public static boolean equals(Point2D p1, Point2D p2)\n    {\n        int xEquals = TOLERANCE_DOUBLE_COMPARATOR.compare(p1.getX(), p2.getX());\n        if (xEquals != 0) {\n            return false;\n        }\n        return TOLERANCE_DOUBLE_COMPARATOR.compare(p1.getY(), p2.getY()) == 0;\n    }\n\n}\n",
            "file_name": "Points.java",
            "human_label": "Using TOLERANCE_DOUBLE_COMPARATOR to compare two points for equality,return true the point p1 is equal to another point p2,otherwise return false.",
            "level": "project_runnable",
            "lineno": "108",
            "name": "equals",
            "oracle_context": "{ \"apis\" : \"[compare, getX, getY]\", \"classes\" : \"[]\", \"vars\" : \"[TOLERANCE_DOUBLE_COMPARATOR]\" }",
            "package": "org.jgrapht.alg.drawing.model",
            "project": "jgrapht-master"
        },
        {
            "_id": "636766fc1a6d9265ec0177ef",
            "all_context": "{ \"class_level\" : \"import net.hasor.utils.ArrayUtils;\\nimport net.hasor.utils.ClassUtils;\\nimport java.lang.reflect.AccessibleObject;\\nimport java.lang.reflect.Field;\\nimport java.lang.reflect.Modifier;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nboolean appendStatics;\\nboolean appendTransients;\\nString[] excludeFieldNames;\\nClass<?> upToClass;\\ntoString(Object object,ToStringStyle style);\\ntoString(Object object,ToStringStyle style,boolean outputTransients);\\ntoString(Object object,ToStringStyle style,boolean outputTransients,boolean outputStatics);\\ntoString(Object object,ToStringStyle style,boolean outputTransients,boolean outputStatics,Class reflectUpToClass);\\ntoStringExclude(Object object,String excludeFieldName);\\ntoStringExclude(Object object,Collection excludeFieldNames);\\ntoNoNullStringArray(Collection collection);\\ntoNoNullStringArray(Object[] array);\\ntoStringExclude(Object object,String[] excludeFieldNames);\\nReflectionToStringBuilder(Object object);\\nReflectionToStringBuilder(Object object,ToStringStyle style);\\nReflectionToStringBuilder(Object object,ToStringStyle style,StringBuffer buffer);\\nReflectionToStringBuilder(Object object,ToStringStyle style,StringBuffer buffer,Class reflectUpToClass,boolean outputTransients,boolean outputStatics);\\naccept(Field field);\\nappendFieldsIn(Class clazz);\\ngetExcludeFieldNames();\\ngetUpToClass();\\ngetValue(Field field);\\nisAppendStatics();\\nisAppendTransients();\\nreflectionAppendArray(Object array);\\nsetAppendStatics(boolean appendStatics);\\nsetAppendTransients(boolean appendTransients);\\nsetExcludeFieldNames(String[] excludeFieldNamesParam);\\nsetUpToClass(Class clazz);\\ntoString();\\ntoString(Object object);\\n\", \"repo_level\" : \"public interface ArrayUtils {static Map toMap(Object[] array);\\nstatic Object[] clone(Object[] array);\\nstatic long[] clone(long[] array);\\nstatic int[] clone(int[] array);\\nstatic short[] clone(short[] array);\\nstatic char[] clone(char[] array);\\nstatic byte[] clone(byte[] array);\\nstatic double[] clone(double[] array);\\nstatic float[] clone(float[] array);\\nstatic boolean[] clone(boolean[] array);\\nstatic String[] clone(String[] array);\\nstatic Object[] nullToEmpty(Object[] array);\\nstatic String[] nullToEmpty(String[] array);\\nstatic long[] nullToEmpty(long[] array);\\nstatic int[] nullToEmpty(int[] array);\\nstatic short[] nullToEmpty(short[] array);\\nstatic char[] nullToEmpty(char[] array);\\nstatic byte[] nullToEmpty(byte[] array);\\nstatic double[] nullToEmpty(double[] array);\\nstatic float[] nullToEmpty(float[] array);\\nstatic boolean[] nullToEmpty(boolean[] array);\\nstatic Long[] nullToEmpty(Long[] array);\\nstatic Integer[] nullToEmpty(Integer[] array);\\nstatic Short[] nullToEmpty(Short[] array);\\nstatic Character[] nullToEmpty(Character[] array);\\nstatic Byte[] nullToEmpty(Byte[] array);\\nstatic Double[] nullToEmpty(Double[] array);\\nstatic Float[] nullToEmpty(Float[] array);\\nstatic Boolean[] nullToEmpty(Boolean[] array);\\nstatic Object[] subarray(Object[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic long[] subarray(long[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic int[] subarray(int[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic short[] subarray(short[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic char[] subarray(char[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic byte[] subarray(byte[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic double[] subarray(double[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic float[] subarray(float[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic boolean[] subarray(boolean[] array,int startIndexInclusive,int endIndexExclusive);\\nstatic boolean isSameLength(Object[] array1,Object[] array2);\\nstatic boolean isSameLength(long[] array1,long[] array2);\\nstatic boolean isSameLength(int[] array1,int[] array2);\\nstatic boolean isSameLength(short[] array1,short[] array2);\\nstatic boolean isSameLength(char[] array1,char[] array2);\\nstatic boolean isSameLength(byte[] array1,byte[] array2);\\nstatic boolean isSameLength(double[] array1,double[] array2);\\nstatic boolean isSameLength(float[] array1,float[] array2);\\nstatic boolean isSameLength(boolean[] array1,boolean[] array2);\\nstatic int getLength(Object array);\\nstatic boolean isSameType(Object array1,Object array2);\\nstatic void reverse(Object[] array);\\nstatic void reverse(long[] array);\\nstatic void reverse(int[] array);\\nstatic void reverse(short[] array);\\nstatic void reverse(char[] array);\\nstatic void reverse(byte[] array);\\nstatic void reverse(double[] array);\\nstatic void reverse(float[] array);\\nstatic void reverse(boolean[] array);\\nstatic int indexOf(Object[] array,Object objectToFind);\\nstatic int indexOf(Object[] array,Object objectToFind,int startIndex);\\nstatic int lastIndexOf(Object[] array,Object objectToFind);\\nstatic int lastIndexOf(Object[] array,Object objectToFind,int startIndex);\\nstatic boolean contains(Object[] array,Object objectToFind);\\nstatic int indexOf(long[] array,long valueToFind);\\nstatic int indexOf(long[] array,long valueToFind,int startIndex);\\nstatic int lastIndexOf(long[] array,long valueToFind);\\nstatic int lastIndexOf(long[] array,long valueToFind,int startIndex);\\nstatic boolean contains(long[] array,long valueToFind);\\nstatic int indexOf(int[] array,int valueToFind);\\nstatic int indexOf(int[] array,int valueToFind,int startIndex);\\nstatic int lastIndexOf(int[] array,int valueToFind);\\nstatic int lastIndexOf(int[] array,int valueToFind,int startIndex);\\nstatic boolean contains(int[] array,int valueToFind);\\nstatic int indexOf(short[] array,short valueToFind);\\nstatic int indexOf(short[] array,short valueToFind,int startIndex);\\nstatic int lastIndexOf(short[] array,short valueToFind);\\nstatic int lastIndexOf(short[] array,short valueToFind,int startIndex);\\nstatic boolean contains(short[] array,short valueToFind);\\nstatic int indexOf(char[] array,char valueToFind);\\nstatic int indexOf(char[] array,char valueToFind,int startIndex);\\nstatic int lastIndexOf(char[] array,char valueToFind);\\nstatic int lastIndexOf(char[] array,char valueToFind,int startIndex);\\nstatic boolean contains(char[] array,char valueToFind);\\nstatic int indexOf(byte[] array,byte valueToFind);\\nstatic int indexOf(byte[] array,byte valueToFind,int startIndex);\\nstatic int lastIndexOf(byte[] array,byte valueToFind);\\nstatic int lastIndexOf(byte[] array,byte valueToFind,int startIndex);\\nstatic boolean contains(byte[] array,byte valueToFind);\\nstatic int indexOf(double[] array,double valueToFind);\\nstatic int indexOf(double[] array,double valueToFind,double tolerance);\\nstatic int indexOf(double[] array,double valueToFind,int startIndex);\\nstatic int indexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\nstatic int lastIndexOf(double[] array,double valueToFind);\\nstatic int lastIndexOf(double[] array,double valueToFind,double tolerance);\\nstatic int lastIndexOf(double[] array,double valueToFind,int startIndex);\\nstatic int lastIndexOf(double[] array,double valueToFind,int startIndex,double tolerance);\\nstatic boolean contains(double[] array,double valueToFind);\\nstatic boolean contains(double[] array,double valueToFind,double tolerance);\\nstatic int indexOf(float[] array,float valueToFind);\\nstatic int indexOf(float[] array,float valueToFind,int startIndex);\\nstatic int lastIndexOf(float[] array,float valueToFind);\\nstatic int lastIndexOf(float[] array,float valueToFind,int startIndex);\\nstatic boolean contains(float[] array,float valueToFind);\\nstatic int indexOf(boolean[] array,boolean valueToFind);\\nstatic int indexOf(boolean[] array,boolean valueToFind,int startIndex);\\nstatic int lastIndexOf(boolean[] array,boolean valueToFind);\\nstatic int lastIndexOf(boolean[] array,boolean valueToFind,int startIndex);\\nstatic boolean contains(boolean[] array,boolean valueToFind);\\nstatic char[] toPrimitive(Character[] array);\\nstatic char[] toPrimitive(Character[] array,char valueForNull);\\nstatic Character[] toObject(char[] array);\\nstatic long[] toPrimitive(Long[] array);\\nstatic long[] toPrimitive(Long[] array,long valueForNull);\\nstatic Long[] toObject(long[] array);\\nstatic int[] toPrimitive(Integer[] array);\\nstatic int[] toPrimitive(Integer[] array,int valueForNull);\\nstatic Integer[] toObject(int[] array);\\nstatic short[] toPrimitive(Short[] array);\\nstatic short[] toPrimitive(Short[] array,short valueForNull);\\nstatic Short[] toObject(short[] array);\\nstatic byte[] toPrimitive(Byte[] array);\\nstatic byte[] toPrimitive(Byte[] array,byte valueForNull);\\nstatic Byte[] toObject(byte[] array);\\nstatic double[] toPrimitive(Double[] array);\\nstatic double[] toPrimitive(Double[] array,double valueForNull);\\nstatic Double[] toObject(double[] array);\\nstatic float[] toPrimitive(Float[] array);\\nstatic float[] toPrimitive(Float[] array,float valueForNull);\\nstatic Float[] toObject(float[] array);\\nstatic boolean[] toPrimitive(Boolean[] array);\\nstatic boolean[] toPrimitive(Boolean[] array,boolean valueForNull);\\nstatic Boolean[] toObject(boolean[] array);\\nstatic boolean isEmpty(Object[] array);\\nstatic boolean isEmpty(long[] array);\\nstatic boolean isEmpty(int[] array);\\nstatic boolean isEmpty(short[] array);\\nstatic boolean isEmpty(char[] array);\\nstatic boolean isEmpty(byte[] array);\\nstatic boolean isEmpty(double[] array);\\nstatic boolean isEmpty(float[] array);\\nstatic boolean isEmpty(boolean[] array);\\nstatic boolean isNotEmpty(Object[] array);\\nstatic boolean isNotEmpty(long[] array);\\nstatic boolean isNotEmpty(int[] array);\\nstatic boolean isNotEmpty(short[] array);\\nstatic boolean isNotEmpty(char[] array);\\nstatic boolean isNotEmpty(byte[] array);\\nstatic boolean isNotEmpty(double[] array);\\nstatic boolean isNotEmpty(float[] array);\\nstatic boolean isNotEmpty(boolean[] array);\\nstatic Object[] addAll(Object[] array1,Object[] array2);\\nstatic boolean[] addAll(boolean[] array1,boolean[] array2);\\nstatic char[] addAll(char[] array1,char[] array2);\\nstatic byte[] addAll(byte[] array1,byte[] array2);\\nstatic short[] addAll(short[] array1,short[] array2);\\nstatic int[] addAll(int[] array1,int[] array2);\\nstatic long[] addAll(long[] array1,long[] array2);\\nstatic float[] addAll(float[] array1,float[] array2);\\nstatic double[] addAll(double[] array1,double[] array2);\\nstatic String[] addAll(String[] array1,String[] array2);\\nstatic T[] add(T[] array,T element);\\nstatic boolean[] add(boolean[] array,boolean element);\\nstatic byte[] add(byte[] array,byte element);\\nstatic char[] add(char[] array,char element);\\nstatic double[] add(double[] array,double element);\\nstatic float[] add(float[] array,float element);\\nstatic int[] add(int[] array,int element);\\nstatic long[] add(long[] array,long element);\\nstatic short[] add(short[] array,short element);\\nstatic Object[] add(Object[] array,int index,Object element);\\nstatic boolean[] add(boolean[] array,int index,boolean element);\\nstatic char[] add(char[] array,int index,char element);\\nstatic byte[] add(byte[] array,int index,byte element);\\nstatic short[] add(short[] array,int index,short element);\\nstatic int[] add(int[] array,int index,int element);\\nstatic long[] add(long[] array,int index,long element);\\nstatic float[] add(float[] array,int index,float element);\\nstatic double[] add(double[] array,int index,double element);\\nstatic Object[] remove(Object[] array,int index);\\nstatic Object[] removeElement(Object[] array,Object element);\\nstatic boolean[] remove(boolean[] array,int index);\\nstatic boolean[] removeElement(boolean[] array,boolean element);\\nstatic byte[] remove(byte[] array,int index);\\nstatic byte[] removeElement(byte[] array,byte element);\\nstatic char[] remove(char[] array,int index);\\nstatic char[] removeElement(char[] array,char element);\\nstatic double[] remove(double[] array,int index);\\nstatic double[] removeElement(double[] array,double element);\\nstatic float[] remove(float[] array,int index);\\nstatic float[] removeElement(float[] array,float element);\\nstatic int[] remove(int[] array,int index);\\nstatic int[] removeElement(int[] array,int element);\\nstatic long[] remove(long[] array,int index);\\nstatic long[] removeElement(long[] array,long element);\\nstatic short[] remove(short[] array,int index);\\nstatic short[] removeElement(short[] array,short element);\\nstatic Object[] clearNull(Object[] arr);\\n }\\npublic interface ClassUtils {static String getShortClassName(Object object,String valueIfNull);\\nstatic String getShortClassName(Class cls);\\nstatic String getShortClassName(String className);\\nstatic String getPackageName(Object object,String valueIfNull);\\nstatic String getPackageName(Class cls);\\nstatic String getPackageName(String className);\\nstatic List<Class<?>> getAllSuperclasses(Class cls);\\nstatic List<Class<?>> getAllInterfaces(Class cls);\\nstatic List<Class<?>> convertClassNamesToClasses(List classNames);\\nstatic List<String> convertClassesToClassNames(List classes);\\nstatic boolean isAssignable(Class<?>[] classArray,Class<?>[] toClassArray);\\nstatic boolean isAssignable(Class<?>[] classArray,Class<?>[] toClassArray,boolean autoboxing);\\nstatic boolean isAssignable(Class cls,Class toClass);\\nstatic boolean isAssignable(Class cls,Class toClass,boolean autoboxing);\\nstatic Class<?> primitiveToWrapper(Class cls);\\nstatic Class<?>[] primitivesToWrappers(Class<?>[] classes);\\nstatic Class<?> wrapperToPrimitive(Class cls);\\nstatic Class<?>[] wrappersToPrimitives(Class<?>[] classes);\\nstatic boolean isInnerClass(Class cls);\\nstatic Class<?> getClass(ClassLoader classLoader,String className,boolean initialize);\\nstatic Class<?> getClass(ClassLoader classLoader,String className);\\nstatic Class<?> getClass(String className);\\nstatic Class<?> getClass(String className,boolean initialize);\\nstatic Method getPublicMethod(Class cls,String methodName,Class parameterTypes);\\nstatic Class<?>[] toClass(Object[] array);\\nstatic String getShortCanonicalName(Object object,String valueIfNull);\\nstatic String getShortCanonicalName(Class cls);\\nstatic String getShortCanonicalName(String canonicalName);\\nstatic String getPackageCanonicalName(Object object,String valueIfNull);\\nstatic String getPackageCanonicalName(Class cls);\\nstatic String getPackageCanonicalName(String canonicalName);\\nstatic ClassLoader getClassLoader(ClassLoader classLoader);\\nstatic boolean isLangClass(Class target);\\nstatic String getDescName(Class type);\\nstatic String getDescNameWithOutModifiers(Method method);\\nstatic String getDescName(Method method);\\nstatic Class<?> getSuperClassGenricType(Class clazz,int index);\\nstatic T newInstance(Class clazz);\\n }\\n\" }",
            "class_name": "ReflectionToStringBuilder",
            "code": "static String[] toNoNullStringArray(Object[] array){\n  ArrayList<String> list=new ArrayList<String>(array.length);\n  for (int i=0; i < array.length; i++) {\n    Object e=array[i];\n    if (e != null) {\n      list.add(e.toString());\n    }\n  }\n  return (String[])list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n}\n",
            "docstring": "/** \n * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists (arrays and collections). Note that  {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}if an array element is <code>null</code>.\n * @param array The array to check\n * @return The given array or a new array without null.\n */\n",
            "end_lineno": "346",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.builder;\nimport net.hasor.utils.ArrayUtils;\nimport net.hasor.utils.ClassUtils;\n\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\n/**\n * <p>\n * Assists in implementing {@link Object#toString()} methods using reflection.\n * </p>\n *\n * <p>\n * This class uses reflection to determine the fields to append. Because these fields are usually private, the class\n * uses {@link java.lang.reflect.AccessibleObject#setAccessible(java.lang.reflect.AccessibleObject[], boolean)} to\n * change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions are\n * set up correctly.\n * </p>\n *\n * <p>\n * A typical invocation for this method would look like:\n * </p>\n *\n * <pre>\n * public String toString() {\n *   return ReflectionToStringBuilder.toString(this);\n * }</pre>\n *\n *\n *\n * <p>\n * You can also use the builder to debug 3rd party objects:\n * </p>\n *\n * <pre>\n * System.out.println(\"An object: \" + ReflectionToStringBuilder.toString(anObject));</pre>\n *\n *\n *\n * <p>\n * A subclass can control field output by overriding the methods:\n * <ul>\n * <li>{@link #accept(java.lang.reflect.Field)}</li>\n * <li>{@link #getValue(java.lang.reflect.Field)}</li>\n * </ul>\n * </p>\n * <p>\n * For example, this method does <i>not</i> include the <code>password</code> field in the returned\n * <code>String</code>:\n * </p>\n *\n * <pre>\n * public String toString() {\n *     return (new ReflectionToStringBuilder(this) {\n *         protected boolean accept(Field f) {\n *             return super.accept(f) && !f.getName().equals(\"password\");\n *         }\n *     }).toString();\n * }</pre>\n *\n *\n *\n * <p>\n * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the\n * constructor.\n * </p>\n *\n * @author Apache Software Foundation\n * @author Gary Gregory\n * @author Pete Gieser\n * @since 2.0\n * @version $Id: ReflectionToStringBuilder.java 905636 2010-02-02 14:03:32Z niallp $\n */\npublic class ReflectionToStringBuilder extends ToStringBuilder {\n    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }\n\n    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object or <code>ToStringStyle</code> is <code>null</code>\n     */\n    public static String toString(Object object, ToStringStyle style) {\n        return toString(object, style, false, false, null);\n    }\n\n    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     *\n     * <p>\n     * Static fields will not be included. Superclass fields will be appended.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\n        return toString(object, style, outputTransients, false, null);\n    }\n\n    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     *\n     * <p>\n     * Static fields will not be included. Superclass fields will be appended.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include transient fields\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\n        return toString(object, style, outputTransients, outputStatics, null);\n    }\n\n    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     *\n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     *\n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     *\n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics, Class<?> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics).toString();\n    }\n\n    /**\n     * Builds a String for a toString method excluding the given field name.\n     *\n     * @param object\n     *            The object to \"toString\".\n     * @param excludeFieldName\n     *            The field name to exclude\n     * @return The toString value.\n     */\n    public static String toStringExclude(Object object, final String excludeFieldName) {\n        return toStringExclude(object, new String[] { excludeFieldName });\n    }\n\n    /**\n     * Builds a String for a toString method excluding the given field names.\n     *\n     * @param object\n     *            The object to \"toString\".\n     * @param excludeFieldNames\n     *            The field names to exclude. Null excludes nothing.\n     * @return The toString value.\n     */\n    public static String toStringExclude(Object object, Collection<?> /*String*/ excludeFieldNames) {\n        return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\n    }\n\n    /**\n     * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code>\n     * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element \n     * is <code>null</code>.\n     *\n     * @param collection\n     *            The collection to convert\n     * @return A new array of Strings.\n     */\n    static String[] toNoNullStringArray(Collection<?> collection) {\n        if (collection == null) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        return toNoNullStringArray(collection.toArray());\n    }\n\n    /**\n     * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists\n     * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}\n     * if an array element is <code>null</code>.\n     *\n     * @param array\n     *            The array to check\n     * @return The given array or a new array without null.\n     */\n    static String[] toNoNullStringArray(Object[] array) {\n        ArrayList<String> list = new ArrayList<String>(array.length);\n        for (int i = 0; i < array.length; i++) {\n            Object e = array[i];\n            if (e != null) {\n                list.add(e.toString());\n            }\n        }\n        return (String[]) list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Builds a String for a toString method excluding the given field names.\n     *\n     * @param object\n     *            The object to \"toString\".\n     * @param excludeFieldNames\n     *            The field names to exclude\n     * @return The toString value.\n     */\n    public static String toStringExclude(Object object, String[] excludeFieldNames) {\n        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\n    }\n\n    /**\n     * Whether or not to append static fields.\n     */\n    private boolean  appendStatics    = false;\n    /**\n     * Whether or not to append transient fields.\n     */\n    private boolean  appendTransients = false;\n    /**\n     * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\n     */\n    private String[] excludeFieldNames;\n    /**\n     * The last super class to stop appending fields for.\n     */\n    private Class<?> upToClass        = null;\n\n    /**\n     * <p>\n     * Constructor.\n     * </p>\n     *\n     * <p>\n     * This constructor outputs using the default style set with <code>setDefaultStyle</code>.\n     * </p>\n     *\n     * @param object\n     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the Object passed in is <code>null</code>\n     */\n    public ReflectionToStringBuilder(Object object) {\n        super(object);\n    }\n\n    /**\n     * <p>\n     * Constructor.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default style is used.\n     * </p>\n     *\n     * @param object\n     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the Object passed in is <code>null</code>\n     */\n    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\n        super(object, style);\n    }\n\n    /**\n     * <p>\n     * Constructor.\n     * </p>\n     *\n     * <p>\n     * If the style is <code>null</code>, the default style is used.\n     * </p>\n     *\n     * <p>\n     * If the buffer is <code>null</code>, a new one is created.\n     * </p>\n     *\n     * @param object\n     *            the Object to build a <code>toString</code> for\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param buffer\n     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the Object passed in is <code>null</code>\n     */\n    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n        super(object, style, buffer);\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param object\n     *            the Object to build a <code>toString</code> for\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param buffer\n     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @since 2.1\n     */\n    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer, Class<?> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\n        super(object, style, buffer);\n        this.setUpToClass(reflectUpToClass);\n        this.setAppendTransients(outputTransients);\n        this.setAppendStatics(outputStatics);\n    }\n\n    /**\n     * Returns whether or not to append the given <code>Field</code>.\n     * <ul>\n     * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\n     * <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\n     * <li>Inner class fields are not appened.</li>\n     * </ul>\n     *\n     * @param field The Field to test.\n     * @return Whether or not to append the given <code>Field</code>.\n     */\n    protected boolean accept(Field field) {\n        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n            // Reject field from inner class.\n            return false;\n        }\n        if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n            // Reject transient fields.\n            return false;\n        }\n        if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n            // Reject static fields.\n            return false;\n        }\n        if (this.getExcludeFieldNames() != null && Arrays.binarySearch(this.getExcludeFieldNames(), field.getName()) >= 0) {\n            // Reject fields from the getExcludeFieldNames list.\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     *\n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     *\n     * @param clazz The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length; i++) {\n            Field field = fields[i];\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }\n\n    /**\n     * @return Returns the excludeFieldNames.\n     */\n    public String[] getExcludeFieldNames() {\n        return this.excludeFieldNames;\n    }\n\n    /**\n     * <p>\n     * Gets the last super class to stop appending fields for.\n     * </p>\n     *\n     * @return The last super class to stop appending fields for.\n     */\n    public Class<?> getUpToClass() {\n        return this.upToClass;\n    }\n\n    /**\n     * <p>\n     * Calls <code>java.lang.reflect.Field.get(Object)</code>.\n     * </p>\n     *\n     * @param field The Field to query.\n     * @return The Object from the given Field.\n     *\n     * @throws IllegalArgumentException see {@link java.lang.reflect.Field#get(Object)}\n     * @throws IllegalAccessException see {@link java.lang.reflect.Field#get(Object)}\n     * @see java.lang.reflect.Field#get(Object)\n     */\n    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\n        return field.get(this.getObject());\n    }\n\n    /**\n     * <p>\n     * Gets whether or not to append static fields.\n     * </p>\n     *\n     * @return Whether or not to append static fields.\n     * @since 2.1\n     */\n    public boolean isAppendStatics() {\n        return this.appendStatics;\n    }\n\n    /**\n     * <p>\n     * Gets whether or not to append transient fields.\n     * </p>\n     *\n     * @return Whether or not to append transient fields.\n     */\n    public boolean isAppendTransients() {\n        return this.appendTransients;\n    }\n\n    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     *\n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }\n\n    /**\n     * <p>\n     * Sets whether or not to append static fields.\n     * </p>\n     *\n     * @param appendStatics\n     *            Whether or not to append static fields.\n     * @since 2.1\n     */\n    public void setAppendStatics(boolean appendStatics) {\n        this.appendStatics = appendStatics;\n    }\n\n    /**\n     * <p>\n     * Sets whether or not to append transient fields.\n     * </p>\n     *\n     * @param appendTransients Whether or not to append transient fields.\n     */\n    public void setAppendTransients(boolean appendTransients) {\n        this.appendTransients = appendTransients;\n    }\n\n    /**\n     * Sets the field names to exclude.\n     *\n     * @param excludeFieldNamesParam\n     *            The excludeFieldNames to excluding from toString or <code>null</code>.\n     * @return <code>this</code>\n     */\n    public ReflectionToStringBuilder setExcludeFieldNames(String[] excludeFieldNamesParam) {\n        if (excludeFieldNamesParam == null) {\n            this.excludeFieldNames = null;\n        } else {\n            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\n            Arrays.sort(this.excludeFieldNames);\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Sets the last super class to stop appending fields for.\n     * </p>\n     *\n     * @param clazz\n     *            The last super class to stop appending fields for.\n     */\n    public void setUpToClass(Class<?> clazz) {\n        if (clazz != null) {\n            Object object = getObject();\n            if (object != null && clazz.isInstance(object) == false) {\n                throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n            }\n        }\n        this.upToClass = clazz;\n    }\n\n    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     *\n     * @return the built string\n     */\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }\n}\n",
            "file_name": "ReflectionToStringBuilder.java",
            "human_label": "Return a new array of strings converted from the elements which are not null of the given array,if the size of the array is zero,it will throw an exception.",
            "level": "project_runnable",
            "lineno": "328",
            "name": "toNoNullStringArray",
            "oracle_context": "{ \"apis\" : \"[add, toString, toArray]\", \"classes\" : \"[ArrayList<String>, Object, ArrayUtils]\", \"vars\" : \"[length, EMPTY_STRING_ARRAY]\" }",
            "package": "net.hasor.utils.builder",
            "project": "hasor-master"
        },
        {
            "_id": "636767061a6d9265ec01794a",
            "all_context": "{ \"class_level\" : \"import java.io.File;\\nimport java.util.Collection;\\nchar EXTENSION_SEPARATOR;\\nString EXTENSION_SEPARATOR_STR;\\nchar UNIX_SEPARATOR;\\nchar WINDOWS_SEPARATOR;\\nchar SYSTEM_SEPARATOR;\\nchar OTHER_SEPARATOR;\\nFilenameUtils();\\nisSeparator(char ch);\\nnormalize(String filename);\\nnormalize(String filename,boolean unixSeparator);\\nnormalizeNoEndSeparator(String filename);\\nnormalizeNoEndSeparator(String filename,boolean unixSeparator);\\ndoNormalize(String filename,char separator,boolean keepSeparator);\\nconcat(String basePath,String fullFilenameToAdd);\\nseparatorsToUnix(String path);\\nseparatorsToWindows(String path);\\nseparatorsToSystem(String path);\\ngetPrefixLength(String filename);\\nindexOfLastSeparator(String filename);\\nindexOfExtension(String filename);\\ngetPrefix(String filename);\\ngetPath(String filename);\\ngetPathNoEndSeparator(String filename);\\ndoGetPath(String filename,int separatorAdd);\\ngetFullPath(String filename);\\ngetFullPathNoEndSeparator(String filename);\\ndoGetFullPath(String filename,boolean includeSeparator);\\ngetName(String filename);\\ngetBaseName(String filename);\\ngetExtension(String filename);\\nremoveExtension(String filename);\\nisExtension(String filename,String extension);\\nisExtension(String filename,String[] extensions);\\nisExtension(String filename,Collection extensions);\\nisSystemWindows();\\n\", \"repo_level\" : \"\" }",
            "class_name": "FilenameUtils",
            "code": "public static int indexOfExtension(String filename){\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator=indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}\n",
            "docstring": "/** \n * Returns the index of the last extension separator character, which is a dot. <p> This method also checks that there is no directory separator after the last dot. To do this it uses  {@link #indexOfLastSeparator(String)} which willhandle a file in either Unix or Windows format. <p> The output will be the same irrespective of the machine that the code is running on.\n * @param filename  the filename to find the last path separator in, null returns -1\n * @return the index of the last separator character, or -1 if thereis no such character\n */\n",
            "end_lineno": "657",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.hasor.utils.io;\nimport java.io.File;\nimport java.util.Collection;\n\n/**\n * General filename and filepath manipulation utilities.\n * <p>\n * When dealing with filenames you can hit problems when moving from a Windows\n * based development machine to a Unix based production machine.\n * This class aims to help avoid those problems.\n * <p>\n * <b>NOTE</b>: You may be able to avoid using this class entirely simply by\n * using JDK {@link File File} objects and the two argument constructor\n * {@link File#File(File, String) File(File,String)}.\n * <p>\n * Most methods on this class are designed to work the same on both Unix and Windows.\n * Those that don't include 'System', 'Unix' or 'Windows' in their name.\n * <p>\n * Most methods recognise both separators (forward and back), and both\n * sets of prefixes. See the javadoc of each method for details.\n * <p>\n * This class defines six components within a filename\n * (example C:\\dev\\project\\file.txt):\n * <ul>\n * <li>the prefix - C:\\</li>\n * <li>the path - dev\\project\\</li>\n * <li>the full path - C:\\dev\\project\\</li>\n * <li>the name - file.txt</li>\n * <li>the base name - file</li>\n * <li>the extension - txt</li>\n * </ul>\n * Note that this class works best if directory filenames end with a separator.\n * If you omit the last separator, it is impossible to determine if the filename\n * corresponds to a file or a directory. As a result, we have chosen to say\n * it corresponds to a file.\n * <p>\n * This class only supports Unix and Windows style names.\n * Prefixes are matched as follows:\n * <pre>\n * Windows:\n * a\\b\\c.txt           --> \"\"          --> relative\n * \\a\\b\\c.txt          --> \"\\\"         --> current drive absolute\n * C:a\\b\\c.txt         --> \"C:\"        --> drive relative\n * C:\\a\\b\\c.txt        --> \"C:\\\"       --> absolute\n * \\\\server\\a\\b\\c.txt  --> \"\\\\server\\\" --> UNC\n *\n * Unix:\n * a/b/c.txt           --> \"\"          --> relative\n * /a/b/c.txt          --> \"/\"         --> absolute\n * ~/a/b/c.txt         --> \"~/\"        --> current user\n * ~                   --> \"~/\"        --> current user (slash added)\n * ~user/a/b/c.txt     --> \"~user/\"    --> named user\n * ~user               --> \"~user/\"    --> named user (slash added)\n * </pre>\n * Both prefix styles are matched always, irrespective of the machine that you are\n * currently running on.\n * <p>\n * Origin of code: Excalibur, Alexandria, Tomcat, Commons-Utils.\n *\n * @version $Id: FilenameUtils.java 1307462 2012-03-30 15:13:11Z ggregory $\n * @since 1.1\n */\npublic class FilenameUtils {\n    /**\n     * The extension separator character.\n     * @since 1.4\n     */\n    public static final  char   EXTENSION_SEPARATOR     = '.';\n    /**\n     * The extension separator String.\n     * @since 1.4\n     */\n    public static final  String EXTENSION_SEPARATOR_STR = Character.toString(EXTENSION_SEPARATOR);\n    /**\n     * The Unix separator character.\n     */\n    private static final char   UNIX_SEPARATOR          = '/';\n    /**\n     * The Windows separator character.\n     */\n    private static final char   WINDOWS_SEPARATOR       = '\\\\';\n    /**\n     * The system separator character.\n     */\n    private static final char   SYSTEM_SEPARATOR        = File.separatorChar;\n    /**\n     * The separator character that is the opposite of the system separator.\n     */\n    private static final char   OTHER_SEPARATOR;\n\n    static {\n        if (isSystemWindows()) {\n            OTHER_SEPARATOR = UNIX_SEPARATOR;\n        } else {\n            OTHER_SEPARATOR = WINDOWS_SEPARATOR;\n        }\n    }\n\n    /**\n     * Instances should NOT be constructed in standard programming.\n     */\n    public FilenameUtils() {\n        super();\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Determines if Windows file system is in use.\n     *\n     * @return true if the system is Windows\n     */\n    static boolean isSystemWindows() {\n        return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR;\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Checks if the character is a separator.\n     *\n     * @param ch  the character to check\n     * @return true if it is a separator character\n     */\n    private static boolean isSeparator(char ch) {\n        return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR;\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               -->   /foo/\n     * /foo/./              -->   /foo/\n     * /foo/../bar          -->   /bar\n     * /foo/../bar/         -->   /bar/\n     * /foo/../bar/../baz   -->   /baz\n     * //foo//./bar         -->   /foo/bar\n     * /../                 -->   null\n     * ../foo               -->   null\n     * foo/bar/..           -->   foo/\n     * foo/../../bar        -->   null\n     * foo/../bar           -->   bar\n     * //server/foo/../bar  -->   //server/bar\n     * //server/../bar      -->   null\n     * C:\\foo\\..\\bar        -->   C:\\bar\n     * C:\\..\\bar            -->   null\n     * ~/foo/../bar/        -->   ~/bar/\n     * ~/../bar             -->   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param filename  the filename to normalize, null returns null\n     * @return the normalized filename, or null if invalid\n     */\n    public static String normalize(String filename) {\n        return doNormalize(filename, SYSTEM_SEPARATOR, true);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               -->   /foo/\n     * /foo/./              -->   /foo/\n     * /foo/../bar          -->   /bar\n     * /foo/../bar/         -->   /bar/\n     * /foo/../bar/../baz   -->   /baz\n     * //foo//./bar         -->   /foo/bar\n     * /../                 -->   null\n     * ../foo               -->   null\n     * foo/bar/..           -->   foo/\n     * foo/../../bar        -->   null\n     * foo/../bar           -->   bar\n     * //server/foo/../bar  -->   //server/bar\n     * //server/../bar      -->   null\n     * C:\\foo\\..\\bar        -->   C:\\bar\n     * C:\\..\\bar            -->   null\n     * ~/foo/../bar/        -->   ~/bar/\n     * ~/../bar             -->   null\n     * </pre>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     *\n     * @param filename  the filename to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized filename, or null if invalid\n     * @since 2.0\n     */\n    public static String normalize(String filename, boolean unixSeparator) {\n        char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(filename, separator, true);\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               -->   /foo\n     * /foo/./              -->   /foo\n     * /foo/../bar          -->   /bar\n     * /foo/../bar/         -->   /bar\n     * /foo/../bar/../baz   -->   /baz\n     * //foo//./bar         -->   /foo/bar\n     * /../                 -->   null\n     * ../foo               -->   null\n     * foo/bar/..           -->   foo\n     * foo/../../bar        -->   null\n     * foo/../bar           -->   bar\n     * //server/foo/../bar  -->   //server/bar\n     * //server/../bar      -->   null\n     * C:\\foo\\..\\bar        -->   C:\\bar\n     * C:\\..\\bar            -->   null\n     * ~/foo/../bar/        -->   ~/bar\n     * ~/../bar             -->   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param filename  the filename to normalize, null returns null\n     * @return the normalized filename, or null if invalid\n     */\n    public static String normalizeNoEndSeparator(String filename) {\n        return doNormalize(filename, SYSTEM_SEPARATOR, false);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     * <pre>\n     * /foo//               -->   /foo\n     * /foo/./              -->   /foo\n     * /foo/../bar          -->   /bar\n     * /foo/../bar/         -->   /bar\n     * /foo/../bar/../baz   -->   /baz\n     * //foo//./bar         -->   /foo/bar\n     * /../                 -->   null\n     * ../foo               -->   null\n     * foo/bar/..           -->   foo\n     * foo/../../bar        -->   null\n     * foo/../bar           -->   bar\n     * //server/foo/../bar  -->   //server/bar\n     * //server/../bar      -->   null\n     * C:\\foo\\..\\bar        -->   C:\\bar\n     * C:\\..\\bar            -->   null\n     * ~/foo/../bar/        -->   ~/bar\n     * ~/../bar             -->   null\n     * </pre>\n     *\n     * @param filename  the filename to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separtor should be used.\n     * @return the normalized filename, or null if invalid\n     * @since 2.0\n     */\n    public static String normalizeNoEndSeparator(String filename, boolean unixSeparator) {\n        char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(filename, separator, false);\n    }\n\n    /**\n     * Internal method to perform the normalization.\n     *\n     * @param filename  the filename\n     * @param separator The separator character to use\n     * @param keepSeparator  true to keep the final separator\n     * @return the normalized filename\n     */\n    private static String doNormalize(String filename, char separator, boolean keepSeparator) {\n        if (filename == null) {\n            return null;\n        }\n        int size = filename.length();\n        if (size == 0) {\n            return filename;\n        }\n        int prefix = getPrefixLength(filename);\n        if (prefix < 0) {\n            return null;\n        }\n        char[] array = new char[size + 2];  // +1 for possible extra slash, +2 for arraycopy\n        filename.getChars(0, filename.length(), array, 0);\n        // fix separators throughout\n        char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR;\n        for (int i = 0; i < array.length; i++) {\n            if (array[i] == otherSeparator) {\n                array[i] = separator;\n            }\n        }\n        // add extra separator on the end to simplify code below\n        boolean lastIsDirectory = true;\n        if (array[size - 1] != separator) {\n            array[size++] = separator;\n            lastIsDirectory = false;\n        }\n        // adjoining slashes\n        for (int i = prefix + 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == separator) {\n                System.arraycopy(array, i, array, i - 1, size - i);\n                size--;\n                i--;\n            }\n        }\n        // dot slash\n        for (int i = prefix + 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' && (i == prefix + 1 || array[i - 2] == separator)) {\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                System.arraycopy(array, i + 1, array, i - 1, size - i);\n                size -= 2;\n                i--;\n            }\n        }\n        // double dot slash\n        outer:\n        for (int i = prefix + 2; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' && (i == prefix + 2 || array[i - 3] == separator)) {\n                if (i == prefix + 2) {\n                    return null;\n                }\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                int j;\n                for (j = i - 4; j >= prefix; j--) {\n                    if (array[j] == separator) {\n                        // remove b/../ from a/b/../c\n                        System.arraycopy(array, i + 1, array, j + 1, size - i);\n                        size -= i - j;\n                        i = j + 1;\n                        continue outer;\n                    }\n                }\n                // remove a/../ from a/../c\n                System.arraycopy(array, i + 1, array, prefix, size - i);\n                size -= i + 1 - prefix;\n                i = prefix + 1;\n            }\n        }\n        if (size <= 0) {  // should never be less than 0\n            return \"\";\n        }\n        if (size <= prefix) {  // should never be less than prefix\n            return new String(array, 0, size);\n        }\n        if (lastIsDirectory && keepSeparator) {\n            return new String(array, 0, size);  // keep trailing separator\n        }\n        return new String(array, 0, size - 1);  // lose trailing separator\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Concatenates a filename to a base path using normal command line style rules.\n     * <p>\n     * The effect is equivalent to resultant directory after changing\n     * directory to the first argument, followed by changing directory to\n     * the second argument.\n     * <p>\n     * The first argument is the base path, the second is the path to concatenate.\n     * The returned path is always normalized via {@link #normalize(String)},\n     * thus <code>..</code> is handled.\n     * <p>\n     * If <code>pathToAdd</code> is absolute (has an absolute prefix), then\n     * it will be normalized and returned.\n     * Otherwise, the paths will be joined, normalized and returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo/ + bar          -->   /foo/bar\n     * /foo + bar           -->   /foo/bar\n     * /foo + /bar          -->   /bar\n     * /foo + C:/bar        -->   C:/bar\n     * /foo + C:bar         -->   C:bar (*)\n     * /foo/a/ + ../bar     -->   foo/bar\n     * /foo/ + ../../bar    -->   null\n     * /foo/ + /bar         -->   /bar\n     * /foo/.. + /bar       -->   /bar\n     * /foo + bar/c.txt     -->   /foo/bar/c.txt\n     * /foo/c.txt + bar     -->   /foo/c.txt/bar (!)\n     * </pre>\n     * (*) Note that the Windows relative drive prefix is unreliable when\n     * used with this method.\n     * (!) Note that the first parameter must be a path. If it ends with a name, then\n     * the name will be built into the concatenated path. If this might be a problem,\n     * use {@link #getFullPath(String)} on the base path argument.\n     *\n     * @param basePath  the base path to attach to, always treated as a path\n     * @param fullFilenameToAdd  the filename (or path) to attach to the base\n     * @return the concatenated path, or null if invalid\n     */\n    public static String concat(String basePath, String fullFilenameToAdd) {\n        int prefix = getPrefixLength(fullFilenameToAdd);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix > 0) {\n            return normalize(fullFilenameToAdd);\n        }\n        if (basePath == null) {\n            return null;\n        }\n        int len = basePath.length();\n        if (len == 0) {\n            return normalize(fullFilenameToAdd);\n        }\n        char ch = basePath.charAt(len - 1);\n        if (isSeparator(ch)) {\n            return normalize(basePath + fullFilenameToAdd);\n        } else {\n            return normalize(basePath + '/' + fullFilenameToAdd);\n        }\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Converts all separators to the Unix separator of forward slash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToUnix(String path) {\n        if (path == null || path.indexOf(WINDOWS_SEPARATOR) == -1) {\n            return path;\n        }\n        return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the Windows separator of backslash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToWindows(String path) {\n        if (path == null || path.indexOf(UNIX_SEPARATOR) == -1) {\n            return path;\n        }\n        return path.replace(UNIX_SEPARATOR, WINDOWS_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the system separator.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToSystem(String path) {\n        if (path == null) {\n            return null;\n        }\n        if (isSystemWindows()) {\n            return separatorsToWindows(path);\n        } else {\n            return separatorsToUnix(path);\n        }\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Returns the length of the filename prefix, such as <code>C:/</code> or <code>~/</code>.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * <p>\n     * The prefix length includes the first slash in the full filename\n     * if applicable. Thus, it is possible that the length returned is greater\n     * than the length of the input string.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --> \"\"          --> relative\n     * \\a\\b\\c.txt          --> \"\\\"         --> current drive absolute\n     * C:a\\b\\c.txt         --> \"C:\"        --> drive relative\n     * C:\\a\\b\\c.txt        --> \"C:\\\"       --> absolute\n     * \\\\server\\a\\b\\c.txt  --> \"\\\\server\\\" --> UNC\n     *\n     * Unix:\n     * a/b/c.txt           --> \"\"          --> relative\n     * /a/b/c.txt          --> \"/\"         --> absolute\n     * ~/a/b/c.txt         --> \"~/\"        --> current user\n     * ~                   --> \"~/\"        --> current user (slash added)\n     * ~user/a/b/c.txt     --> \"~user/\"    --> named user\n     * ~user               --> \"~user/\"    --> named user (slash added)\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * @param filename  the filename to find the prefix in, null returns -1\n     * @return the length of the prefix, -1 if invalid or null\n     */\n    public static int getPrefixLength(String filename) {\n        if (filename == null) {\n            return -1;\n        }\n        int len = filename.length();\n        if (len == 0) {\n            return 0;\n        }\n        char ch0 = filename.charAt(0);\n        if (ch0 == ':') {\n            return -1;\n        }\n        if (len == 1) {\n            if (ch0 == '~') {\n                return 2;  // return a length greater than the input\n            }\n            return isSeparator(ch0) ? 1 : 0;\n        } else {\n            if (ch0 == '~') {\n                int posUnix = filename.indexOf(UNIX_SEPARATOR, 1);\n                int posWin = filename.indexOf(WINDOWS_SEPARATOR, 1);\n                if (posUnix == -1 && posWin == -1) {\n                    return len + 1;  // return a length greater than the input\n                }\n                posUnix = posUnix == -1 ? posWin : posUnix;\n                posWin = posWin == -1 ? posUnix : posWin;\n                return Math.min(posUnix, posWin) + 1;\n            }\n            char ch1 = filename.charAt(1);\n            if (ch1 == ':') {\n                ch0 = Character.toUpperCase(ch0);\n                if (ch0 >= 'A' && ch0 <= 'Z') {\n                    if (len == 2 || isSeparator(filename.charAt(2)) == false) {\n                        return 2;\n                    }\n                    return 3;\n                }\n                return -1;\n            } else if (isSeparator(ch0) && isSeparator(ch1)) {\n                int posUnix = filename.indexOf(UNIX_SEPARATOR, 2);\n                int posWin = filename.indexOf(WINDOWS_SEPARATOR, 2);\n                if (posUnix == -1 && posWin == -1 || posUnix == 2 || posWin == 2) {\n                    return -1;\n                }\n                posUnix = posUnix == -1 ? posWin : posUnix;\n                posWin = posWin == -1 ? posUnix : posWin;\n                return Math.min(posUnix, posWin) + 1;\n            } else {\n                return isSeparator(ch0) ? 1 : 0;\n            }\n        }\n    }\n\n    /**\n     * Returns the index of the last directory separator character.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The position of the last forward or backslash is returned.\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param filename  the filename to find the last path separator in, null returns -1\n     * @return the index of the last separator character, or -1 if there\n     * is no such character\n     */\n    public static int indexOfLastSeparator(String filename) {\n        if (filename == null) {\n            return -1;\n        }\n        int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);\n        int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);\n        return Math.max(lastUnixPos, lastWindowsPos);\n    }\n\n    /**\n     * Returns the index of the last extension separator character, which is a dot.\n     * <p>\n     * This method also checks that there is no directory separator after the last dot.\n     * To do this it uses {@link #indexOfLastSeparator(String)} which will\n     * handle a file in either Unix or Windows format.\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param filename  the filename to find the last path separator in, null returns -1\n     * @return the index of the last separator character, or -1 if there\n     * is no such character\n     */\n    public static int indexOfExtension(String filename) {\n        if (filename == null) {\n            return -1;\n        }\n        int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);\n        int lastSeparator = indexOfLastSeparator(filename);\n        return lastSeparator > extensionPos ? -1 : extensionPos;\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Gets the prefix from a full filename, such as <code>C:/</code>\n     * or <code>~/</code>.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The prefix includes the first slash in the full filename where applicable.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --> \"\"          --> relative\n     * \\a\\b\\c.txt          --> \"\\\"         --> current drive absolute\n     * C:a\\b\\c.txt         --> \"C:\"        --> drive relative\n     * C:\\a\\b\\c.txt        --> \"C:\\\"       --> absolute\n     * \\\\server\\a\\b\\c.txt  --> \"\\\\server\\\" --> UNC\n     *\n     * Unix:\n     * a/b/c.txt           --> \"\"          --> relative\n     * /a/b/c.txt          --> \"/\"         --> absolute\n     * ~/a/b/c.txt         --> \"~/\"        --> current user\n     * ~                   --> \"~/\"        --> current user (slash added)\n     * ~user/a/b/c.txt     --> \"~user/\"    --> named user\n     * ~user               --> \"~user/\"    --> named user (slash added)\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * @param filename  the filename to query, null returns null\n     * @return the prefix of the file, null if invalid\n     */\n    public static String getPrefix(String filename) {\n        if (filename == null) {\n            return null;\n        }\n        int len = getPrefixLength(filename);\n        if (len < 0) {\n            return null;\n        }\n        if (len > filename.length()) {\n            return filename + UNIX_SEPARATOR;  // we know this only happens for unix\n        }\n        return filename.substring(0, len);\n    }\n\n    /**\n     * Gets the path from a full filename, which excludes the prefix.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --> a\\b\\\n     * ~/a/b/c.txt  --> a/b/\n     * a.txt        --> \"\"\n     * a/b/c        --> a/b/\n     * a/b/c/       --> a/b/c/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPath(String)} for the method that retains the prefix.\n     *\n     * @param filename  the filename to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getPath(String filename) {\n        return doGetPath(filename, 1);\n    }\n\n    /**\n     * Gets the path from a full filename, which excludes the prefix, and\n     * also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --> a\\b\n     * ~/a/b/c.txt  --> a/b\n     * a.txt        --> \"\"\n     * a/b/c        --> a/b\n     * a/b/c/       --> a/b/c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.\n     *\n     * @param filename  the filename to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getPathNoEndSeparator(String filename) {\n        return doGetPath(filename, 0);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param filename  the filename\n     * @param separatorAdd  0 to omit the end separator, 1 to return it\n     * @return the path\n     */\n    private static String doGetPath(String filename, int separatorAdd) {\n        if (filename == null) {\n            return null;\n        }\n        int prefix = getPrefixLength(filename);\n        if (prefix < 0) {\n            return null;\n        }\n        int index = indexOfLastSeparator(filename);\n        int endIndex = index + separatorAdd;\n        if (prefix >= filename.length() || index < 0 || prefix >= endIndex) {\n            return \"\";\n        }\n        return filename.substring(prefix, endIndex);\n    }\n\n    /**\n     * Gets the full path from a full filename, which is the prefix + path.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --> C:\\a\\b\\\n     * ~/a/b/c.txt  --> ~/a/b/\n     * a.txt        --> \"\"\n     * a/b/c        --> a/b/\n     * a/b/c/       --> a/b/c/\n     * C:           --> C:\n     * C:\\          --> C:\\\n     * ~            --> ~/\n     * ~/           --> ~/\n     * ~user        --> ~user/\n     * ~user/       --> ~user/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param filename  the filename to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPath(String filename) {\n        return doGetFullPath(filename, true);\n    }\n\n    /**\n     * Gets the full path from a full filename, which is the prefix + path,\n     * and also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --> C:\\a\\b\n     * ~/a/b/c.txt  --> ~/a/b\n     * a.txt        --> \"\"\n     * a/b/c        --> a/b\n     * a/b/c/       --> a/b/c\n     * C:           --> C:\n     * C:\\          --> C:\\\n     * ~            --> ~\n     * ~/           --> ~\n     * ~user        --> ~user\n     * ~user/       --> ~user\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param filename  the filename to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPathNoEndSeparator(String filename) {\n        return doGetFullPath(filename, false);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param filename  the filename\n     * @param includeSeparator  true to include the end separator\n     * @return the path\n     */\n    private static String doGetFullPath(String filename, boolean includeSeparator) {\n        if (filename == null) {\n            return null;\n        }\n        int prefix = getPrefixLength(filename);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix >= filename.length()) {\n            if (includeSeparator) {\n                return getPrefix(filename);  // add end slash if necessary\n            } else {\n                return filename;\n            }\n        }\n        int index = indexOfLastSeparator(filename);\n        if (index < 0) {\n            return filename.substring(0, prefix);\n        }\n        int end = index + (includeSeparator ? 1 : 0);\n        if (end == 0) {\n            end++;\n        }\n        return filename.substring(0, end);\n    }\n\n    /**\n     * Gets the name minus the path from a full filename.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash is returned.\n     * <pre>\n     * a/b/c.txt --> c.txt\n     * a.txt     --> a.txt\n     * a/b/c     --> c\n     * a/b/c/    --> \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param filename  the filename to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists\n     */\n    public static String getName(String filename) {\n        if (filename == null) {\n            return null;\n        }\n        int index = indexOfLastSeparator(filename);\n        return filename.substring(index + 1);\n    }\n\n    /**\n     * Gets the base name, minus the full path and extension, from a full filename.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash and before the last dot is returned.\n     * <pre>\n     * a/b/c.txt --> c\n     * a.txt     --> a\n     * a/b/c     --> c\n     * a/b/c/    --> \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param filename  the filename to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists\n     */\n    public static String getBaseName(String filename) {\n        return removeExtension(getName(filename));\n    }\n\n    /**\n     * Gets the extension of a filename.\n     * <p>\n     * This method returns the textual part of the filename after the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt      --> \"txt\"\n     * a/b/c.jpg    --> \"jpg\"\n     * a/b.txt/c    --> \"\"\n     * a/b/c        --> \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param filename the filename to retrieve the extension of.\n     * @return the extension of the file or an empty string if none exists or {@code null}\n     * if the filename is {@code null}.\n     */\n    public static String getExtension(String filename) {\n        if (filename == null) {\n            return null;\n        }\n        int index = indexOfExtension(filename);\n        if (index == -1) {\n            return \"\";\n        } else {\n            return filename.substring(index + 1);\n        }\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Removes the extension from a filename.\n     * <p>\n     * This method returns the textual part of the filename before the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt    --> foo\n     * a\\b\\c.jpg  --> a\\b\\c\n     * a\\b\\c      --> a\\b\\c\n     * a.b\\c      --> a.b\\c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param filename  the filename to query, null returns null\n     * @return the filename minus the extension\n     */\n    public static String removeExtension(String filename) {\n        if (filename == null) {\n            return null;\n        }\n        int index = indexOfExtension(filename);\n        if (index == -1) {\n            return filename;\n        } else {\n            return filename.substring(0, index);\n        }\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * Checks whether the extension of the filename is that specified.\n     * <p>\n     * This method obtains the extension as the textual part of the filename\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param filename  the filename to query, null returns false\n     * @param extension  the extension to check for, null or empty checks for no extension\n     * @return true if the filename has the specified extension\n     */\n    public static boolean isExtension(String filename, String extension) {\n        if (filename == null) {\n            return false;\n        }\n        if (extension == null || extension.length() == 0) {\n            return indexOfExtension(filename) == -1;\n        }\n        String fileExt = getExtension(filename);\n        return fileExt.equals(extension);\n    }\n\n    /**\n     * Checks whether the extension of the filename is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the filename\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param filename  the filename to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the filename is one of the extensions\n     */\n    public static boolean isExtension(String filename, String[] extensions) {\n        if (filename == null) {\n            return false;\n        }\n        if (extensions == null || extensions.length == 0) {\n            return indexOfExtension(filename) == -1;\n        }\n        String fileExt = getExtension(filename);\n        for (String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the extension of the filename is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the filename\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param filename  the filename to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the filename is one of the extensions\n     */\n    public static boolean isExtension(String filename, Collection<String> extensions) {\n        if (filename == null) {\n            return false;\n        }\n        if (extensions == null || extensions.isEmpty()) {\n            return indexOfExtension(filename) == -1;\n        }\n        String fileExt = getExtension(filename);\n        for (String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
            "file_name": "FilenameUtils.java",
            "human_label": "Return the last index of the extension separator in the given filename,it will return -1 if the filename doesn't have the separator or there is a directory separator after it.",
            "level": "class_runnable",
            "lineno": "637",
            "name": "indexOfExtension",
            "oracle_context": "{ \"apis\" : \"[lastIndexOf, indexOfLastSeparator]\", \"classes\" : \"[]\", \"vars\" : \"[EXTENSION_SEPARATOR]\" }",
            "package": "net.hasor.utils.io",
            "project": "hasor-master"
        },
        {
            "_id": "6367675d1a6d9265ec018082",
            "all_context": "{ \"class_level\" : \"import org.jgrapht.*;\\nimport org.jgrapht.alg.interfaces.*;\\nimport org.jgrapht.alg.util.*;\\nimport org.jgrapht.graph.*;\\nimport org.jgrapht.util.*;\\nimport java.lang.reflect.*;\\nimport java.util.*;\\nimport java.util.function.*;\\nboolean DEBUG;\\nboolean PRINT_CASES;\\nGraph<V,E> graph;\\nint n;\\nEmbedding<V,E> embedding;\\nGraph<V,E> kuratowskiSubdivision;\\nList<Node> nodes;\\nList<Node> dfsTreeRoots;\\nList<Node> componentRoots;\\nList<MergeInfo> stack;\\nNode failedV;\\nboolean tested;\\nboolean planar;\\nNode current;\\nEdge prevEdge;\\nboolean backtrack;\\nV current;\\nV parent;\\nE parentEdge;\\nNode parent;\\nNode parentNext;\\nNode child;\\nNode childPrev;\\nint vIn;\\nint vOut;\\nNode prev;\\nE graphEdge;\\nNode source;\\nNode target;\\nint sign;\\nboolean embedded;\\nboolean shortCircuit;\\nV graphVertex;\\nboolean rootVertex;\\nint dfsIndex;\\nint height;\\nint lowpoint;\\nint leastAncestor;\\nint visited;\\nint backEdgeFlag;\\nint boundaryHeight;\\nboolean marked;\\nEdge parentEdge;\\nEdge edgeToEmbed;\\nNode initialComponentRoot;\\nNode[] outerFaceNeighbors;\\nDoublyLinkedList<Node> separatedDfsChildList;\\nDoublyLinkedList<Node> pertinentRoots;\\nList<Edge> treeEdges;\\nList<Edge> downEdges;\\nList<Edge> backEdges;\\nDoublyLinkedList.ListNode<Node> listNode;\\nDoublyLinkedList<Edge> embedded;\\nBoyerMyrvoldPlanarityInspector(Graph graph);\\norientDfs(Map vertexMap,V startGraphVertex,int currentDfsIndex);\\norient();\\nsortVertices();\\nlazyTestPlanarity();\\nmergeBiconnectedComponent();\\nembedBackEdge(Node root,int entryDir,Edge edge,Node childPrev);\\nembedShortCircuit(Node componentRoot,int entryDir,OuterFaceCirculator circulator);\\nwalkDown(Node componentRoot);\\nwalkUp(Node start,Node end,Edge edge);\\nlazyComputeEmbedding();\\nprintBiconnectedComponent(Node node);\\nprintState();\\nselectOnOuterFace(Predicate predicate,Node start,Node stop,int dir);\\ngetActiveSuccessorOnOuterFace(Node start,Node v,int dir);\\ngetExternallyActiveSuccessorOnOuterFace(Node start,Node stop,Node v,int dir);\\ngetComponentRoot(Node node);\\naddPathEdges(Set edges,Edge startEdge,Node stop);\\naddPathEdges(Set edges,Node start,Node stop);\\nsearchEdge(Node current,int heightMax);\\nsearchEdge(Node current,int heightMax,Edge forbiddenEdge);\\nsearchEdge(Node current,Predicate isNeeded);\\nsearchSubtreeDfs(Node start,Predicate isNeeded);\\nhighest(Node a,Node b);\\nlowest(Node a,Node b);\\nsetBoundaryDepth(Node componentRoot,Node w,int dir,int delta);\\nclearVisited();\\nfindPathDfs(Node start,Edge startPrev,Predicate canGo,Predicate isFinish,List edges);\\nfindHighestObstructingPath(Node componentRoot,Node w);\\nfinish(Set subdivision);\\naddBoundaryEdges(Set edges,Node componentRoot);\\nkuratowskiCleanUp();\\ncleanUpDfs(Node dfsTreeRoot);\\nfixBoundaryOrder(Node componentRoot);\\nremoveUp(Node start,Node end,int dir,Set edges);\\ngetNextOnPath(Node w,Edge backEdge);\\nfindPathToV(List path,Node v);\\nfirstStrictlyHigher(Node a,Node b,Node c);\\ncheckComponentForFailedEdge(Node componentRoot,Node v);\\nfindFailedEdge(Node v);\\nlazyExtractKuratowskiSubdivision();\\nisPlanar();\\ngetEmbedding();\\ngetKuratowskiSubdivision();\\nSearchInfo(Node current,Edge prevEdge,boolean backtrack);\\nOrientDfsStackInfo(V current,V parent,E parentEdge,boolean backtrack);\\nMergeInfo(Node parent,Node parentNext,Node child,Node childPrev,int vIn,int vOut);\\nisInverted();\\ntoString();\\nOuterFaceCirculator(Node current,Node prev);\\nhasNext();\\nnext();\\nedgeToNext();\\ngetCurrent();\\ngetPrev();\\ntoExistingNode(Node node);\\nEdge(Node source,Node target);\\nEdge(E graphEdge,Node source);\\nEdge(E graphEdge,Node source,Node target);\\nisIncidentTo(Node node);\\ngetOpposite(Node node);\\nNode(V graphVertex,int dfsIndex,int height,Node initialComponentRoot,Edge parentEdge);\\nNode(int dfsIndex,Edge parentEdge);\\nNode(V graphVertex,int dfsIndex,Edge parentEdge,boolean rootVertex);\\nisVisitedWrtTo(Node node);\\nisPertinentWrtTo(Node node);\\nhasBackEdgeWrtTo(Node node);\\nisExternallyActiveWrtTo(Node node);\\nisRootVertex();\\nisInternallyActiveWrtTo(Node node);\\nisInactiveWrtTo(Node node);\\nisActiveWrtTo(Node node);\\niterator(int direction);\\nremoveShortCircuitEdges();\\ngetParent();\\ncheckIsAdjacent(Node node);\\nswapNeighbors();\\nsubstitute(Node node,Node newNeighbor);\\nsubstituteAnother(Node node,Node newNeighbor);\\nhasRootNeighbor();\\nnextOnOuterFace(Node prev);\\nembedBackEdge(Edge edge,Node prev);\\nmergeChildEdges(DoublyLinkedList edges,int vIn,int vOut,Node parentNext,Edge parentEdge);\\ntoString(boolean full);\\ncreateNewNode(Map vertexMap,V graphVertex,E edge,Node parent,int dfsIndex);\\n\", \"repo_level\" : \"\" }",
            "class_name": "BoyerMyrvoldPlanarityInspector$OuterFaceCirculator",
            "code": "Edge edgeToNext(){\n  Edge edge=prev.embedded.getFirst();\n  Node target=toExistingNode(current);\n  Node source=toExistingNode(prev);\n  if (edge.getOpposite(source) == target) {\n    return edge;\n  }\n else {\n    return prev.embedded.getLast();\n  }\n}\n",
            "docstring": "/** \n * Returns an edge connecting previously returned node with node, which will be returned next. If either of the mentioned nodes is virtual, the edge will be incident to its real counterpart.\n * @return an edge from the current node to the next node\n */\n",
            "end_lineno": "1744",
            "file_content": "/*\n * (C) Copyright 2018-2021, by Timofey Chudakov and Contributors.\n *\n * JGraphT : a free Java graph-theory library\n *\n * See the CONTRIBUTORS.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the\n * GNU Lesser General Public License v2.1 or later\n * which is available at\n * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later\n */\npackage org.jgrapht.alg.planar;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.interfaces.*;\nimport org.jgrapht.alg.util.*;\nimport org.jgrapht.graph.*;\nimport org.jgrapht.util.*;\n\nimport java.lang.reflect.*;\nimport java.util.*;\nimport java.util.function.*;\n\n/**\n * An implementation of the Boyer-Myrvold planarity testing algorithm. This class determines whether\n * an input graph is planar or not. If the graph is planar, the algorithm provides a\n * <a href=\"https://en.wikipedia.org/wiki/Graph_embedding#Combinatorial_embedding\">combinatorial\n * embedding</a> of the graph, which is represented as a clockwise ordering of the edges of the\n * graph. Otherwise, the algorithm provides a\n * <a href=\"https://en.wikipedia.org/wiki/Kuratowski%27s_theorem#Kuratowski_subgraphs\"> Kuratowski\n * subgraph</a> as a certificate. Both embedding of the graph and Kuratowski subdivision are\n * computed lazily, meaning that the call to the {@link BoyerMyrvoldPlanarityInspector#isPlanar()}\n * does spend time only on the planarity testing. All of the operations of this algorithm (testing,\n * embedding and Kuratowski subgraph extraction) run in linear time.\n * <p>\n * A <a href=\"https://en.wikipedia.org/wiki/Planar_graph\">planar graph</a> is a graph, which can be\n * drawn in two-dimensional space without any of its edges crossing. According to the\n * <a href=\"https://en.wikipedia.org/wiki/Kuratowski%27s_theorem\">Kuratowski theorem</a>, a graph is\n * planar if and only if it doesn't contain a subdivision of the $K_{3,3}$ or $K_{5}$ graphs.\n * <p>\n * The Boyer-Myrvold planarity testing algorithm was originally described in: <i>Boyer, John amp;\n * Myrvold, Wendy. (2004). On the Cutting Edge: Simplified O(n) Planarity by Edge Addition. J. Graph\n * Algorithms Appl.. 8. 241-273. 10.7155/jgaa.00091. </i>. We refer to this paper for the complete\n * description of the Boyer-Myrvold algorithm\n *\n * @param <V> the graph vertex type\n * @param <E> the graph edge type\n * @author Timofey Chudakov\n */\npublic class BoyerMyrvoldPlanarityInspector<V, E>\n    implements\n    PlanarityTestingAlgorithm<V, E>\n{\n    /**\n     * Whether to print debug messages\n     */\n    private static final boolean DEBUG = false;\n    /**\n     * Whether to print Kuratowski case distinction messages\n     */\n    private static final boolean PRINT_CASES = false;\n    /**\n     * The graph we're testing planarity of\n     */\n    private Graph<V, E> graph;\n    /**\n     * The number of vertices in the {@code graph}\n     */\n    private int n;\n    /**\n     * The resulting combinatorial embedding. This value is computed only after the first call to\n     * the {@link BoyerMyrvoldPlanarityInspector#getEmbedding()}\n     */\n    private Embedding<V, E> embedding;\n    /**\n     * The subgraph of the {@code graph}, which is a Kuratowski subdivision. This subgraph certifies\n     * the nonplanarity of the graph.\n     */\n    private Graph<V, E> kuratowskiSubdivision;\n    /**\n     * List of the vertices of the {@code graph} in their internal representation. After the\n     * orientation of the {@code graph} and edge sorting, nodes in this list are sorted according to\n     * their dfs indexes\n     */\n    private List<Node> nodes;\n    /**\n     * List of the dfs tree roots of the {@code graph}. This list has length more than 1 if the\n     * input {@code graph} isn't connected\n     */\n    private List<Node> dfsTreeRoots;\n    /**\n     * List of the virtual biconnected component roots. Initially, a virtual biconnected component\n     * root is created for every node in the {@code graph}, except for the dfs roots. These\n     * component roots don't belong to the {@code graph}. At each step of the algorithm, every\n     * biconnected component has its own unique component root.\n     */\n    private List<Node> componentRoots;\n    /**\n     * The stack containing merge information for every consecutive pair of biconnected components\n     * on the path to the back edge source. After all the biconnected components are merged, this\n     * stack is cleared\n     */\n    private List<MergeInfo> stack;\n    /**\n     * The node $v$, which has an unembedded back edge incident to it.\n     */\n    private Node failedV;\n    /**\n     * Whether the planarity of the {@code graph} has been tested already\n     */\n    private boolean tested;\n    /**\n     * Whether the graph is planar or not. Is valid, if {@code tested} is {@code true}\n     */\n    private boolean planar;\n\n    /**\n     * Creates new instance of the planarity testing algorithm for the {@code graph}. The input\n     * graph can't be null.\n     *\n     * @param graph the graph to test the planarity of\n     */\n    public BoyerMyrvoldPlanarityInspector(Graph<V, E> graph)\n    {\n        this.graph = Objects.requireNonNull(graph, \"Graph can't be null\");\n        this.n = graph.vertexSet().size();\n        this.nodes = new ArrayList<>(n);\n        this.dfsTreeRoots = new ArrayList<>();\n        this.componentRoots = new ArrayList<>(n);\n        this.stack = new ArrayList<>();\n    }\n\n    /**\n     * Creates a new node by converting the {@code graphVertex} to the internal node representation.\n     *\n     * @param vertexMap the map from vertices of the {@code graph} to their internal representation\n     * @param graphVertex the vertex of the {@code graph} we're processing\n     * @param edge the parent edge of the {@code graphVertex}, is {@code null} for dfs tree roots\n     * @param parent the parent node of the {@code graphVertex}\n     * @param dfsIndex the dfs index of the {@code graphVertex}\n     * @return the newly created node\n     */\n    private Node createNewNode(\n        Map<V, Node> vertexMap, V graphVertex, E edge, Node parent, int dfsIndex)\n    {\n        Node child;\n        if (parent == null) {\n            child = new Node(graphVertex, dfsIndex, 0, null, null);\n            child.outerFaceNeighbors[0] = child.outerFaceNeighbors[1] = child;\n            dfsTreeRoots.add(child);\n        } else {\n            Edge treeEdge = new Edge(edge, parent);\n            Node componentRoot = new Node(parent.dfsIndex, treeEdge);\n            child = new Node(graphVertex, dfsIndex, parent.height + 1, componentRoot, treeEdge);\n            treeEdge.target = child;\n\n            componentRoots.add(componentRoot);\n\n            parent.treeEdges.add(treeEdge);\n\n            child.outerFaceNeighbors[0] = child.outerFaceNeighbors[1] = componentRoot;\n            componentRoot.outerFaceNeighbors[0] = componentRoot.outerFaceNeighbors[1] = child;\n        }\n        nodes.add(child);\n        vertexMap.put(graphVertex, child);\n        return child;\n    }\n\n    /**\n     * Orients the input graph according to its dfs traversal by creating a dfs tree. Computes the\n     * least ancestors and lowpoints of the nodes\n     *\n     * @param vertexMap the map from {@code graph} vertices to their internal representatives\n     * @param startGraphVertex the node to start the traversal from (this is a dfs tree root).\n     * @param currentDfsIndex the dfs index of the {@code startGraphVertex}\n     * @return the {@code currentDfsIndex} + number of nodes in the traversed subtree\n     */\n    private int orientDfs(Map<V, Node> vertexMap, V startGraphVertex, int currentDfsIndex)\n    {\n        List<OrientDfsStackInfo> stack = new ArrayList<>();\n        stack.add(new OrientDfsStackInfo(startGraphVertex, null, null, false));\n        while (!stack.isEmpty()) {\n            OrientDfsStackInfo info = stack.remove(stack.size() - 1);\n\n            if (info.backtrack) {\n                Node current = vertexMap.get(info.current);\n                current.leastAncestor = current.lowpoint = current.dfsIndex;\n                for (Edge backEdge : current.backEdges) {\n                    current.leastAncestor =\n                        Math.min(current.leastAncestor, backEdge.target.dfsIndex);\n                }\n                for (Edge treeEdge : current.treeEdges) {\n                    current.lowpoint = Math.min(current.lowpoint, treeEdge.target.lowpoint);\n                }\n                current.lowpoint = Math.min(current.lowpoint, current.leastAncestor);\n            } else {\n                if (vertexMap.containsKey(info.current)) {\n                    // other dfs branch has reached this vertex earlier\n                    continue;\n                }\n                stack.add(new OrientDfsStackInfo(info.current, info.parent, info.parentEdge, true));\n                Node current = createNewNode(\n                    vertexMap, info.current, info.parentEdge, vertexMap.get(info.parent),\n                    currentDfsIndex);\n                ++currentDfsIndex;\n                for (E e : graph.edgesOf(info.current)) {\n                    V opposite = Graphs.getOppositeVertex(graph, e, info.current);\n                    if (vertexMap.containsKey(opposite)) {\n                        // back edge or parent edge\n                        Node oppositeNode = vertexMap.get(opposite);\n                        if (opposite.equals(info.parent)) {\n                            continue;\n                        }\n                        Edge backEdge = new Edge(e, current, oppositeNode);\n                        oppositeNode.downEdges.add(backEdge);\n                        current.backEdges.add(backEdge);\n                    } else {\n                        // possible tree edge\n                        stack.add(new OrientDfsStackInfo(opposite, current.graphVertex, e, false));\n                    }\n                }\n            }\n        }\n        return currentDfsIndex;\n    }\n\n    /**\n     * Iteratively start an orienting dfs from every {@code graph} vertex that hasn't been visited\n     * yet. After orienting the graph, sorts the nodes by their lowpoints and adds them to the\n     * {@code separatedDfsChildList}\n     */\n    private void orient()\n    {\n        Map<V, Node> visited = new HashMap<>();\n        int currentDfsIndex = 0;\n        for (V vertex : graph.vertexSet()) {\n            if (!visited.containsKey(vertex)) {\n                currentDfsIndex = orientDfs(visited, vertex, currentDfsIndex);\n            }\n        }\n        sortVertices();\n    }\n\n    /**\n     * Performs sorting of the vertices by their lowpoints and adding them to the\n     * {@code separatedDfsChildList}\n     */\n    private void sortVertices()\n    {\n        List<List<Node>> sorted = new ArrayList<>(Collections.nCopies(n, null));\n        for (Node node : nodes) {\n            int lowpoint = node.lowpoint;\n            if (sorted.get(lowpoint) == null) {\n                sorted.set(lowpoint, new ArrayList<>());\n            }\n            sorted.get(lowpoint).add(node);\n        }\n        int i = 0;\n        for (List<Node> list : sorted) {\n            if (i >= n) {\n                break;\n            }\n            if (list != null) {\n                for (Node node : list) {\n                    nodes.set(i++, node);\n                    if (node.parentEdge != null) {\n                        node.listNode =\n                            node.parentEdge.source.separatedDfsChildList.addElementLast(node);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Lazily tests the planarity of the graph. The implementation below is close to the code\n     * presented in the original paper\n     *\n     * @return true if the graph is planar, false otherwise\n     */\n    private boolean lazyTestPlanarity()\n    {\n        if (!tested) {\n            tested = true;\n\n            orient();\n            if (DEBUG) {\n                printState();\n                System.out.println(\"Start testing planarity\");\n            }\n            for (int currentNode = n - 1; currentNode >= 0; currentNode--) {\n                Node current = nodes.get(currentNode);\n                if (DEBUG) {\n                    System.out.printf(\"Current vertex is %s\\n\", current.toString(false));\n                }\n                for (Edge downEdge : current.downEdges) {\n                    walkUp(downEdge.source, current, downEdge);\n                }\n                for (Edge treeEdge : current.treeEdges) {\n                    walkDown(treeEdge.target.initialComponentRoot);\n                }\n\n                for (Edge downEdge : current.downEdges) {\n                    if (!downEdge.embedded) {\n                        failedV = current;\n                        return planar = false;\n                    }\n                }\n            }\n            planar = true;\n        }\n        return planar;\n    }\n\n    /**\n     * Merges the last two biconnected components using the info stored on top of the stack. The key\n     * goal of this method is to merge the outer faces of the two components and to merge the\n     * embedded edges of the child component root with the embedded edges of the component parent\n     * node.\n     */\n    private void mergeBiconnectedComponent()\n    {\n        MergeInfo info = stack.get(stack.size() - 1);\n        stack.remove(stack.size() - 1);\n        if (DEBUG) {\n            System.out.printf(\"\\nMerging biconnected component, info: %s\\n\", info.toString());\n        }\n        Node virtualRoot = info.child;\n        if (info.isInverted()) {\n            virtualRoot.swapNeighbors();\n        }\n        Node root = info.parent;\n        Node virtualRootChild = virtualRoot.parentEdge.target;\n\n        root.pertinentRoots.removeNode(virtualRoot.listNode);\n        root.separatedDfsChildList.removeNode(virtualRootChild.listNode);\n\n        root\n            .mergeChildEdges(\n                virtualRoot.embedded, info.vIn, info.vOut, info.parentNext, virtualRoot.parentEdge);\n\n        root.substituteAnother(info.parentNext, info.childPrev);\n        info.childPrev.substitute(virtualRoot, root);\n        virtualRoot.outerFaceNeighbors[0] = virtualRoot.outerFaceNeighbors[1] = null;\n    }\n\n    /**\n     * Embeds the back edge {@code edge} into the list of embedded edges of the source and the\n     * virtual target of the edge such that the {@code childPrev} belongs to the new inner face.\n     * This method also takes care of modifying the boundary of the outer face accordingly\n     *\n     * @param root the component root\n     * @param entryDir the component entry direction\n     * @param edge the edge to embed\n     * @param childPrev the neighbor of the source of the edge that should belong to the inner face\n     * @return a circulator starting from the edge's source\n     */\n    private OuterFaceCirculator embedBackEdge(Node root, int entryDir, Edge edge, Node childPrev)\n    {\n        if (DEBUG) {\n            System.out.printf(\"Embedding back edge %s\\n\", edge.toString());\n        }\n        assert !edge.embedded;\n        if (entryDir == 0) {\n            root.embedded.addLast(edge);\n        } else {\n            root.embedded.addFirst(edge);\n        }\n        Node child = edge.source;\n        child.embedBackEdge(edge, childPrev);\n        child.edgeToEmbed = null;\n        child.backEdgeFlag = n;\n        edge.embedded = true;\n\n        child.substitute(childPrev, root);\n        root.outerFaceNeighbors[entryDir] = child;\n        Node next = child.nextOnOuterFace(root);\n        return new OuterFaceCirculator(next, child);\n    }\n\n    /**\n     * Embeds a short-circuit edge from the {@code componentRoot} to the current node of the\n     * {@code circulator}. Changes the outer face accordingly\n     *\n     * @param componentRoot the component root\n     * @param entryDir the direction used to enter the component\n     * @param circulator a circulator to the source of the new edge\n     */\n    private void embedShortCircuit(Node componentRoot, int entryDir, OuterFaceCirculator circulator)\n    {\n        Node current = circulator.getCurrent(), prev = circulator.getPrev();\n        Edge shortCircuit = new Edge(current, componentRoot.getParent());\n        if (entryDir == 0) {\n            componentRoot.embedded.addLast(shortCircuit);\n            componentRoot.outerFaceNeighbors[0] = current;\n        } else {\n            componentRoot.embedded.addFirst(shortCircuit);\n            componentRoot.outerFaceNeighbors[1] = current;\n        }\n        current.embedBackEdge(shortCircuit, prev);\n        current.substitute(prev, componentRoot);\n        if (DEBUG) {\n            System.out.printf(\"Embedding short circuit edge: %s\\n\", shortCircuit.toString());\n            printState();\n        }\n    }\n\n    /**\n     * The walkdown procedure from the original paper. Either embeds all of the back edges in the\n     * subtree rooted at the child of the {@code componentRoot} or identifies the back edges which\n     * can be used to extract a Kuratowski subdivision. Iteratively traverses the tree of the\n     * biconnected component and descends only to the pertinent components. This procedure is also\n     * responsible for embedding short-circuit edges to make the algorithm run in linear time in the\n     * worst case.\n     *\n     * @param componentRoot the root of the component to start the walkdown from\n     */\n    private void walkDown(Node componentRoot)\n    {\n        if (DEBUG) {\n            System.out.printf(\"\\nStart walk down on node %s\\n\", componentRoot.toString(true));\n        }\n        for (int componentEntryDir = 0; componentEntryDir < 2 && stack.isEmpty();\n            componentEntryDir++)\n        {\n            if (DEBUG) {\n                System.out.println(\"\\nNew traversal direction = \" + componentEntryDir);\n            }\n            int currentComponentEntryDir = componentEntryDir;\n            OuterFaceCirculator circulator = componentRoot.iterator(currentComponentEntryDir);\n            for (Node current = circulator.next(); current != componentRoot;) {\n                if (DEBUG) {\n                    System.out.printf(\"Current = %s\\n\", current.toString());\n                }\n                if (current.hasBackEdgeWrtTo(componentRoot)) {\n                    Node childPrev = circulator.getPrev();\n                    while (!stack.isEmpty()) {\n                        mergeBiconnectedComponent();\n                        if (DEBUG) {\n                            printState();\n                        }\n                    }\n                    circulator = embedBackEdge(\n                        componentRoot, componentEntryDir, current.edgeToEmbed, childPrev);\n                    if (DEBUG) {\n                        printState();\n                        printBiconnectedComponent(current);\n                    }\n                }\n                if (!current.pertinentRoots.isEmpty()) {\n                    int parentComponentEntryDir = currentComponentEntryDir;\n                    Node root = current.pertinentRoots.getFirst();\n\n                    if (DEBUG) {\n                        System.out.printf(\"Descending to the root = %s\\n\", root.toString());\n                    }\n                    OuterFaceCirculator ccwCirculator =\n                        getActiveSuccessorOnOuterFace(root, componentRoot, 0);\n                    Node ccwActiveNode = ccwCirculator.getCurrent();\n                    OuterFaceCirculator cwCirculator =\n                        getActiveSuccessorOnOuterFace(root, componentRoot, 1);\n                    Node cwActiveNode = cwCirculator.getCurrent();\n\n                    if (ccwActiveNode.isInternallyActiveWrtTo(componentRoot)) {\n                        currentComponentEntryDir = 0;\n                    } else if (cwActiveNode.isInternallyActiveWrtTo(componentRoot)) {\n                        currentComponentEntryDir = 1;\n                    } else if (ccwActiveNode.isPertinentWrtTo(componentRoot)) {\n                        currentComponentEntryDir = 0;\n                    } else {\n                        currentComponentEntryDir = 1;\n                    }\n\n                    if (currentComponentEntryDir == 0) {\n                        stack\n                            .add(\n                                new MergeInfo(\n                                    current, circulator.next(), root, root.outerFaceNeighbors[1],\n                                    parentComponentEntryDir, currentComponentEntryDir));\n                        current = ccwActiveNode;\n                        circulator = ccwCirculator;\n\n                        if (!cwActiveNode.hasRootNeighbor()) {\n                            embedShortCircuit(root, 1, cwCirculator);\n                        }\n                    } else {\n                        stack\n                            .add(\n                                new MergeInfo(\n                                    current, circulator.next(), root, root.outerFaceNeighbors[0],\n                                    parentComponentEntryDir, currentComponentEntryDir));\n                        current = cwActiveNode;\n                        circulator = cwCirculator;\n\n                        if (!ccwActiveNode.hasRootNeighbor()) {\n                            embedShortCircuit(root, 0, ccwCirculator);\n                        }\n                    }\n\n                } else if (current.isInactiveWrtTo(componentRoot)) {\n                    current = circulator.next();\n                } else {\n                    // current vertex is externally active\n                    if (DEBUG) {\n                        System.out.println(\"Current vertex is externally active, stop\\n\");\n                    }\n                    if (!current.hasRootNeighbor() && stack.isEmpty()) {\n                        embedShortCircuit(componentRoot, componentEntryDir, circulator);\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * The walkup procedure from the original paper. Identifies the pertinent subgraph of the graph\n     * by going up the dfs tree from the {@code start} node to the {@code end} node using the edge\n     * {@code edge}\n     *\n     * @param start the node to start the walkup from\n     * @param end the node currently processed by the main loop of the algorithm\n     * @param edge a back edge to embed\n     */\n    private void walkUp(Node start, Node end, Edge edge)\n    {\n        if (DEBUG) {\n            System.out.printf(\"\\nStart walk up on edge = %s\\n\", edge.toString());\n        }\n        int visited = end.dfsIndex;\n\n        start.backEdgeFlag = visited;\n        start.edgeToEmbed = edge;\n\n        Node x = start.outerFaceNeighbors[0], y = start.outerFaceNeighbors[1], xPrev = start,\n            yPrev = start;\n        start.visited = visited;\n        while (x != end && !x.isVisitedWrtTo(end) && !y.isVisitedWrtTo(end)) {\n            if (DEBUG) {\n                System.out.printf(\"Current x = %s\\nCurrent y = %s\\n\", x.toString(), y.toString());\n            }\n            x.visited = y.visited = visited;\n\n            Node root = null;\n            if (x.isRootVertex()) {\n                root = x;\n            } else if (y.isRootVertex()) {\n                root = y;\n            }\n            if (root != null) {\n                if (DEBUG) {\n                    System.out.printf(\"Found root = %s\\n\", root.toString());\n                }\n                Node rootChild = root.parentEdge.target;\n                Node newStart = root.parentEdge.source;\n                if (newStart != end) {\n                    if (rootChild.lowpoint < end.dfsIndex) {\n                        // the component in externally active\n                        root.listNode = newStart.pertinentRoots.addElementLast(root);\n                    } else {\n                        // the component is internally active\n                        root.listNode = newStart.pertinentRoots.addElementFirst(root);\n                    }\n                } else {\n                    break;\n                }\n                newStart.visited = visited;\n                xPrev = yPrev = newStart;\n                x = newStart.outerFaceNeighbors[0];\n                y = newStart.outerFaceNeighbors[1];\n\n            } else {\n                Node t = x;\n                x = x.nextOnOuterFace(xPrev);\n                xPrev = t;\n\n                t = y;\n                y = y.nextOnOuterFace(yPrev);\n                yPrev = t;\n            }\n        }\n    }\n\n    /**\n     * Lazily computes a combinatorial embedding of the {@code graph} by removing all the\n     * short-circuit edges and properly orienting the edges around the nodes.\n     *\n     * @return a combinatorial embedding of the {@code graph}\n     */\n    private Embedding<V, E> lazyComputeEmbedding()\n    {\n        lazyTestPlanarity();\n        if (!planar) {\n            throw new IllegalArgumentException(\n                \"Input graph is not planar, can't compute graph embedding\");\n        }\n        if (embedding == null) {\n            for (Node dfsTreeRoot : dfsTreeRoots) {\n                cleanUpDfs(dfsTreeRoot);\n            }\n            Map<V, List<E>> embeddingMap = new HashMap<>();\n            for (Node node : nodes) {\n                for (Node child : node.separatedDfsChildList) {\n                    Node virtualRoot = child.initialComponentRoot;\n                    node.embedded.append(virtualRoot.embedded);\n                }\n                List<E> embeddedEdges = new ArrayList<>(node.embedded.size());\n                for (Edge edge : node.embedded) {\n                    embeddedEdges.add(edge.graphEdge);\n                }\n                embeddingMap.put(node.graphVertex, embeddedEdges);\n            }\n            embedding = new EmbeddingImpl<>(graph, embeddingMap);\n        }\n        return embedding;\n    }\n\n    /**\n     * Method for debug purposes, prints the boundary the {@code node} belongs to\n     *\n     * @param node a node on the outer face\n     */\n    private void printBiconnectedComponent(Node node)\n    {\n        StringBuilder builder = new StringBuilder(node.toString(false));\n        OuterFaceCirculator circulator = node.iterator(0);\n        Node current = circulator.next();\n        Node stop = current;\n        do {\n            builder.append(\" -> \").append(current.toString(false));\n            current = circulator.next();\n        } while (current != stop);\n        System.out.println(\"Biconnected component after merge: \" + builder.toString());\n    }\n\n    /**\n     * Method for debug purposes, prints the state of the algorithm\n     */\n    private void printState()\n    {\n        System.out.println(\"\\nPrinting state:\");\n        System.out.println(\"Dfs roots: \" + dfsTreeRoots);\n        System.out.println(\"Nodes:\");\n        for (Node node : nodes) {\n            System.out.println(node.toString(true));\n        }\n        System.out.println(\"Virtual nodes:\");\n        for (Node node : componentRoots) {\n            System.out.println(node.toString(true));\n        }\n        List<Edge> inverted = new ArrayList<>();\n        for (Node node : nodes) {\n            for (Edge edge : node.treeEdges) {\n                if (edge.sign < 0) {\n                    inverted.add(edge);\n                }\n            }\n        }\n        System.out.println(\"Inverted edges = \" + inverted);\n    }\n\n    /**\n     * Either finds and returns a circulator to the node on the boundary of the component, which\n     * satisfies the {@code predicate} or returns a circulator to the {@code stop} node.\n     *\n     * @param predicate the condition the desired node should satisfy\n     * @param start the node to start the search from\n     * @param stop the node to end the search with\n     * @param dir the direction to start the traversal in\n     * @return a circulator to the node satisfying the {@code predicate} or to the {@code stop} node\n     */\n    private OuterFaceCirculator selectOnOuterFace(\n        Predicate<Node> predicate, Node start, Node stop, int dir)\n    {\n        OuterFaceCirculator circulator = start.iterator(dir);\n        Node current = circulator.next();\n        while (current != stop && !predicate.test(current)) {\n            current = circulator.next();\n        }\n        return circulator;\n    }\n\n    /**\n     * Returns an active node on the outer face in the direction {@code dir} starting from the\n     * {@code start} node\n     *\n     * @param start the node to start the search from\n     * @param v an ancestor of the {@code start}\n     * @param dir the direction of the search\n     * @return a circulator to the found node\n     */\n    private OuterFaceCirculator getActiveSuccessorOnOuterFace(Node start, Node v, int dir)\n    {\n        return selectOnOuterFace(n -> n.isActiveWrtTo(v), start, start, dir);\n    }\n\n    /**\n     * Returns acirculator to the externally active node on the outer face between the {@code start}\n     * and {@code end} nodes in the direction {@code dir}.\n     *\n     * @param start the node to start the search from\n     * @param stop the node to end the search with\n     * @param v an ancestor of the {@code start} and the {@code end}\n     * @param dir the direction of the search\n     * @return a circulator to the found node\n     */\n    private OuterFaceCirculator getExternallyActiveSuccessorOnOuterFace(\n        Node start, Node stop, Node v, int dir)\n    {\n        return selectOnOuterFace(n -> n.isExternallyActiveWrtTo(v), start, stop, dir);\n    }\n\n    /**\n     * Returns a component root of component the {@code node} is contained in.\n     *\n     * @param node a node in the partially embedded graph\n     * @return a component root of the component the {@code node} belongs to\n     */\n    private Node getComponentRoot(Node node)\n    {\n        return selectOnOuterFace(Node::isRootVertex, node, node, 0).getCurrent();\n    }\n\n    /**\n     * Adds the edges on the path from the {@code startEdge} up to the node {@code stop} to the set\n     * {@code edges}\n     *\n     * @param edges the set to add the path edges to\n     * @param startEdge the edge to start from\n     * @param stop the last node on the path\n     */\n    private void addPathEdges(Set<Edge> edges, Edge startEdge, Node stop)\n    {\n        edges.add(startEdge);\n        Node current = startEdge.source;\n        while (current != stop) {\n            edges.add(current.parentEdge);\n            current = current.getParent();\n        }\n    }\n\n    /**\n     * Adds the edges between the {@code start} and the {@code end} to the set {@code edges}\n     *\n     * @param edges the set to add the path edges to to\n     * @param start the node to start from\n     * @param stop the node to end with\n     */\n    private void addPathEdges(Set<Edge> edges, Node start, Node stop)\n    {\n        if (start != stop) {\n            addPathEdges(edges, start.parentEdge, stop);\n        }\n    }\n\n    /**\n     * Searches a back edge which target has a height smaller than {@code heightMax}\n     *\n     * @param current the node to start from\n     * @param heightMax an upper bound on the height of the desired back edge\n     * @return the desired back edge or null, if no such edge exist\n     */\n    private Edge searchEdge(Node current, int heightMax)\n    {\n        return searchEdge(current, heightMax, null);\n    }\n\n    /**\n     * Searches a back edge which target has a height smaller than {@code heightMax}\n     *\n     * @param current the node to start from\n     * @param heightMax an upper bound on the height of the desired back edge\n     * @param forbiddenEdge an edge the desired edge should not be equal to\n     * @return the desired back edge or null, if no such edge exist\n     */\n    private Edge searchEdge(Node current, int heightMax, Edge forbiddenEdge)\n    {\n        Predicate<Edge> isNeeded = e -> {\n            if (forbiddenEdge == e) {\n                return false;\n            }\n            return e.target.height < heightMax;\n        };\n        return searchEdge(current, isNeeded);\n    }\n\n    /**\n     * Generically searches an edge in the subtree rooted at the {@code current}, which doesn't\n     * include the children of the {@code current} that have beem merged to the parent biconnected\n     * component.\n     *\n     * @param current the node to start the searh from\n     * @param isNeeded the predicate which the desired edge should satisfy\n     * @return an edge which satisfies the {@code predicate}, or null if such an edge doesn't exist\n     */\n    private Edge searchEdge(Node current, Predicate<Edge> isNeeded)\n    {\n        for (Node node : current.separatedDfsChildList) {\n            Edge result = searchSubtreeDfs(node, isNeeded);\n            if (result != null) {\n                return result;\n            }\n        }\n        for (Edge edge : current.backEdges) {\n            if (isNeeded.test(edge)) {\n                return edge;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Recursively searches all the subtree root at the node {@code start} to find an edge\n     * satisfying the {@code predicate}.\n     *\n     * @param start the node to start the search from.\n     * @param isNeeded a predicate, which the desired edge should satisfy\n     * @return a desired edge, or null if no such edge exist.\n     */\n    private Edge searchSubtreeDfs(Node start, Predicate<Edge> isNeeded)\n    {\n        List<Node> stack = new ArrayList<>();\n        stack.add(start);\n        while (!stack.isEmpty()) {\n            Node current = stack.remove(stack.size() - 1);\n\n            for (Edge edge : current.backEdges) {\n                if (isNeeded.test(edge)) {\n                    return edge;\n                }\n            }\n            for (Edge edge : current.treeEdges) {\n                stack.add(edge.target);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the highest of the two input node, i.e. the node with the greater height\n     *\n     * @param a a node in the dfs tree\n     * @param b a node in the dfs tree\n     * @return the highest of the two nodes\n     */\n    private Node highest(Node a, Node b)\n    {\n        return a.height > b.height ? a : b;\n    }\n\n    /**\n     * Returns the lowest of the two input node, i.e. the node with the least height.\n     *\n     * @param a a node in the dfs tree\n     * @param b a node in the dfs tree\n     * @return the lowest of the two nodes\n     */\n    private Node lowest(Node a, Node b)\n    {\n        return a.height < b.height ? a : b;\n    }\n\n    /**\n     * Iteratively sets a boundary height for the nodes on the outer face branch ending at the node\n     * {@code w}.\n     *\n     * @param componentRoot the root of the component\n     * @param w the end of the outer face branch\n     * @param dir the direction to start the traversal in\n     * @param delta a value in $\\{+1, -1\\}$ to set either positive or negative boundary height\n     */\n    private void setBoundaryDepth(Node componentRoot, Node w, int dir, int delta)\n    {\n        OuterFaceCirculator circulator = componentRoot.iterator(dir);\n        Node current = circulator.next();\n        int currentHeight = delta;\n        while (current != w) {\n            current.boundaryHeight = currentHeight;\n            currentHeight += delta;\n            current = circulator.next();\n        }\n    }\n\n    /**\n     * Clears the visited variable of all the nodes and component roots\n     */\n    private void clearVisited()\n    {\n        nodes.forEach(n -> n.visited = 0);\n        componentRoots.forEach(n -> n.visited = 0);\n    }\n\n    /**\n     * Generically searches a path from the {@code current} node to the first node satisfying the\n     * {@code isFinish} predicate consisting of all the nodes satisfying the {@code canGo}\n     * predicate. The key property of this method is that it searches the next edge on the path in\n     * the clockwise order starting from the previous edge. The edges of the resulting path are\n     * added to the {@code edges}.\n     *\n     * @param start the start node of the traversal\n     * @param startPrev the previous edge of the start node\n     * @param canGo specifies where the search can go\n     * @param isFinish specifies what nodes are finish nodes\n     * @param edges the list containing the resulting path\n     * @return true if the search was successful, false otherwise\n     */\n    private boolean findPathDfs(\n        Node start, Edge startPrev, Predicate<Node> canGo, Predicate<Node> isFinish,\n        List<Edge> edges)\n    {\n        List<SearchInfo> stack = new ArrayList<>();\n        stack.add(new SearchInfo(start, startPrev, false));\n        while (!stack.isEmpty()) {\n            SearchInfo info = stack.remove(stack.size() - 1);\n            if (isFinish.test(info.current)) {\n                edges.add(info.prevEdge);\n                edges.remove(0);\n                return true;\n            }\n            if (info.backtrack) {\n                edges.remove(edges.size() - 1);\n            } else {\n                if (info.current.visited != 0) {\n                    continue;\n                }\n                info.current.visited = 1;\n                stack.add(new SearchInfo(info.current, info.prevEdge, true));\n                edges.add(info.prevEdge);\n                /*\n                 * The iteration is performed in the reverse order since the infos are pushed on the\n                 * stack and therefore will be processed in the again reverse order\n                 */\n                Iterator<Edge> iterator =\n                    info.current.embedded.reverseCircularIterator(info.prevEdge);\n                while (iterator.hasNext()) {\n                    Edge currentEdge = iterator.next();\n                    Node opposite = currentEdge.getOpposite(info.current);\n                    if ((!canGo.test(opposite) || opposite.visited != 0)\n                        && !isFinish.test(opposite))\n                    {\n                        continue;\n                    }\n                    stack.add(new SearchInfo(opposite, currentEdge, false));\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Finds the highest obstructing path in the component rooted at {@code componentRoot}. See the\n     * original paper for the definition of the obstructing path. This method heavily relies on the\n     * fact that the method\n     * {@link BoyerMyrvoldPlanarityInspector#findPathDfs(Node, Edge, Predicate, Predicate, List)}\n     * chooses the edges in the clockwise order.\n     *\n     * @param componentRoot the root of the component\n     * @param w the node called {@code w} in the Kuratowski subdivision extraction phase.\n     * @return the edges of the desired path as a list\n     */\n    private List<Edge> findHighestObstructingPath(Node componentRoot, Node w)\n    {\n        clearVisited();\n        List<Edge> result = new ArrayList<>();\n        OuterFaceCirculator circulator = componentRoot.iterator(0);\n        Node current = circulator.next();\n        while (current != w) {\n            if (findPathDfs(\n                current, current.embedded.getFirst(), n -> !n.marked, n -> n.boundaryHeight < 0,\n                result))\n            {\n                return result;\n            }\n            current = circulator.next();\n        }\n        return result;\n    }\n\n    /**\n     * Finishes the Kuratowski subdivision extraction by constructing the desired subgraph\n     *\n     * @param subdivision the edges in the Kuratowski subdivision\n     * @return the Kuratowski subgraph of the {@code graph}\n     */\n    private Graph<V, E> finish(Set<Edge> subdivision)\n    {\n        Set<E> edgeSubset = new HashSet<>();\n        Set<V> vertexSubset = new HashSet<>();\n        subdivision.forEach(e -> {\n            edgeSubset.add(e.graphEdge);\n            vertexSubset.add(e.target.graphVertex);\n            vertexSubset.add(e.source.graphVertex);\n        });\n        kuratowskiSubdivision = new AsSubgraph<>(graph, vertexSubset, edgeSubset);\n        return kuratowskiSubdivision;\n    }\n\n    /**\n     * Adds the edges on the outer face of the component rooted at {@code componentRoot} to the set\n     * {@code edges}\n     *\n     * @param edges the set to add the edges to\n     * @param componentRoot the root of the biconnected component\n     */\n    private void addBoundaryEdges(Set<Edge> edges, Node componentRoot)\n    {\n        OuterFaceCirculator circulator = componentRoot.iterator(0);\n        Node current;\n        do {\n            Edge edge = circulator.edgeToNext();\n            edge.source.marked = edge.target.marked = true;\n            edges.add(edge);\n            current = circulator.next();\n        } while (current != componentRoot);\n    }\n\n    /**\n     * Cleans up the dfs trees before the Kuratowski subdivision extraction phase\n     */\n    private void kuratowskiCleanUp()\n    {\n        for (Node dfsTreeRoot : dfsTreeRoots) {\n            cleanUpDfs(dfsTreeRoot);\n        }\n        for (Node node : componentRoots) {\n            if (node.outerFaceNeighbors[0] != null) {\n                node.removeShortCircuitEdges();\n                fixBoundaryOrder(node);\n            }\n        }\n    }\n\n    /**\n     * Recursively cleans up the dfs tree rooted at the {@code dfsTreeRoot} my removing all the\n     * short-circuit edges and properly orienting other embedded edges\n     *\n     * @param dfsTreeRoot the root of the dfs tree to clean up\n     */\n    private void cleanUpDfs(Node dfsTreeRoot)\n    {\n        List<Pair<Node, Integer>> stack = new ArrayList<>();\n        stack.add(Pair.of(dfsTreeRoot, 1));\n        while (!stack.isEmpty()) {\n            Pair<Node, Integer> entry = stack.remove(stack.size() - 1);\n            Node current = entry.getFirst();\n            int sign = entry.getSecond();\n            if (sign < 0) {\n                current.embedded.invert();\n            }\n            current.removeShortCircuitEdges();\n            for (Node node : current.separatedDfsChildList) {\n                // all the components, that aren't merged, aren't inverted\n                node.parentEdge.sign = sign;\n            }\n\n            for (Edge treeEdge : current.treeEdges) {\n                stack.add(Pair.of(treeEdge.target, sign * treeEdge.sign));\n            }\n        }\n\n    }\n\n    /**\n     * Orient the connections on the outer face of the component rooted at {@code componentRoot}\n     * such that they are ordered\n     *\n     * @param componentRoot the root of the component to process\n     */\n    private void fixBoundaryOrder(Node componentRoot)\n    {\n        if (componentRoot.embedded.size() < 2) {\n            return;\n        }\n        Node componentParent = componentRoot.getParent();\n        Edge edgeToNext = componentRoot.embedded.getLast(),\n            edgeToPrev = componentRoot.embedded.getFirst();\n        Node next = edgeToNext.getOpposite(componentParent),\n            prev = edgeToPrev.getOpposite(componentParent);\n\n        componentRoot.outerFaceNeighbors[0] = next;\n        componentRoot.outerFaceNeighbors[1] = prev;\n        next.outerFaceNeighbors[1] = componentRoot;\n        prev.outerFaceNeighbors[0] = componentRoot;\n        Node current = componentRoot.outerFaceNeighbors[0];\n        do {\n            edgeToNext = current.embedded.getLast();\n            edgeToPrev = current.embedded.getFirst();\n            next = edgeToNext.getOpposite(current);\n            prev = edgeToPrev.getOpposite(current);\n            if (prev != componentParent) {\n                current.outerFaceNeighbors[1] = prev;\n            }\n            if (next != componentParent) {\n                current.outerFaceNeighbors[0] = next;\n            }\n            current = next;\n        } while (current != componentParent);\n    }\n\n    /**\n     * Removes the edges from the outer face from the {@code start} node to the {@code end} node in\n     * the direction {@code dir} from the set {@code edges}\n     *\n     * @param start the start of the boundary path\n     * @param end the end of the boundary path\n     * @param dir the direction to take from the {@code start} node\n     * @param edges the set of edges to modify\n     */\n    private void removeUp(Node start, Node end, int dir, Set<Edge> edges)\n    {\n        if (start == end) {\n            return;\n        }\n        OuterFaceCirculator circulator = start.iterator(dir);\n        Node next;\n        do {\n            Edge edge = circulator.edgeToNext();\n            edges.remove(edge);\n            next = circulator.next();\n        } while (next != end);\n    }\n\n    /**\n     * Effectively is a method for finding node {@code z} in the notations of the original paper.\n     * The search proceeds in the reverse order of the path from the {@code backEdge} to the node\n     * {@code w}\n     *\n     * @param w the start of the path down\n     * @param backEdge the last edge on the path\n     * @return the desired node {@code z} or null if the source of the {@code backEdge} is equal to\n     *         {@code w}\n     */\n    private Node getNextOnPath(Node w, Edge backEdge)\n    {\n        if (backEdge.source == w) {\n            return null;\n        }\n        Node prev = backEdge.source, current = backEdge.source.getParent();\n        while (current != w) {\n            prev = current;\n            current = current.getParent();\n        }\n        return prev;\n    }\n\n    /**\n     * Finds a path from some intermediate nodes on the path represented by the list {@code path} to\n     * the node {@code v}. The path to {@code v} certainly doesn't exist if the list {@code path}\n     * has size 1, because we're looking for a path from some intermediate node\n     *\n     * @param path the path between left and right outer face branches\n     * @param v the parent of the biconnected component\n     * @return the path edges in a list, which can be empty\n     */\n    private List<Edge> findPathToV(List<Edge> path, Node v)\n    {\n        clearVisited();\n        int i = 0;\n        Edge currentEdge = path.get(i);\n        Node current =\n            currentEdge.source.boundaryHeight != 0 ? currentEdge.target : currentEdge.source;\n        List<Edge> result = new ArrayList<>();\n        while (i < path.size() - 1) {\n            if (findPathDfs(current, currentEdge, n -> !n.marked, n -> n == v, result)) {\n                return result;\n            }\n            ++i;\n            currentEdge = path.get(i);\n            current = currentEdge.getOpposite(current);\n        }\n        return result;\n    }\n\n    /**\n     * Checks whether the first node {@code a} is strictly higher than nodes {@code b} and {@code c}\n     *\n     * @param a a node in the dfs tree\n     * @param b a node in the dfs tree\n     * @param c a node in the dfs tree\n     * @return true if the first node in strictly higher that other node, false otherwise\n     */\n    private boolean firstStrictlyHigher(Node a, Node b, Node c)\n    {\n        return a.height > b.height && a.height > c.height;\n    }\n\n    /**\n     * Checks whether the biconnected component rooted at {@code componentRoot} can be used to\n     * extract a Kuratowski subdivision. It can be used in the case there is one externally active\n     * node on each branch of the outer face and there is a pertinent node on the lower part of the\n     * outer face between these two externally active nodes.\n     *\n     * @param componentRoot the root of the biconnected component\n     * @param v an ancestor of the nodes in the biconnected component\n     * @return an unembedded back edge, which target is {@code v} and which can be used to extract a\n     *         Kuratowski subdivision, or {@code null} is no such edge exist for this biconnected\n     *         component\n     */\n    private Edge checkComponentForFailedEdge(Node componentRoot, Node v)\n    {\n        OuterFaceCirculator firstDir =\n            getExternallyActiveSuccessorOnOuterFace(componentRoot, componentRoot, v, 0);\n        Node firstDirNode = firstDir.getCurrent();\n        OuterFaceCirculator secondDir =\n            getExternallyActiveSuccessorOnOuterFace(componentRoot, componentRoot, v, 1);\n        Node secondDirNode = secondDir.getCurrent();\n        if (firstDirNode != componentRoot && firstDirNode != secondDirNode) {\n            Node current = firstDir.next();\n            while (current != secondDirNode) {\n                if (current.isPertinentWrtTo(v)) {\n                    return searchEdge(current, e -> e.target == v && !e.embedded);\n                }\n                current = firstDir.next();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Finds an unembedded back edge to {@code v}, which can be used to extract the Kuratowski\n     * subdivision. If the merge stack isn't empty, the last biconnected component processed by the\n     * walkdown can be used to find such an edge, because walkdown descended to that component\n     * (which means that component is pertinent) and couldn't reach a pertinent node. This can only\n     * happen by encountering externally active nodes on both branches of the traversal. Otherwise,\n     * be have look in all the child biconnected components to find an unembedded back edge. We're\n     * guided by the fact that an edge can not be embedded only in the case both traversals of the\n     * walkdown could reach all off the pertinent nodes. This in turn can happen only if both\n     * traversals get stuck on externally active nodes.\n     * <p>\n     * <b>Note:</b> not every unembedded back edge can be used to extract a Kuratowski subdivision\n     *\n     * @param v the vertex which has an unembedded back edge incident to it\n     * @return the found unembedded back edge which can be used to extract a Kuratowski subdivision\n     */\n    private Edge findFailedEdge(Node v)\n    {\n        if (stack.isEmpty()) {\n            for (Node child : v.separatedDfsChildList) {\n                Node componentRoot = child.initialComponentRoot;\n                Edge result = checkComponentForFailedEdge(componentRoot, v);\n                if (result != null) {\n                    return result;\n                }\n            }\n            return null; // should not happen in case node v has an incident unembedded back edge\n        } else {\n            MergeInfo info = stack.get(stack.size() - 1);\n            return checkComponentForFailedEdge(info.child, v);\n        }\n    }\n\n    /**\n     * Lazily extracts a Kuratowski subdivision from the {@code graph}. The process of adding the\n     * edges of the subdivision to the resulting set of edges had been made explicit for every case.\n     *\n     * @return a Kuratowski subgraph of the {@code graph}\n     */\n    private Graph<V, E> lazyExtractKuratowskiSubdivision()\n    {\n        if (kuratowskiSubdivision == null) {\n            // remove short-circuit edges and orient all embedded lists clockwise\n            kuratowskiCleanUp();\n            if (DEBUG) {\n                printState();\n            }\n            Set<Edge> subdivision = new HashSet<>();\n            // find the needed unembedded back edge which can be used to find Kuratowski subgraph\n            Edge failedEdge = findFailedEdge(failedV);\n            assert failedEdge != null;\n            /*\n             * We're iteratively moving up traversing the outer faces of the biconnected components\n             * to find externally active nodes x and y, which are on different branches of the outer\n             * face. The way we're finding the nodes x and y helps us eliminate the case E_1\n             * described in the original paper. This can be done because we always find the closest\n             * to the node w externally active nodes x and y.\n             */\n            Node x, y, v = failedEdge.target, w = failedEdge.source, componentRoot;\n            while (true) {\n                componentRoot = getComponentRoot(w);\n                x = getExternallyActiveSuccessorOnOuterFace(w, componentRoot, v, 1).getCurrent();\n                y = getExternallyActiveSuccessorOnOuterFace(w, componentRoot, v, 0).getCurrent();\n                if (x.isRootVertex()) {\n                    w = x.getParent();\n                } else if (y.isRootVertex()) {\n                    w = y.getParent();\n                } else {\n                    componentRoot = getComponentRoot(w);\n                    break;\n                }\n            }\n            Edge xBackEdge = searchEdge(x, v.height);\n            Edge yBackEdge = searchEdge(y, v.height);\n            if (DEBUG) {\n                System.out\n                    .printf(\n                        \"Failed v = %s, failed edge = %s\\n\", failedV.toString(false),\n                        failedEdge.toString());\n                System.out.printf(\"x = %s, y = %s\\n\", x.toString(false), y.toString(false));\n                System.out\n                    .printf(\n                        \"xBackEdge = %s, yBackEdge = %s\\n\", xBackEdge.toString(),\n                        yBackEdge.toString());\n            }\n            Node backLower = lowest(xBackEdge.target, yBackEdge.target);\n            Node backHigher = highest(xBackEdge.target, yBackEdge.target);\n            addPathEdges(subdivision, xBackEdge, x);\n            addPathEdges(subdivision, yBackEdge, y);\n            addBoundaryEdges(subdivision, componentRoot);\n\n            if (componentRoot.getParent() != v) {\n                // case A, v isn't a parent of the component we've found\n                if (PRINT_CASES) {\n                    System.out.println(\"Case A\");\n                }\n                addPathEdges(subdivision, componentRoot.getParent(), backLower);\n                addPathEdges(subdivision, failedEdge, w);\n                return finish(subdivision);\n            }\n            // node z will be null only if the tree path from w to failedEdge is failedEdge itself\n            Node z = getNextOnPath(w, failedEdge);\n            Edge backEdge = null;\n            if (z != null) {\n                backEdge = searchSubtreeDfs(z, e -> e.target.height < v.height && e != failedEdge);\n            }\n            if (backEdge != null) {\n                // case B\n                if (PRINT_CASES) {\n                    System.out.println(\"Case B\");\n                }\n                addPathEdges(subdivision, backEdge, w);\n                addPathEdges(subdivision, failedEdge, w);\n                Node highest =\n                    highest(xBackEdge.target, highest(yBackEdge.target, backEdge.target));\n                Node lowest = lowest(xBackEdge.target, lowest(yBackEdge.target, backEdge.target));\n                addPathEdges(subdivision, highest, lowest);\n                return finish(subdivision);\n            }\n            /*\n             * If we failed to either case A or B, we have to find a highest obstructing path and\n             * then deal with cases C - E\n             */\n            setBoundaryDepth(componentRoot, w, 0, 1);\n            setBoundaryDepth(componentRoot, w, 1, -1);\n\n            assert x.boundaryHeight > 0;\n            List<Edge> path = findHighestObstructingPath(componentRoot, w);\n            assert !path.isEmpty();\n            if (DEBUG) {\n                System.out.println(\"Path = \" + path);\n            }\n\n            Edge firstEdge = path.get(0);\n            Edge lastEdge = path.get(path.size() - 1);\n            Node firstNode =\n                firstEdge.source.boundaryHeight > 0 ? firstEdge.source : firstEdge.target;\n            Node lastNode = lastEdge.source.boundaryHeight < 0 ? lastEdge.source : lastEdge.target;\n            if (firstNode.boundaryHeight < x.boundaryHeight\n                || lastNode.boundaryHeight > y.boundaryHeight)\n            {\n                // case C, either the first node or the last node of the path is higher than x or y\n                // respectively\n                if (PRINT_CASES) {\n                    System.out.println(\"Case C\");\n                }\n                Node removeStart;\n                if (lastNode.boundaryHeight > y.boundaryHeight) {\n                    removeStart = firstNode.boundaryHeight < x.boundaryHeight ? firstNode : x;\n                    removeUp(removeStart, componentRoot, 1, subdivision);\n                } else {\n                    removeUp(y, componentRoot, 0, subdivision);\n                }\n                addPathEdges(subdivision, failedEdge, w);\n                subdivision.addAll(path);\n                addPathEdges(subdivision, v, backLower);\n                return finish(subdivision);\n            }\n            path.forEach(e -> e.source.marked = e.target.marked = true);\n            List<Edge> pathToV = findPathToV(path, v);\n            if (!pathToV.isEmpty()) {\n                // case D, we have a path to the node v\n                if (PRINT_CASES) {\n                    System.out.println(\"Case D\");\n                }\n                removeUp(x, componentRoot, 1, subdivision);\n                removeUp(y, componentRoot, 0, subdivision);\n                subdivision.addAll(path);\n                subdivision.addAll(pathToV);\n                addPathEdges(subdivision, v, backLower);\n                addPathEdges(subdivision, failedEdge, w);\n                return finish(subdivision);\n            }\n            Edge externallyActive = searchEdge(w, v.height, failedEdge);\n            assert externallyActive != null;\n            if (DEBUG) {\n                System.out.printf(\"Externally active edge = %s\\n\", externallyActive.toString());\n            }\n            addPathEdges(subdivision, externallyActive, w);\n            if (firstStrictlyHigher(externallyActive.target, xBackEdge.target, yBackEdge.target)) {\n                // case E_2, equivalent to A\n                if (PRINT_CASES) {\n                    System.out.println(\"Case E_2\");\n                }\n                addPathEdges(subdivision, componentRoot.getParent(), backLower);\n            } else if (firstStrictlyHigher(\n                xBackEdge.target, yBackEdge.target, externallyActive.target))\n            {\n                // case E_2, u_x is higher\n                if (PRINT_CASES) {\n                    System.out.println(\"Case E_2, u_x is higher\");\n                }\n                removeUp(componentRoot, x, 0, subdivision);\n                removeUp(w, lastNode, 0, subdivision);\n                subdivision.addAll(path);\n                addPathEdges(subdivision, failedEdge, w);\n                addPathEdges(subdivision, v, lowest(backLower, externallyActive.target));\n            } else if (firstStrictlyHigher(\n                yBackEdge.target, xBackEdge.target, externallyActive.target))\n            {\n                // case E_2, u_y is higher\n                if (PRINT_CASES) {\n                    System.out.println(\"Case E_2, u_y is higher\");\n                }\n                removeUp(y, componentRoot, 0, subdivision);\n                removeUp(firstNode, w, 0, subdivision);\n                subdivision.addAll(path);\n                addPathEdges(subdivision, failedEdge, w);\n                addPathEdges(subdivision, v, lowest(backLower, externallyActive.target));\n            } else if (firstNode.boundaryHeight > x.boundaryHeight) {\n                // case E_4, p_x is lower than x\n                if (PRINT_CASES) {\n                    System.out.println(\"Case E_3, p_x is lower than x\");\n                }\n                removeUp(w, lastNode, 0, subdivision);\n                subdivision.addAll(path);\n                addPathEdges(subdivision, failedEdge, w);\n                addPathEdges(\n                    subdivision, highest(backHigher, externallyActive.target),\n                    lowest(backLower, externallyActive.target));\n            } else if (lastNode.boundaryHeight < y.boundaryHeight) {\n                // case E_4, p_y is lower than y\n                if (PRINT_CASES) {\n                    System.out.println(\"Case E_3, p_y is lower than y\");\n                }\n                removeUp(firstNode, w, 0, subdivision);\n                subdivision.addAll(path);\n                addPathEdges(subdivision, failedEdge, w);\n                addPathEdges(\n                    subdivision, highest(backHigher, externallyActive.target),\n                    lowest(backLower, externallyActive.target));\n            } else {\n                // case E, extracting K_5\n                if (PRINT_CASES) {\n                    System.out.println(\"Case E, extracting K_5\");\n                }\n                subdivision.addAll(path);\n                addPathEdges(subdivision, v, lowest(backLower, externallyActive.target));\n                addPathEdges(subdivision, failedEdge, w);\n            }\n            return finish(subdivision);\n        }\n        return kuratowskiSubdivision;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Only the first call to this method does the actual computation, all subsequent calls only\n     * return the previously computed value.\n     */\n    @Override\n    public boolean isPlanar()\n    {\n        return lazyTestPlanarity();\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Only the first call to this method does the actual computation, all subsequent calls only\n     * return the previously computed value.\n     */\n    @Override\n    public Embedding<V, E> getEmbedding()\n    {\n        if (isPlanar()) {\n            return lazyComputeEmbedding();\n        } else {\n            throw new IllegalArgumentException(\"Graph is not planar\");\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Only the first call to this method does the actual computation, all subsequent calls only\n     * return the previously computed value.\n     */\n    @Override\n    public Graph<V, E> getKuratowskiSubdivision()\n    {\n        if (isPlanar()) {\n            throw new IllegalArgumentException(\"Graph is planar\");\n        } else {\n            return lazyExtractKuratowskiSubdivision();\n        }\n    }\n\n    /**\n     * Represents information needed to search a path within a biconnected component\n     */\n    private class SearchInfo\n    {\n        /**\n         * The current node of the dfs traversal\n         */\n        Node current;\n        /**\n         * The edge used to go to the {@code current} vertex\n         */\n        Edge prevEdge;\n        /**\n         * Whether dfs is in a forward or a backtracking phase\n         */\n        boolean backtrack;\n\n        /**\n         * Creates a new search info\n         *\n         * @param current the current node of the traversal\n         * @param prevEdge the edge used to go to the {@code current} vertex\n         * @param backtrack whether dfs is in a forward or a backtracking phase\n         */\n        SearchInfo(Node current, Edge prevEdge, boolean backtrack)\n        {\n            this.current = current;\n            this.prevEdge = prevEdge;\n            this.backtrack = backtrack;\n        }\n    }\n\n    /**\n     * Represents information needed to store in the stack during the input {@code graph}\n     * orientation.\n     */\n    private class OrientDfsStackInfo\n    {\n        /**\n         * The current vertex of the dfs traversal\n         */\n        V current;\n        /**\n         * The parent vertex of the {@code current} vertex, which is null for dfs tree roots\n         */\n        V parent;\n        /**\n         * The edge connecting {@code parent} and {@code current} vertices\n         */\n        E parentEdge;\n        /**\n         * Whether dfs is moving forward or backtracking on the {@code current} node\n         */\n        boolean backtrack;\n\n        /**\n         * Creates new instance of the information stored on the stack during the orientation of the\n         * {@code graph}\n         *\n         * @param current the vertex dfs is currently processing\n         * @param parent the parent of the {@code current} vertex\n         * @param parentEdge the edge between {@code current} and {@code parent} vertices\n         * @param backtrack whether dfs is moving forward or backtracking on the {@code current}\n         *        vertex\n         */\n        OrientDfsStackInfo(V current, V parent, E parentEdge, boolean backtrack)\n        {\n            this.current = current;\n            this.parent = parent;\n            this.parentEdge = parentEdge;\n            this.backtrack = backtrack;\n        }\n    }\n\n    /**\n     * The information needed to merge two consecutive biconnected components\n     */\n    private class MergeInfo\n    {\n        /**\n         * The node current traversal descended from. This node belongs to the parent biconnected\n         * component\n         */\n        Node parent;\n        /**\n         * The next node along the traversal of the parent biconnected component\n         */\n        Node parentNext;\n        /**\n         * The virtual root of the child biconnected component\n         */\n        Node child;\n        /**\n         * The previous node along the traversal of the child biconnected component\n         */\n        Node childPrev;\n        /**\n         * The direction used to enter the parent biconnected component.\n         * <p>\n         * <b>Note:</b> this value doesn't specify the direction from {@code parent} node to the\n         * {@code parentNext} node, i.e. {@code parent.outerFaceNeighbors[vIn]} may not be equal to\n         * the {@code parentNext}. Instead, this value specifies the direction used to start the\n         * traversal from the parent's biconnected component virtual root.\n         */\n        int vIn;\n        /**\n         * The direction used to start the traversal of the child biconnected component. Since the\n         * {@code child} is the component root, {@code child.outerFaceNeighbors[|1-vOut|]} is equal\n         * to the {@code childPrev}\n         */\n        int vOut;\n\n        /**\n         * Creates new instance of the infromation needed to merge to biconnected components\n         *\n         * @param parent the node current traversal descended from\n         * @param parentNext the next node along the traversal of the parent component\n         * @param child the virtual root of the child biconnected component\n         * @param childPrev the previous node along the traversal of the child component\n         * @param vIn the direction used to enter the parent biconnected component\n         * @param vOut the direction used to enter the child biconnected component\n         */\n        MergeInfo(Node parent, Node parentNext, Node child, Node childPrev, int vIn, int vOut)\n        {\n            this.parent = parent;\n            this.parentNext = parentNext;\n            this.child = child;\n            this.childPrev = childPrev;\n            this.vIn = vIn;\n            this.vOut = vOut;\n        }\n\n        /**\n         * Returns true if the traversal was inverted when descending to the child biconnected\n         * component, false otherwise\n         *\n         * @return true if the traversal was inverted when descending to the child biconnected\n         *         component, false otherwise\n         */\n        boolean isInverted()\n        {\n            return vIn != vOut;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            return String\n                .format(\n                    \"Parent dir = {%s -> %s}, child_dir = {%s -> %s}, inverted = %b, vIn = %d, vOut = %d\",\n                    parent.toString(false), parentNext.toString(false), childPrev.toString(false),\n                    child.toString(false), isInverted(), vIn, vOut);\n        }\n    }\n\n    /**\n     * A circulator over the nodes on the boundary of the biconnected component. Traverses the nodes\n     * in the cyclic manner, i.e. it doesn't stop when all the nodes are traversed\n     */\n    private class OuterFaceCirculator\n        implements\n        Iterator<Node>\n    {\n        /**\n         * The node this circulator will return next\n         */\n        private Node current;\n        /**\n         * The previous node along the traversal of the component boundary. This node is needed\n         * because the component boundary nodes aren't connected in an ordered way.\n         */\n        private Node prev;\n\n        /**\n         * Creates a new instance of the circulator over the biconnected component boundary nodes.\n         * The {@code prev} node is considered to be just traversed\n         *\n         * @param current the node this circulator will return next\n         * @param prev the previous node along the traversal\n         */\n        OuterFaceCirculator(Node current, Node prev)\n        {\n            this.current = current;\n            this.prev = prev;\n        }\n\n        /**\n         * {@inheritDoc}\n         * <p>\n         * Always returns true since this is a circulator\n         */\n        @Override\n        public boolean hasNext()\n        {\n            return true;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Node next()\n        {\n            Node t = current;\n            current = current.nextOnOuterFace(prev);\n            prev = t;\n            return prev;\n        }\n\n        /**\n         * Returns an edge connecting previously returned node with node, which will be returned\n         * next. If either of the mentioned nodes is virtual, the edge will be incident to its real\n         * counterpart.\n         *\n         * @return an edge from the current node to the next node\n         */\n        Edge edgeToNext()\n        {\n            Edge edge = prev.embedded.getFirst();\n            Node target = toExistingNode(current);\n            Node source = toExistingNode(prev);\n            if (edge.getOpposite(source) == target) {\n                return edge;\n            } else {\n                return prev.embedded.getLast();\n            }\n        }\n\n        /**\n         * Returns the node this circulator has just traversed\n         *\n         * @return the node this circulator has just traversed\n         */\n        Node getCurrent()\n        {\n            return prev;\n        }\n\n        /**\n         * Returns a node adjacent to the current node along the boundary, which is not equal to the\n         * next node along the traversal. If the component consist of just one real node, returns\n         * the only neighbor the the current node.\n         *\n         * @return node before the current node along the traversal\n         */\n        Node getPrev()\n        {\n            return prev.nextOnOuterFace(current);\n        }\n\n        /**\n         * Returns either {@code node} or its real counterpart in the case the {@code node} is a\n         * component root.\n         *\n         * @param node the input argument\n         * @return the real counterpath of the {@code node}\n         */\n        private Node toExistingNode(Node node)\n        {\n            return node.isRootVertex() ? node.getParent() : node;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            return String.format(\"%s -> %s\", prev.toString(false), current.toString(false));\n        }\n    }\n\n    /**\n     * Internal representation of the edges of the input {@code graph}.\n     */\n    private class Edge\n    {\n        /**\n         * The counterpart of this edge in the {@code graph}. This value can be null if the edge was\n         * created as a short-circuit edge.\n         */\n        E graphEdge;\n        /**\n         * The source node of this edge. For tree edges the {@code source} is lower than the\n         * {@code target}, for back edges the {@code target} is lower (having smaller height)\n         */\n        Node source;\n        /**\n         * The target of this edge\n         */\n        Node target;\n        /**\n         * Either $+1$ or $-1$ for regular and inverted edges respectively. This value is set to\n         * $-1$ to flip a biconnected component in $\\mathcal{O}(1)$ time. <b>Note:</b> this\n         * operation doesn't flip any of the child biconnected components of this biconnected\n         * component\n         */\n        int sign;\n        /**\n         * Whether the edge is embedded or not. This value is important for\n         */\n        boolean embedded;\n        /**\n         * Whether the edge is real or short-circuit. See the original paper for the definition of\n         * the short-circuit edges.\n         */\n        boolean shortCircuit;\n\n        /**\n         * Creates a new short-circuit edge with no counterpart in {@code graph}. The {@code source}\n         * of this edge is always a real node on the boundary of some biconnected component, and the\n         * {@code target} node is the parent node of the biconnected component the source node\n         * belongs to, so the edge resembles a regular back edge except for that it doesn't have a\n         * counterpart in the {@code graph}\n         *\n         * @param source the source of the short-circuit edge\n         * @param target the target of the short-circuit edge\n         */\n        Edge(Node source, Node target)\n        {\n            this(null, source, target);\n            this.shortCircuit = true;\n            this.embedded = true;\n        }\n\n        /**\n         * Creates a new tree edge.\n         *\n         * @param graphEdge the counterpart of this edge in the {@code graph}\n         * @param source the source node of this edge\n         */\n        Edge(E graphEdge, Node source)\n        {\n            this(graphEdge, source, null);\n        }\n\n        /**\n         * Creates a new edge. This constructor is used directly for the creation of the back edges\n         *\n         * @param graphEdge the counterpart of this edge in the {@code graph}\n         * @param source the source node of this edge\n         * @param target the target node of this edge\n         */\n        Edge(E graphEdge, Node source, Node target)\n        {\n            this.graphEdge = graphEdge;\n            this.source = source;\n            this.target = target;\n            this.sign = 1;\n        }\n\n        /**\n         * True if this edge is incident to the node {@code node}, false otherwise\n         *\n         * @param node the node to test\n         * @return true if this edge is incident to the node {@code node}, false otherwise\n         */\n        boolean isIncidentTo(Node node)\n        {\n            return source == node || target == node;\n        }\n\n        /**\n         * Returns the opposite node of the {@code node}\n         *\n         * @param node an endpoint of this edge\n         * @return the other endpoint of this edge\n         */\n        Node getOpposite(Node node)\n        {\n            assert isIncidentTo(node); // debug purpose assertion\n            return source == node ? target : source;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            String formatString = \"%s -> %s\";\n            if (shortCircuit) {\n                formatString = \"%s ~ %s\";\n            }\n            return String.format(formatString, source.toString(false), target.toString(false));\n        }\n    }\n\n    /**\n     * The internal representation of the vertices of the graph. Contains necessary information to\n     * perform dfs traversals, biconnected component boundary traversals, to embed edges, etc.\n     */\n    private class Node\n    {\n        /**\n         * The counterpart of this node in the {@code graph}. For the component roots this value is\n         * {@code null}.\n         */\n        V graphVertex;\n        /**\n         * Whether this node is a root of the biconnected component or not.\n         */\n        boolean rootVertex;\n        /**\n         * The dfs index of this node in the graph. Every node has a unique dfs index in the range\n         * $[0,|V| - 1]$. This value is used to order the nodes for the embedding of the edges\n         * incident to them. The index of the first dfs root is $1$\n         */\n        int dfsIndex;\n        /**\n         * The height of the node in the created dfs tree. The root of the tree has height $0$. The\n         * smaller this value is, the lower the node is considered to be.\n         */\n        int height;\n        /**\n         * The least <b>dfs index</b> of the nodes' least ancestors in the subtree rooted at this\n         * node. If the subtree doesn't contain a node with a back edge, that ends lower that this\n         * node, this value is equal to the dfs index of this node.\n         */\n        int lowpoint;\n        /**\n         * The least dfs index of the nodes adjacent to this node. If the node doesn't have incident\n         * back edges, this value is equal to the dfs index of the node itself.\n         */\n        int leastAncestor;\n        /**\n         * Stores some value to indicate whether this node is visited in the current context or not.\n         * During the testing phase, if this value if equal to the dfs index of the currently\n         * processed node $v$, then this node is visited, otherwise not. During the Kuratowski\n         * subdivision extraction phase, the value of $0$ indicates that the node isn't visited,\n         * otherwise, the node is considered to be visited.\n         */\n        int visited;\n        /**\n         * During the process of embedding of the down edges of the node $v$, this variable is set\n         * to the dfs index of $v$ to indicate that this node has a back edge incident to $v$, which\n         * needs to be embedded.\n         */\n        int backEdgeFlag;\n        /**\n         * The height of this node on the boundary of the biconnected component, which is used to\n         * extract the Kuratowski subdivision. The height of the component root is $0$, the heights\n         * on the left side are positive, on the right side - negative. This value is used to\n         * quickly determine for two nodes on the same boundary branch which one is higher (closer\n         * to the component root).\n         */\n        int boundaryHeight;\n        /**\n         * Used to mark the boundary nodes of the biconnected\n         */\n        boolean marked;\n        /**\n         * Edge to the parent node of this node in the dfs tree. For tree roots this value is\n         * {@code null}\n         */\n        Edge parentEdge;\n        /**\n         * If this node has a back edge incident to the currently processed node $v$, then this\n         * variable stores this edge\n         */\n        Edge edgeToEmbed;\n        /**\n         * The component root the node is created in. For dfs tree roots this value is {@code null}\n         */\n        Node initialComponentRoot;\n        /**\n         * Two neighbors on the outer face of the biconnected component. Their order is completely\n         * irrelevant for the algorithm to traverse the outer face.\n         */\n        Node[] outerFaceNeighbors;\n        /**\n         * The list containing the dfs children of this node, which are in the different child\n         * biconnected component, i.e. their weren't merged in the parent component.\n         */\n        DoublyLinkedList<Node> separatedDfsChildList;\n        /**\n         * The roots of the pertinent components during the processing of the node $v$. These are\n         * the components that have pertinent descendant nodes, i.e. nodes incident to the node $v$\n         * via a back edge\n         */\n        DoublyLinkedList<Node> pertinentRoots;\n        /**\n         * The list of tree edges incident to this node in the dfs tree. This list doesn't contain a\n         * parent edge of this node\n         */\n        List<Edge> treeEdges;\n        /**\n         * The list containing the edges from descendants of this node in the dfs tree. For each\n         * such descendant the corresponding edge is a back edge.\n         */\n        List<Edge> downEdges;\n        /**\n         * The list of back edges incident to this node.\n         */\n        List<Edge> backEdges;\n        /**\n         * Stores the list node from the {@code separatedDfsChildList} of the parent node this node\n         * is stored in. This enable deleting of this node from the {@code separatedDfsChildList}\n         * list in $\\mathcal{O}(1)$ time\n         */\n        DoublyLinkedList.ListNode<Node> listNode;\n        /**\n         * The list of the embedded edges incident to this node in a clockwise or a counterclockwise\n         * order. The order is counterclockwise if the product of the signs of the parent edges\n         * along the path from the root of the component this node is contained in to this node is\n         * equal to $-1$. Otherwise, the order is clockwise.\n         */\n        DoublyLinkedList<Edge> embedded;\n\n        /**\n         * Creates a new real node with the specified parameters.\n         *\n         * @param graphVertex the counterpart of this node in the {@code graph}\n         * @param dfsIndex the dfs index of this node\n         * @param height the height of this node in the dfs tree\n         * @param initialComponentRoot the component root of this node.\n         * @param parentEdge the parent edge of this node\n         */\n        Node(V graphVertex, int dfsIndex, int height, Node initialComponentRoot, Edge parentEdge)\n        {\n            this(graphVertex, dfsIndex, parentEdge, false);\n            this.height = height;\n            this.initialComponentRoot = initialComponentRoot;\n        }\n\n        /**\n         * Creates a new component root. Dfs index of the component root is equal to dfs index of\n         * its parent.\n         *\n         * @param dfsIndex the dfs index of this node\n         * @param parentEdge the parent edge of this component root\n         */\n        Node(int dfsIndex, Edge parentEdge)\n        {\n            this(null, dfsIndex, parentEdge, true);\n        }\n\n        /**\n         * Creates a new node with the specified parameters\n         *\n         * @param graphVertex the vertex in the {@code graph} corresponding to this node\n         * @param dfsIndex the dfs index of this node\n         * @param parentEdge the parent edge of this node\n         * @param rootVertex whether this is real or virtual node\n         */\n        Node(V graphVertex, int dfsIndex, Edge parentEdge, boolean rootVertex)\n        {\n            this.graphVertex = graphVertex;\n            this.dfsIndex = dfsIndex;\n            this.parentEdge = parentEdge;\n            this.rootVertex = rootVertex;\n            this.outerFaceNeighbors = TypeUtil.uncheckedCast(Array.newInstance(Node.class, 2));\n            this.embedded = new DoublyLinkedList<>();\n            if (parentEdge != null) {\n                embedded.add(parentEdge);\n            }\n            this.visited = this.backEdgeFlag = n;\n            if (!rootVertex) {\n                separatedDfsChildList = new DoublyLinkedList<>();\n                pertinentRoots = new DoublyLinkedList<>();\n                treeEdges = new ArrayList<>();\n                downEdges = new ArrayList<>();\n                backEdges = new ArrayList<>();\n            }\n        }\n\n        /**\n         * Checks whether this node is visited in the context of processing the node {@code node}\n         *\n         * @param node the node that is currently been processed\n         * @return true if this node is visited, false otherwise\n         */\n        boolean isVisitedWrtTo(Node node)\n        {\n            return node.dfsIndex == visited;\n        }\n\n        /**\n         * Checks whether this node is pertinent in the context of processing the node {@code node}.\n         * During the processing of the node {@code node}, a node is pertinent if it has a back edge\n         * to {@code node} or it has a child biconnected component, which has a pertinent node.\n         *\n         * @param node the node that is currently been processed\n         * @return true if this node is pertinent, false otherwise\n         */\n        boolean isPertinentWrtTo(Node node)\n        {\n            return backEdgeFlag == node.dfsIndex || !pertinentRoots.isEmpty();\n        }\n\n        /**\n         * Checks whether this node has a back edge to the {@code node}.\n         *\n         * @param node the other endpoint of the edge we're looking for\n         * @return true if the edge between this node and {@code node} exists, false otherwise\n         */\n        boolean hasBackEdgeWrtTo(Node node)\n        {\n            return backEdgeFlag == node.dfsIndex;\n        }\n\n        /**\n         * Checks whether this node is externally active with respect to the {@code node}. A node is\n         * externally active, if it is incident to the edge ending higher than {@code node}, or it\n         * has a child biconnected component with a pertinent node\n         *\n         * @param node an ancestor of this node\n         * @return true if this node is externally active with respect to the {@code node}, false\n         *         otherwise\n         */\n        boolean isExternallyActiveWrtTo(Node node)\n        {\n            return leastAncestor < node.dfsIndex || (!separatedDfsChildList.isEmpty()\n                && separatedDfsChildList.getFirst().lowpoint < node.dfsIndex);\n        }\n\n        /**\n         * Returns true if the node is a component root, false otherwise\n         *\n         * @return true if the node is a component root, false otherwise\n         */\n        boolean isRootVertex()\n        {\n            return rootVertex;\n        }\n\n        /**\n         * Check whether this node is internally active. A node is internally active if it's\n         * pertinent and not externally active\n         *\n         * @param node an ancestor of this node\n         * @return true if this node is internally active, false otherwise\n         */\n        boolean isInternallyActiveWrtTo(Node node)\n        {\n            return isPertinentWrtTo(node) && !isExternallyActiveWrtTo(node);\n        }\n\n        /**\n         * Check whether this node is inactive. A node is inactive it is neither pertinent nor\n         * externally active\n         *\n         * @param node an ancestor of this node\n         * @return true if this node is inactive, false otherwise\n         */\n        boolean isInactiveWrtTo(Node node)\n        {\n            return !isExternallyActiveWrtTo(node) && !isPertinentWrtTo(node);\n        }\n\n        /**\n         * Check whether this node is active. A node is active it is either pertinent or externally\n         * active\n         *\n         * @param node an ancestor of this node\n         * @return true if this node is active, false otherwise\n         */\n        boolean isActiveWrtTo(Node node)\n        {\n            return !isInactiveWrtTo(node);\n        }\n\n        /**\n         * Returns a circulator, that moves in the direction {@code direction}. The next node along\n         * the traversal will be {@code this.outerFaceNeighbor[direction]}.\n         *\n         * @param direction the direction to move in\n         * @return an iterator over the boundary nodes in the direction {@code direction}\n         */\n        OuterFaceCirculator iterator(int direction)\n        {\n            return new OuterFaceCirculator(outerFaceNeighbors[direction], this);\n        }\n\n        void removeShortCircuitEdges()\n        {\n            embedded.removeIf(e -> e.shortCircuit);\n        }\n\n        /**\n         * Returns the parent of this node in the dfs tree. Tree parent of the dfs root node is\n         * {@code null}\n         *\n         * @return the parent of this node in the dfs tree\n         */\n        Node getParent()\n        {\n            return parentEdge == null ? null : parentEdge.source;\n        }\n\n        /**\n         * Checks whether this node has a neighbor {@code node} on the boundary of the biconnected\n         * component\n         *\n         * @param node a possible neighbor of this node\n         */\n        void checkIsAdjacent(Node node)\n        {\n            assert node == outerFaceNeighbors[0] || node == outerFaceNeighbors[1];\n        }\n\n        /**\n         * Swaps the outer face neighbors of this node\n         */\n        void swapNeighbors()\n        {\n            Node t = outerFaceNeighbors[0];\n            outerFaceNeighbors[0] = outerFaceNeighbors[1];\n            outerFaceNeighbors[1] = t;\n        }\n\n        /**\n         * Substitutes the neighbor {@code node} with a {@code newNeighbor}\n         *\n         * @param node an old neighbor\n         * @param newNeighbor a new neighbor\n         */\n        void substitute(Node node, Node newNeighbor)\n        {\n            checkIsAdjacent(node);\n            if (outerFaceNeighbors[0] == node) {\n                outerFaceNeighbors[0] = newNeighbor;\n            } else {\n                outerFaceNeighbors[1] = newNeighbor;\n            }\n        }\n\n        /**\n         * Substitutes a neighbor of this node, which is not equal to the {@code node}, with the\n         * {@code newNeighbor}\n         *\n         * @param node the remaining neighbor\n         * @param newNeighbor a new neighbor\n         */\n        void substituteAnother(Node node, Node newNeighbor)\n        {\n            checkIsAdjacent(node);\n            if (outerFaceNeighbors[0] == node) {\n                outerFaceNeighbors[1] = newNeighbor;\n            } else {\n                outerFaceNeighbors[0] = newNeighbor;\n            }\n        }\n\n        /**\n         * Checks whether this node has a neighbor, which is a root of a biconnected component\n         *\n         * @return true, if this node has a root node neighbor, false otherwise\n         */\n        boolean hasRootNeighbor()\n        {\n            return outerFaceNeighbors[0].isRootVertex() || outerFaceNeighbors[1].isRootVertex();\n        }\n\n        /**\n         * Returns a neighbor of this node which is not equal to the {@code prev}\n         *\n         * @param prev a neighbor of this node\n         * @return a neightbor, which is not equal to the {@code prev}\n         */\n        Node nextOnOuterFace(Node prev)\n        {\n            checkIsAdjacent(prev);\n            if (outerFaceNeighbors[0] == prev) {\n                return outerFaceNeighbors[1];\n            } else {\n                return outerFaceNeighbors[0];\n            }\n        }\n\n        /**\n         * Adds {@code edge} to the list of the embedded edges such that the {@code prev} node\n         * becomes an inner node.\n         *\n         * @param edge an edge to embed\n         * @param prev the node which should be on the new inner face\n         */\n        void embedBackEdge(Edge edge, Node prev)\n        {\n            assert !embedded.isEmpty();\n            if (prev.isRootVertex()) {\n                prev = prev.getParent();\n            }\n            Edge firstEdge = embedded.getFirst();\n            if (firstEdge.getOpposite(this) == prev) {\n                // edge on the new inner face is at the beginning of the list\n                embedded.addFirst(edge);\n            } else {\n                embedded.addLast(edge);\n            }\n        }\n\n        /**\n         * Merges the embedded edges of the child component root into this node's embedded edges.\n         * Note, that the edges in the {@code edges} list are always in the clockwise order. There\n         * are 3 parameters which determine how the {@code edges} list is merged: the {@code vIn}\n         * direction, the {@code vOut} direction and the orientation of the edges around this node\n         * (clockwise or counterclockwise). The edges in the {@code edges} list should have the same\n         * orientation. If this list is inverted, the sign of the {@code parentEdge} is set to $-1$.\n         *\n         * @param edges the edges from the child component root\n         * @param vIn the direction used to enter the parent component\n         * @param vOut the direction used to enter the child component\n         * @param parentNext the next node along the traversal of the parent biconnected component\n         * @param parentEdge the parent edge if the child component\n         */\n        void mergeChildEdges(\n            DoublyLinkedList<Edge> edges, int vIn, int vOut, Node parentNext, Edge parentEdge)\n        {\n            assert !embedded.isEmpty();\n            Node firstOpposite = embedded.getFirst().getOpposite(this);\n            boolean alongParentTraversal = firstOpposite != parentNext;\n            boolean actionAppend = false, invert = false;\n            if (vIn == 0) {\n                if (vOut == 0) {\n                    if (!alongParentTraversal) {\n                        invert = actionAppend = true;\n                    }\n                } else {\n                    if (alongParentTraversal) {\n                        invert = true;\n                    } else {\n                        actionAppend = true;\n                    }\n                }\n            } else {\n                if (vOut == 0) {\n                    if (!alongParentTraversal) {\n                        invert = actionAppend = true;\n                    }\n                } else {\n                    if (alongParentTraversal) {\n                        invert = true;\n                    } else {\n                        actionAppend = true;\n                    }\n                }\n            }\n            if (invert) {\n                parentEdge.sign = -1;\n                edges.invert();\n            }\n            if (actionAppend) {\n                embedded.append(edges);\n            } else {\n                embedded.prepend(edges);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public String toString()\n        {\n            String neighbor1 =\n                outerFaceNeighbors[0] == null ? \"null\" : outerFaceNeighbors[0].toString(false);\n            String neighbor2 =\n                outerFaceNeighbors[1] == null ? \"null\" : outerFaceNeighbors[1].toString(false);\n            String childListString = \"null\";\n            if (separatedDfsChildList != null) {\n                StringBuilder builder = new StringBuilder(\"{\");\n                separatedDfsChildList.forEach(n -> builder.append(n.toString(false)).append(\", \"));\n                childListString = builder.append(\"}\").toString();\n            }\n            if (rootVertex) {\n                return String\n                    .format(\n                        \"R {%s}: neighbors = [%s, %s], embedded = %s, visited = %d, back_edge_flag = %d, dfs_index = %d\",\n                        toString(false), neighbor1, neighbor2, embedded.toString(), visited,\n                        backEdgeFlag, dfsIndex);\n            } else {\n                return String\n                    .format(\n                        \"{%s}:  neighbors = [%s, %s], embedded = %s, visited = %d, back_edge_flag = %d, dfs_index = %d, separated = %s, tree_edges = %s, down_edges = %s, back_edges = %s, parent = %s, lowpoint = %d, least_ancestor = %d\",\n                        toString(false), neighbor1, neighbor2, embedded.toString(), visited,\n                        backEdgeFlag, dfsIndex, childListString, treeEdges.toString(),\n                        downEdges.toString(), backEdges.toString(),\n                        parentEdge == null ? \"null\" : parentEdge.source.toString(false), lowpoint,\n                        leastAncestor);\n            }\n        }\n\n        /**\n         * Returns a full or a partial string representation of this node\n         *\n         * @param full whether to return full or partial string representation of this node\n         * @return either full or partial string representation of this node\n         */\n        public String toString(boolean full)\n        {\n            if (!full) {\n                if (rootVertex) {\n                    return String\n                        .format(\n                            \"%s^%s\", parentEdge.source.graphVertex.toString(),\n                            parentEdge.target.graphVertex.toString());\n                } else {\n                    return graphVertex.toString();\n                }\n            } else {\n                return toString();\n            }\n        }\n    }\n}\n",
            "file_name": "BoyerMyrvoldPlanarityInspector.java",
            "human_label": "Return the edge connecting the previously returned node with the current node.",
            "level": "class_runnable",
            "lineno": "1727",
            "name": "edgeToNext",
            "oracle_context": "{ \"apis\" : \"[getFirst, toExistingNode, getOpposite, getLast, Edge, Node]\", \"classes\" : \"[Edge, Node, prev]\", \"vars\" : \"[embedded, prev, current]\" }",
            "package": "org.jgrapht.alg.planar",
            "project": "jgrapht-master"
        },
        {
            "_id": "636767781a6d9265ec01823e",
            "all_context": "{ \"class_level\" : \"import org.apache.log4j.AppenderSkeleton;\\nimport org.apache.log4j.helpers.LogLog;\\nimport org.apache.log4j.spi.LoggingEvent;\\nimport java.io.IOException;\\nimport java.io.PrintWriter;\\nimport java.io.InterruptedIOException;\\nimport java.net.ServerSocket;\\nimport java.net.Socket;\\nimport java.util.Enumeration;\\nimport java.util.Iterator;\\nimport java.util.Vector;\\nSocketHandler sh;\\nint port;\\nVector writers;\\nVector connections;\\nServerSocket serverSocket;\\nint MAX_CONNECTIONS;\\nactivateOptions();\\ngetPort();\\nsetPort(int port);\\nclose();\\nappend(LoggingEvent event);\\nfinalize();\\nsend(String message);\\nrun();\\nSocketHandler(int port);\\nrequiresLayout();\\n\", \"repo_level\" : \"public interface AppenderSkeleton {public void activateOptions();\\npublic void addFilter(Filter newFilter);\\nprotected void append(LoggingEvent event);\\npublic void clearFilters();\\npublic void finalize();\\npublic ErrorHandler getErrorHandler();\\npublic Filter getFilter();\\nfinal Filter getFirstFilter();\\npublic Layout getLayout();\\nfinal String getName();\\npublic Priority getThreshold();\\npublic boolean isAsSevereAsThreshold(Priority priority);\\nsynchronized void doAppend(LoggingEvent event);\\nsynchronized void setErrorHandler(ErrorHandler eh);\\npublic void setLayout(Layout layout);\\npublic void setName(String name);\\npublic void setThreshold(Priority threshold);\\n }\\npublic interface LogLog {public void setInternalDebugging(boolean enabled);\\nstatic void debug(String msg);\\nstatic void debug(String msg,Throwable t);\\nstatic void error(String msg);\\nstatic void error(String msg,Throwable t);\\nstatic void setQuietMode(boolean quietMode);\\nstatic void warn(String msg);\\nstatic void warn(String msg,Throwable t);\\n }\\npublic interface LoggingEvent {public LocationInfo getLocationInformation();\\npublic Level getLevel();\\npublic String getLoggerName();\\npublic Category getLogger();\\npublic Object getMessage();\\npublic String getNDC();\\npublic Object getMDC(String key);\\npublic void getMDCCopy();\\npublic String getRenderedMessage();\\nstatic long getStartTime();\\npublic String getThreadName();\\npublic ThrowableInformation getThrowableInformation();\\npublic String[] getThrowableStrRep();\\nfinal void setProperty(String propName,String propValue);\\nfinal String getProperty(String key);\\nfinal boolean locationInformationExists();\\nfinal long getTimeStamp();\\npublic Set getPropertyKeySet();\\npublic Map getProperties();\\npublic String getFQNOfLoggerClass();\\npublic Object removeProperty(String propName);\\n }\\n\" }",
            "class_name": "TelnetAppender",
            "code": "protected void append(LoggingEvent event){\n  if (sh != null) {\n    sh.send(layout.format(event));\n    if (layout.ignoresThrowable()) {\n      String[] s=event.getThrowableStrRep();\n      if (s != null) {\n        StringBuffer buf=new StringBuffer();\n        for (int i=0; i < s.length; i++) {\n          buf.append(s[i]);\n          buf.append(\"\\r\\n\");\n        }\n        sh.send(buf.toString());\n      }\n    }\n  }\n}\n",
            "docstring": "/** \n * Handles a log event.  For this appender, that means writing the message to each connected client.  \n */\n",
            "end_lineno": "131",
            "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.log4j.net;\n\nimport org.apache.log4j.AppenderSkeleton;\nimport org.apache.log4j.helpers.LogLog;\nimport org.apache.log4j.spi.LoggingEvent;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.InterruptedIOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.Vector;\n\n/**\n  <p>The TelnetAppender is a log4j appender that specializes in\n  writing to a read-only socket.  The output is provided in a\n  telnet-friendly way so that a log can be monitored over TCP/IP.\n  Clients using telnet connect to the socket and receive log data.\n  This is handy for remote monitoring, especially when monitoring a\n  servlet.\n\n  <p>Here is a list of the available configuration options:\n\n  <table border=1>\n   <tr>\n   <th>Name</th>\n   <th>Requirement</th>\n   <th>Description</th>\n   <th>Sample Value</th>\n   </tr>\n\n   <tr>\n   <td>Port</td>\n   <td>optional</td>\n   <td>This parameter determines the port to use for announcing log events.  The default port is 23 (telnet).</td>\n   <td>5875</td>\n   </table>\n\n   @author <a HREF=\"mailto:jay@v-wave.com\">Jay Funnell</a>\n*/\n\npublic class TelnetAppender extends AppenderSkeleton {\n\n  private SocketHandler sh;\n  private int port = 23;\n\n  /** \n      This appender requires a layout to format the text to the\n      attached client(s). */\n  public boolean requiresLayout() {\n    return true;\n  }\n\n  /** all of the options have been set, create the socket handler and\n      wait for connections. */\n  public void activateOptions() {\n    try {\n      sh = new SocketHandler(port);\n      sh.start();\n    }\n    catch(InterruptedIOException e) {\n      Thread.currentThread().interrupt();\n      e.printStackTrace();\n    } catch(IOException e) {\n      e.printStackTrace();\n    } catch(RuntimeException e) {\n      e.printStackTrace();\n    }\n    super.activateOptions();\n  }\n\n  public\n  int getPort() {\n    return port;\n  }\n\n  public\n  void setPort(int port) {\n    this.port = port;\n  }\n\n\n  /** shuts down the appender. */\n  public void close() {\n    if (sh != null) {\n        sh.close();\n        try {\n            sh.join();\n        } catch(InterruptedException ex) {\n            Thread.currentThread().interrupt();\n        }\n    }\n  }\n\n  /** Handles a log event.  For this appender, that means writing the\n    message to each connected client.  */\n  protected void append(LoggingEvent event) {\n      if(sh != null) {\n        sh.send(layout.format(event));\n        if(layout.ignoresThrowable()) {\n            String[] s = event.getThrowableStrRep();\n            if (s != null) {\n                StringBuffer buf = new StringBuffer();\n                for(int i = 0; i < s.length; i++) {\n                    buf.append(s[i]);\n                    buf.append(\"\\r\\n\");\n                }\n                sh.send(buf.toString());\n            }\n        }\n      }\n  }\n\n  //---------------------------------------------------------- SocketHandler:\n\n  /** The SocketHandler class is used to accept connections from\n      clients.  It is threaded so that clients can connect/disconnect\n      asynchronously. */\n  protected class SocketHandler extends Thread {\n\n    private Vector writers = new Vector();\n    private Vector connections = new Vector();\n    private ServerSocket serverSocket;\n    private int MAX_CONNECTIONS = 20;\n\n    public void finalize() {\n        close();\n    }\n      \n    /** \n    * make sure we close all network connections when this handler is destroyed.\n    * @since 1.2.15 \n    */\n    public void close() {\n      synchronized(this) {\n        for(Enumeration e = connections.elements();e.hasMoreElements();) {\n            try {\n                ((Socket)e.nextElement()).close();\n            } catch(InterruptedIOException ex) {\n                Thread.currentThread().interrupt();\n            } catch(IOException ex) {\n            } catch(RuntimeException ex) {\n            }\n        }\n      }\n\n      try {\n        serverSocket.close();\n      } catch(InterruptedIOException ex) {\n          Thread.currentThread().interrupt();\n      } catch(IOException ex) {\n      } catch(RuntimeException ex) {\n      }\n    }\n\n    /** sends a message to each of the clients in telnet-friendly output. */\n    public synchronized void send(final String message) {\n      Iterator ce = connections.iterator();\n      for(Iterator e = writers.iterator();e.hasNext();) {\n        ce.next();\n        PrintWriter writer = (PrintWriter)e.next();\n        writer.print(message);\n        if(writer.checkError()) {\n          ce.remove();\n          e.remove();\n        }\n      }\n    }\n\n    /** \n\tContinually accepts client connections.  Client connections\n        are refused when MAX_CONNECTIONS is reached. \n    */\n    public void run() {\n      while(!serverSocket.isClosed()) {\n        try {\n          Socket newClient = serverSocket.accept();\n          PrintWriter pw = new PrintWriter(newClient.getOutputStream());\n          if(connections.size() < MAX_CONNECTIONS) {\n            synchronized(this) {\n                connections.addElement(newClient);\n                writers.addElement(pw);\n                pw.print(\"TelnetAppender v1.0 (\" + connections.size()\n\t\t            + \" active connections)\\r\\n\\r\\n\");\n                pw.flush();\n            }\n          } else {\n            pw.print(\"Too many connections.\\r\\n\");\n            pw.flush();\n            newClient.close();\n          }\n        } catch(Exception e) {\n          if (e instanceof InterruptedIOException || e instanceof InterruptedException) {\n              Thread.currentThread().interrupt();\n          }\n          if (!serverSocket.isClosed()) {\n            LogLog.error(\"Encountered error while in SocketHandler loop.\", e);\n          }\n          break;\n        }\n      }\n\n      try {\n          serverSocket.close();\n      } catch(InterruptedIOException ex) {\n          Thread.currentThread().interrupt();\n      } catch(IOException ex) {\n      }\n    }\n\n    public SocketHandler(int port) throws IOException {\n      serverSocket = new ServerSocket(port);\n      setName(\"TelnetAppender-\" + getName() + \"-\" + port);\n    }\n\n  }\n}\n",
            "file_name": "TelnetAppender.java",
            "human_label": "Haddling a logging event by using layout.format(),and if layout.ignoresThrowable() is true,it will continue to send the StrRep of the event.",
            "level": "project_runnable",
            "lineno": "114",
            "name": "append",
            "oracle_context": "{ \"apis\" : \"[send, format, ignoresThrowable, getThrowableStrRep, toString]\", \"classes\" : \"[String[], StringBuffer]\", \"vars\" : \"[length, sh]\" }",
            "package": "org.apache.log4j.net",
            "project": "logging-log4j1-main"
        },
        {
            "_id": "636767a31a6d9265ec01854f",
            "all_context": "{ \"class_level\" : \"import java.io.DataInput;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.nio.ByteBuffer;\\nimport java.util.ArrayList;\\nimport java.util.List;\\nimport io.protostuff.StringSerializer.STRING;\\nimport static io.protostuff.WireFormat.TAG_TYPE_BITS;\\nimport static io.protostuff.WireFormat.TAG_TYPE_MASK;\\nimport static io.protostuff.WireFormat.WIRETYPE_END_GROUP;\\nimport static io.protostuff.WireFormat.WIRETYPE_LENGTH_DELIMITED;\\nimport static io.protostuff.WireFormat.WIRETYPE_TAIL_DELIMITER;\\nbyte[] buffer;\\nint bufferSize;\\nint bufferSizeAfterLimit;\\nint bufferPos;\\nInputStream input;\\nint lastTag;\\nint packedLimit;\\nint totalBytesRetired;\\nint currentLimit;\\nboolean decodeNestedMessageAsGroup;\\nint sizeLimit;\\nint DEFAULT_SIZE_LIMIT;\\nint DEFAULT_BUFFER_SIZE;\\nnewInstance(byte[] buf);\\nnewInstance(byte[] buf,int off,int len);\\nreadTag();\\ncheckLastTagWas(int value);\\nskipField(int tag);\\nskipMessage();\\nreadDouble();\\nreadFloat();\\nreadUInt64();\\nreadInt64();\\nreadInt32();\\nreadFixed64();\\nreadFixed32();\\nreadBool();\\nreadString();\\nreadBytes(ByteBuffer bb);\\nmergeObject(T value,Schema schema);\\nmergeObjectEncodedAsGroup(T value,Schema schema);\\nreadBytes();\\nreadUInt32();\\nreadEnum();\\nreadSFixed32();\\nreadSFixed64();\\nreadSInt32();\\nreadSInt64();\\nreadRawVarint32();\\nreadRawVarint32(InputStream input);\\nreadRawVarint32(InputStream input,int firstByte);\\nreadRawVarint32(DataInput input,byte firstByte);\\nreadRawVarint64();\\nreadRawLittleEndian32();\\nreadRawLittleEndian64();\\ndecodeZigZag32(int n);\\ndecodeZigZag64(long n);\\nCodedInput(byte[] buffer,int off,int len,boolean decodeNestedMessageAsGroup);\\nCodedInput(InputStream input,boolean decodeNestedMessageAsGroup);\\nCodedInput(InputStream input,byte[] buffer,boolean decodeNestedMessageAsGroup);\\nCodedInput(InputStream input,byte[] buffer,int offset,int limit,boolean decodeNestedMessageAsGroup);\\nsetSizeLimit(int limit);\\nresetSizeCounter();\\nreset();\\npushLimit(int byteLimit);\\nrecomputeBufferSizeAfterLimit();\\npopLimit(int oldLimit);\\ngetBytesUntilLimit();\\nisCurrentFieldPacked();\\nisAtEnd();\\ngetTotalBytesRead();\\nrefillBuffer(boolean mustSucceed);\\nreadRawByte();\\nreadRawBytes(int size);\\nskipRawBytes(int size);\\nreadFieldNumber(Schema schema);\\ncheckIfPackedField();\\nreadByteArray();\\nhandleUnknownField(int fieldNumber,Schema schema);\\ntransferByteRangeTo(Output output,boolean utf8String,int fieldNumber,boolean repeated);\\ngetLastTag();\\nreadByteBuffer();\\nnewInstance(InputStream input);\\n\", \"repo_level\" : \"\" }",
            "class_name": "CodedInput",
            "code": "private void checkIfPackedField() throws IOException {\n  if (packedLimit == 0 && WireFormat.getTagWireType(lastTag) == WIRETYPE_LENGTH_DELIMITED) {\n    final int length=readRawVarint32();\n    if (length < 0)     throw ProtobufException.negativeSize();\n    this.packedLimit=getTotalBytesRead() + length;\n  }\n}\n",
            "docstring": "/** \n * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that packed fields are being read.\n * @throws IOException\n */\n",
            "end_lineno": "1229",
            "file_content": "//========================================================================\n//Copyright 2007-2009 David Yu dyuproject@gmail.com\n//------------------------------------------------------------------------\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at \n//http://www.apache.org/licenses/LICENSE-2.0\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//========================================================================\n\n// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// http://code.google.com/p/protobuf/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npackage io.protostuff;\n\nimport java.io.DataInput;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport io.protostuff.StringSerializer.STRING;\n\nimport static io.protostuff.WireFormat.TAG_TYPE_BITS;\nimport static io.protostuff.WireFormat.TAG_TYPE_MASK;\nimport static io.protostuff.WireFormat.WIRETYPE_END_GROUP;\nimport static io.protostuff.WireFormat.WIRETYPE_LENGTH_DELIMITED;\nimport static io.protostuff.WireFormat.WIRETYPE_TAIL_DELIMITER;\n\n/**\n * Reads and decodes protocol message fields.\n * <p>\n * This class contains two kinds of methods: methods that read specific protocol message constructs and field types\n * (e.g. {@link #readTag()} and {@link #readInt32()}) and methods that read low-level values (e.g.\n * {@link #readRawVarint32()} and {@link #readRawBytes}). If you are reading encoded protocol messages, you should use\n * the former methods, but if you are reading some other format of your own design, use the latter.\n *\n * @author kenton@google.com Kenton Varda\n * @author David Yu\n */\npublic final class CodedInput implements Input\n{\n    /**\n     * Create a new CodedInput wrapping the given InputStream.\n     */\n    public static CodedInput newInstance(final InputStream input)\n    {\n        return new CodedInput(input, false);\n    }\n\n    /**\n     * Create a new CodedInput wrapping the given byte array.\n     */\n    public static CodedInput newInstance(final byte[] buf)\n    {\n        return newInstance(buf, 0, buf.length);\n    }\n\n    /**\n     * Create a new CodedInput wrapping the given byte array slice.\n     */\n    public static CodedInput newInstance(final byte[] buf, final int off,\n            final int len)\n    {\n        return new CodedInput(buf, off, len, false);\n    }\n\n    // -----------------------------------------------------------------\n\n    /**\n     * Attempt to read a field tag, returning zero if we have reached EOF. Protocol message parsers use this to read\n     * tags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.\n     */\n    public int readTag() throws IOException\n    {\n        if (isAtEnd())\n        {\n            lastTag = 0;\n            return 0;\n        }\n\n        final int tag = readRawVarint32();\n        if (tag >>> TAG_TYPE_BITS == 0)\n        {\n            // If we actually read zero, that's not a valid tag.\n            throw ProtobufException.invalidTag();\n        }\n        lastTag = tag;\n        return tag;\n    }\n\n    /**\n     * Verifies that the last call to readTag() returned the given tag value. This is used to verify that a nested group\n     * ended with the correct end tag.\n     *\n     * @throws ProtobufException\n     *             {@code value} does not match the last tag.\n     */\n    public void checkLastTagWas(final int value)\n            throws ProtobufException\n    {\n        if (lastTag != value)\n        {\n            throw ProtobufException.invalidEndTag();\n        }\n    }\n\n    /**\n     * Reads and discards a single field, given its tag value.\n     *\n     * @return {@code false} if the tag is an endgroup tag, in which case nothing is skipped. Otherwise, returns\n     *         {@code true}.\n     */\n    public boolean skipField(final int tag) throws IOException\n    {\n        switch (WireFormat.getTagWireType(tag))\n        {\n            case WireFormat.WIRETYPE_VARINT:\n                readInt32();\n                return true;\n            case WireFormat.WIRETYPE_FIXED64:\n                readRawLittleEndian64();\n                return true;\n            case WireFormat.WIRETYPE_LENGTH_DELIMITED:\n                skipRawBytes(readRawVarint32());\n                return true;\n            case WireFormat.WIRETYPE_START_GROUP:\n                skipMessage();\n                checkLastTagWas(WireFormat.makeTag(WireFormat.getTagFieldNumber(tag),\n                        WireFormat.WIRETYPE_END_GROUP));\n                return true;\n            case WireFormat.WIRETYPE_END_GROUP:\n                return false;\n            case WireFormat.WIRETYPE_FIXED32:\n                readRawLittleEndian32();\n                return true;\n            default:\n                throw ProtobufException.invalidWireType();\n        }\n    }\n\n    /**\n     * Reads and discards an entire message. This will read either until EOF or until an endgroup tag, whichever comes\n     * first.\n     */\n    public void skipMessage() throws IOException\n    {\n        while (true)\n        {\n            final int tag = readTag();\n            if (tag == 0 || !skipField(tag))\n            {\n                return;\n            }\n        }\n    }\n\n    // -----------------------------------------------------------------\n\n    /**\n     * Read a {@code double} field value from the stream.\n     */\n    @Override\n    public double readDouble() throws IOException\n    {\n        checkIfPackedField();\n        return Double.longBitsToDouble(readRawLittleEndian64());\n    }\n\n    /**\n     * Read a {@code float} field value from the stream.\n     */\n    @Override\n    public float readFloat() throws IOException\n    {\n        checkIfPackedField();\n        return Float.intBitsToFloat(readRawLittleEndian32());\n    }\n\n    /**\n     * Read a {@code uint64} field value from the stream.\n     */\n    @Override\n    public long readUInt64() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint64();\n    }\n\n    /**\n     * Read an {@code int64} field value from the stream.\n     */\n    @Override\n    public long readInt64() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint64();\n    }\n\n    /**\n     * Read an {@code int32} field value from the stream.\n     */\n    @Override\n    public int readInt32() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint32();\n    }\n\n    /**\n     * Read a {@code fixed64} field value from the stream.\n     */\n    @Override\n    public long readFixed64() throws IOException\n    {\n        checkIfPackedField();\n        return readRawLittleEndian64();\n    }\n\n    /**\n     * Read a {@code fixed32} field value from the stream.\n     */\n    @Override\n    public int readFixed32() throws IOException\n    {\n        checkIfPackedField();\n        return readRawLittleEndian32();\n    }\n\n    /**\n     * Read a {@code bool} field value from the stream.\n     */\n    @Override\n    public boolean readBool() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint32() != 0;\n    }\n\n    /**\n     * Read a {@code string} field value from the stream.\n     */\n    @Override\n    public String readString() throws IOException\n    {\n        final int size = readRawVarint32();\n        if (size <= (bufferSize - bufferPos) && size > 0)\n        {\n            // Fast path: We already have the bytes in a contiguous buffer, so\n            // just copy directly from it.\n            final String result = STRING.deser(buffer, bufferPos, size);\n            bufferPos += size;\n            return result;\n        }\n        else\n        {\n            // Slow path: Build a byte array first then copy it.\n            return STRING.deser(readRawBytes(size));\n        }\n    }\n\n    /**\n     * Read a {@code string} field value from the stream into a ByteBuffer.\n     */\n    @Override\n    public void readBytes(final ByteBuffer bb) throws IOException\n    {\n        final int size = readRawVarint32();\n\n        if (size <= (bufferSize - bufferPos) && size > 0)\n        {\n            // Fast path: We already have the bytes in a contiguous buffer, so\n            // just copy directly from it.\n            bb.limit(size);\n            bb.put(buffer, bufferPos, size);\n            bufferPos += size;\n        }\n        else\n        {\n            // Slow path: Build a byte array first then copy it.\n            bb.put(readRawBytes(size));\n        }\n    }\n\n    @Override\n    public <T> T mergeObject(T value, final Schema<T> schema) throws IOException\n    {\n        if (decodeNestedMessageAsGroup)\n            return mergeObjectEncodedAsGroup(value, schema);\n\n        final int length = readRawVarint32();\n        // if (recursionDepth >= recursionLimit) {\n        // throw ProtobufException.recursionLimitExceeded();\n        // }\n        final int oldLimit = pushLimit(length);\n        // ++recursionDepth;\n\n        if (value == null)\n        {\n            value = schema.newMessage();\n        }\n        schema.mergeFrom(this, value);\n        if (!schema.isInitialized(value))\n        {\n            throw new UninitializedMessageException(value, schema);\n        }\n        checkLastTagWas(0);\n        // --recursionDepth;\n        popLimit(oldLimit);\n        return value;\n    }\n\n    /**\n     * Reads a message field value from the stream (using the {@code group} encoding).\n     */\n    private <T> T mergeObjectEncodedAsGroup(T value, final Schema<T> schema) throws IOException\n    {\n        // if (recursionDepth >= recursionLimit) {\n        // throw ProtobufException.recursionLimitExceeded();\n        // }\n        // ++recursionDepth;\n\n        if (value == null)\n        {\n            value = schema.newMessage();\n        }\n        schema.mergeFrom(this, value);\n        if (!schema.isInitialized(value))\n        {\n            throw new UninitializedMessageException(value, schema);\n        }\n        // handling is in #readFieldNumber\n        checkLastTagWas(0);\n        // --recursionDepth;\n        return value;\n    }\n\n    /*\n     * @ Reads a {@code group} field value from the stream and merges it into the given {@link UnknownFieldSet}.\n     * \n     * @deprecated UnknownFieldSet.Builder now implements MessageLite.Builder, so you can just call {@link #readGroup}.\n     */\n    /*\n     * @Deprecated public void readUnknownGroup(final int fieldNumber, final MessageLite.Builder builder) throws\n     * IOException { // We know that UnknownFieldSet will ignore any ExtensionRegistry so it // is safe to pass null\n     * here. (We can't call // ExtensionRegistry.getEmptyRegistry() because that would make this // class depend on\n     * ExtensionRegistry, which is not part of the lite // library.) readGroup(fieldNumber, builder, null); }\n     */\n\n    /**\n     * Read a {@code bytes} field value from the stream.\n     */\n    @Override\n    public ByteString readBytes() throws IOException\n    {\n        final int size = readRawVarint32();\n        if (size == 0)\n        {\n            return ByteString.EMPTY;\n        }\n\n        if (size <= (bufferSize - bufferPos) && size > 0)\n        {\n            // Fast path: We already have the bytes in a contiguous buffer, so\n            // just copy directly from it.\n            final ByteString result = ByteString.copyFrom(buffer, bufferPos, size);\n            bufferPos += size;\n            return result;\n        }\n        else\n        {\n            // Slow path: Build a byte array first then copy it.\n            // return ByteString.copyFrom(readRawBytes(size));\n            return ByteString.wrap(readRawBytes(size));\n        }\n    }\n\n    /**\n     * Read a {@code uint32} field value from the stream.\n     */\n    @Override\n    public int readUInt32() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint32();\n    }\n\n    /**\n     * Read an enum field value from the stream. Caller is responsible for converting the numeric value to an actual\n     * enum.\n     */\n    @Override\n    public int readEnum() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint32();\n    }\n\n    /**\n     * Read an {@code sfixed32} field value from the stream.\n     */\n    @Override\n    public int readSFixed32() throws IOException\n    {\n        checkIfPackedField();\n        return readRawLittleEndian32();\n    }\n\n    /**\n     * Read an {@code sfixed64} field value from the stream.\n     */\n    @Override\n    public long readSFixed64() throws IOException\n    {\n        checkIfPackedField();\n        return readRawLittleEndian64();\n    }\n\n    /**\n     * Read an {@code sint32} field value from the stream.\n     */\n    @Override\n    public int readSInt32() throws IOException\n    {\n        checkIfPackedField();\n        return decodeZigZag32(readRawVarint32());\n    }\n\n    /**\n     * Read an {@code sint64} field value from the stream.\n     */\n    @Override\n    public long readSInt64() throws IOException\n    {\n        checkIfPackedField();\n        return decodeZigZag64(readRawVarint64());\n    }\n\n    // =================================================================\n\n    /**\n     * Read a raw Varint from the stream. If larger than 32 bits, discard the upper bits.\n     */\n    public int readRawVarint32() throws IOException\n    {\n        byte tmp = readRawByte();\n        if (tmp >= 0)\n        {\n            return tmp;\n        }\n        int result = tmp & 0x7f;\n        if ((tmp = readRawByte()) >= 0)\n        {\n            result |= tmp << 7;\n        }\n        else\n        {\n            result |= (tmp & 0x7f) << 7;\n            if ((tmp = readRawByte()) >= 0)\n            {\n                result |= tmp << 14;\n            }\n            else\n            {\n                result |= (tmp & 0x7f) << 14;\n                if ((tmp = readRawByte()) >= 0)\n                {\n                    result |= tmp << 21;\n                }\n                else\n                {\n                    result |= (tmp & 0x7f) << 21;\n                    result |= (tmp = readRawByte()) << 28;\n                    if (tmp < 0)\n                    {\n                        // Discard upper 32 bits.\n                        for (int i = 0; i < 5; i++)\n                        {\n                            if (readRawByte() >= 0)\n                            {\n                                return result;\n                            }\n                        }\n                        throw ProtobufException.malformedVarint();\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Reads a varint from the input one byte at a time, so that it does not read any bytes after the end of the varint.\n     * If you simply wrapped the stream in a CodedInput and used {@link #readRawVarint32(InputStream)} then you would\n     * probably end up reading past the end of the varint since CodedInput buffers its input.\n     */\n    static int readRawVarint32(final InputStream input) throws IOException\n    {\n        final int firstByte = input.read();\n        if (firstByte == -1)\n        {\n            throw ProtobufException.truncatedMessage();\n        }\n\n        if ((firstByte & 0x80) == 0)\n        {\n            return firstByte;\n        }\n        return readRawVarint32(input, firstByte);\n    }\n\n    /**\n     * Reads a varint from the input one byte at a time, so that it does not read any bytes after the end of the varint.\n     * If you simply wrapped the stream in a CodedInput and used {@link #readRawVarint32(InputStream)} then you would\n     * probably end up reading past the end of the varint since CodedInput buffers its input.\n     */\n    static int readRawVarint32(final InputStream input, final int firstByte) throws IOException\n    {\n        int result = firstByte & 0x7f;\n        int offset = 7;\n        for (; offset < 32; offset += 7)\n        {\n            final int b = input.read();\n            if (b == -1)\n            {\n                throw ProtobufException.truncatedMessage();\n            }\n            result |= (b & 0x7f) << offset;\n            if ((b & 0x80) == 0)\n            {\n                return result;\n            }\n        }\n        // Keep reading up to 64 bits.\n        for (; offset < 64; offset += 7)\n        {\n            final int b = input.read();\n            if (b == -1)\n            {\n                throw ProtobufException.truncatedMessage();\n            }\n            if ((b & 0x80) == 0)\n            {\n                return result;\n            }\n        }\n        throw ProtobufException.malformedVarint();\n    }\n\n    /**\n     * Reads a varint from the input one byte at a time from a {@link DataInput}, so that it does not read any bytes\n     * after the end of the varint.\n     */\n    static int readRawVarint32(final DataInput input, final byte firstByte) throws IOException\n    {\n        int result = firstByte & 0x7f;\n        int offset = 7;\n        for (; offset < 32; offset += 7)\n        {\n            final byte b = input.readByte();\n            result |= (b & 0x7f) << offset;\n            if ((b & 0x80) == 0)\n            {\n                return result;\n            }\n        }\n        // Keep reading up to 64 bits.\n        for (; offset < 64; offset += 7)\n        {\n            final byte b = input.readByte();\n            if ((b & 0x80) == 0)\n            {\n                return result;\n            }\n        }\n        throw ProtobufException.malformedVarint();\n    }\n\n    /**\n     * Read a raw Varint from the stream.\n     */\n    public long readRawVarint64() throws IOException\n    {\n        int shift = 0;\n        long result = 0;\n        while (shift < 64)\n        {\n            final byte b = readRawByte();\n            result |= (long) (b & 0x7F) << shift;\n            if ((b & 0x80) == 0)\n            {\n                return result;\n            }\n            shift += 7;\n        }\n        throw ProtobufException.malformedVarint();\n    }\n\n    /**\n     * Read a 32-bit little-endian integer from the stream.\n     */\n    public int readRawLittleEndian32() throws IOException\n    {\n        final byte b1 = readRawByte();\n        final byte b2 = readRawByte();\n        final byte b3 = readRawByte();\n        final byte b4 = readRawByte();\n        return (((int) b1 & 0xff)) |\n                (((int) b2 & 0xff) << 8) |\n                (((int) b3 & 0xff) << 16) |\n                (((int) b4 & 0xff) << 24);\n    }\n\n    /**\n     * Read a 64-bit little-endian integer from the stream.\n     */\n    public long readRawLittleEndian64() throws IOException\n    {\n        final byte b1 = readRawByte();\n        final byte b2 = readRawByte();\n        final byte b3 = readRawByte();\n        final byte b4 = readRawByte();\n        final byte b5 = readRawByte();\n        final byte b6 = readRawByte();\n        final byte b7 = readRawByte();\n        final byte b8 = readRawByte();\n        return (((long) b1 & 0xff)) |\n                (((long) b2 & 0xff) << 8) |\n                (((long) b3 & 0xff) << 16) |\n                (((long) b4 & 0xff) << 24) |\n                (((long) b5 & 0xff) << 32) |\n                (((long) b6 & 0xff) << 40) |\n                (((long) b7 & 0xff) << 48) |\n                (((long) b8 & 0xff) << 56);\n    }\n\n    /**\n     * Decode a ZigZag-encoded 32-bit value. ZigZag encodes signed integers into values that can be efficiently encoded\n     * with varint. (Otherwise, negative values must be sign-extended to 64 bits to be varint encoded, thus always\n     * taking 10 bytes on the wire.)\n     *\n     * @param n\n     *            An unsigned 32-bit integer, stored in a signed int because Java has no explicit unsigned support.\n     * @return A signed 32-bit integer.\n     */\n    public static int decodeZigZag32(final int n)\n    {\n        return (n >>> 1) ^ -(n & 1);\n    }\n\n    /**\n     * Decode a ZigZag-encoded 64-bit value. ZigZag encodes signed integers into values that can be efficiently encoded\n     * with varint. (Otherwise, negative values must be sign-extended to 64 bits to be varint encoded, thus always\n     * taking 10 bytes on the wire.)\n     *\n     * @param n\n     *            An unsigned 64-bit integer, stored in a signed int because Java has no explicit unsigned support.\n     * @return A signed 64-bit integer.\n     */\n    public static long decodeZigZag64(final long n)\n    {\n        return (n >>> 1) ^ -(n & 1);\n    }\n\n    // -----------------------------------------------------------------\n\n    private final byte[] buffer;\n    private int bufferSize;\n    private int bufferSizeAfterLimit;\n    private int bufferPos;\n    private final InputStream input;\n    private int lastTag;\n    private int packedLimit = 0;\n\n    /**\n     * The total number of bytes read before the current buffer. The total bytes read up to the current position can be\n     * computed as {@code totalBytesRetired + bufferPos}. This value may be negative if reading started in the middle of\n     * the current buffer (e.g. if the constructor that takes a byte array and an offset was used).\n     */\n    private int totalBytesRetired;\n\n    /**\n     * The absolute position of the end of the current message.\n     */\n    private int currentLimit = Integer.MAX_VALUE;\n\n    // ** See setRecursionLimit() */\n    // private int recursionDepth;\n    // private int recursionLimit = DEFAULT_RECURSION_LIMIT;\n\n    /**\n     * If true, the nested messages are group-encoded\n     */\n    public final boolean decodeNestedMessageAsGroup;\n\n    /**\n     * See setSizeLimit()\n     */\n    private int sizeLimit = DEFAULT_SIZE_LIMIT;\n\n    // static final int DEFAULT_RECURSION_LIMIT = 64;\n    static final int DEFAULT_SIZE_LIMIT = 64 << 20; // 64MB\n    static final int DEFAULT_BUFFER_SIZE = 4096;\n\n    public CodedInput(final byte[] buffer, final int off, final int len,\n            boolean decodeNestedMessageAsGroup)\n    {\n        this.buffer = buffer;\n        bufferSize = off + len;\n        bufferPos = off;\n        totalBytesRetired = -off;\n        input = null;\n        this.decodeNestedMessageAsGroup = decodeNestedMessageAsGroup;\n    }\n\n    public CodedInput(final InputStream input, boolean decodeNestedMessageAsGroup)\n    {\n        this(input, new byte[DEFAULT_BUFFER_SIZE], 0, 0, decodeNestedMessageAsGroup);\n    }\n\n    public CodedInput(final InputStream input, byte[] buffer,\n            boolean decodeNestedMessageAsGroup)\n    {\n        this(input, buffer, 0, 0, decodeNestedMessageAsGroup);\n    }\n\n    public CodedInput(final InputStream input, byte[] buffer, int offset, int limit,\n            boolean decodeNestedMessageAsGroup)\n    {\n        this.buffer = buffer;\n        bufferSize = limit;\n        bufferPos = offset;\n        totalBytesRetired = -offset;\n        this.input = input;\n        this.decodeNestedMessageAsGroup = decodeNestedMessageAsGroup;\n    }\n\n    /*\n     * Set the maximum message recursion depth. In order to prevent malicious messages from causing stack overflows,\n     * {@code CodedInput} limits how deeply messages may be nested. The default limit is 64.\n     * \n     * @return the old limit.\n     * \n     * public int setRecursionLimit(final int limit) { if (limit < 0) { throw new IllegalArgumentException(\n     * \"Recursion limit cannot be negative: \" + limit); } final int oldLimit = recursionLimit; recursionLimit = limit;\n     * return oldLimit; }\n     */\n\n    /**\n     * Set the maximum message size. In order to prevent malicious messages from exhausting memory or causing integer\n     * overflows, {@code CodedInput} limits how large a message may be. The default limit is 64MB. You should set this\n     * limit as small as you can without harming your app's functionality. Note that size limits only apply when reading\n     * from an {@code InputStream}, not when constructed around a raw byte array.\n     * <p>\n     * If you want to read several messages from a single CodedInput, you could call {@link #resetSizeCounter()} after\n     * each one to avoid hitting the size limit.\n     *\n     * @return the old limit.\n     */\n    public int setSizeLimit(final int limit)\n    {\n        if (limit < 0)\n        {\n            throw new IllegalArgumentException(\n                    \"Size limit cannot be negative: \" + limit);\n        }\n        final int oldLimit = sizeLimit;\n        sizeLimit = limit;\n        return oldLimit;\n    }\n\n    /**\n     * Resets the current size counter to zero (see {@link #setSizeLimit(int)}). The field {@code totalBytesRetired}\n     * will be negative if the initial position was not zero.\n     */\n    public void resetSizeCounter()\n    {\n        totalBytesRetired = -bufferPos;\n    }\n\n    /**\n     * Resets the buffer position and limit to re-use this CodedInput object.\n     */\n    public void reset()\n    {\n        this.bufferSize = 0;\n        this.bufferPos = 0;\n        this.bufferSizeAfterLimit = 0;\n        this.currentLimit = Integer.MAX_VALUE;\n        this.lastTag = 0;\n        this.packedLimit = 0;\n        this.sizeLimit = DEFAULT_SIZE_LIMIT;\n        resetSizeCounter();\n    }\n\n    /**\n     * Note that {@code pushLimit()} does NOT affect how many bytes the {@code CodedInputStream} reads from an\n     * underlying {@code InputStream} when refreshing its buffer. If you need to prevent reading past a certain point in\n     * the underlying {@code InputStream} (e.g. because you expect it to contain more data after the end of the message\n     * which you need to handle differently) then you must place a wrapper around your {@code InputStream} which limits\n     * the amount of data that can be read from it.\n     *\n     * @return the old limit.\n     */\n    public int pushLimit(int byteLimit) throws ProtobufException\n    {\n        if (byteLimit < 0)\n        {\n            throw ProtobufException.negativeSize();\n        }\n        byteLimit += totalBytesRetired + bufferPos;\n        final int oldLimit = currentLimit;\n        if (byteLimit > oldLimit)\n        {\n            throw ProtobufException.truncatedMessage();\n        }\n        currentLimit = byteLimit;\n\n        recomputeBufferSizeAfterLimit();\n\n        return oldLimit;\n    }\n\n    private void recomputeBufferSizeAfterLimit()\n    {\n        bufferSize += bufferSizeAfterLimit;\n        final int bufferEnd = totalBytesRetired + bufferSize;\n        if (bufferEnd > currentLimit)\n        {\n            // Limit is in current buffer.\n            bufferSizeAfterLimit = bufferEnd - currentLimit;\n            bufferSize -= bufferSizeAfterLimit;\n        }\n        else\n        {\n            bufferSizeAfterLimit = 0;\n        }\n    }\n\n    /**\n     * Discards the current limit, returning to the previous limit.\n     *\n     * @param oldLimit\n     *            The old limit, as returned by {@code pushLimit}.\n     */\n    public void popLimit(final int oldLimit)\n    {\n        currentLimit = oldLimit;\n        recomputeBufferSizeAfterLimit();\n    }\n\n    /**\n     * Returns the number of bytes to be read before the current limit. If no limit is set, returns -1.\n     */\n    public int getBytesUntilLimit()\n    {\n        if (currentLimit == Integer.MAX_VALUE)\n        {\n            return -1;\n        }\n\n        final int currentAbsolutePosition = totalBytesRetired + bufferPos;\n        return currentLimit - currentAbsolutePosition;\n    }\n\n    /**\n     * Return true if currently reading packed field\n     */\n    public boolean isCurrentFieldPacked()\n    {\n        return packedLimit != 0 && packedLimit != getTotalBytesRead();\n    }\n\n    /**\n     * Returns true if the stream has reached the end of the input. This is the case if either the end of the underlying\n     * input source has been reached or if the stream has reached a limit created using {@link #pushLimit(int)}.\n     */\n    public boolean isAtEnd() throws IOException\n    {\n        return bufferPos == bufferSize && !refillBuffer(false);\n    }\n\n    /**\n     * The total bytes read up to the current position. Calling {@link #resetSizeCounter()} resets this value to zero.\n     */\n    public int getTotalBytesRead()\n    {\n        return totalBytesRetired + bufferPos;\n    }\n\n    /**\n     * Called with {@code this.buffer} is empty to read more bytes from the input. If {@code mustSucceed} is true,\n     * refillBuffer() guarantees that either there will be at least one byte in the buffer when it returns or it will\n     * throw an exception. If {@code mustSucceed} is false, refillBuffer() returns false if no more bytes were\n     * available.\n     */\n    private boolean refillBuffer(final boolean mustSucceed) throws IOException\n    {\n        if (bufferPos < bufferSize)\n        {\n            throw new IllegalStateException(\n                    \"refillBuffer() called when buffer wasn't empty.\");\n        }\n\n        if (totalBytesRetired + bufferSize == currentLimit)\n        {\n            // Oops, we hit a limit.\n            if (mustSucceed)\n            {\n                throw ProtobufException.truncatedMessage();\n            }\n            else\n            {\n                return false;\n            }\n        }\n\n        totalBytesRetired += bufferSize;\n\n        bufferPos = 0;\n        bufferSize = (input == null) ? -1 : input.read(buffer);\n        if (bufferSize == 0 || bufferSize < -1)\n        {\n            throw new IllegalStateException(\n                    \"InputStream#read(byte[]) returned invalid result: \" + bufferSize +\n                            \"\\nThe InputStream implementation is buggy.\");\n        }\n        if (bufferSize == -1)\n        {\n            bufferSize = 0;\n            if (mustSucceed)\n            {\n                throw ProtobufException.truncatedMessage();\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else\n        {\n            recomputeBufferSizeAfterLimit();\n            final int totalBytesRead =\n                    totalBytesRetired + bufferSize + bufferSizeAfterLimit;\n            if (totalBytesRead > sizeLimit || totalBytesRead < 0)\n            {\n                throw ProtobufException.sizeLimitExceeded();\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Read one byte from the input.\n     *\n     * @throws ProtobufException\n     *             The end of the stream or the current limit was reached.\n     */\n    public byte readRawByte() throws IOException\n    {\n        if (bufferPos == bufferSize)\n        {\n            refillBuffer(true);\n        }\n        return buffer[bufferPos++];\n    }\n\n    /**\n     * Read a fixed size of bytes from the input.\n     *\n     * @throws ProtobufException\n     *             The end of the stream or the current limit was reached.\n     */\n    public byte[] readRawBytes(final int size) throws IOException\n    {\n        if (size < 0)\n        {\n            throw ProtobufException.negativeSize();\n        }\n\n        if (totalBytesRetired + bufferPos + size > currentLimit)\n        {\n            // Read to the end of the stream anyway.\n            skipRawBytes(currentLimit - totalBytesRetired - bufferPos);\n            // Then fail.\n            throw ProtobufException.truncatedMessage();\n        }\n\n        if (size <= bufferSize - bufferPos)\n        {\n            // We have all the bytes we need already.\n            final byte[] bytes = new byte[size];\n            System.arraycopy(buffer, bufferPos, bytes, 0, size);\n            bufferPos += size;\n            return bytes;\n        }\n        else if (size < buffer.length)\n        {\n            // Reading more bytes than are in the buffer, but not an excessive number\n            // of bytes. We can safely allocate the resulting array ahead of time.\n\n            // First copy what we have.\n            final byte[] bytes = new byte[size];\n            int pos = bufferSize - bufferPos;\n            System.arraycopy(buffer, bufferPos, bytes, 0, pos);\n            bufferPos = bufferSize;\n\n            // We want to use refillBuffer() and then copy from the buffer into our\n            // byte array rather than reading directly into our byte array because\n            // the input may be unbuffered.\n            refillBuffer(true);\n\n            while (size - pos > bufferSize)\n            {\n                System.arraycopy(buffer, 0, bytes, pos, bufferSize);\n                pos += bufferSize;\n                bufferPos = bufferSize;\n                refillBuffer(true);\n            }\n\n            System.arraycopy(buffer, 0, bytes, pos, size - pos);\n            bufferPos = size - pos;\n\n            return bytes;\n        }\n        else\n        {\n            // The size is very large. For security reasons, we can't allocate the\n            // entire byte array yet. The size comes directly from the input, so a\n            // maliciously-crafted message could provide a bogus very large size in\n            // order to trick the app into allocating a lot of memory. We avoid this\n            // by allocating and reading only a small chunk at a time, so that the\n            // malicious message must actually *be* extremely large to cause\n            // problems. Meanwhile, we limit the allowed size of a message elsewhere.\n\n            // Remember the buffer markers since we'll have to copy the bytes out of\n            // it later.\n            final int originalBufferPos = bufferPos;\n            final int originalBufferSize = bufferSize;\n\n            // Mark the current buffer consumed.\n            totalBytesRetired += bufferSize;\n            bufferPos = 0;\n            bufferSize = 0;\n\n            // Read all the rest of the bytes we need.\n            int sizeLeft = size - (originalBufferSize - originalBufferPos);\n            final List<byte[]> chunks = new ArrayList<byte[]>();\n\n            while (sizeLeft > 0)\n            {\n                final byte[] chunk = new byte[Math.min(sizeLeft, buffer.length)];\n                int pos = 0;\n                while (pos < chunk.length)\n                {\n                    final int n = (input == null) ? -1 :\n                            input.read(chunk, pos, chunk.length - pos);\n                    if (n == -1)\n                    {\n                        throw ProtobufException.truncatedMessage();\n                    }\n                    totalBytesRetired += n;\n                    pos += n;\n                }\n                sizeLeft -= chunk.length;\n                chunks.add(chunk);\n            }\n\n            // OK, got everything. Now concatenate it all into one buffer.\n            final byte[] bytes = new byte[size];\n\n            // Start by copying the leftover bytes from this.buffer.\n            int pos = originalBufferSize - originalBufferPos;\n            System.arraycopy(buffer, originalBufferPos, bytes, 0, pos);\n\n            // And now all the chunks.\n            for (final byte[] chunk : chunks)\n            {\n                System.arraycopy(chunk, 0, bytes, pos, chunk.length);\n                pos += chunk.length;\n            }\n\n            // Done.\n            return bytes;\n        }\n    }\n\n    /**\n     * Reads and discards {@code size} bytes.\n     *\n     * @throws ProtobufException\n     *             The end of the stream or the current limit was reached.\n     */\n    public void skipRawBytes(final int size) throws IOException\n    {\n        if (size < 0)\n        {\n            throw ProtobufException.negativeSize();\n        }\n\n        if (totalBytesRetired + bufferPos + size > currentLimit)\n        {\n            // Read to the end of the stream anyway.\n            skipRawBytes(currentLimit - totalBytesRetired - bufferPos);\n            // Then fail.\n            throw ProtobufException.truncatedMessage();\n        }\n\n        if (size <= bufferSize - bufferPos)\n        {\n            // We have all the bytes we need already.\n            bufferPos += size;\n        }\n        else\n        {\n            // Skipping more bytes than are in the buffer. First skip what we have.\n            int pos = bufferSize - bufferPos;\n            bufferPos = bufferSize;\n\n            // Keep refilling the buffer until we get to the point we wanted to skip\n            // to. This has the side effect of ensuring the limits are updated\n            // correctly.\n            refillBuffer(true);\n            while (size - pos > bufferSize)\n            {\n                pos += bufferSize;\n                bufferPos = bufferSize;\n                refillBuffer(true);\n            }\n\n            bufferPos = size - pos;\n        }\n    }\n\n    // START EXTRA\n    @Override\n    public <T> int readFieldNumber(Schema<T> schema) throws IOException\n    {\n        if (isAtEnd())\n        {\n            lastTag = 0;\n            return 0;\n        }\n\n        // are we reading packed field?\n        if (isCurrentFieldPacked())\n        {\n            if (packedLimit < getTotalBytesRead())\n                throw ProtobufException.misreportedSize();\n\n            // Return field number while reading packed field\n            return lastTag >>> TAG_TYPE_BITS;\n        }\n\n        packedLimit = 0;\n        final int tag = readRawVarint32();\n        final int fieldNumber = tag >>> TAG_TYPE_BITS;\n        if (fieldNumber == 0)\n        {\n            if (decodeNestedMessageAsGroup && WIRETYPE_TAIL_DELIMITER == (tag & TAG_TYPE_MASK))\n            {\n                // protostuff's tail delimiter for streaming\n                // 2 options: length-delimited or tail-delimited.\n                lastTag = 0;\n                return 0;\n            }\n            // If we actually read zero, that's not a valid tag.\n            throw ProtobufException.invalidTag();\n        }\n        if (decodeNestedMessageAsGroup && WIRETYPE_END_GROUP == (tag & TAG_TYPE_MASK))\n        {\n            lastTag = 0;\n            return 0;\n        }\n\n        lastTag = tag;\n        return fieldNumber;\n    }\n\n    /**\n     * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that\n     * packed fields are being read.\n     *\n     * @throws IOException\n     */\n    private void checkIfPackedField() throws IOException\n    {\n        // Do we have the start of a packed field?\n        if (packedLimit == 0 && WireFormat.getTagWireType(lastTag) == WIRETYPE_LENGTH_DELIMITED)\n        {\n            final int length = readRawVarint32();\n            if (length < 0)\n                throw ProtobufException.negativeSize();\n\n            this.packedLimit = getTotalBytesRead() + length;\n        }\n    }\n\n    @Override\n    public byte[] readByteArray() throws IOException\n    {\n        final int size = readRawVarint32();\n        if (size <= (bufferSize - bufferPos) && size > 0)\n        {\n            // Fast path: We already have the bytes in a contiguous buffer, so\n            // just copy directly from it.\n            final byte[] copy = new byte[size];\n            System.arraycopy(buffer, bufferPos, copy, 0, size);\n            bufferPos += size;\n            return copy;\n        }\n        else\n        {\n            // Slow path: Build a byte array first then copy it.\n            return readRawBytes(size);\n        }\n    }\n\n    @Override\n    public <T> void handleUnknownField(int fieldNumber, Schema<T> schema) throws IOException\n    {\n        skipField(lastTag);\n    }\n\n    @Override\n    public void transferByteRangeTo(Output output, boolean utf8String, int fieldNumber,\n            boolean repeated) throws IOException\n    {\n        final int size = readRawVarint32();\n        if (size <= (bufferSize - bufferPos) && size > 0)\n        {\n            // Fast path: We already have the bytes in a contiguous buffer\n            output.writeByteRange(utf8String, fieldNumber, buffer, bufferPos, size, repeated);\n            bufferPos += size;\n        }\n        else\n        {\n            // Slow path: Build a byte array first then copy it.\n            output.writeByteRange(utf8String, fieldNumber, readRawBytes(size), 0, size, repeated);\n        }\n    }\n\n    /**\n     * Returns the last tag.\n     */\n    public int getLastTag()\n    {\n        return lastTag;\n    }\n\n    /**\n     * Reads a byte array/ByteBuffer value.\n     */\n    @Override\n    public ByteBuffer readByteBuffer() throws IOException\n    {\n        return ByteBuffer.wrap(readByteArray());\n    }\n\n    // END EXTRA\n}\n",
            "file_name": "CodedInput.java",
            "human_label": "Check if the field should be packed,if so,read the field and update the internal state. It will throw an exception when the process of reading is wrong.",
            "level": "class_runnable",
            "lineno": "1212",
            "name": "checkIfPackedField",
            "oracle_context": "{ \"apis\" : \"[getTagWireType, readRawVarint32, negativeSize, getTotalBytesRead]\", \"classes\" : \"[]\", \"vars\" : \"[packedLimit, lastTag]\" }",
            "package": "io.protostuff",
            "project": "protostuff-master"
        },
        {
            "_id": "636767a81a6d9265ec0185fc",
            "all_context": "{ \"class_level\" : \"import static io.protostuff.WireFormat.TAG_TYPE_BITS;\\nimport static io.protostuff.WireFormat.TAG_TYPE_MASK;\\nimport static io.protostuff.WireFormat.WIRETYPE_END_GROUP;\\nimport static io.protostuff.WireFormat.WIRETYPE_FIXED32;\\nimport static io.protostuff.WireFormat.WIRETYPE_FIXED64;\\nimport static io.protostuff.WireFormat.WIRETYPE_LENGTH_DELIMITED;\\nimport static io.protostuff.WireFormat.WIRETYPE_START_GROUP;\\nimport static io.protostuff.WireFormat.WIRETYPE_TAIL_DELIMITER;\\nimport static io.protostuff.WireFormat.WIRETYPE_VARINT;\\nimport static io.protostuff.WireFormat.getTagFieldNumber;\\nimport static io.protostuff.WireFormat.getTagWireType;\\nimport static io.protostuff.WireFormat.makeTag;\\nimport java.io.IOException;\\nimport java.nio.ByteBuffer;\\nimport io.protostuff.StringSerializer.STRING;\\nByteBuffer buffer;\\nint lastTag;\\nint packedLimit;\\nboolean decodeNestedMessageAsGroup;\\nByteBufferInput(ByteBuffer buffer,boolean protostuffMessage);\\ncurrentOffset();\\ncurrentLimit();\\nisCurrentFieldPacked();\\ngetLastTag();\\nreadTag();\\ncheckLastTagWas(int value);\\nskipField(int tag);\\nskipMessage();\\nhandleUnknownField(int fieldNumber,Schema schema);\\nreadFieldNumber(Schema schema);\\ncheckIfPackedField();\\nreadDouble();\\nreadFloat();\\nreadUInt64();\\nreadInt64();\\nreadInt32();\\nreadFixed64();\\nreadFixed32();\\nreadBool();\\nreadUInt32();\\nreadEnum();\\nreadSFixed32();\\nreadSFixed64();\\nreadSInt32();\\nreadSInt64();\\nreadString();\\nreadBytes();\\nreadBytes(ByteBuffer bb);\\nreadByteArray();\\nmergeObject(T value,Schema schema);\\nmergeObjectEncodedAsGroup(T value,Schema schema);\\nreadRawVarint32();\\nreadRawVarint64();\\nreadRawLittleEndian32();\\nreadRawLittleEndian64();\\ntransferByteRangeTo(Output output,boolean utf8String,int fieldNumber,boolean repeated);\\nreadByteBuffer();\\nreset(int offset,int len);\\n\", \"repo_level\" : \"\" }",
            "class_name": "ByteBufferInput",
            "code": "public int readTag() throws IOException {\n  if (!buffer.hasRemaining()) {\n    lastTag=0;\n    return 0;\n  }\n  final int tag=readRawVarint32();\n  if (tag >>> TAG_TYPE_BITS == 0) {\n    throw ProtobufException.invalidTag();\n  }\n  lastTag=tag;\n  return tag;\n}\n",
            "docstring": "/** \n * Attempt to read a field tag, returning zero if we have reached EOF. Protocol message parsers use this to read tags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.\n */\n",
            "end_lineno": "133",
            "file_content": "//========================================================================\n//Copyright 2007-2010 David Yu dyuproject@gmail.com\n//------------------------------------------------------------------------\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at\n//http://www.apache.org/licenses/LICENSE-2.0\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//========================================================================\n\npackage io.protostuff;\n\nimport static io.protostuff.WireFormat.TAG_TYPE_BITS;\nimport static io.protostuff.WireFormat.TAG_TYPE_MASK;\nimport static io.protostuff.WireFormat.WIRETYPE_END_GROUP;\nimport static io.protostuff.WireFormat.WIRETYPE_FIXED32;\nimport static io.protostuff.WireFormat.WIRETYPE_FIXED64;\nimport static io.protostuff.WireFormat.WIRETYPE_LENGTH_DELIMITED;\nimport static io.protostuff.WireFormat.WIRETYPE_START_GROUP;\nimport static io.protostuff.WireFormat.WIRETYPE_TAIL_DELIMITER;\nimport static io.protostuff.WireFormat.WIRETYPE_VARINT;\nimport static io.protostuff.WireFormat.getTagFieldNumber;\nimport static io.protostuff.WireFormat.getTagWireType;\nimport static io.protostuff.WireFormat.makeTag;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\n\nimport io.protostuff.StringSerializer.STRING;\n\n/**\n * Reads and decodes protocol buffer message fields from an internal byte array buffer. This object is re-usable via\n * doing a reset on the byte array position and length. This is used internally by {@link IOUtil} where it catches\n * {@link ArrayIndexOutOfBoundsException} when a message is truncated.\n * \n * @author David Yu\n * @created Jun 22, 2010\n */\npublic final class ByteBufferInput implements Input\n{\n\n    private final ByteBuffer buffer;\n    // private final byte[] buffer;\n    private int lastTag = 0;\n    // private int offset, limit, lastTag = 0;\n    private int packedLimit = 0;\n\n    /**\n     * If true, the nested messages are group-encoded\n     */\n    public final boolean decodeNestedMessageAsGroup;\n\n    /**\n     * An input for a ByteBuffer\n     * \n     * @param buffer\n     *            the buffer to read from, it will be sliced\n     * @param protostuffMessage\n     *            if we are parsing a protostuff (true) or protobuf (false) message\n     */\n    public ByteBufferInput(ByteBuffer buffer, boolean protostuffMessage)\n    {\n        this.buffer = buffer.slice();\n        this.decodeNestedMessageAsGroup = protostuffMessage;\n    }\n\n    /**\n     * Resets the offset and the limit of the internal buffer.\n     */\n    public ByteBufferInput reset(int offset, int len)\n    {\n        buffer.rewind();\n\n        return this;\n    }\n\n    /**\n     * Returns the current offset (the position).\n     */\n    public int currentOffset()\n    {\n        return buffer.position();\n    }\n\n    /**\n     * Returns the current limit (the end index).\n     */\n    public int currentLimit()\n    {\n        return buffer.limit();\n    }\n\n    /**\n     * Return true if currently reading packed field\n     */\n    public boolean isCurrentFieldPacked()\n    {\n        return packedLimit != 0 && packedLimit != buffer.position();\n    }\n\n    /**\n     * Returns the last tag.\n     */\n    public int getLastTag()\n    {\n        return lastTag;\n    }\n\n    /**\n     * Attempt to read a field tag, returning zero if we have reached EOF. Protocol message parsers use this to read\n     * tags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.\n     */\n    public int readTag() throws IOException\n    {\n        if (!buffer.hasRemaining())\n        {\n            lastTag = 0;\n            return 0;\n        }\n\n        final int tag = readRawVarint32();\n        if (tag >>> TAG_TYPE_BITS == 0)\n        {\n            // If we actually read zero, that's not a valid tag.\n            throw ProtobufException.invalidTag();\n        }\n        lastTag = tag;\n        return tag;\n    }\n\n    /**\n     * Verifies that the last call to readTag() returned the given tag value. This is used to verify that a nested group\n     * ended with the correct end tag.\n     * \n     * @throws ProtobufException\n     *             {@code value} does not match the last tag.\n     */\n    public void checkLastTagWas(final int value) throws ProtobufException\n    {\n        if (lastTag != value)\n        {\n            throw ProtobufException.invalidEndTag();\n        }\n    }\n\n    /**\n     * Reads and discards a single field, given its tag value.\n     * \n     * @return {@code false} if the tag is an endgroup tag, in which case nothing is skipped. Otherwise, returns\n     *         {@code true}.\n     */\n    public boolean skipField(final int tag) throws IOException\n    {\n        switch (getTagWireType(tag))\n        {\n            case WIRETYPE_VARINT:\n                readInt32();\n                return true;\n            case WIRETYPE_FIXED64:\n                readRawLittleEndian64();\n                return true;\n            case WIRETYPE_LENGTH_DELIMITED:\n                final int size = readRawVarint32();\n                if (size < 0)\n                    throw ProtobufException.negativeSize();\n                buffer.position(buffer.position() + size);\n                // offset += size;\n                return true;\n            case WIRETYPE_START_GROUP:\n                skipMessage();\n                checkLastTagWas(makeTag(getTagFieldNumber(tag), WIRETYPE_END_GROUP));\n                return true;\n            case WIRETYPE_END_GROUP:\n                return false;\n            case WIRETYPE_FIXED32:\n                readRawLittleEndian32();\n                return true;\n            default:\n                throw ProtobufException.invalidWireType();\n        }\n    }\n\n    /**\n     * Reads and discards an entire message. This will read either until EOF or until an endgroup tag, whichever comes\n     * first.\n     */\n    public void skipMessage() throws IOException\n    {\n        while (true)\n        {\n            final int tag = readTag();\n            if (tag == 0 || !skipField(tag))\n            {\n                return;\n            }\n        }\n    }\n\n    @Override\n    public <T> void handleUnknownField(int fieldNumber, Schema<T> schema) throws IOException\n    {\n        skipField(lastTag);\n    }\n\n    @Override\n    public <T> int readFieldNumber(Schema<T> schema) throws IOException\n    {\n        if (!buffer.hasRemaining())\n        {\n            lastTag = 0;\n            return 0;\n        }\n\n        // are we reading packed field?\n        if (isCurrentFieldPacked())\n        {\n            if (packedLimit < buffer.position())\n                throw ProtobufException.misreportedSize();\n\n            // Return field number while reading packed field\n            return lastTag >>> TAG_TYPE_BITS;\n        }\n\n        packedLimit = 0;\n        final int tag = readRawVarint32();\n        final int fieldNumber = tag >>> TAG_TYPE_BITS;\n        if (fieldNumber == 0)\n        {\n            if (decodeNestedMessageAsGroup &&\n                    WIRETYPE_TAIL_DELIMITER == (tag & TAG_TYPE_MASK))\n            {\n                // protostuff's tail delimiter for streaming\n                // 2 options: length-delimited or tail-delimited.\n                lastTag = 0;\n                return 0;\n            }\n            // If we actually read zero, that's not a valid tag.\n            throw ProtobufException.invalidTag();\n        }\n        if (decodeNestedMessageAsGroup && WIRETYPE_END_GROUP == (tag & TAG_TYPE_MASK))\n        {\n            lastTag = 0;\n            return 0;\n        }\n\n        lastTag = tag;\n        return fieldNumber;\n    }\n\n    /**\n     * Check if this field have been packed into a length-delimited field. If so, update internal state to reflect that\n     * packed fields are being read.\n     * \n     * @throws IOException\n     */\n    private void checkIfPackedField() throws IOException\n    {\n        // Do we have the start of a packed field?\n        if (packedLimit == 0 && getTagWireType(lastTag) == WIRETYPE_LENGTH_DELIMITED)\n        {\n            final int length = readRawVarint32();\n            if (length < 0)\n                throw ProtobufException.negativeSize();\n\n            if (buffer.position() + length > buffer.limit())\n                throw ProtobufException.misreportedSize();\n\n            this.packedLimit = buffer.position() + length;\n        }\n    }\n\n    /**\n     * Read a {@code double} field value from the internal buffer.\n     */\n    @Override\n    public double readDouble() throws IOException\n    {\n        checkIfPackedField();\n        return Double.longBitsToDouble(readRawLittleEndian64());\n    }\n\n    /**\n     * Read a {@code float} field value from the internal buffer.\n     */\n    @Override\n    public float readFloat() throws IOException\n    {\n        checkIfPackedField();\n        return Float.intBitsToFloat(readRawLittleEndian32());\n    }\n\n    /**\n     * Read a {@code uint64} field value from the internal buffer.\n     */\n    @Override\n    public long readUInt64() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint64();\n    }\n\n    /**\n     * Read an {@code int64} field value from the internal buffer.\n     */\n    @Override\n    public long readInt64() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint64();\n    }\n\n    /**\n     * Read an {@code int32} field value from the internal buffer.\n     */\n    @Override\n    public int readInt32() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint32();\n    }\n\n    /**\n     * Read a {@code fixed64} field value from the internal buffer.\n     */\n    @Override\n    public long readFixed64() throws IOException\n    {\n        checkIfPackedField();\n        return readRawLittleEndian64();\n    }\n\n    /**\n     * Read a {@code fixed32} field value from the internal buffer.\n     */\n    @Override\n    public int readFixed32() throws IOException\n    {\n        checkIfPackedField();\n        return readRawLittleEndian32();\n    }\n\n    /**\n     * Read a {@code bool} field value from the internal buffer.\n     */\n    @Override\n    public boolean readBool() throws IOException\n    {\n        checkIfPackedField();\n        return buffer.get() != 0;\n    }\n\n    /**\n     * Read a {@code uint32} field value from the internal buffer.\n     */\n    @Override\n    public int readUInt32() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint32();\n    }\n\n    /**\n     * Read an enum field value from the internal buffer. Caller is responsible for converting the numeric value to an\n     * actual enum.\n     */\n    @Override\n    public int readEnum() throws IOException\n    {\n        checkIfPackedField();\n        return readRawVarint32();\n    }\n\n    /**\n     * Read an {@code sfixed32} field value from the internal buffer.\n     */\n    @Override\n    public int readSFixed32() throws IOException\n    {\n        checkIfPackedField();\n        return readRawLittleEndian32();\n    }\n\n    /**\n     * Read an {@code sfixed64} field value from the internal buffer.\n     */\n    @Override\n    public long readSFixed64() throws IOException\n    {\n        checkIfPackedField();\n        return readRawLittleEndian64();\n    }\n\n    /**\n     * Read an {@code sint32} field value from the internal buffer.\n     */\n    @Override\n    public int readSInt32() throws IOException\n    {\n        checkIfPackedField();\n        final int n = readRawVarint32();\n        return (n >>> 1) ^ -(n & 1);\n    }\n\n    /**\n     * Read an {@code sint64} field value from the internal buffer.\n     */\n    @Override\n    public long readSInt64() throws IOException\n    {\n        checkIfPackedField();\n        final long n = readRawVarint64();\n        return (n >>> 1) ^ -(n & 1);\n    }\n\n    @Override\n    public String readString() throws IOException\n    {\n        final int length = readRawVarint32();\n        if (length < 0)\n            throw ProtobufException.negativeSize();\n\n        if (buffer.remaining() < length)\n            throw ProtobufException.misreportedSize();\n\n        // if(offset + length > limit)\n\n        if (buffer.hasArray())\n        {\n            final int currPosition = buffer.position();\n            buffer.position(buffer.position() + length);\n            return STRING.deser(buffer.array(),\n                    buffer.arrayOffset() + currPosition,\n                    length);\n        }\n        else\n        {\n            byte[] tmp = new byte[length];\n            buffer.get(tmp);\n            return STRING.deser(tmp);\n        }\n\n        // final int offset = this.offset;\n\n        // this.offset += length;\n\n        // return STRING.deser(buffer, offset, length);\n    }\n\n    @Override\n    public ByteString readBytes() throws IOException\n    {\n        return ByteString.wrap(readByteArray());\n    }\n\n    @Override\n    public void readBytes(final ByteBuffer bb) throws IOException\n    {\n        final int length = readRawVarint32();\n        if (length < 0)\n            throw ProtobufException.negativeSize();\n\n        if (buffer.remaining() < length)\n            // if(offset + length > limit)\n            throw ProtobufException.misreportedSize();\n\n        bb.put(buffer);\n    }\n\n    @Override\n    public byte[] readByteArray() throws IOException\n    {\n        final int length = readRawVarint32();\n        if (length < 0)\n            throw ProtobufException.negativeSize();\n\n        if (buffer.remaining() < length)\n            // if(offset + length > limit)\n            throw ProtobufException.misreportedSize();\n\n        final byte[] copy = new byte[length];\n        buffer.get(copy);\n        return copy;\n    }\n\n    @Override\n    public <T> T mergeObject(T value, final Schema<T> schema) throws IOException\n    {\n        if (decodeNestedMessageAsGroup)\n            return mergeObjectEncodedAsGroup(value, schema);\n\n        final int length = readRawVarint32();\n        if (length < 0)\n            throw ProtobufException.negativeSize();\n\n        if (buffer.remaining() < length)\n            throw ProtobufException.misreportedSize();\n\n        ByteBuffer dup = buffer.slice();\n        dup.limit(length);\n\n        // save old limit\n        // final int oldLimit = this.limit;\n\n        // this.limit = offset + length;\n\n        if (value == null)\n            value = schema.newMessage();\n        ByteBufferInput nestedInput = new ByteBufferInput(dup, decodeNestedMessageAsGroup);\n        schema.mergeFrom(nestedInput, value);\n        if (!schema.isInitialized(value))\n            throw new UninitializedMessageException(value, schema);\n        nestedInput.checkLastTagWas(0);\n        // checkLastTagWas(0);\n\n        // restore old limit\n        // this.limit = oldLimit;\n\n        buffer.position(buffer.position() + length);\n        return value;\n    }\n\n    private <T> T mergeObjectEncodedAsGroup(T value, final Schema<T> schema) throws IOException\n    {\n        if (value == null)\n            value = schema.newMessage();\n        schema.mergeFrom(this, value);\n        if (!schema.isInitialized(value))\n            throw new UninitializedMessageException(value, schema);\n        // handling is in #readFieldNumber\n        checkLastTagWas(0);\n        return value;\n    }\n\n    /**\n     * Reads a var int 32 from the internal byte buffer.\n     */\n    public int readRawVarint32() throws IOException\n    {\n        byte tmp = buffer.get();\n        if (tmp >= 0)\n        {\n            return tmp;\n        }\n        int result = tmp & 0x7f;\n        if ((tmp = buffer.get()) >= 0)\n        {\n            result |= tmp << 7;\n        }\n        else\n        {\n            result |= (tmp & 0x7f) << 7;\n            if ((tmp = buffer.get()) >= 0)\n            {\n                result |= tmp << 14;\n            }\n            else\n            {\n                result |= (tmp & 0x7f) << 14;\n                if ((tmp = buffer.get()) >= 0)\n                {\n                    result |= tmp << 21;\n                }\n                else\n                {\n                    result |= (tmp & 0x7f) << 21;\n                    result |= (tmp = buffer.get()) << 28;\n                    if (tmp < 0)\n                    {\n                        // Discard upper 32 bits.\n                        for (int i = 0; i < 5; i++)\n                        {\n                            if (buffer.get() >= 0)\n                            {\n                                return result;\n                            }\n                        }\n                        throw ProtobufException.malformedVarint();\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Reads a var int 64 from the internal byte buffer.\n     */\n    public long readRawVarint64() throws IOException\n    {\n        // final byte[] buffer = this.buffer;\n        // int offset = this.offset;\n\n        int shift = 0;\n        long result = 0;\n        while (shift < 64)\n        {\n            final byte b = buffer.get();\n            result |= (long) (b & 0x7F) << shift;\n            if ((b & 0x80) == 0)\n            {\n                // this.offset = offset;\n                return result;\n            }\n            shift += 7;\n        }\n        throw ProtobufException.malformedVarint();\n    }\n\n    /**\n     * Read a 32-bit little-endian integer from the internal buffer.\n     */\n    public int readRawLittleEndian32() throws IOException\n    {\n        // final byte[] buffer = this.buffer;\n        // int offset = this.offset;\n\n        final byte[] bs = new byte[4];\n        buffer.get(bs);\n\n        // final byte b1 = buffer[offset++];\n        // final byte b2 = buffer[offset++];\n        // final byte b3 = buffer[offset++];\n        // final byte b4 = buffer[offset++];\n        //\n        // this.offset = offset;\n\n        return (((int) bs[0] & 0xff)) |\n                (((int) bs[1] & 0xff) << 8) |\n                (((int) bs[2] & 0xff) << 16) |\n                (((int) bs[3] & 0xff) << 24);\n    }\n\n    /**\n     * Read a 64-bit little-endian integer from the internal byte buffer.\n     */\n    public long readRawLittleEndian64() throws IOException\n    {\n        // final byte[] buffer = this.buffer;\n        // int offset = this.offset;\n\n        final byte[] bs = new byte[8];\n        buffer.get(bs);\n\n        // final byte b1 = buffer[offset++];\n        // final byte b2 = buffer[offset++];\n        // final byte b3 = buffer[offset++];\n        // final byte b4 = buffer[offset++];\n        // final byte b5 = buffer[offset++];\n        // final byte b6 = buffer[offset++];\n        // final byte b7 = buffer[offset++];\n        // final byte b8 = buffer[offset++];\n        //\n        // this.offset = offset;\n\n        return (((long) bs[0] & 0xff)) |\n                (((long) bs[1] & 0xff) << 8) |\n                (((long) bs[2] & 0xff) << 16) |\n                (((long) bs[3] & 0xff) << 24) |\n                (((long) bs[4] & 0xff) << 32) |\n                (((long) bs[5] & 0xff) << 40) |\n                (((long) bs[6] & 0xff) << 48) |\n                (((long) bs[7] & 0xff) << 56);\n    }\n\n    @Override\n    public void transferByteRangeTo(Output output, boolean utf8String, int fieldNumber,\n            boolean repeated) throws IOException\n    {\n        final int length = readRawVarint32();\n        if (length < 0)\n            throw ProtobufException.negativeSize();\n\n        if (utf8String)\n        {\n            // if it is a UTF string, we have to call the writeByteRange.\n\n            if (buffer.hasArray())\n            {\n                output.writeByteRange(true, fieldNumber, buffer.array(),\n                        buffer.arrayOffset() + buffer.position(), length, repeated);\n                buffer.position(buffer.position() + length);\n            }\n            else\n            {\n                byte[] bytes = new byte[length];\n                buffer.get(bytes);\n                output.writeByteRange(true, fieldNumber, bytes, 0, bytes.length, repeated);\n            }\n        }\n        else\n        {\n            // Do the potentially vastly more efficient potential splice call.\n            if (buffer.remaining() < length)\n                throw ProtobufException.misreportedSize();\n\n            ByteBuffer dup = buffer.slice();\n            dup.limit(length);\n\n            output.writeBytes(fieldNumber, dup, repeated);\n\n            buffer.position(buffer.position() + length);\n        }\n\n        // output.writeByteRange(utf8String, fieldNumber, buffer, offset, length, repeated);\n        //\n        // offset += length;\n    }\n\n    /**\n     * Reads a byte array/ByteBuffer value.\n     */\n    @Override\n    public ByteBuffer readByteBuffer() throws IOException\n    {\n        return ByteBuffer.wrap(readByteArray());\n    }\n}\n",
            "file_name": "ByteBufferInput.java",
            "human_label": "Return a field tag, and if reach the EOF the tag will be zero.It will throw an exception when the tag is equal to zero after logical shift right  TAG_TYPE_BITS.",
            "level": "class_runnable",
            "lineno": "113",
            "name": "readTag",
            "oracle_context": "{ \"apis\" : \"[hasRemaining, readRawVarint32, invalidTag]\", \"classes\" : \"[]\", \"vars\" : \"[buffer, lastTag]\" }",
            "package": "io.protostuff",
            "project": "protostuff-master"
        },
        {
            "_id": "636766a81a6d9265ec017595",
            "all_context": "{ \"class_level\" : \"byte[] data;\\nint length;\\nByteVector(int initialCapacity);\\nput11(int byteValue1,int byteValue2);\\nputShort(int shortValue);\\nput12(int byteValue,int shortValue);\\nputInt(int intValue);\\nput122(int byteValue,int shortValue1,int shortValue2);\\nputLong(long longValue);\\nputUTF8(String stringValue);\\nencodeUtf8(String stringValue,int offset,int maxByteLength);\\nputByteArray(byte[] byteArrayValue,int byteOffset,int byteLength);\\nenlarge(int size);\\nputByte(int byteValue);\\n\", \"repo_level\" : \"\" }",
            "class_name": "ByteVector",
            "code": "final ByteVector put11(final int byteValue1,final int byteValue2){\n  int currentLength=length;\n  if (currentLength + 2 > data.length) {\n    enlarge(2);\n  }\n  byte[] currentData=data;\n  currentData[currentLength++]=(byte)byteValue1;\n  currentData[currentLength++]=(byte)byteValue2;\n  length=currentLength;\n  return this;\n}\n",
            "docstring": "/** \n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n * @param byteValue1 a byte.\n * @param byteValue2 another byte.\n * @return this byte vector.\n */\n",
            "end_lineno": "96",
            "file_content": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage com.alibaba.fastjson2.internal.asm;\n\n/**\n * A dynamically extensible vector of bytes. This class is roughly equivalent to a DataOutputStream\n * on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n */\npublic class ByteVector {\n    /**\n     * The content of this vector. Only the first {@link #length} bytes contain real data.\n     */\n    byte[] data;\n\n    /**\n     * The actual number of bytes in this vector.\n     */\n    int length;\n//\n//    /**\n//     * Constructs a new {@link ByteVector} with a default initial capacity.\n//     */\n//    public ByteVector() {\n//        data = new byte[64];\n//    }\n\n    /**\n     * Constructs a new {@link ByteVector} with the given initial capacity.\n     *\n     * @param initialCapacity the initial capacity of the byte vector to be constructed.\n     */\n    public ByteVector(final int initialCapacity) {\n        data = new byte[initialCapacity];\n    }\n\n    /**\n     * Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue a byte.\n     * @return this byte vector.\n     */\n    public ByteVector putByte(final int byteValue) {\n        int currentLength = length;\n        if (currentLength + 1 > data.length) {\n            enlarge(1);\n        }\n        data[currentLength++] = (byte) byteValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param byteValue1 a byte.\n     * @param byteValue2 another byte.\n     * @return this byte vector.\n     */\n    final ByteVector put11(final int byteValue1, final int byteValue2) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue1;\n        currentData[currentLength++] = (byte) byteValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    public ByteVector putShort(final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteValue  a byte.\n     * @param shortValue a short.\n     * @return this byte vector.\n     */\n    final ByteVector put12(final int byteValue, final int shortValue) {\n        int currentLength = length;\n        if (currentLength + 3 > data.length) {\n            enlarge(3);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param intValue an int.\n     * @return this byte vector.\n     */\n    public ByteVector putInt(final int intValue) {\n        int currentLength = length;\n        if (currentLength + 4 > data.length) {\n            enlarge(4);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\n     * if necessary.\n     *\n     * @param byteValue   a byte.\n     * @param shortValue1 a short.\n     * @param shortValue2 another short.\n     * @return this byte vector.\n     */\n    final ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) {\n        int currentLength = length;\n        if (currentLength + 5 > data.length) {\n            enlarge(5);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) byteValue;\n        currentData[currentLength++] = (byte) (shortValue1 >>> 8);\n        currentData[currentLength++] = (byte) shortValue1;\n        currentData[currentLength++] = (byte) (shortValue2 >>> 8);\n        currentData[currentLength++] = (byte) shortValue2;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\n     *\n     * @param longValue a long.\n     * @return this byte vector.\n     */\n    public ByteVector putLong(final long longValue) {\n        int currentLength = length;\n        if (currentLength + 8 > data.length) {\n            enlarge(8);\n        }\n        byte[] currentData = data;\n        int intValue = (int) (longValue >>> 32);\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        intValue = (int) longValue;\n        currentData[currentLength++] = (byte) (intValue >>> 24);\n        currentData[currentLength++] = (byte) (intValue >>> 16);\n        currentData[currentLength++] = (byte) (intValue >>> 8);\n        currentData[currentLength++] = (byte) intValue;\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param stringValue a String whose UTF8 encoded length must be less than 65536.\n     * @return this byte vector.\n     */\n    // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\n    public ByteVector putUTF8(final String stringValue) {\n        int charLength = stringValue.length();\n        if (charLength > 65535) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        int currentLength = length;\n        if (currentLength + 2 + charLength > data.length) {\n            enlarge(2 + charLength);\n        }\n        byte[] currentData = data;\n        // Optimistic algorithm: instead of computing the byte length and then serializing the string\n        // (which requires two loops), we assume the byte length is equal to char length (which is the\n        // most frequent case), and we start serializing the string right away. During the\n        // serialization, if we find that this assumption is wrong, we continue with the general method.\n        currentData[currentLength++] = (byte) (charLength >>> 8);\n        currentData[currentLength++] = (byte) charLength;\n        for (int i = 0; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= '\\u0001' && charValue <= '\\u007F') {\n                currentData[currentLength++] = (byte) charValue;\n            } else {\n                length = currentLength;\n                return encodeUtf8(stringValue, i, 65535);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n     * necessary. The string length is encoded in two bytes before the encoded characters, if there is\n     * space for that (i.e. if this.length - offset - 2 &gt;= 0).\n     *\n     * @param stringValue   the String to encode.\n     * @param offset        the index of the first character to encode. The previous characters are supposed\n     *                      to have already been encoded, using only one byte per character.\n     * @param maxByteLength the maximum byte length of the encoded string, including the already\n     *                      encoded characters.\n     * @return this byte vector.\n     */\n    final ByteVector encodeUtf8(final String stringValue, final int offset, final int maxByteLength) {\n        int charLength = stringValue.length();\n        int byteLength = offset;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                byteLength++;\n            } else if (charValue <= 0x07FF) {\n                byteLength += 2;\n            } else {\n                byteLength += 3;\n            }\n        }\n        if (byteLength > maxByteLength) {\n            throw new IllegalArgumentException(\"UTF8 string too large\");\n        }\n        // Compute where 'byteLength' must be stored in 'data', and store it at this location.\n        int byteLengthOffset = length - offset - 2;\n        if (byteLengthOffset >= 0) {\n            data[byteLengthOffset] = (byte) (byteLength >>> 8);\n            data[byteLengthOffset + 1] = (byte) byteLength;\n        }\n        if (length + byteLength - offset > data.length) {\n            enlarge(byteLength - offset);\n        }\n        int currentLength = length;\n        for (int i = offset; i < charLength; ++i) {\n            char charValue = stringValue.charAt(i);\n            if (charValue >= 0x0001 && charValue <= 0x007F) {\n                data[currentLength++] = (byte) charValue;\n            } else if (charValue <= 0x07FF) {\n                data[currentLength++] = (byte) (0xC0 | charValue >> 6 & 0x1F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            } else {\n                data[currentLength++] = (byte) (0xE0 | charValue >> 12 & 0xF);\n                data[currentLength++] = (byte) (0x80 | charValue >> 6 & 0x3F);\n                data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n            }\n        }\n        length = currentLength;\n        return this;\n    }\n\n    /**\n     * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\n     * necessary.\n     *\n     * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\n     *                       bytes into this byte vector.\n     * @param byteOffset     index of the first byte of byteArrayValue that must be copied.\n     * @param byteLength     number of bytes of byteArrayValue that must be copied.\n     * @return this byte vector.\n     */\n    public ByteVector putByteArray(\n            final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n        if (length + byteLength > data.length) {\n            enlarge(byteLength);\n        }\n        if (byteArrayValue != null) {\n            System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength);\n        }\n        length += byteLength;\n        return this;\n    }\n\n    /**\n     * Enlarges this byte vector so that it can receive 'size' more bytes.\n     *\n     * @param size number of additional bytes that this byte vector should be able to receive.\n     */\n    private void enlarge(final int size) {\n        int doubleCapacity = 2 * data.length;\n        int minimalCapacity = length + size;\n        byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\n        System.arraycopy(data, 0, newData, 0, length);\n        data = newData;\n    }\n}\n",
            "file_name": "ByteVector.java",
            "human_label": "Put two bytes into a byte vector called data.The vector will be enlarged if necessary.And return the ByteVector object.",
            "level": "class_runnable",
            "lineno": "79",
            "name": "put11",
            "oracle_context": "{ \"apis\" : \"[enlarge, ByteVector]\", \"classes\" : \"[byte[], data]\", \"vars\" : \"[length, data]\" }",
            "package": "com.alibaba.fastjson2.internal.asm",
            "project": "fastjson2-main"
        },
        {
            "_id": "636766ae1a6d9265ec0175d8",
            "all_context": "{ \"class_level\" : \"import java.util.List;\\nimport java.util.Map;\\nimport java.util.concurrent.ConcurrentHashMap;\\nimport java.util.logging.Logger;\\nimport javax.enterprise.context.RequestScoped;\\nimport javax.inject.Inject;\\nimport javax.ws.rs.container.ContainerResponseContext;\\nimport javax.ws.rs.container.ResourceInfo;\\nimport javax.ws.rs.core.HttpHeaders;\\nimport javax.ws.rs.core.UriInfo;\\nimport org.demoiselle.jee.crud.AbstractDAO;\\nimport org.demoiselle.jee.crud.CrudUtilHelper;\\nimport org.demoiselle.jee.crud.DemoiselleRequestContext;\\nimport org.demoiselle.jee.crud.ReservedHTTPHeaders;\\nimport org.demoiselle.jee.crud.ReservedKeyWords;\\nimport org.demoiselle.jee.crud.Search;\\nUriInfo uriInfo;\\nResourceInfo resourceInfo;\\nDemoiselleRequestContext drc;\\nPaginationHelperMessage message;\\nPaginationHelperConfig paginationConfig;\\nLogger logger;\\nPaginationHelper();\\nPaginationHelper(ResourceInfo resourceInfo,UriInfo uriInfo,PaginationHelperConfig paginationConfig,DemoiselleRequestContext drc,PaginationHelperMessage message);\\nfillObjects(ResourceInfo resourceInfo,UriInfo uriInfo);\\nisPaginationEnabled();\\nisRequestPagination();\\ncheckAndFillRangeValues();\\ngetDefaultNumberPagination();\\nhasSearchAnnotation();\\nisPartialContentResponse();\\nlogInvalidRangeParameters(String range);\\nbuildContentRange();\\nbuildAcceptRange();\\nbuildHeaders(ResourceInfo resourceInfo,UriInfo uriInfo);\\nbuildLinkHeader();\\nisFirstPage();\\nbuildAcceptRangeWithResponse(ContainerResponseContext response);\\nexecute(ResourceInfo resourceInfo,UriInfo uriInfo);\\n\", \"repo_level\" : \"public interface AbstractDAO {abstract EntityManager getEntityManager();\\npublic T persist(T entity);\\npublic T mergeHalf(I id,T entity);\\npublic T mergeFull(T entity);\\npublic void remove(I id);\\npublic T find(I id);\\npublic Result find();\\nprotected void configureCriteriaQuery(CriteriaBuilder criteriaBuilder,CriteriaQuery criteriaQuery);\\nprotected void configureOrder(CriteriaBuilder criteriaBuilder,CriteriaQuery criteriaQuery,Root root);\\nprotected Predicate[] buildPredicates(CriteriaBuilder criteriaBuilder,CriteriaQuery criteriaQuery,Root root);\\nprotected Boolean isEnumFilter(String key,String value,TreeNodeField tnf);\\nprotected Boolean isUUIDFilter(String key,String value,TreeNodeField tnf);\\nprotected Integer convertEnumToInt(String key,String value,TreeNodeField tnf);\\nprotected Boolean isLikeFilter(String value);\\nprotected Predicate buildLikePredicate(CriteriaBuilder criteriaBuilder,CriteriaQuery criteriaQuery,From root,String key,String value);\\nprotected Integer getMaxResult();\\npublic Long count();\\nprotected Predicate[] extractPredicates(MultivaluedMap queryParameters,CriteriaBuilder criteriaBuilder,Root root);\\npublic PaginationHelperConfig getPaginationConfig();\\npublic DemoiselleRequestContext getDrc();\\npublic Class<T> getEntityClass();\\n }\\npublic interface CrudUtilHelper {static Class<?> getTargetClass(Class targetClass);\\nstatic void checkIfExistField(Class targetClass,String field);\\nstatic List<Field> getAllFields(List fields,Class type);\\nstatic Field getField(Class targetClass,String name);\\nstatic List<String> extractFields(String fields);\\nstatic TreeNodeField<String,Set<String>> extractFieldsFromSearchAnnotation(ResourceInfo resourceInfo);\\nstatic void fillLeafTreeNodeField(TreeNodeField tnf,String field,Set value);\\nstatic void validateFields(TreeNodeField tnf,ResourceInfo resourceInfo,CrudMessage crudMessage);\\nstatic String getMethodAnnotatedWithID(Class targetClass);\\n }\\npublic interface DemoiselleRequestContext { Integer getLimit();\\n void setLimit(Integer limit);\\n Integer getOffset();\\n void setOffset(Integer offset);\\n Long getCount();\\n void setCount(Long count);\\n Class<?> getEntityClass();\\n void setEntityClass(Class entityClass);\\n TreeNodeField<String,Set<String>> getFilters();\\n void setFilters(TreeNodeField filters);\\n List<SortModel> getSorts();\\n void setSorts(List sorts);\\n TreeNodeField<String,Set<String>> getFields();\\n void setFields(TreeNodeField fields);\\n Boolean isPaginationEnabled();\\n void setPaginationEnabled(Boolean isPaginationEnabled);\\n }\\n\" }",
            "class_name": "PaginationHelper",
            "code": "private String buildContentRange(){\n  Integer limit=drc.getLimit() == null ? getDefaultNumberPagination() - 1 : drc.getLimit();\n  Integer offset=drc.getOffset() == null ? 0 : drc.getOffset();\n  Long count=drc.getCount() == null ? 0 : drc.getCount();\n  return offset + \"-\" + (limit.equals(0) ? count - 1 : limit)+ \"/\"+ count;\n}\n",
            "docstring": "/** \n * Build the 'Content-Range' HTTP Header value.\n * @return 'Content-Range' value\n */\n",
            "end_lineno": "235",
            "file_content": "/*\n * Demoiselle Framework\n *\n * License: GNU Lesser General Public License (LGPL), version 3 or later.\n * See the lgpl.txt file in the root directory or <https://www.gnu.org/licenses/lgpl.html>.\n */\npackage org.demoiselle.jee.crud.pagination;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Logger;\n\nimport javax.enterprise.context.RequestScoped;\nimport javax.inject.Inject;\nimport javax.ws.rs.container.ContainerResponseContext;\nimport javax.ws.rs.container.ResourceInfo;\nimport javax.ws.rs.core.HttpHeaders;\nimport javax.ws.rs.core.UriInfo;\n\nimport org.demoiselle.jee.crud.AbstractDAO;\nimport org.demoiselle.jee.crud.CrudUtilHelper;\nimport org.demoiselle.jee.crud.DemoiselleRequestContext;\nimport org.demoiselle.jee.crud.ReservedHTTPHeaders;\nimport org.demoiselle.jee.crud.ReservedKeyWords;\nimport org.demoiselle.jee.crud.Search;\n\n/**\n * Class responsible for managing the 'range' parameter comes from Url Query\n * String.\n *\n * Ex:\n *\n * Given a request\n * <pre>\n * GET @{literal http://localhost:8080/api/users?range=0-10}\n * </pre>\n *\n * This class will processing the request above and parse the range parameters\n * to {@link DemoiselleRequestContext} object.\n *\n * This object will be use on {@link AbstractDAO} class to execute the\n * pagination on database.\n *\n */\n@RequestScoped\npublic class PaginationHelper {\n\n    private UriInfo uriInfo;\n\n    private ResourceInfo resourceInfo;\n\n    @Inject\n    private DemoiselleRequestContext drc;\n\n    @Inject\n    private PaginationHelperMessage message;\n\n    @Inject\n    private PaginationHelperConfig paginationConfig;\n\n    private static final Logger logger = Logger.getLogger(PaginationHelper.class.getName());\n\n    public PaginationHelper() {\n    }\n\n    public PaginationHelper(ResourceInfo resourceInfo, UriInfo uriInfo, PaginationHelperConfig paginationConfig, DemoiselleRequestContext drc, PaginationHelperMessage message) {\n        this.resourceInfo = resourceInfo;\n        this.uriInfo = uriInfo;\n        this.paginationConfig = paginationConfig;\n        this.drc = drc;\n        this.message = message;\n    }\n\n    /**\n     * Open the request query string to extract values from 'range' parameter\n     * and fill the {@link DemoiselleRequestContext#setOffset(Integer)} and\n     * {@link DemoiselleRequestContext#setLimit(Integer)}\n     *\n     * @param resourceInfo ResourceInfo\n     * @param uriInfo UriInfo\n     */\n    public void execute(ResourceInfo resourceInfo, UriInfo uriInfo) {\n        fillObjects(resourceInfo, uriInfo);\n\n        drc.setPaginationEnabled(isPaginationEnabled());\n\n        if (drc.isPaginationEnabled()) {\n\n            if (isRequestPagination()) {\n                checkAndFillRangeValues();\n            }\n\n            if (hasSearchAnnotation() && !isRequestPagination()) {\n                drc.setLimit(getDefaultNumberPagination() - 1);\n                drc.setOffset(new Integer(0));\n            }\n        }\n\n        if (hasSearchAnnotation() && isRequestPagination()) {\n            Search searchAnnotation = resourceInfo.getResourceMethod().getAnnotation(Search.class);\n            // Pagination @Search.withPagination is disabled but the request parameter has 'range' parameter\n            if (searchAnnotation.withPagination() == Boolean.FALSE) {\n                throw new IllegalArgumentException(message.paginationIsNotEnabled());\n            }\n        }\n    }\n\n    private void fillObjects(ResourceInfo resourceInfo, UriInfo uriInfo) {\n        this.resourceInfo = resourceInfo == null ? this.resourceInfo : resourceInfo;\n        this.uriInfo = uriInfo == null ? this.uriInfo : uriInfo;\n    }\n\n    /**\n     * Check the pagination is enabled\n     *\n     * @return pagination enabled/disabled\n     */\n    private Boolean isPaginationEnabled() {\n        if (paginationConfig.getIsGlobalEnabled() == Boolean.FALSE) {\n            return Boolean.FALSE;\n        }\n\n        if (hasSearchAnnotation()) {\n            Search searchAnnotation = resourceInfo.getResourceMethod().getAnnotation(Search.class);\n            return searchAnnotation.withPagination();\n        }\n\n        return paginationConfig.getIsGlobalEnabled();\n    }\n\n    /**\n     * Check if the actual request has the 'range' parameter on query string\n     *\n     * @return is request pagination or not\n     */\n    private Boolean isRequestPagination() {\n        // Verify if contains 'range' in url\n        if (uriInfo.getQueryParameters().containsKey(ReservedKeyWords.DEFAULT_RANGE_KEY.getKey())) {\n            return Boolean.TRUE;\n        }\n        return Boolean.FALSE;\n    }\n\n    /**\n     * Check if the value of 'range' parameter is valid using the rules:\n     *\n     * - Value formatted like offset-limit (range=0-10); - The 'offset' and\n     * 'limit' should be a integer; - The 'offset' should be less than or equals\n     * 'limit';\n     *\n     *\n     * @throws IllegalArgumentException The format is invalid\n     */\n    private void checkAndFillRangeValues() throws IllegalArgumentException {\n        List<String> rangeList = uriInfo.getQueryParameters().get(ReservedKeyWords.DEFAULT_RANGE_KEY.getKey());\n        if (!rangeList.isEmpty()) {\n            String range[] = rangeList.get(0).split(\"-\");\n            if (range.length == 2) {\n                String offset = range[0];\n                String limit = range[1];\n\n                try {\n                    drc.setOffset(new Integer(offset));\n                    drc.setLimit(new Integer(limit));\n\n                    if (drc.getOffset() > drc.getLimit()) {\n                        logInvalidRangeParameters(rangeList.get(0));\n                        throw new IllegalArgumentException(this.message.invalidRangeParameters());\n                    }\n\n                    if (((drc.getLimit() - drc.getOffset()) + 1) > getDefaultNumberPagination()) {\n                        logger.warning(message.defaultPaginationNumberExceed(getDefaultNumberPagination()) + \", [\" + drc.toString() + \"]\");\n                        throw new IllegalArgumentException(message.defaultPaginationNumberExceed(getDefaultNumberPagination()));\n                    }\n\n                } catch (NumberFormatException nfe) {\n                    logInvalidRangeParameters(rangeList.get(0));\n                    throw new IllegalArgumentException(message.invalidRangeParameters());\n                }\n            } else {\n                logInvalidRangeParameters(rangeList.get(0));\n                throw new IllegalArgumentException(message.invalidRangeParameters());\n            }\n        }\n\n    }\n\n    /**\n     * Get default pagination number, if the target method is annotated with\n     * Search annotation the default annotation will be\n     * {@link Search#quantityPerPage()} otherwise the default pagination will be\n     * {@link PaginationHelperConfig#getDefaultPagination()} value;\n     *\n     * @return Number per page\n     */\n    private Integer getDefaultNumberPagination() {\n        if (hasSearchAnnotation()) {\n            Search searchAnnotation = resourceInfo.getResourceMethod().getAnnotation(Search.class);\n            return searchAnnotation.quantityPerPage();\n        }\n\n        return paginationConfig.getDefaultPagination();\n    }\n\n    private Boolean hasSearchAnnotation() {\n        return resourceInfo.getResourceMethod().isAnnotationPresent(Search.class);\n    }\n\n    /**\n     * Check if the actual response is a Partial Content (HTTP 206 code)\n     *\n     * @return is partial content or not\n     */\n    public Boolean isPartialContentResponse() {\n        Integer limit = drc.getLimit() == null ? 0 : drc.getLimit();\n        Long count = drc.getCount() == null ? 0 : drc.getCount();\n        return !((limit + 1) >= count);\n    }\n\n    private void logInvalidRangeParameters(String range) {\n        logger.warning(message.invalidRangeParameters() + \", [params: \" + range + \"]\");\n    }\n\n    /**\n     * Build the 'Content-Range' HTTP Header value.\n     *\n     * @return 'Content-Range' value\n     */\n    private String buildContentRange() {\n        Integer limit = drc.getLimit() == null ? getDefaultNumberPagination() - 1 : drc.getLimit();\n        Integer offset = drc.getOffset() == null ? 0 : drc.getOffset();\n        Long count = drc.getCount() == null ? 0 : drc.getCount();\n        return offset + \"-\" + (limit.equals(0) ? count - 1 : limit) + \"/\" + count;\n    }\n\n    /**\n     * Build the 'Accept-Range' HTTP Header value.\n     *\n     * @return 'Accept-Range' value\n     */\n    public String buildAcceptRange() {\n        String resource = \"\";\n\n        if (drc.getEntityClass() != null) {\n            resource = drc.getEntityClass().getSimpleName().toLowerCase();\n        } else {\n            if (resourceInfo != null && resourceInfo.getResourceClass() != null) {\n                Class<?> targetClass = CrudUtilHelper.getTargetClass(resourceInfo.getResourceClass());\n                if (targetClass != null) {\n                    resource = targetClass.getSimpleName().toLowerCase();\n                }\n            }\n        }\n\n        if (!resource.isEmpty()) {\n            return resource + \" \" + getDefaultNumberPagination();\n        }\n\n        return null;\n    }\n\n    /**\n     * Set the 'Content-Range', 'Accept-Range', 'Link' and\n     * 'Access-Control-Expose-Headers' HTTP headers;\n     *\n     * @param resourceInfo ResourceInfo\n     * @param uriInfo UriInfo\n     *\n     * @return A map with HTTP headers\n     */\n    public Map<String, String> buildHeaders(ResourceInfo resourceInfo, UriInfo uriInfo) {\n        fillObjects(resourceInfo, uriInfo);\n        Map<String, String> headers = new ConcurrentHashMap<>();\n\n        if (drc.isPaginationEnabled()) {\n            headers.putIfAbsent(ReservedHTTPHeaders.HTTP_HEADER_CONTENT_RANGE.getKey(), buildContentRange());\n            headers.putIfAbsent(ReservedHTTPHeaders.HTTP_HEADER_ACCEPT_RANGE.getKey(), buildAcceptRange());\n            String linkHeader = buildLinkHeader();\n\n            if (!linkHeader.isEmpty()) {\n                headers.putIfAbsent(HttpHeaders.LINK, linkHeader);\n            }\n        }\n\n        return headers;\n    }\n\n    /**\n     * Build the 'Link' HTTP header value\n     *\n     * @return 'Link' value\n     */\n    private String buildLinkHeader() {\n        StringBuffer sb = new StringBuffer();\n        String url = uriInfo.getRequestUri().toString();\n        url = url.replaceFirst(\".range=([^&]*)\", \"\");\n\n        if (drc.getOffset() == null) {\n            drc.setOffset(new Integer(0));\n        }\n\n        if (drc.getLimit() == null) {\n            drc.setLimit(getDefaultNumberPagination() - 1);\n        }\n\n        Integer offset = drc.getOffset() + 1;\n        Integer limit = drc.getLimit() + 1;\n        Integer quantityPerPage = (limit - offset) + 1;\n\n        if (uriInfo.getQueryParameters().isEmpty()\n                || (uriInfo.getQueryParameters().size() == 1 && uriInfo.getQueryParameters().containsKey(ReservedKeyWords.DEFAULT_RANGE_KEY.getKey()))) {\n            url += \"?\" + ReservedKeyWords.DEFAULT_RANGE_KEY.getKey() + \"=\";\n        } else {\n            url += \"&\" + ReservedKeyWords.DEFAULT_RANGE_KEY.getKey() + \"=\";\n        }\n\n        if (!isFirstPage()) {\n            Integer prevPageRangeInit = (drc.getOffset() - quantityPerPage) < 0 ? 0 : (drc.getOffset() - quantityPerPage);\n            Integer firstRange2 = quantityPerPage - 1 < drc.getOffset() - 1 ? quantityPerPage - 1 : drc.getOffset() - 1;\n\n            String firstPage = url + 0 + \"-\" + firstRange2;\n            String prevPage = url + prevPageRangeInit + \"-\" + (drc.getOffset() - 1);\n\n            sb.append(\"<\").append(firstPage).append(\">; rel=\\\"first\\\",\");\n            sb.append(\"<\").append(prevPage).append(\">; rel=\\\"prev\\\",\");\n        }\n\n        if (isPartialContentResponse()) {\n            String nextPage = url + (drc.getOffset() + quantityPerPage) + \"-\" + (2 * quantityPerPage + drc.getOffset() - 1);\n            String lastPage = url + (drc.getCount() - quantityPerPage) + \"-\" + (drc.getCount() - 1);\n\n            if (offset + quantityPerPage >= drc.getCount() - 1) {\n                nextPage = lastPage;\n            }\n\n            sb.append(\"<\").append(nextPage).append(\">; rel=\\\"next\\\",\");\n            sb.append(\"<\").append(lastPage).append(\">; rel=\\\"last\\\"\");\n        }\n\n        return sb.toString();\n    }\n\n    private Boolean isFirstPage() {\n        return drc.getOffset().equals(0);\n    }\n\n    public void buildAcceptRangeWithResponse(ContainerResponseContext response) {\n        if (response != null) {\n            String acceptRangeHeader = buildAcceptRange();\n            if (acceptRangeHeader != null) {\n                response.getHeaders().putSingle(ReservedHTTPHeaders.HTTP_HEADER_ACCEPT_RANGE.getKey(), acceptRangeHeader);\n            }\n        }\n\n    }\n\n}\n",
            "file_name": "PaginationHelper.java",
            "human_label": "Return the string that contains the content range from offset to limit(when limit is zero,the upper bound will be count-1) and count.",
            "level": "class_runnable",
            "lineno": "225",
            "name": "buildContentRange",
            "oracle_context": "{ \"apis\" : \"[getLimit, getDefaultNumberPagination, getOffset, getCount, equals]\", \"classes\" : \"[Integer, Long]\", \"vars\" : \"[drc]\" }",
            "package": "org.demoiselle.jee.crud.pagination",
            "project": "framework-master"
        }
    ]
}